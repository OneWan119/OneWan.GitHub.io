{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5bfc\u822a\u680f","text":"<p>     \u672c\u7ad9\u603b\u8bbf\u95ee\u91cf\u6b21 </p> <p>\u672c\u7ad9\u6c47\u603b-pdf(\u6253\u5370\u7528)</p>"},{"location":"contest/nowcoer-summer/2024/contest-1/","title":"2024\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u84251","text":"<p>2024\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u84251</p>"},{"location":"template/problem-set/","title":"\u6742\u9898","text":"ABC295FHydroOJ4017\u725b\u5ba257359I\u725b\u5ba262662E\u6d1b\u8c37P4688CF1849E <p>F - substr = S</p> <p>\u5df2\u77e5 \\(f(i)\\) \u4e3a \\(i\\) \u7684\u6570\u4f4d\u4e2d\u542b\u6709\u7684 \\(s\\) \u7684\u4e2a\u6570</p> <p>\u6c42 \\(\\sum_{i=L}^Rf(i)\\)</p> <p>\u56fa\u5b9a \\(s\\) \u7684\u4f4d\u7f6e, \u53d1\u73b0\u5bf9\u4e8e\u7b2c \\(i\\) \u4e2a\u7b26\u5408\u7684\u5339\u914d\u6570, \u53bb\u6389 \\(s\\) \u540e, \u4f1a\u5f97\u5230 \\(i-1\\).</p> <p>\u90a3\u4e48\u53ef\u4ee5\u679a\u4e3e \\(s\\) \u7684\u51fa\u73b0\u4f4d\u7f6e, \u7136\u540e\u4e8c\u5206\u6c42\u6700\u5927\u7684\u7b26\u5408\u7684\u5339\u914d\u6570, \u7136\u540e\u6c42\u548c\u5373\u53ef.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 p10[18];\nstring str;\ni64 strll;\nvoid solve() {\n    cin &gt;&gt; str;\n    strll = 0;\n    for (auto &amp;x : str) {\n        strll = strll * 10 + x - '0';\n    }\n    auto get1 = [&amp;](int idx, i64 x) -&gt; i64 {\n        x--;\n        if (x &lt; 0) return 0LL;\n        if (idx + str.size() &gt;= 18) {\n            return 0x7fffffffffffffff;\n        }\n        if (str[0] == '0') {\n            x += p10[idx];\n        }\n        i64 p = x % p10[idx];\n        i64 q = x / p10[idx];\n        return q * p10[idx + str.size()] + strll * p10[idx] + p;\n\n    };\n    auto get2 = [&amp;](i64 x) {\n        i64 ans = 0;\n        for (int i = 0 ; i &lt; 16 ; i++) {\n            i64 L = 0, R = p10[16 - str.size()];\n            while (L &lt; R) {\n                i64 mid = L + R + 1 &gt;&gt; 1;\n                if (get1(i, mid) &lt;= x) {\n                    L = mid;\n                } else {\n                    R = mid - 1;\n                }\n            }\n            ans += L;\n        }\n        return ans;\n    };\n    i64 L, R;\n    cin &gt;&gt; L &gt;&gt; R;\n    cout &lt;&lt; get2(R) - get2(L - 1) &lt;&lt; \"\\n\";\n}\nint main() {\n    p10[0] = 1;\n    for (int i = 1 ; i &lt; 18 ; i++) {\n        p10[i] = p10[i - 1] * 10;\n    }\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>\u5c0fQ\u7684\u65e0\u654c\u5f02\u6216 - HydroOJ</p> <p>\u6c42\u6240\u6709\u5b50\u533a\u95f4\u5f02\u6216\u7684\u548c \u548c \u6240\u6709\u5b50\u533a\u95f4\u548c\u7684\u5f02\u6216</p> <p>\\(sumxor(L,R)=a_L\\oplus a_{L+1}\\oplus \u2026\\oplus a_R\\)</p> <p>\u6c42 \\(\\sum_{i=1}^n\\sum_{j=i}^nsumxor(i,j)\\) \u548c \\(sumxor(\\sum_{i=1}^n\\sum_{j=i}^n(a_i+a_{i+1}+\u2026+a_j))\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint n;\nint tr[100005];\nint lowbit(int x) {\n    return x &amp; -x;\n}\nvoid add(int x) {\n    while (x &lt;= n + 1) {\n        tr[x] ^= 1;\n        x += lowbit(x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res ^= tr[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint a[100005];\ni64 p[100005];\ni64 sum[100005], sumXor[100005];\nconst i64 P = 998244353;\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        sum[i] = sum[i - 1] + a[i];\n        sumXor[i] = sumXor[i - 1] ^ a[i];\n    }\n    i64 ans1 = 0, ans2 = 0;\n    { // task 1\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            array&lt;int, 2&gt; cnt{1, 0};\n            for (int j = 1 ; j &lt;= n ; j++) {\n                int k = sumXor[j] &gt;&gt; i &amp; 1;\n                ans1 = (ans1 + cnt[k ^ 1] * (1LL &lt;&lt; i) % P) % P;\n                cnt[k]++;\n            }\n        }\n    }\n    { // task 2\n        auto get = [&amp;](i64 x) {\n            return upper_bound(p, p + n + 1, x) - p;\n        };\n        for (int i = 37 ; i &gt;= 0 ; i--) {\n            for (int j = 0 ; j &lt;= n ; j++) {\n                p[j] = sum[j] &amp; ((1LL &lt;&lt; (i + 1)) - 1);\n            }\n            sort(p, p + n + 1);\n            fill(tr, tr + n + 2, 0);\n            int res = 0;\n            for (int j = 0 ; j &lt;= n ; j++) {\n                i64 k = sum[j] &amp; ((1LL &lt;&lt; (i + 1)) - 1);\n                add(get(k));\n                int t1 = query(get(k - (1LL &lt;&lt; i)));\n                int t2 = query(get(k + (1LL &lt;&lt; i)));\n                int t3 = query(get(k));\n                res ^= t1 ^ t2 ^ t3;\n            }\n            if (res &amp; 1) {\n                ans2 |= 1LL &lt;&lt; i;\n            }\n        }\n    }\n    cout &lt;&lt; ans1 &lt;&lt; \" \" &lt;&lt; ans2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>I-The Yakumo Family_2023\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u84255</p> <p>\\(f(L,R)=a_L\\oplus a_{L+1}\\oplus\u2026\\oplus a_R\\)</p> <p>\u6c42 \\(\\sum_{1\\le{L_1}\\le{R_1}&lt;{L_2}\\leq{R_2}&lt;{L_3}\\le{R_3}&lt;{n}}f(L_1,R_1)\\times{f(L_2,R_2)}\\times{f(L_2,R_2)}\\) \u7684\u503c</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[200005], sumXor[200005], sum[200005], f[200005];\nconst i64 P = 998244353;\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        sumXor[i] = sumXor[i - 1] ^ a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        sum[i] = 1;\n    }\n    for (int _ = 0 ; _ &lt; 3 ; _++) {\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            array&lt;i64, 2&gt; cnt{_ == 0, 0};\n            for (int j = 1 ; j &lt;= n ; j++) {\n                int k = sumXor[j] &gt;&gt; i &amp; 1;\n                f[j] = (f[j] + cnt[k ^ 1] * (1LL &lt;&lt; i) % P) % P;\n                cnt[k] = (cnt[k] + sum[j]) % P;\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i] = (sum[i - 1] + f[i]) % P;\n            f[i] = 0;\n        }\n    }\n    cout &lt;&lt; sum[n] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>E-\u5c0f\u7ea2\u7684\u5faa\u73af\u8282\u957f\u5ea6_\u725b\u5ba2\u5468\u8d5b Round 6</p> <p>\u6c42 \\(\\frac{p}{q}\\) \u7684 \u6700\u5c0f\u5faa\u73af\u8282\u957f\u5ea6\u4ee5\u53ca\u5faa\u73af\u8282\u524d\u9762\u7684\u90e8\u5206</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 eulerPhi(i64 n) {\n    i64 ans = n;\n    for (int i = 2 ; 1LL * i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n * (n - 1);\n    }\n    return ans;\n}\ni64 qpow(__int128 a, i64 b, i64 P, __int128 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    i64 p, q;\n    cin &gt;&gt; p &gt;&gt; q;\n    i64 k = __gcd(p, q);\n    p /= k;\n    q /= k;\n    int cnt2 = 0, cnt5 = 0;\n    while (q % 2 == 0) {\n        q /= 2;\n        cnt2++;\n    }\n    while (q % 5 == 0) {\n        q /= 5;\n        cnt5++;\n    }\n    if (q == 1) {\n        cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n    } else {\n        cout &lt;&lt; max(cnt2, cnt5) &lt;&lt; \" \";\n        i64 ans = 0x7fffffffffffffff;\n        i64 phi = eulerPhi(q);\n        for (int i = 1 ; 1LL * i * i &lt;= phi ; i++) {\n            if (phi % i == 0) {\n                if (qpow(10, i, q) == 1) {\n                    ans = min&lt;i64&gt;(ans, i);\n                }\n                if (qpow(10, phi / i, q) == 1) {\n                    ans = min&lt;i64&gt;(ans, phi / i);\n                }\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P4688 [Ynoi2016] \u6389\u8fdb\u5154\u5b50\u6d1e - \u6d1b\u8c37</p> <p>\u591a\u6b21\u8be2\u95ee, \u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u4e09\u4e2a\u533a\u95f4\uff0c\u4e09\u4e2a\u533a\u95f4\u7684\u6570\u5168\u90e8\u62ff\u51fa\u6765, \u7136\u540e\u5220\u6389\u4e09\u4e2a\u533a\u95f4\u540c\u65f6\u51fa\u73b0\u7684\u6570(\u4e5f\u5c31\u662f\u51fa\u73b0\u4e86 \\(2\\) \u4e2a \\(4\\), \u5219\u5220\u6389 \\(2*3\\) \u4e2a \\(4\\)), \u95ee\u5269\u4e0b\u51e0\u4e2a\u6570.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint n;\nint a[100005];\nint belong[100005], st[100005], ed[100005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        if (belong[x.L] &amp; 1) {\n            return x.R &lt; y.R;\n        }\n        return x.R &gt; y.R;\n    }\n};\nbitset&lt;100001&gt; bs[100000 / 3 + 1], res;\nint cnt[100005];\nbool vis[100005];\nvoid add(int x) {\n    res[cnt[x] + x] = 1;\n    cnt[x]++;\n}\nvoid del(int x) {\n    cnt[x]--;\n    res[cnt[x] + x] = 0;\n}\nvoid solve(int q) {\n    vector&lt;MO&gt; mo;\n    vector&lt;int&gt; ans(q);\n    for (int i = 0 ; i &lt; q ; i++) {\n        for (int j = 0 ; j &lt; 3 ; j++) {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            mo.push_back({L, R, i});\n            ans[i] += R - L + 1;\n        }\n    }\n    sort(begin(mo), end(mo));\n    fill(vis, vis + n + 1, false);\n    fill(cnt, cnt + n + 1, 0);\n    res.reset();\n    int L = 1, R = 0;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        while (L &gt; QL) {\n            add(a[--L]);\n        }\n        while (R &lt; QR) {\n            add(a[++R]);\n        }\n        while (L &lt; QL) {\n            del(a[L++]);\n        }\n        while (R &gt; QR) {\n            del(a[R--]);\n        }\n        if (vis[idx]) {\n            bs[idx] &amp;= res;\n        } else {\n            vis[idx] = true;\n            bs[idx] = res;\n        }\n    }\n    for (int i = 0 ; i &lt; q ; i++) {\n        ans[i] -= bs[i].count() * 3;\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n}\nint main() {\n    int q;\n    cin &gt;&gt; n &gt;&gt; q;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    vector&lt;int&gt; idx(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    int B = q / 3;\n    solve(B);\n    solve(B);\n    solve(q - 2 * B);\n    return 0;\n}\n</code></pre> <p>Problem - E - Codeforces</p> <p>\\(n\\) \u6392\u5217</p> <p>\u95ee\u6709\u591a\u5c11\u5b50\u533a\u95f4 \\([L,R]\\) \u6ee1\u8db3\u533a\u95f4 \\(\\max\\) \u51fa\u73b0\u5728\u533a\u95f4 \\(\\min\\) \u7684\u53f3\u4fa7.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[1000005];\nint miL[1000005], mxL[1000005], miR[1000005], mxR[1000005];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    { // \u5355\u8c03\u6808\u5904\u7406 \u5de6\u8fb9\u5c0f\u7684\u548c\u53f3\u8fb9\u5c0f\u7684\n        stack&lt;int&gt; st;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            miR[i] = n + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (!st.empty() &amp;&amp; a[i] &lt; a[st.top()]) {\n                miR[st.top()] = i;\n                st.pop();\n            }\n            miL[i] = st.empty() ? 0 : st.top();\n            st.push(i);\n        }\n    }\n    { // \u5355\u8c03\u6808\u5904\u7406 \u5de6\u8fb9\u5927\u7684\u548c\u53f3\u8fb9\u5927\u7684\n        stack&lt;int&gt; st;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            mxR[i] = n + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) {\n                mxR[st.top()] = i;\n                st.pop();\n            }\n            mxL[i] = st.empty() ? 0 : st.top();\n            st.push(i);\n        }\n    }\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int L = mxL[i], R = mxR[i];\n        if (i - L &gt; R - i) {\n            int now = n;\n            for (int j = i ; j &lt; R ; j++) {\n                now = min(now, miL[j]);\n                ans += max(0, now - L);\n            }\n        } else {\n            int now = i;\n            for (int j = i ; j &gt; L ; j--) {\n                if (a[j] &lt; a[now]) {\n                    now = j;\n                }\n                if (now != i) {\n                    ans += max(0, min(R, miR[now]) - i);\n                }\n            }\n        }\n        // cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/convex-hull/","title":"\u51f8\u5305","text":""},{"location":"template/computational-geometry/convex-hull/#_2","title":"\u4e8c\u7ef4\u51f8\u5305","text":"\u6a21\u7248 Andrew \\(O(n\\cdot\\log{n})\\)Graham \\(O(n\\cdot\\log{n})\\) \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nint st[100005];\nbool used[100005];\nvector&lt;Point&gt; ConvexHull2D(vector&lt;Point&gt; &amp;p) {\n    sort(begin(p), end(p));\n    int len = p.size(), top = 0;\n    for (int i = 0 ; i &lt; len ; i++) {\n        used[i] = false;\n    }\n    st[++top] = 0;\n    for (int i = 1 ; i &lt; len ; i++) {\n        while (top &gt; 1 &amp;&amp; sgn(cross(p[st[top]] - p[st[top - 1]], p[i] - p[st[top]])) &lt;= 0) {\n            used[st[top--]] = false;\n        }\n        used[i] = true;\n        st[++top] = i;\n    }\n    int temp = top;\n    for (int i = len - 2 ; i &gt;= 0 ; i--) {\n        if (used[i]) continue;\n        while (top &gt; temp &amp;&amp; sgn(cross(p[st[top]] - p[st[top - 1]], p[i] - p[st[top]])) &lt;= 0) {\n            used[st[top--]] = false;\n        }\n        used[i] = true;\n        st[++top] = i;\n    }\n    vector&lt;Point&gt; res;\n    for (int i = 1 ; i &lt;= top ; i++) {\n        res.emplace_back(p[st[i]]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto b = ConvexHull2D(a);\n    Tdouble ans = 0;\n    int len = b.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(b[i], b[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nint st[100005];\nvector&lt;Point&gt; ConvexHull2D(vector&lt;Point&gt; &amp;p) {\n    sort(begin(p) + 1, end(p), [&amp;](const Point &amp;x, const Point &amp;y) {\n        Tdouble temp = cross(x - p[0], y - p[0]);\n        if (sgn(temp) == 1) return true;\n        return sgn(temp) == 0 &amp;&amp; distance(x, p[0]) &lt; distance(y, p[0]);\n    });\n    int len = p.size(), top = 0;\n    st[++top] = 0;\n    for (int i = 1 ; i &lt; len ; i++) {\n        while (top &gt; 1 &amp;&amp; sgn(cross(p[st[top - 1]] - p[st[top]], p[st[top]] - p[i])) &lt;= 0) {\n            top--;\n        }\n        st[++top] = i;\n    }\n    st[++top] = 0;\n    vector&lt;Point&gt; res;\n    for (int i = 1 ; i &lt;= top ; i++) {\n        res.emplace_back(p[st[i]]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n        if (a[i].y &lt; a[0].y || (a[i].y == a[0].y &amp;&amp; a[i].x &lt; a[0].x)) {\n            swap(a[i], a[0]);\n        }\n    }\n    auto b = ConvexHull2D(a);\n    Tdouble ans = 0;\n    int len = b.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(b[i], b[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 <p>P2742 [USACO5.1] \u5708\u5976\u725bFencing the Cows /\u3010\u6a21\u677f\u3011\u4e8c\u7ef4\u51f8\u5305 - \u6d1b\u8c37</p> \u4e60\u9898 \u6d1b\u8c37P3829 <p>P3829 [SHOI2012] \u4fe1\u7528\u5361\u51f8\u5305 - \u6d1b\u8c37</p> <p>\u7ed9\u51fa \\(n\\) \u4e2a\u5706\u89d2\u77e9\u5f62, \u95ee\u8fd9 \\(n\\) \u4e2a\u77e9\u5f62\u6784\u6210\u7684\u51f8\u5305\u7684\u5468\u957f.</p> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    Tdouble a, b, r;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; r;\n    a -= 2 * r;\n    b -= 2 * r;\n    Tdouble L = sqrt(a * a + b * b) / 2;\n    Tdouble phi = atan(a / b);\n    vector&lt;Point&gt; c;\n    for (int i = 0 ; i &lt; n ; i++) {\n        Tdouble x, y, theta;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; theta;\n        {\n            Tdouble dx = cos(theta + phi) * L;\n            Tdouble dy = sin(theta + phi) * L;\n            c.emplace_back(x + dx, y + dy);\n            c.emplace_back(x - dx, y - dy);\n        }\n        {\n            Tdouble dx = cos(theta - phi) * L;\n            Tdouble dy = sin(theta - phi) * L;\n            c.emplace_back(x + dx, y + dy);\n            c.emplace_back(x - dx, y - dy);\n        }\n    }\n    auto res = ConvexHull2D(c);\n    Tdouble ans = 0;\n    int len = res.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(res[i], res[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans + 2 * PI * r &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/convex-hull/#_3","title":"\u4e09\u7ef4\u51f8\u5305","text":"\u6a21\u7248 \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nFace st[2005];\nFace temp[2005];\nbool vis[2005][2005];\nvector&lt;Face&gt; ConvexHull3D(const vector&lt;Point3D&gt; &amp;p) {\n    int cnt = 2;\n    temp[1] = {{p[0], 0}, {p[1], 1}, {p[2], 2}};\n    temp[2] = {{p[2], 2}, {p[1], 1}, {p[0], 0}};\n    int len = p.size();\n    for (int i = 3, top = 0 ; i &lt; len ; i++) {\n        for (int j = 1, v ; j &lt;= cnt ; j++) {\n            if (!(v = temp[j].see(p[i]))) {\n                st[++top] = temp[j];\n            }\n            for (int k = 0 ; k &lt; 3 ; k++) {\n                vis[temp[j][k]][temp[j][(k + 1) % 3]] = v;\n            }\n        }\n        for (int j = 1 ; j &lt;= cnt ; j++) {\n            for (int k = 0 ; k &lt; 3 ; k++) {\n                int x = temp[j][k], y = temp[j][(k + 1) % 3];\n                if (vis[x][y] &amp;&amp; !vis[y][x]) {\n                    st[++top] = {{p[x], x}, {p[y], y}, {p[i], i}};\n                }\n            }\n        }\n        for (int j = 1 ; j &lt;= top ; j++) {\n            temp[j] = st[j];\n        }\n        cnt = top;\n        top = 0;\n    }\n    vector&lt;Face&gt; res;\n    for (int i = 1 ; i &lt;= cnt ; i++) {\n        res.emplace_back(temp[i]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point3D&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n        a[i].shake();\n    }\n    auto res = ConvexHull3D(a);\n    Tdouble ans = 0;\n    int len = res.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        ans += res[i].area();\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 <p>P4724 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u51f8\u5305 - \u6d1b\u8c37</p>"},{"location":"template/computational-geometry/default/","title":"\u57fa\u7840","text":""},{"location":"template/computational-geometry/default/#_2","title":"\u51e0\u4f55\u516c\u5f0f","text":""},{"location":"template/computational-geometry/default/#_3","title":"\u4e09\u89d2\u5f62","text":"<p>\u5468\u957f \\(P=\\dfrac{a+b+c}{2}\\)</p> <p>\u9762\u79ef \\(S=\\dfrac{\\text{\u5e95}*\\text{\u9ad8}}{2}=\\dfrac{ab\\cdot\\sin{C}}{2}=\\sqrt{P\\cdot(P-a)\\cdot(P-b)\\cdot(P-c)}\\)</p> <p>\u4e2d\u7ebf \\(Ma=\\dfrac{\\sqrt{2b^2+2c^2-a^2}}{2}=\\dfrac{\\sqrt{b^2+c^2+2\\cdot{b}\\cdot{c}\\cdot\\cos(A)}}{2}\\)</p> <p>\u89d2\u5e73\u5206\u7ebf \\(Ta=\\dfrac{\\sqrt{b\\cdot{c}\\cdot((b+c)^2-a^2)}}{b+c}=\\dfrac{2\\cdot{b}\\cdot{c}\\cdot\\cos(\\frac{A}{2})}{b+c}\\)</p> <p>\u9ad8 \\(Ha=b\\cdot\\sin C=c\\cdot\\sin B=\\sqrt{b^2-{(\\frac{a^2+b^2-c^2}{2a})}^2}\\)</p> <p>\u5916\u5207\u5706\u534a\u5f84 \\(R=\\dfrac{a\\cdot{b}\\cdot{c}}{4S}=\\dfrac{a}{2\\sin(A)}=\\dfrac{b}{2\\sin(B)}=\\dfrac{c}{2\\sin(C)}\\)</p> <p>\u5185\u5207\u5706\u534a\u5f84 \\(r=\\dfrac{S}{P}=\\dfrac{arcsin(\\frac{B}{2})\\cdot\\sin(\\frac{C}{2})}{\\sin(\\frac{B+C}{2})}=4R\\cdot\\sin(\\frac{A}{2})\\cdot\\sin(\\frac{B}{2})\\cdot\\sin(\\frac{C}{2})=P\\cdot\\tan(\\frac{A}{2})\\cdot\\tan(\\frac{B}{2})\\cdot\\tan(\\frac{C}{2})\\)</p>"},{"location":"template/computational-geometry/default/#_4","title":"\u56db\u8fb9\u5f62","text":"<p>\\(D_1\\)\u3001\\(D_2\\) \u4e3a\u5bf9\u89d2\u7ebf\uff0cM\u662f\u5bf9\u89d2\u7ebf\u4e2d\u70b9\u7684\u8fde\u7ebf\uff0cA\u4e3a\u5bf9\u89d2\u7ebf\u5939\u89d2</p> <p>\\(a^2+b^2+c^2+d^2=D_1^2+D_2^2+4M^2\\)</p> <p>\\(S=\\dfrac{D_1\\cdot{D_2}\\cdot\\sin(A)}{2}\\)</p>"},{"location":"template/computational-geometry/default/#_5","title":"\u5706\u7684\u5185\u63a5\u56db\u8fb9\u5f62","text":"<p>\\(a\\cdot{c}+b\\cdot{d}=D_1\\cdot{D_2}\\)</p> <p>\\(S=\\sqrt{(P-a)\\cdot(P-b)\\cdot(P-c)\\cdot(P-d)}\\)</p>"},{"location":"template/computational-geometry/default/#n","title":"\u6b63n\u8fb9\u5f62","text":"<p>R\u4e3a\u5916\u63a5\u5706\u534a\u5f84\uff0cr\u4e3a\u5185\u5207\u5706\u534a\u5f84</p> <p>\u4e2d\u5fc3\u89d2 \\(A=\\dfrac{2\\pi}{n}\\)</p> <p>\u5185\u89d2 \\(C=\\dfrac{(n-2)\\cdot\\pi}{n}\\)</p> <p>\u8fb9\u957f \\(a=2\\sqrt{R * R - r * r}\\)</p>"},{"location":"template/computational-geometry/default/#pick","title":"Pick \u5b9a\u7406","text":"<p>\u7ed9\u5b9a\u9876\u70b9\u5747\u4e3a\u6574\u70b9\u7684\u7b80\u5355\u591a\u8fb9\u5f62\uff0c\u76ae\u514b\u5b9a\u7406\u8bf4\u660e\u4e86\u5176\u9762\u79ef \\(A\\) \u548c\u5185\u90e8\u683c\u70b9\u6570\u76ee \\(a\\) \u3001\u8fb9\u4e0a\u683c\u70b9\u6570\u76ee \\(b\\) \u7684\u5173\u7cfb\uff1a\\(A=a+\\dfrac{b}{2}-1\\)</p> \u4ee3\u7801 C++<pre><code>namespace ComputingGeometry {\n    using Tdouble = double;\n    const Tdouble eps = 1e-9;\n    const Tdouble PI = acos(-1.0);\n    Tdouble Rand() {\n        return rand() / (Tdouble) RAND_MAX;\n    }\n    Tdouble reps() {\n        return (Rand() - 0.5) * eps;\n    }\n    int sgn(Tdouble x) { // \u5224\u65ad x \u7684\u7b26\u53f7\n        if (fabs(x) &lt; eps) return 0;\n        if (x &lt; 0) return -1;\n        return 1;\n    }\n    struct Point {\n        Tdouble x, y;\n        Point() = default;\n        Point(Tdouble x, Tdouble y) : x(x), y(y) {}\n        Point rotate(Point base, Tdouble rad) { // \u7ed5\u70b9base \u9006\u65f6\u9488\u65cb\u8f6c rad \u5f27\u5ea6\n            Point v(x - base.x, y - base.y);\n            Tdouble si = sin(rad), co = cos(rad);\n            return Point(base.x + v.x * co - v.y * si, base.y + v.x * si +  v.y * co);\n        }\n    }; // \u70b9\n    Point operator*(Point lhs, Tdouble rhs) {\n        return Point(lhs.x * rhs, lhs.y * rhs);\n    }\n    Point operator/(Point lhs, Tdouble rhs) {\n        return Point(lhs.x / rhs, lhs.y / rhs);\n    }\n    bool operator&lt;(const Point &amp;lhs, const Point &amp;rhs) {\n        return sgn(lhs.x - rhs.x) &lt; 0 || (sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) &lt; 0);\n    }\n    bool operator==(const Point &amp;lhs, const Point &amp;rhs) {\n        return !sgn(lhs.x - rhs.x) &amp;&amp; !sgn(lhs.y - rhs.y);\n    }\n    istream &amp;operator&gt;&gt;(istream &amp;is, Point &amp;point) {\n        return is &gt;&gt; point.x &gt;&gt; point.y;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point point) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; point.x &lt;&lt; \" \" &lt;&lt; point.y;\n    }\n    Tdouble distance(Point a, Point b) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    Tdouble distance2(Point a, Point b) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u5e73\u65b9\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n    struct Vector {\n        Tdouble x, y;\n        Vector() = default;\n        Vector(Tdouble x, Tdouble y) : x(x), y(y) {}\n        Tdouble length() { // \u5411\u91cf\u7684\u6a21\u957f\n            return sqrt(x * x + y * y);\n        }\n        Tdouble length2() { // \u5411\u91cf\u7684\u6a21\u957f\u7684\u5e73\u65b9\n            return x * x + y * y;\n        }\n        Tdouble getAngle() const { // \u5411\u91cf\u4e0ex\u8f74\u6b63\u65b9\u5411\u7684\u6781\u89d2\n            return atan2(y, x);\n        }\n        Vector format() { // \u5355\u4f4d\u5411\u91cf\n            Tdouble len = length();\n            return Vector(x / len, y / len);\n        }\n        Vector rotate(Tdouble rad) { // \u9006\u65f6\u9488\u65cb\u8f6c rad \u5f27\u5ea6\n            Tdouble si = sin(rad), co = cos(rad);\n            return Vector(x * co - y * si, x * si + y * co);\n        }\n        Vector rotateLeft() { // \u5de6\u65cb 90\u00b0\n            return Vector(-y, x);\n        }\n        Vector rotateRight() { // \u53f3\u65cb 90\u00b0\n            return Vector(y, -x);\n        }\n    }; // \u5411\u91cf\n    istream &amp;operator&gt;&gt;(istream &amp;is, Vector &amp;vec) {\n        return is &gt;&gt; vec.x &gt;&gt; vec.y;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vector vec) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; vec.x &lt;&lt; \" \" &lt;&lt; vec.y;\n    }\n    Vector operator+(const Vector lhs, const Vector rhs) { // \u5411\u91cf+\u5411\u91cf=\u5411\u91cf\n        return Vector(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Vector operator-(const Point lhs, const Point rhs) { // \u70b9-\u70b9=\u5411\u91cf\n        return Vector(lhs.x - rhs.x, lhs.y - rhs.y);\n    }\n    Point operator+(const Point lhs, const Point rhs) { // \u70b9+\u70b9=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator+(const Point lhs, const Vector rhs) { // \u70b9+\u5411\u91cf=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator+(const Vector lhs, const Point rhs) { // \u5411\u91cf+\u70b9=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator-(const Point lhs, const Vector rhs) { // \u70b9-\u5411\u91cf=\u70b9\n        return Point(lhs.x - rhs.x, lhs.y - rhs.y);\n    }\n    Vector operator*(Vector lhs, Tdouble rhs) {\n        return Vector(lhs.x * rhs, lhs.y * rhs);\n    }\n    Vector operator/(Vector lhs, Tdouble rhs) {\n        return Vector(lhs.x / rhs, lhs.y / rhs);\n    }\n    Tdouble dot(Vector A, Vector B) { // \u5411\u91cf\u70b9\u79ef\n        return A.x * B.x + A.y * B.y;\n    }\n    Tdouble cross(Point A, Point B) { // \u5411\u91cf\u53c9\u79ef\n        return A.x * B.y - B.x * A.y;\n    }\n    Tdouble cross(Vector A, Vector B) { // \u5411\u91cf\u53c9\u79ef\n        return A.x * B.y - B.x * A.y;\n    }\n    Tdouble cross(Point A, Point B, Point C) { // \u5411\u91cf\u53c9\u79ef\n        return cross(B - A, C - A);\n    }\n    Tdouble angle(Vector A, Vector B) { // \u8ba1\u7b97\u5939\u89d2(\u5f27\u5ea6\u5236)\n        return acos(dot(A, B) / A.length() / B.length());\n    }\n    Tdouble area2(Point a, Point b, Point c) { // \u8ba1\u7b97\u4e24\u5411\u91cf\u6784\u6210\u7684\u5e73\u884c\u56db\u8fb9\u5f62\u6709\u5411\u9762\u79ef\n        return cross(b - a, c - a);\n    }\n    struct Line {\n        Vector v;\n        Point p1, p2;\n        Line() = default;\n        Line(Point a, Vector v) : v(v), p1(a), p2(a + v) {}\n        Line(Point a, Point b) : v(b - a), p1(a), p2(b) {}\n        Point getPoint(Tdouble t) { // \u83b7\u53d6\u76f4\u7ebf\u4e0a\u4e00\u70b9\n            return v * t + p1;\n        }\n        bool isVertical(Line x) { // \u4e24\u7ebf\u662f\u5426\u5782\u76f4\n            return sgn(dot(v, x.v)) == 0;\n        }\n        bool isParallel(Line x) { // \u4e24\u7ebf\u662f\u5426\u5e73\u884c\n            return sgn(cross(v, x.v)) == 0;\n        }\n    };\n    bool operator&lt;(const Line &amp;lhs, const Line &amp;rhs) {\n        Tdouble delta = lhs.v.getAngle() - rhs.v.getAngle();\n        if (sgn(delta) == 0) {\n            Vector a = rhs.p1 - lhs.p1, b = rhs.p2 - lhs.p1;\n            return cross(a, b) &gt; 0;\n        }\n        return delta &lt; 0;\n    }\n    bool operator==(const Line &amp;lhs, const Line &amp;rhs) {\n        return sgn(lhs.v.getAngle() - rhs.v.getAngle()) == 0;\n    }\n    int pointLineRelation(Point A, Point B, Point C) { // \u5224\u65ad\u70b9\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n        return sgn(cross(C - B, A - B));\n    }\n    int pointLineRelation(Point A, Line L) { // \u5224\u65ad\u70b9\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n        return sgn(cross(L.p2 - L.p1, A - L.p1));\n    }\n    int lineCrossRelation(Line A, Line B) { // \u5224\u65ad\u76f4\u7ebf\u4e0e\u76f4\u7ebf\u95f4\u7684\u5173\u7cfb\n        // 0 \u5e73\u884c; 1 \u91cd\u5408; 2 \u76f8\u4ea4;\n        if (A.isParallel(B)) return (pointLineRelation(B.p1, A) == 0);\n        return 2;\n    }\n    bool segmentIntersection(Point A1, Point A2, Point B1, Point B2, bool contain = true) { // \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4(\u9ed8\u8ba4\u542b\u7aef\u70b9)\n        double c1 = cross(A2 - A1, B1 - A1), c2 = cross(A2 - A1, B2 - A1);\n        double c3 = cross(B2 - B1, A1 - B1), c4 = cross(B2 - B1, A2 - B1);\n        if (contain) return sgn(c1) * sgn(c2) &lt;= 0 &amp;&amp; sgn(c3) * sgn(c4) &lt;= 0;\n        return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(c3) * sgn(c4) &lt; 0;\n    }\n    bool onSegment(Point P, Point A, Point B) { // \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\n        return sgn(cross(A - P, B - P)) == 0 &amp;&amp; sgn(dot(A - P, B - P)) &lt;= 0;\n    }\n    bool onSegment(Point P, Line L) { // \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\n        Point s = L.p1, e = L.p2; \n        return onSegment(P, s, e);\n    }\n    int segmentLineRelation(Line seg, Line line) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 0 \u4e0d\u76f8\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n        int r1 = sgn(cross(line.v, seg.p1 - line.p1));\n        int r2 = sgn(cross(line.v, seg.p2 - line.p1));\n        if (r1 * r2 &lt; 0) return 2;\n        return (r1 == 0 || r2 == 0);\n    }\n    int segmentCrossRelation(Line a, Line b) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u7ebf\u6bb5\u7684\u5173\u7cfb\n        // 0 \u4e0d\u60f3\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n        int r1 = segmentLineRelation(a, b);\n        int r2 = segmentLineRelation(b, a);\n        if (r1 == 2 &amp;&amp; r2 == 2) return 2;\n        if (r1 == 1 || r2 == 1) {\n            return onSegment(b.p1, a) || onSegment(b.p2, a) || onSegment(a.p1, b) || onSegment(a.p2, b);\n        }\n        return 0;\n    }\n    Point getLineIntersection(Line A, Line B) { // \u4e24\u76f4\u7ebf\u4ea4\u70b9\n        assert(cross(A.v, B.v) != 0);\n        Vector u = A.p1 - B.p1;\n        Tdouble t = cross(B.v, u) / cross(A.v, B.v);\n        return A.p1 + A.v * t;\n    }\n    Tdouble distanceLine(Point P, Point A, Point B) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector v1 = B - A, v2 = P - A;\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceLine(Point P, Line x) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector v1 = x.v, v2 = P - x.p1;\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceSegment(Point P, Point A, Point B) { // \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\n        if (A == B) return (P - A).length();\n        Vector v1 = B - A, v2 = P - A, v3 = P - B;\n        if (sgn(dot(v1, v2)) &lt; 0) return v2.length();\n        if (sgn(dot(v1, v3)) &gt; 0) return v3.length();\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceSegment(Point P, Line S) { // \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\n        return distanceSegment(P, S.p1, S.p2);\n    }\n    Point lineProjection(Point P, Line x) { // \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9\n        return getLineIntersection(Line(P, x.v.rotateLeft()), x);\n    }\n    Point lineProjection(Point P, Point A, Point B) { // \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9\n        return lineProjection(P, Line(A, B));\n    }\n    Point footPoint(Point P, Point A, Point B) { // \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3\n        Vector x = P - A, y = P - B, z = B - A;\n        double len1 = dot(x, z) / z.length(), len2 = -1.0 * dot(y, z) / z.length();\n        return A + z * (len1 / (len1 + len2));\n    }\n    Point footPoint(Point P, Line X) { // \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3\n        Vector x = P - X.p1, y = P - X.p2, z = X.v;\n        double len1 = dot(x, z) / z.length(), len2 = -1.0 * dot(y, z) / z.length();\n        return X.p1 + z * (len1 / (len1 + len2));\n    }\n    Point symmetry(Point P, Line x) { // \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9\n        Point t = lineProjection(P, x);\n        return Point(2 * t.x - P.x, 2 * t.y - P.y);\n    }\n    Point symmetry(Point P, Point A, Point B) { // \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9\n        return symmetry(P, Line(A, B));\n    }\n    int pointTriangleRelation(Point P, Point A, Point B, Point C) { // \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb\n        // 1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n        if (P == A || P == B || P == C) return 4;\n        Vector v[3];\n        v[0] = A - P;\n        v[1] = B - P;\n        v[2] = C - P;\n        Tdouble z[3];\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            z[i] = fabs(cross(v[i], v[(i + 1) % 3]));\n        }\n        Tdouble S = fabs(cross(A - C, B - C));\n        if ((S - z[0] - z[1] - z[2]) &lt; 0) return 2;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            if (sgn(z[i]) == 0) return 3;\n        }\n        return 1;\n    }\n    Tdouble polygonArea(const vector&lt;Point&gt; &amp;points) { // \u6c42\u591a\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef\n        Tdouble area = 0.0;\n        int len = points.size();\n        for (int i = 1 ; i &lt; len - 1 ; i++) {\n            area += cross(points[i] - points[0], points[i + 1] - points[0]);\n        }\n        return area / 2.0;\n    }\n    Point polygonCenter(const vector&lt;Point&gt; &amp;points) { // \u6c42\u591a\u8fb9\u5f62\u91cd\u5fc3\n        Point res(0, 0);\n        Tdouble area = polygonArea(points);\n        if (sgn(area) == 0) return res;\n        int len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            res = res + (points[i] + points[(i + 1) % len]) * cross(points[i], points[(i + 1) % len]);\n        }\n        return res / area / 6.0;\n    }\n    int pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points) { // \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb\n        // 0 \u5728\u5916; 1 \u5728\u5185; 2 \u5728\u8fb9\u4e0a; 3 \u5728\u9876\u70b9\u4e0a;\n        int cnt = 0, len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            if (P == points[i]) return 3;\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            int j = (i + 1) % len;\n            if (onSegment(P, Line(points[i], points[j]))) return 2;\n            int c = sgn(cross(P - points[j], points[i] - points[j]));\n            int u = sgn(points[i].y - P.y);\n            int v = sgn(points[j].y - P.y);\n            if (c &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0) cnt++;\n            if (c &lt; 0 &amp;&amp; u &gt;= 0 &amp;&amp; v &lt; 0) cnt--;\n        }\n        return cnt != 0;\n    }\n    int segmentPolygonRelation(Line S, const vector&lt;Point&gt; &amp;points) { // \u7ebf\u7aef\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb\n        // 0 \u89c4\u8303\u76f8\u4ea4(\u4e0d\u542b\u7aef\u70b9); 1 \u5185\u76f8\u4ea4; 2 \u5185\u4e0d\u76f8\u4ea4; 3 \u4e0d\u76f8\u4ea4;\n        if (pointPolygonRelation(S.p1, points) == 1 &amp;&amp; pointPolygonRelation(S.p2, points) == 1) {\n            return 2;\n        }\n        vector&lt;Point&gt; temp;\n        int len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            Line a(points[i], points[(i + 1) % len]);\n            if (segmentCrossRelation(S, a) == 2) return 0;\n            else if (onSegment(S.p1, a)) temp.emplace_back(S.p1);\n            else if (onSegment(S.p2, a)) temp.emplace_back(S.p2);\n            if (onSegment(points[i], S)) temp.emplace_back(points[i]);\n        }\n        sort(begin(temp), end(temp));\n        len = temp.size();\n        for (int i = 1 ; i &lt; len ; i++) {\n            if (pointPolygonRelation((temp[i] + temp[i - 1]) / 2, points) == 1) return 1;\n        }\n        return 3;\n    }\n    int gridOnEdge(const vector&lt;Point&gt; &amp;points) { // \u591a\u8fb9\u5f62\u4e0a\u7f51\u683c\u70b9\u4e2a\u6570\n        int len = points.size();\n        int res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            res += __gcd(llabs(points[i].x - points[(i + 1) % len].x), llabs(points[i].y - points[(i + 1) % len].y));\n        }\n        return res;\n    }\n    int gridInSide(const vector&lt;Point&gt; &amp;points) { // \u591a\u8fb9\u5f62\u5185\u7f51\u683c\u70b9\u4e2a\u6570\n        int len = points.size();\n        int res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            res += points[(i + 1) % len].y * (points[i].x - points[(i + 2) % len].x);\n        }\n        return (llabs(res) - gridOnEdge(points)) / 2 + 1;\n    }\n    struct Circle {\n        Point c;\n        Tdouble r;\n        Circle() = default;\n        Circle(Point c, Tdouble r) : c(c), r(r) {}\n        Circle(Point A, Point B, Point C) {\n            Tdouble x11 = A.x * A.x + A.y * A.y;\n            Tdouble x22 = B.x * B.x + B.y * B.y;\n            Tdouble D = (x22 - (C.x * C.x + C.y * C.y)) * (A.y - B.y) - (x11 - x22) * (B.y - C.y);\n            D /=  (A.x - B.x) * (B.y - C.y) - (B.x - C.x) * (A.y - B.y);\n            Tdouble E = x11 - x22 + D * (A.x - B.x);\n            E /= B.y - A.y;\n            Tdouble F = -(x11 + D * A.x + E * A.y);\n            c = Point(-D / 2.0, -E / 2.0);\n            r = (D * D + E * E - 4 * F) / 4.0;\n        }\n        Point getPoint(Tdouble a) { // a \u4e3a\u5706\u5fc3\u89d2\n            return Point(c.x + cos(a) * r, c.y + sin(a) * r);\n        }\n    };\n    int pointCircleRelation(Point P, Circle C) { // \u5224\u65ad\u70b9\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = (P.x - C.c.x) * (P.x - C.c.x) + (P.y - C.c.y) * (P.y - C.c.y);\n        return 1 - sgn(dis - C.r * C.r);\n    }\n    int segmentCircleRelation(Line S, Circle C) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = distanceSegment(C.c, S);\n        int flag = sgn(dis - C.r);\n        if (flag &lt; 0) return 2;\n        else if (flag == 0) return 1;\n        return 0;\n    }\n    int lineCircleRelation(Line L, Circle C) { // \u5224\u65ad\u76f4\u7ebf\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = distanceLine(C.c, L);\n        int flag = sgn(dis - C.r);\n        if (flag &lt; 0) return 2;\n        else if (flag == 0) return 1;\n        return 0;\n    }\n    int circleCrossRelation(Circle C1, Circle C2) { //\u5224\u65ad\u4e24\u5706\u4e4b\u95f4\u7684\u5173\u7cfb\n        // 5 \u76f8\u79bb; 4 \u5916\u5207; 3 \u76f8\u4ea4; 2 \u5185\u5207; 1 \u5185\u542b;\n        Tdouble d = (C1.c - C2.c).length();\n        int k = sgn(d - (C1.r + C2.r));\n        if (k &gt; 0) return 5;\n        if (k == 0) return 4;\n        Tdouble dif = fabs(C1.r - C2.r);\n        int k2 = sgn(d - dif);\n        if (k &lt; 0 &amp;&amp; k2 &gt; 0) return 3;\n        if (k2 == 0) return 2;\n        return 1;\n    }\n    vector&lt;Point&gt; getLineCircleIntersection(Line L, Circle C) { // \u5706\u4e0e\u76f4\u7ebf\u4ea4\u70b9\n        Tdouble a = L.v.x, b = L.p1.x - C.c.x, c = L.v.y, d = L.p1.y - C.c.y;\n        Tdouble e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;\n        Tdouble delta = f * f - 4 * e * g;\n        if (sgn(delta) &lt; 0) {\n            return {};\n        }\n        if (sgn(delta) == 0) {\n            return {L.getPoint(-f / (2.0 * e))};\n        }\n        Tdouble sqr = sqrt(delta);\n        return {L.getPoint((-f - sqr) / (2.0 * e)), L.getPoint((-f + sqr) / (2.0 * e))};\n    }\n    vector&lt;Point&gt; getSegmentCircleIntersection(Line S, Circle C) { // \u7ebf\u6bb5\u548c\u5706\u7684\u4ea4\u70b9\n        Point proj = lineProjection(C.c, S);\n        Tdouble d1 = distance(C.c, proj);\n        if (!onSegment(proj, S)) {\n            d1 = min(distance(C.c, S.p1), distance(C.c, S.p2));\n        }\n        if (sgn(d1 - C.r) &gt; 0) return {};\n        Tdouble d2 = sqrt(C.r * C.r - distance(C.c, proj) * distance(C.c, proj));\n        if (sgn(d2) == 0) {\n            return {proj};\n        }\n        Vector v = S.v.format() * d2;\n        return {proj - v, proj + v};\n    }\n    vector&lt;Point&gt; getCircleIntersection(Circle C1, Circle C2) { // \u4e24\u5706\u4ea4\u70b9\n        int r = circleCrossRelation(C1, C2);\n        if (r == 1 || r == 5) return {};\n        Tdouble d1 = distance(C1.c, C2.c);\n        Tdouble len = (d1 * d1 + C1.r * C1.r - C2.r * C2.r) / (2 * d1);\n        Tdouble h = sqrt(C1.r * C1.r - len * len);\n        Vector u = C2.c - C1.c, v = u.rotateLeft();\n        Point proj = C1.c + u.format() * len;\n        Vector temp = v.format() * h;\n        if (r == 2 || r == 4) return {proj + temp};\n        return {proj + temp, proj - temp};\n    }\n    vector&lt;Line&gt; getCircleTangents(Point P, Circle C) { // \u70b9\u5230\u5706\u7684\u5207\u7ebf\n        int flag = pointCircleRelation(P, C);\n        if (flag == 2) return {};\n        if (flag == 1) {\n            return {Line(P, P + (P - C.c).rotateLeft())};\n        }\n        Tdouble d = distance(P, C.c);\n        Tdouble len = C.r * C.r / d;\n        Tdouble h = sqrt(C.r * C.r - len * len);\n        Point proj = C.c + (P - C.c).format() * len;\n        Vector temp = (P - C.c).format().rotateLeft() * h;\n        return {Line(P, proj + temp), Line(P, proj - temp)};\n    }\n    Tdouble circleOverlap2(Circle C1, Circle C2) { // \u4e24\u5706\u9762\u79ef\u4ea4\n        double d = (C1.c - C2.c).length();\n        if (sgn(C1.r + C2.r - d) == -1) {\n            return 0.0;\n        }\n        if (sgn(fabs(C1.r - C2.r) - d) == 1) {\n            Tdouble r = min(C1.r, C2.r);\n            return PI * r * r;\n        }\n        Tdouble x = (d * d + C1.r * C1.r - C2.r * C2.r) / (2.0 * d);\n        Tdouble p = (C1.r + C2.r + d) / 2.0;\n        Tdouble t1 = acos(x / C1.r);\n        Tdouble t2 = acos((d - x) / C2.r);\n        Tdouble s1 = C1.r * C1.r * t1;\n        Tdouble s2 = C2.r * C2.r * t2;\n        Tdouble s3 = 2 * sqrt(p * (p - C1.r) * (p - C2.r) * (p - d));\n        return s1 + s2 - s3;\n    }\n    Point nearPointToCircle(Point P, Circle C) { // \u5706\u4e0a\u8ddd\u79bbP\u6700\u8fd1\u7684\u70b9\n        Vector z = P - C.c;\n        Tdouble len = z.length();\n        if (sgn(len) == 0) return P;\n        Tdouble sign = (C.c.x - P.x) * (C.c.y - P.y) &lt; 0 ? -1 : 1;\n        Tdouble a1 = C.r * fabs(C.c.x - P.x) / len;\n        Tdouble a2 = C.r * fabs(C.c.y - P.y) / len * sign;\n        Point u(C.c.x + a1, C.c.y + a2), v(C.c.x - a1, C.c.y - a2);\n        return (u - P).length() &lt; (v - P).length() ? u : v;\n    }\n    Circle getCircumCircle(Point A, Point B, Point C) { // \u5916\u63a5\u5706\n        Tdouble Bx = B.x - A.x, By = B.y - A.y;\n        Tdouble Cx = C.x - A.x, Cy = C.y - A.y;\n        Tdouble D = 2.0 * (Bx * Cy - By * Cx);\n        Tdouble ansX = A.x + (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D;\n        Tdouble ansY = A.y + (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D;\n        Point c(ansX, ansY);\n        return Circle(c, (A - c).length());\n    }\n    Circle getInscribedCircle(Point A, Point B, Point C) { // \u5185\u63a5\u5706\n        Tdouble a = (B - C).length();\n        Tdouble b = (C - A).length();\n        Tdouble c = (A - B).length();\n        Point p = (A * a + B * b + C * c) / (a + b + c);\n        return Circle(p, distanceLine(p, A, B));\n    }\n    struct Point3D {\n        Tdouble x, y, z;\n        Point3D() = default;\n        Point3D(Tdouble x, Tdouble y, Tdouble z) : x(x), y(y), z(z) {}\n        Point3D(Point P) : x(P.x), y(P.y), z(P.x * P.x + P.y * P.y) {}\n        void shake() {\n            x += reps();\n            y += reps();\n            z += reps();\n        }\n    };\n    bool operator==(const Point3D &amp;lhs, const Point3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) == 0 &amp;&amp; sgn(lhs.z - rhs.z) == 0;\n    }\n    istream &amp;operator&gt;&gt;(istream &amp;is, Point3D &amp;point) {\n        return is &gt;&gt; point.x &gt;&gt; point.y &gt;&gt; point.z;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point3D point) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; point.x &lt;&lt; \" \" &lt;&lt; point.y &lt;&lt; \" \" &lt;&lt; point.z;\n    }\n    struct Vector3D {\n        Tdouble x, y, z;\n        Vector3D() = default;\n        Vector3D(Point3D P) : x(P.x), y(P.y), z(P.z) {}\n        Vector3D(Tdouble x, Tdouble y, Tdouble z) : x(x), y(y), z(z) {}\n        Tdouble length() const {\n            return sqrtl(x * x + y * y + z * z);\n        }\n        Vector3D format() { // \u5355\u4f4d\u5411\u91cf\n            Tdouble len = length();\n            return Vector3D(x / len, y / len, z / len);\n        }\n    };\n    istream &amp;operator&gt;&gt;(istream &amp;is, Vector3D &amp;vec) {\n        return is &gt;&gt; vec.x &gt;&gt; vec.y &gt;&gt; vec.z;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vector3D vec) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; vec.x &lt;&lt; \" \" &lt;&lt; vec.y &lt;&lt; \" \" &lt;&lt; vec.z;\n    }\n    bool operator==(const Vector3D &amp;lhs, const Vector3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) == 0 &amp;&amp; sgn(lhs.z - rhs.z) == 0;\n    }\n    bool operator!=(const Vector3D &amp;lhs, const Vector3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) != 0 || sgn(lhs.y - rhs.y) != 0 || sgn(lhs.z - rhs.z) != 0;\n    }\n    Vector3D operator+(const Vector3D lhs, const Vector3D rhs) { // \u5411\u91cf+\u5411\u91cf=\u5411\u91cf\n        return Vector3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Vector3D operator-(const Point3D lhs, const Point3D rhs) { // \u70b9-\u70b9=\u5411\u91cf\n        return Vector3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n    }\n    Point3D operator+(const Point3D lhs, const Point3D rhs) { // \u70b9+\u70b9=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator+(const Point3D lhs, const Vector3D rhs) { // \u70b9+\u5411\u91cf=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator+(const Vector3D lhs, const Point3D rhs) { // \u5411\u91cf+\u70b9=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator-(const Point3D lhs, const Vector3D rhs) { // \u70b9-\u5411\u91cf=\u70b9\n        return Point3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n    }\n    Vector3D operator*(const Vector3D lhs, const Tdouble rhs) {\n        return Vector3D(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);\n    }\n    Tdouble distance(Point3D A, Point3D B) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n        return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) + (A.z - B.z) * (A.z - B.z));\n    }\n    Vector3D cross(Vector3D A, Vector3D B) { // \u4e09\u7ef4\u53c9\u79ef\n        return Vector3D(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);\n    }\n    Vector3D cross(Point3D A, Point3D B, Point3D C) { // \u4e09\u7ef4\u53c9\u79ef\n        return cross(B - A, C - A);\n    }\n    Tdouble dot(Vector3D A, Vector3D B) { // \u4e09\u7ef4\u70b9\u79ef\n        return A.x * B.x + A.y * B.y + A.z * B.z;\n    }\n    int inCircle(Point P, Point A, Point B, Point C) { // \u70b9\u4e0e\u5706\u7684\u5173\u7cfb\n        // -1 \u5185; 0 \u4e0a; 1 \u5916; \n        if (cross(A, B, C) &lt; 0) swap(B, C);\n        Point3D p(P), a(A), b(B), c(C);\n        Vector3D p1(p - a), a1(a), b1(b - a), c1(c - a);\n        return sgn(dot(p1, cross(b1, c1)));\n    }\n    struct Line3D {\n        Vector3D v;\n        Point3D p1, p2;\n        Line3D() = default;\n        Line3D(Point3D a, Vector3D v) : v(v), p1(a), p2(a + v) {}\n        Line3D(Point3D a, Point3D b) : v(b - a), p1(a), p2(b) {}\n        Point3D getPoint3D(Tdouble t) { // \u5f97\u5230\u7ebf\u4e0a\u4e00\u70b9\n            return v * t + p1;\n        }\n        bool isVertical(Line3D x) { // \u5224\u65ad\u5782\u76f4\n            return sgn(dot(v, x.v)) == 0;\n        }\n        bool isParallel(Line3D x) { // \u5224\u65ad\u5e73\u884c\n            return sgn(cross(v, x.v).length()) == 0;\n        }\n    };\n    Tdouble distanceLine(Point3D P, Line3D x) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector3D v1 = x.v, v2 = P - x.p1;\n        return fabs(cross(v1, v2).length() / v1.length());\n    }\n    Point3D getLineIntersection(Line3D A, Line3D B) { // \u4e24\u76f4\u7ebf\u4ea4\u70b9\n        Vector3D u = cross(B.v, A.p1 - B.p1);\n        Vector3D v = cross(A.v, B.v);\n        Tdouble flag = dot(u, v);\n        if (sgn(flag) &gt; 0) return A.p1 + A.v * (u.length() / v.length());\n        return A.p1 + A.v * (-u.length() / v.length());\n    }\n    Line3D getPlaneIntersection(Line3D A, Line3D B) { // \u4e24\u9762\u4ea4\u7ebf\n        // A, B\u4e3a\u6cd5\u5411\u91cf \u8d77\u70b9\u5728\u5e73\u9762\u4e0a\n        Vector3D v = cross(A.v, B.v);\n        Tdouble d1 = -dot(Vector3D(A.p1), A.v);\n        Tdouble d2 = -dot(Vector3D(B.p1), B.v);\n        Tdouble x = 0, y = 0, z = 0;\n        if (sgn(v.x)) {\n            y = (A.v.z * d2 - B.v.z * d1) / (A.v.y * B.v.z - B.v.y * A.v.z);\n            z = (B.v.y * d1 - A.v.y * d2) / (A.v.y * B.v.z - B.v.y * A.v.z);\n        } else if (sgn(v.y)) {\n            x = (A.v.z * d2 - B.v.z * d1) / (A.v.x * B.v.z - B.v.x * A.v.z);\n            z = (B.v.x * d1 - A.v.x * d2) / (A.v.x * B.v.z - B.v.x * A.v.z);\n        } else {\n            x = (A.v.y * d2 - B.v.y * d1) / (A.v.x * B.v.y - B.v.x * A.v.y);\n            y = (B.v.x * d1 - A.v.x * d2) / (A.v.x * B.v.y - B.v.x * A.v.y);\n        }\n        return Line3D(Point3D(x, y, z), v);\n    }\n    int point3DTriangleRelation(Point3D P, Point3D A, Point3D B, Point3D C) { // \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb\n        // 1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n        if (P == A || P == B || P == C) return 4;\n        Vector3D v[3];\n        v[0] = A - P;\n        v[1] = B - P;\n        v[2] = C - P;\n        Tdouble z[3];\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            z[i] = fabs(cross(v[i], v[(i + 1) % 3]).length());\n        }\n        Tdouble S = fabs(cross(A - C, B - C).length());\n        if (sgn(S - z[0] - z[1] - z[2]) &lt; 0) return 2;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            if (sgn(z[i]) == 0) return 3;\n        }\n        return 1;\n    }\n    struct Face {\n        pair&lt;Point3D, int&gt; x, y, z;\n        Face() = default;\n        Face(pair&lt;Point3D, int&gt; x, pair&lt;Point3D, int&gt; y, pair&lt;Point3D, int&gt; z) : x(x), y(y), z(z) {}\n        Vector3D normal() const { // \u6cd5\u5411\u91cf\n            return cross(x.first, y.first, z.first);\n        }\n        Tdouble area() { // \u9762\u79ef\n            return normal().length() / 2.0;\n        }\n        bool see(Point3D P) { // \u662f\u5426\u5728\u5e73\u9762\u4e0a\n            return sgn(dot(normal(), P - x.first)) &gt; 0;\n        }\n        int operator[](int pos) {\n            if (pos == 0) return x.second;\n            if (pos == 1) return y.second;\n            if (pos == 2) return z.second;\n            return -1;\n        }\n    };\n    Point3D lineFaceIntersection(Line3D L, Point3D A, Point3D B, Point3D C) { // \u7ebf\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9\n        Vector3D v = cross(A, B, C);\n        Tdouble vt = dot(L.v, v);\n        assert(sgn(vt) != 0);\n        return L.getPoint3D(dot(A, v) / vt);\n    }\n}; // ComputingGeometry\n/*\n    \u70b9\u7ed5\u70b9\u9006\u65f6\u9488\u65cb\u8f6c    Point::rotate(Point base, Tdouble rad)\n    \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb     distance(Point a, Point b) \n                   distance(Point3D A, Point3D B)\n    \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u5e73\u65b9 distance2(Point a, Point b)\n    \u6a21\u957f         Vector::length()\n    \u6a21\u957f\u7684\u5e73\u65b9         Vector::length2()\n    \u4e0ex\u8f74\u6b63\u65b9\u5411\u5939\u89d2 Vector::getAngle()\n    \u5355\u4f4d\u5411\u91cf       Vector::format()\n    \u5411\u91cf\u9006\u65f6\u9488\u65cb\u8f6c  Vector::rotate(Tdouble rad)\n    \u5411\u91cf\u5de6\u65cb90\u00b0  Vector::rotateLeft()\n    \u5411\u91cf\u53f3\u65cb90\u00b0  Vector::rotateRight()\n    \u5411\u91cf\u70b9\u79ef  dot(Vector A, Vector B)\n            dot(Vector3D A, Vector3D B)\n    \u5411\u91cf\u53c9\u79ef  cross(Vector A, Vector B)\n            cross(Point A, Point B)\n            cross(Point A, Point B, Point C)\n            cross(Vector3D A, Vector3D B)\n            cross(Point3D A, Point3D B, Point3D C)\n    \u5411\u91cf\u5939\u89d2 angle(Vector A, Vector B)\n    \u5411\u91cf\u6784\u6210\u5e73\u884c\u56db\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef area2(Point a, Point b, Point c)\n    \u76f4\u7ebf\u4e0a\u4e00\u70b9 Line::getPoint(Tdouble t)\n            Line3D::getPoint3D(Tdouble t)\n    \u5224\u65ad\u76f4\u7ebf\u5782\u76f4 Line::isVertical(Line x)\n                Line3D:;isVertical(Line3D x)\n    \u5224\u65ad\u76f4\u7ebf\u5e73\u884c Line::isParallel(Line x)\n            Line3D::isParallel(Line3D x)\n    \u70b9\u548c\u76f4\u7ebf\u5173\u7cfb pointLineRelation(Point A, Line L)\n              pointLineRelation(Point A, Point B, Point C)\n              1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n    \u76f4\u7ebf\u4e0e\u76f4\u7ebf\u95f4\u7684\u5173\u7cfb lineCrossRelation(Line A, Line B)\n            0 \u5e73\u884c; 1 \u91cd\u5408; 2 \u76f8\u4ea4;\n    \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a onSegment(Point P, Line L)\n            onSegment(Point P, Point A, Point B)\n    \u7ebf\u6bb5\u548c\u76f4\u7ebf\u7684\u5173\u7cfb segmentLineRelation(Line seg, Line line)\n            0 \u4e0d\u76f8\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n    \u7ebf\u6bb5\u548c\u7ebf\u6bb5\u7684\u5173\u7cfb segmentCrossRelation(Line a, Line b)\n            0 \u4e0d\u60f3\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n    \u4e24\u76f4\u7ebf\u4ea4\u70b9 getLineIntersection(Line A, Line B)\n    \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb distanceLine(Point P, Line x)\n               distanceLine(Point P, Point A, Point B)\n               distanceLine(Point3D P, Line3D x)\n    \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb  distanceSegment(Point P, Line S)\n            distanceSegment(Point P, Point A, Point B)\n    \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9 lineProjection(Point P, Line x)\n                lineProjection(Point P, Point A, Point B)\n    \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3 footPoint(Point P, Line X)\n            footPoint(Point P, Point A, Point B)\n    \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9  symmetry(Point P, Line x)\n                symmetry(Point P, Point A, Point B)\n    \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb pointTriangleRelation(Point P, Point A, Point B, Point C)\n                   point3DTriangleRelation(Point3D P, Point3D A, Point3D B, Point3D C)\n                1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n    \u591a\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef polygonArea(const vector&lt;Point&gt; &amp;points)\n    \u591a\u8fb9\u5f62\u91cd\u5fc3 polygonCenter(const vector&lt;Point&gt; &amp;points)\n    \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points)\n            0 \u5728\u5916; 1 \u5728\u5185; 2 \u5728\u8fb9\u4e0a; 3 \u5728\u9876\u70b9\u4e0a;\n    \u7ebf\u7aef\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb segmentPolygonRelation(Line S, const vector&lt;Point&gt; &amp;points)\n            0 \u89c4\u8303\u76f8\u4ea4(\u4e0d\u542b\u7aef\u70b9); 1 \u5185\u76f8\u4ea4; 2 \u5185\u4e0d\u76f8\u4ea4; 3 \u4e0d\u76f8\u4ea4;\n    \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points)\n                1 \u591a\u8fb9\u5f62\u5185; 0 \u591a\u8fb9\u5f62\u5916; -1 \u591a\u8fb9\u5f62\u4e0a;\n    \u591a\u8fb9\u5f62\u4e0a\u7f51\u683c\u70b9\u4e2a\u6570 gridOnEdge(const vector&lt;Point&gt; &amp;points)\n    \u591a\u8fb9\u5f62\u5185\u7f51\u683c\u70b9\u4e2a\u6570 gridInSide(const vector&lt;Point&gt; &amp;points)\n    \u5706\u4e0a\u4e00\u70b9 Circle::getPoint(Tdouble a)\n    \u70b9\u548c\u5706\u7684\u5173\u7cfb pointCircleRelation(Point P, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u7ebf\u6bb5\u548c\u5706\u7684\u5173\u7cfb segmentCircleRelation(Line S, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u76f4\u7ebf\u548c\u5706\u7684\u5173\u7cfb lineCircleRelation(Line L, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u4e24\u5706\u4e4b\u95f4\u7684\u5173\u7cfb circleCrossRelation(Circle C1, Circle C2)\n            5 \u76f8\u79bb; 4 \u5916\u5207; 3 \u76f8\u4ea4; 2 \u5185\u5207; 1 \u5185\u542b;\n    \u76f4\u7ebf\u4e0e\u5706\u4ea4\u70b9 getLineCircleIntersection(Line L, Circle C)\n    \u7ebf\u6bb5\u4e0e\u5706\u7684\u4ea4\u70b9 getSegmentCircleIntersection(Line S, Circle C)\n    \u4e24\u5706\u4ea4\u70b9 getCircleIntersection(Circle C1, Circle C2)\n    \u70b9\u5230\u5706\u7684\u5207\u7ebf getCircleTangents(Point P, Circle C)\n    \u4e24\u5706\u9762\u79ef\u4ea4 circleOverlap2(Circle C1, Circle C2)\n    \u5706\u4e0a\u8ddd\u79bbP\u6700\u8fd1\u7684\u70b9 nearPointToCircle(Point P, Circle C)\n    \u5916\u63a5\u5706 getCircumCircle(Point A, Point B, Point C)\n    \u5185\u63a5\u5706 getInscribedCircle(Point A, Point B, Point C)\n    \u9762\u9762\u4ea4\u7ebf getPlaneIntersection(Line3D A, Line3D B)\n    \u5e73\u9762\u6cd5\u5411\u91cf Face::normal()\n    \u5e73\u9762\u9762\u79ef Face::area()\n    \u70b9\u662f\u5426\u5728\u5e73\u9762\u4e0a Face::see(Point3D P)\n    \u7ebf\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9 lineFaceIntersection(Line3D L, Point3D A, Point3D B, Point3D C)\n*/\nusing namespace ComputingGeometry;\n</code></pre>"},{"location":"template/computational-geometry/half-plane/","title":"\u534a\u5e73\u9762\u4ea4","text":"<p>\u6c42\u591a\u4e2a\u51f8\u591a\u8fb9\u5f62\u7684\u4ea4\u7684\u9762\u79ef</p> \u4f8b\u9898 <p>P4196 [CQOI2006] \u51f8\u591a\u8fb9\u5f62 /\u3010\u6a21\u677f\u3011\u534a\u5e73\u9762\u4ea4 - \u6d1b\u8c37</p> <p>\u6c42 \\(n\\) \u4e2a\u51f8\u591a\u8fb9\u5f62\u7684\u9762\u79ef\u4ea4</p> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nvector&lt;Point&gt; points[10];\nvector&lt;Line&gt; lines;\nint deq[505];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int m;\n        cin &gt;&gt; m;\n        points[i].resize(m);\n        for (int j = 0 ; j &lt; m ; j++) {\n            cin &gt;&gt; points[i][j];\n        }\n        for (int j = 0 ; j &lt; m ; j++) {\n            lines.emplace_back(points[i][j], points[i][(j + 1) % m]);\n        }\n    }\n    sort(begin(lines), end(lines));\n    lines.resize(unique(begin(lines), end(lines)) - begin(lines));\n    auto check = [&amp;](int i, int j, int k) {\n        Point x = getLineIntersection(lines[j], lines[k]);\n        return sgn(cross(x, lines[i].p1, lines[i].p2)) &lt; 0;\n    };\n    int L = 1, R = 0;\n    deq[++R] = 0;\n    deq[++R] = 1;\n    int len = lines.size();\n    for (int i = 2 ; i &lt; len ; i++) {\n        while (L &lt; R &amp;&amp; check(i, deq[R], deq[R - 1])) {\n            R--;\n        }\n        while (L &lt; R &amp;&amp; check(i, deq[L], deq[L + 1])) {\n            L++;\n        }\n        deq[++R] = i;\n    }\n    while (L &lt; R &amp;&amp; check(deq[L], deq[R - 1], deq[R])) {\n        R--;\n    }\n    while (L &lt; R &amp;&amp; check(deq[R], deq[L], deq[L + 1])) {\n        L++;\n    }\n    vector&lt;Point&gt; res;\n    for (int i = L ; i &lt; R ; i++) {\n        res.emplace_back(getLineIntersection(lines[deq[i]], lines[deq[i + 1]]));\n    }\n    if (R - L &gt; 1) {\n        res.emplace_back(getLineIntersection(lines[deq[R]], lines[deq[L]]));\n    }\n    len = res.size();\n    Tdouble ans = 0;\n    for (int i = 0 ; i &lt; len ; i++) {\n        ans += cross(res[i], res[(i + 1) % len]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; fabs(ans) / 2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/problem-set/","title":"\u6742\u9898(1)","text":""},{"location":"template/computational-geometry/problem-set/#_1","title":"\u6c42\u4e09\u7ef4\u7a7a\u95f4\u4e0a\u4e24\u4e2a\u5706\u9762\u7684\u4ea4\u7ebf\u7684\u957f\u5ea6","text":"Code <p>\u8f93\u5165\u662f\u4e24\u4e2a\u5706\u9762\u7684\u534a\u5f84\uff0c\u5706\u5f62\u3001\u6cd5\u5411\u91cf</p> C++<pre><code>// Problem: H - Circle Intersection\n// Contest: Virtual Judge - \u6e56\u5357\u7701\u7b2c\u5341\u4e03\u5c4a\u5927\u5b66\u751f\u8ba1\u7b97\u673a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08HNCPC2021\uff09 [Cloned]\n// URL: https://vjudge.net/contest/577909#problem/H\n// Memory Limit: 128 MB\n// Time Limit: 1000 ms\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u57fa\u7840\u8ba1\u7b97\u51e0\u4f55 }\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    Point3D A, C;\n    Vector3D B, D;\n    Tdouble R1, R2;\n    while (cin &gt;&gt; R1 &gt;&gt; A &gt;&gt; B) {\n        cin &gt;&gt; R2 &gt;&gt; C &gt;&gt; D;\n        Vector3D G = cross(B, D);\n        Line3D v = getPlaneIntersection(Line3D(A, B), Line3D(C, D));\n        if (sgn(distanceLine(A, v) - R1) &gt; 0 || sgn(distanceLine(C, v) - R2) &gt; 0) {\n            cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n            continue;\n        }\n        Line3D C1(A, cross(v.v, B));\n        Point3D mid1 = getLineIntersection(C1, v);\n        Tdouble d1 = (A - mid1).length();\n        Vector3D t1 = v.v * (sqrt(R1 * R1 - d1 * d1) / v.v.length());\n        Point3D p1 = mid1 + t1;\n        Point3D p2 = mid1 - t1;\n        Line3D C2(C, cross(v.v, D));\n        Point3D mid2 = getLineIntersection(C2, v);\n        Tdouble d2 = (C - mid2).length();\n        Vector3D t2 = v.v * (sqrt(R2 * R2 - d2 * d2) / v.v.length());\n        Point3D p3 = mid2 + t2;\n        Point3D p4 = mid2 - t2;\n        Tdouble res = 0.0;\n        if (sgn(dot(p1 - p3, p1 - p4)) &lt;= 0) {\n            res = min(distance(p1, p2), distance(p1, p4));\n        } else if (sgn(dot(p2 - p3, p2 - p4)) &lt;= 0) {\n            res = min(distance(p2, p1), distance(p2, p3));\n        } else if (sgn(dot(p3 - p1, p3 - p2)) &lt;= 0) {\n            res = min(distance(p3, p4), distance(p3, p2));\n        } else if (sgn(dot(p4 - p1, p4 - p2)) &lt;= 0) {\n            res = min(distance(p4, p3), distance(p4, p1));\n        }\n        if (sgn(res) &lt;= 0) cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n        else cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/rotating-calipers/","title":"\u65cb\u8f6c\u5361\u58f3","text":"\u4e60\u9898 \u6d1b\u8c37P1452\u6d1b\u8c37P3187 <p>P1452 [USACO03FALL] Beauty Contest G /\u3010\u6a21\u677f\u3011\u65cb\u8f6c\u5361\u58f3 - \u6d1b\u8c37</p> <p>\u6c42\u51f8\u5305\u7684\u76f4\u5f84.</p> <p>\u6c42\u51f8\u5305\u540e, \u679a\u4e3e\u8fb9, \u627e\u5230\u6700\u8fdc\u7684\u70b9, \u8ba1\u7b97\u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb.</p> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\nTdouble RoatingCalipers(const vector&lt;Point&gt; &amp;p) {\n    if (p.size() == 3) return (p[0] - p[1]).length();\n    int cur = 0, len = p.size();\n    Tdouble ans = 0;\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        Line line(p[i], p[i + 1]);\n        while (sgn(distanceLine(p[cur], line) - distanceLine(p[(cur + 1) % len], line)) &lt;= 0) {\n            cur = (cur + 1) % len;\n        }\n        ans = max({ans, (p[i] - p[cur]).length(), (p[i + 1] - p[cur]).length()});\n    } \n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto c = ConvexHull2D(a);\n    auto d = RoatingCalipers(c);\n    cout &lt;&lt; int(d * d);\n    return 0;\n}\n</code></pre> <p>P3187 [HNOI2007] \u6700\u5c0f\u77e9\u5f62\u8986\u76d6 - \u6d1b\u8c37</p> <p>\u6c42\u8986\u76d6 \\(n\\) \u4e2a\u70b9\u4e14\u9762\u79ef\u6700\u5c0f\u7684\u77e9\u5f62, \u4ee5\u53ca\u8be5\u77e9\u5f62\u7684\u56db\u4e2a\u9876\u70b9</p> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\n#define func(a) (sgn(a) &lt; 0 ? a = -a : 0.0)\npair&lt;array&lt;Point, 4&gt;, Tdouble&gt; RoatingCalipers(const vector&lt;Point&gt; &amp;p) {\n    Tdouble res, ans = 1e100;\n    int a = 1, b = 1, c = 1, len = p.size();\n    array&lt;Point, 4&gt; point;\n    for (int i = 1 ; i &lt; len ; i++) {\n        Vector v1 = p[i - 1] - p[i], v2 = p[i] - p[i - 1];\n        while (sgn(cross(p[(a + 1) % len] - p[i], v1) - cross(p[a] - p[i], v1) &gt;= 0)) {\n            a = (a + 1) % len;\n        }\n        while (sgn(dot(p[(b + 1) % len] - p[i], v1) - dot(p[b] - p[i], v1)) &lt;= 0) {\n            b = (b + 1) % len;\n        }\n        if (i == 1) c = a;\n        while (sgn(dot(p[(c + 1) % len] - p[i - 1], p[i] - p[i - 1]) - dot(p[c] - p[i - 1], p[i] - p[i - 1])) &lt;= 0) {\n            c = (c + 1) % len;\n        }\n        Tdouble dis = v2.length();\n        Tdouble L = dot(p[c] - p[i], v1) / dis;\n        Tdouble R = dot(p[b] - p[i - 1], v2) / dis;\n        Tdouble H = fabs(area2(p[i], p[i - 1], p[a])) / dis;\n        func(L);func(R);func(H);\n        res = (L + R - dis) * H;\n        if (res &lt; ans) {\n            ans = res;\n            point[0] = p[i] - v2 * (L / dis);\n            point[1] = point[0] + v2 * ((L + R - dis) / dis);\n            point[2] = point[1] + (p[b] - point[1]) * (H / (p[b] - point[1]).length());\n            point[3] = point[2] + v1 * ((L + R - dis) / dis);\n        }\n    }\n    return {point, ans};\n}\n#undef func(a)\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto c = ConvexHull2D(a);\n    auto [point, ans] = RoatingCalipers(c);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; ans &lt;&lt; \"\\n\";\n    int pos = 0;\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        if (point[i].y &lt; point[pos].y || (point[i].y == point[pos].y &amp;&amp; point[i].x &lt; point[pos].x)) {\n            pos = i;\n        }\n    }\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        int k = (pos + i) % 4;\n        if (sgn(point[k].x) == 0) point[k].x = 0.0;\n        if (sgn(point[k].y) == 0) point[k].y = 0.0;\n        cout &lt;&lt; point[k] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/scanning/","title":"\u626b\u63cf\u7ebf","text":""},{"location":"template/computational-geometry/scanning/#_2","title":"\u6c42\u77e9\u9635\u9762\u79ef\u5e76","text":"\u4f8b\u9898 \u6d1b\u8c37P5490\u6d1b\u8c37P1856 <p>P5490 \u3010\u6a21\u677f\u3011\u626b\u63cf\u7ebf - \u6d1b\u8c37</p> <p>\u6c42 \\(n\\) \u4e2a\u77e9\u9635\u7684\u9762\u79ef\u5e76</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;int&gt; idx(1, -1);\nint sum[200010 &lt;&lt; 3], cnt[200010 &lt;&lt; 3];\nvoid pushup(int p, int L, int R) {\n    if (sum[p]) { // \u6709\u7ebf\u6bb5\u8986\u76d6, \u5219\u4e3a\u6574\u4e2a\u533a\u95f4\u957f\u5ea6[L, R)\n        cnt[p] = idx[R + 1] - idx[L];\n    } else {\n        cnt[p] = cnt[p &lt;&lt; 1] + cnt[p &lt;&lt; 1 | 1];\n    }\n}\nvoid modify(int p, int L, int R, int QL, int QR, int k) {\n    if (idx[R + 1] &lt;= QL || idx[L] &gt;= QR) return;\n    if (QL &lt;= idx[L] &amp;&amp; idx[R + 1] &lt;= QR) {\n        sum[p] += k;\n        pushup(p, L, R);\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n    modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n    pushup(p, L, R);\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;array&lt;int, 4&gt;&gt; lines;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        idx.push_back(x1);\n        idx.push_back(x2);\n        lines.push_back({x1, x2, y1, 1});\n        lines.push_back({x1, x2, y2, -1});\n    }\n    sort(begin(lines), end(lines), [&amp;](const auto &amp;x, const auto &amp;y) {\n        if (x[2] == y[2]) {\n            return x[3] &gt; y[3];\n        }\n        return x[2] &lt; y[2];\n    });\n    idx.push_back(2e9);\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    i64 ans = 0;\n    int len = idx.size() - 2;\n    for (int i = 0 ; i &lt; (int) lines.size() - 1 ; i++) {\n        auto [L, R, H, mark] = lines[i];\n        modify(1, 1, len, L, R, mark);\n        ans += 1LL * cnt[1] * (lines[i + 1][2] - H);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P1856 [IOI1998] [USACO5.5] \u77e9\u5f62\u5468\u957fPicture</p> <p>\u6c42 \\(n\\) \u4e2a\u77e9\u9635\u7684\u5468\u957f\u5e76</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;int&gt; idx(1, -200000);\nint sum[200010 &lt;&lt; 3], cnt[200010 &lt;&lt; 3], mark[200010 &lt;&lt; 3];\nbool vis[200010 &lt;&lt; 3][2];\nvoid pushup(int p, int L, int R) {\n    int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n    if (sum[p]) { // \u6709\u7ebf\u6bb5\u8986\u76d6, \u5219\u4e3a\u6574\u4e2a\u533a\u95f4\u957f\u5ea6[L, R)\n        cnt[p] = idx[R + 1] - idx[L];\n        vis[p][0] = vis[p][1] = true;\n        mark[p] = 1;\n    } else {\n        cnt[p] = cnt[x] + cnt[y];\n        vis[p][0] = vis[x][0];\n        vis[p][1] = vis[y][1];\n        mark[p] = mark[x] + mark[y];\n        if (vis[x][1] &amp;&amp; vis[y][0]) {\n            mark[p]--;\n        }\n    }\n}\nvoid modify(int p, int L, int R, int QL, int QR, int k) {\n    if (idx[R + 1] &lt;= QL || idx[L] &gt;= QR) return;\n    if (QL &lt;= idx[L] &amp;&amp; idx[R + 1] &lt;= QR) {\n        sum[p] += k;\n        pushup(p, L, R);\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n    modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n    pushup(p, L, R);\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;array&lt;int, 4&gt;&gt; lines;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        idx.push_back(x1);\n        idx.push_back(x2);\n        lines.push_back({x1, x2, y1, 1});\n        lines.push_back({x1, x2, y2, -1});\n    }\n    sort(begin(lines), end(lines), [&amp;](const auto &amp;x, const auto &amp;y) {\n        if (x[2] == y[2]) {\n            return x[3] &gt; y[3];\n        }\n        return x[2] &lt; y[2];\n    });\n    idx.push_back(2e9);\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    i64 ans = 0;\n    int len = idx.size() - 2;\n    int last = 0;\n    for (int i = 0 ; i &lt; (int) lines.size() - 1 ; i++) {\n        auto [L, R, H, mrk] = lines[i];\n        modify(1, 1, len, L, R, mrk);\n        ans += llabs(last - cnt[1]);\n        last = cnt[1];\n        ans += 2LL * mark[1] * (lines[i + 1][2] - H);\n    }\n    ans += lines.back()[1] - lines.back()[0];\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/computational-geometry/triangulation/","title":"\u4e09\u89d2\u5256\u5206","text":"\u6a21\u7248 \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nstruct Edge {\n    int idx;\n    list&lt;Edge&gt;::iterator nxt;\n    Edge(int idx = 0) : idx(idx) {}\n};\nlist&lt;Edge&gt; head[100005];\nint idx[100005], n;\nvector&lt;pair&lt;Point, int&gt;&gt; points;\nvoid addEdge(int u, int v) {\n    head[u].emplace_front(v);\n    head[v].emplace_front(u);\n    begin(head[u]) -&gt; nxt = begin(head[v]);\n    begin(head[v]) -&gt; nxt = begin(head[u]);\n}\nvoid Delaunay(int L, int R) {\n    if (R - L &lt; 3) {\n        for (int i = L ; i &lt;= R ; i++) {\n            for (int j = i + 1 ; j &lt;= R ; j++) {\n                addEdge(i, j);\n            }\n        }\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Delaunay(L, mid);\n    Delaunay(mid + 1, R);\n    int _L = L, _R = R;\n    for (bool up = true ; up ; ) {\n        up = false;\n        Point pL = points[_L].first, pR = points[_R].first;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pR, pL, t));\n            if (res &gt; 0 || (res == 0 &amp;&amp; sgn(distance(pR, t) - distance(pR, pL)) &lt; 0)) {\n                _L = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n        if (up) continue;\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pL, pR, t));\n            if (res &lt; 0 || (res == 0 &amp;&amp; sgn(distance(pL, t) - distance(pL, pR)) &lt; 0)) {\n                _R = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n    }\n    addEdge(_L, _R);\n    while (true) {\n        Point pL = points[_L].first, pR = points[_R].first;\n        int ch = -1, side = 0;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            if (sgn(cross(pL, pR, points[it -&gt; idx].first)) &gt; 0 &amp;&amp; (ch == -1 || pointCircleRelation(points[it -&gt; idx].first, Circle(pL, pR, points[ch].first)) == 0)) {\n                ch = it -&gt; idx;\n                side = -1;\n            }\n        }\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            if (sgn(cross(pR, points[it -&gt; idx].first, pL)) &gt; 0 &amp;&amp; (ch == -1 || pointCircleRelation(points[it -&gt; idx].first, Circle(pL, pR, points[ch].first)) == 0)) {\n                ch = it -&gt; idx;\n                side = 1;\n            }\n        }\n        if (ch == -1) break;\n        if (side == -1) {\n            for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n                if (lineCrossRelation(Line(pL, points[it -&gt; idx].first), Line(pR, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_L].erase(it);\n                }\n            }\n            _L = ch;\n            addEdge(_L, _R);\n        } else {\n            for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n                if (lineCrossRelation(Line(pR, points[it -&gt; idx].first), Line(pL, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_R].erase(it);\n                }\n            }\n            _R = ch;\n            addEdge(_L, _R);\n        }\n    }\n}\nvector&lt;pair&lt;int, int&gt;&gt; getEdge() {\n    vector&lt;pair&lt;int, int&gt;&gt; res;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (auto it = begin(head[i]) ; it != end(head[i]) ; it++) {\n            if (it -&gt; idx &lt; i) continue;\n            res.emplace_back(points[i].second, points[it -&gt; idx].second);\n        }\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        points.emplace_back(Point(x, y), i);\n    }\n    sort(begin(points), end(points));\n    for (int i = 0 ; i &lt; n ; i++) {\n        idx[points[i].second] = i;\n    }\n    Delaunay(0, n - 1);\n    auto res = getEdge();\n    for (auto &amp;[x, y] : res) {\n        cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 <p>Problem - 99999383 - Codeforces</p> <p>\\(n\\) \u4e2a\u70b9, \u4efb\u610f\u4e24\u70b9\u90fd\u6709\u8fb9, \u957f\u5ea6\u4e3a\u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb.</p> <p>q\u6b21\u67e5\u8be2\u4e24\u70b9\u4e4b\u95f4\u7684\u6700\u77ed\u8def.</p> \u4ee3\u7801 C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nstruct Edge {\n    int idx;\n    list&lt;Edge&gt;::iterator nxt;\n    Edge(int idx = 0) : idx(idx) {}\n};\nlist&lt;Edge&gt; head[100005];\nint n;\nvector&lt;pair&lt;Point, int&gt;&gt; points;\nvoid addEdge(int u, int v) {\n    head[u].emplace_front(v);\n    head[v].emplace_front(u);\n    begin(head[u]) -&gt; nxt = begin(head[v]);\n    begin(head[v]) -&gt; nxt = begin(head[u]);\n}\nvoid Delaunay(int L, int R) {\n    if (R - L &lt; 3) {\n        for (int i = L ; i &lt;= R ; i++) {\n            for (int j = i + 1 ; j &lt;= R ; j++) {\n                addEdge(i, j);\n            }\n        }\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Delaunay(L, mid);\n    Delaunay(mid + 1, R);\n    int _L = L, _R = R;\n    for (bool up = true ; up ; ) {\n        up = false;\n        Point pL = points[_L].first, pR = points[_R].first;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pR, pL, t));\n            if (res &gt; 0 || (res == 0 &amp;&amp; sgn(distance(pR, t) - distance(pR, pL)) &lt; 0)) {\n                _L = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n        if (up) continue;\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pL, pR, t));\n            if (res &lt; 0 || (res == 0 &amp;&amp; sgn(distance(pL, t) - distance(pL, pR)) &lt; 0)) {\n                _R = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n    }\n    addEdge(_L, _R);\n    while (true) {\n        Point pL = points[_L].first, pR = points[_R].first;\n        int ch = -1, side = 0;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            if (sgn(cross(pL, pR, points[it -&gt; idx].first)) &gt; 0 &amp;&amp; (ch == -1 || inCircle(points[it -&gt; idx].first, pL, pR, points[ch].first) &lt; 0)) {\n                ch = it -&gt; idx;\n                side = -1;\n            }\n        }\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            if (sgn(cross(pR, points[it -&gt; idx].first, pL)) &gt; 0 &amp;&amp; (ch == -1 || inCircle(points[it -&gt; idx].first, pL, pR, points[ch].first) &lt; 0)) {\n                ch = it -&gt; idx;\n                side = 1;\n            }\n        }\n        if (ch == -1) break;\n        if (side == -1) {\n            for (auto it = begin(head[_L]) ; it != end(head[_L]) ; ) {\n                if (segmentCrossRelation(Line(pL, points[it -&gt; idx].first), Line(pR, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_L].erase(it++);\n                } else {\n                    it++;\n                }\n            }\n            _L = ch;\n            addEdge(_L, _R);\n        } else {\n            for (auto it = begin(head[_R]) ; it != end(head[_R]) ; ) {\n                if (segmentCrossRelation(Line(pR, points[it -&gt; idx].first), Line(pL, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_R].erase(it++);\n                } else {\n                    it++;\n                }\n            }\n            _R = ch;\n            addEdge(_L, _R);\n        }\n    }\n}\nstruct Node {\n    int u, v;\n    Tdouble d;\n    Node() = default;\n    Node(int u, int v, Tdouble d) : u(u), v(v), d(d) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return sgn(d - x.d) &lt; 0;\n    }\n};\nvector&lt;Node&gt; getEdge() {\n    vector&lt;Node&gt; res;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (auto it = begin(head[i]) ; it != end(head[i]) ; it++) {\n            if (it -&gt; idx &lt; i) continue;\n            res.emplace_back(points[i].second, points[it -&gt; idx].second, distance(points[i].first, points[it -&gt; idx].first));\n        }\n    }\n    return res;\n}\nint f[100005];\nint find(int x) {\n    return f[x] == x ? x : f[x] = find(f[x]);\n}\nvector&lt;pair&lt;int, double&gt;&gt; adj[100005];\nint fa[100005][21], deep[100005];\nTdouble val[100005][21];\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; (1 &lt;&lt; i) &lt;= deep[u] ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        val[u][i] = max(val[u][i - 1], val[fa[u][i - 1]][i - 1]);\n    }\n    for (auto &amp;[v, d] : adj[u]) {\n        if (v == p) continue;\n        val[v][0] = d;\n        dfs(v, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &gt; deep[y]) swap(x, y);\n    for (int i = 20 ; i &gt;= 0 ; i--) {\n        if (deep[x] &gt; deep[fa[y][i]]) continue;\n        y = fa[y][i];\n    }\n    if (x == y) return x;\n    for (int i = 20 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nTdouble calc(int x, int y) {\n    Tdouble res = 0;\n    while (x != y) {\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == 0 || deep[fa[x][i]] &lt; deep[y]) continue;\n            res = max(res, val[x][i]);\n            x = fa[x][i];\n        }\n    }\n    return res;\n}\nTdouble solve(int u, int v) {\n    int k = LCA(u, v);\n    return max(calc(u, k), calc(v, k));\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        points.emplace_back(Point(x, y), i);\n    }\n    sort(begin(points), end(points));\n    Delaunay(0, n - 1);\n    auto res = getEdge();\n    sort(begin(res), end(res));\n    int len = res.size();\n    iota(f, f + n + 1, 0);\n    for (int i = 0 ; i &lt; len ; i++) {\n        auto [u, v, d] = res[i];\n        u++;\n        v++;\n        int x = find(u), y = find(v);\n        if (x == y) continue;\n        f[x] = y;\n        adj[u].emplace_back(v, d);\n        adj[v].emplace_back(u, d);\n    }\n    dfs(1, 0);\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; solve(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/block/","title":"\u5757\u72b6\u6570\u636e\u7ed3\u6784","text":""},{"location":"template/data-structure/block/#_2","title":"\u5757\u72b6\u6570\u7ec4","text":"\u6a21\u7248 C++<pre><code>template&lt;class T1, class T2&gt;\nstruct Block {\n    int B;\n    vector&lt;int&gt; belong, size, st, ed;\n    vector&lt;T1&gt; ainfo;\n    vector&lt;T2&gt; binfo;\n    Block(int n) {\n        init(n);\n    }\n    void init(int n) {\n        B = sqrt(n);\n        st.resize(0);\n        st.resize(B + 1);\n        ed.resize(0);\n        ed.resize(B + 1);\n        size.resize(0);\n        size.resize(B + 1);\n        belong.resize(0);\n        belong.resize(n + 1);\n        ainfo.resize(0);\n        ainfo.resize(n + 1);\n        binfo.resize(0);\n        binfo.resize(B + 1);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n            size[i] = ed[i] - st[i] + 1;\n        }\n    }\n    void modify(int L, int R, int k) {\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u4fee\u6539\n            for (int i = L ; i &lt;= R ; i++) {\n\n            }\n            return;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u4fee\u6539\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u4fee\u6539\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u4fee\u6539\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n\n        }\n    }\n    i64 query(int L, int R) {\n        i64 res = 0;\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u67e5\u8be2\n            for (int i = L ; i &lt;= R ; i++) {\n\n            }\n            return res;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u67e5\u8be2\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u67e5\u8be2\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u67e5\u8be2\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n\n        }\n        return res;\n    }\n};\n</code></pre> \u4f8b\u9898 LOJ#6280\u6d1b\u8c37P2801 <p>#6280. \u6570\u5217\u5206\u5757\u5165\u95e8 4 - LibreOJ</p> <p>\u64cd\u4f5c\u4e00: \u533a\u95f4\u52a0 \\(C\\)</p> <p>\u64cd\u4f5c\u4e8c: \u67e5\u8be2\u533a\u95f4\u548c\u6a21 \\(C+1\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T1, class T2&gt;\nstruct Block {\n    int B;\n    vector&lt;int&gt; belong, size, st, ed;\n    vector&lt;T1&gt; ainfo;\n    vector&lt;T2&gt; binfo;\n    Block(int n) {\n        init(n);\n    }\n    void init(int n) {\n        B = sqrt(n);\n        st.resize(0);\n        st.resize(B + 1);\n        ed.resize(0);\n        ed.resize(B + 1);\n        size.resize(0);\n        size.resize(B + 1);\n        belong.resize(0);\n        belong.resize(n + 1);\n        ainfo.resize(0);\n        ainfo.resize(n + 1);\n        binfo.resize(0);\n        binfo.resize(B + 1);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n            size[i] = ed[i] - st[i] + 1;\n        }\n    }\n    void modify(int L, int R, i64 k) {\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u4fee\u6539\n            for (int i = L ; i &lt;= R ; i++) {\n                ainfo[i] += k;\n                binfo[x].sum += k;\n            }\n            return;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u4fee\u6539\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n            ainfo[i] += k;\n            binfo[x].sum += k;\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u4fee\u6539\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n            ainfo[i] += k;\n            binfo[y].sum += k;\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u4fee\u6539\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n            binfo[i].sum += k * size[i];\n            binfo[i].delta += k;\n        }\n    }\n    i64 query(int L, int R, int P) {\n        i64 res = 0;\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u67e5\u8be2\n            for (int i = L ; i &lt;= R ; i++) {\n                res = (res + ainfo[i] + binfo[x].delta) % P;\n            }\n            return res;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u67e5\u8be2\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n            res = (res + ainfo[i] + binfo[x].delta) % P;\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u67e5\u8be2\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n            res = (res + ainfo[i] + binfo[y].delta) % P;\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u67e5\u8be2\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n            res = (res + binfo[i].sum) % P;\n        }\n        return res;\n    }\n};\nstruct Info {\n    i64 sum, delta;\n};\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    Block&lt;int, Info&gt; b(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        b.modify(i, i, x);\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op, L, R, c;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R &gt;&gt; c;\n        if (op == 0) {\n            b.modify(L, R, c);\n        } else {\n            cout &lt;&lt; b.query(L, R, c + 1) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>P2801 \u6559\u4e3b\u7684\u9b54\u6cd5 - \u6d1b\u8c37</p> <p>\u64cd\u4f5c\u4e00: \u533a\u95f4\u52a0</p> <p>\u64cd\u4f5c\u4e8c: \u67e5\u8be2\u533a\u95f4\u5927\u4e8e\u7b49\u4e8e \\(C\\) \u7684\u6570\u4e2a\u6570</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T1, class T2&gt;\nstruct Block {\n    int B;\n    vector&lt;int&gt; belong, size, st, ed, sorted;\n    vector&lt;T1&gt; ainfo;\n    vector&lt;T2&gt; binfo;\n    Block(int n) {\n        init(n);\n    }\n    void init(int n) {\n        B = sqrt(n);\n        st.resize(0);\n        st.resize(B + 1);\n        ed.resize(0);\n        ed.resize(B + 1);\n        size.resize(0);\n        size.resize(B + 1);\n        belong.resize(0);\n        belong.resize(n + 1);\n        ainfo.resize(0);\n        ainfo.resize(n + 1);\n        binfo.resize(0);\n        binfo.resize(B + 1);\n        sorted.resize(0);\n        sorted.resize(n + 1);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n            size[i] = ed[i] - st[i] + 1;\n        }\n    }\n    void sort(int idx) {\n        for (int i = st[idx] ; i &lt;= ed[idx] ; i++) {\n            sorted[i] = ainfo[i];\n        }\n        ::sort(begin(sorted) + st[idx], begin(sorted) + ed[idx] + 1);\n    }\n    void modify(int L, int R, int k) {\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u4fee\u6539\n            for (int i = L ; i &lt;= R ; i++) {\n                ainfo[i] += k;\n            }\n            sort(x);\n            return;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u4fee\u6539\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n            ainfo[i] += k;\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u4fee\u6539\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n            ainfo[i] += k;\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u4fee\u6539\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n            binfo[i] += k;\n        }\n        sort(x);\n        sort(y);\n    }\n    i64 query(int L, int R, int k) {\n        i64 res = 0;\n        int x = belong[L], y = belong[R];\n        if (x == y) { // \u4f4d\u4e8e\u540c\u4e00\u5757\u66b4\u529b\u67e5\u8be2\n            for (int i = L ; i &lt;= R ; i++) {\n                if (ainfo[i] + binfo[x] &gt;= k) {\n                    res++;\n                }\n            }\n            return res;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) { // \u66b4\u529b\u67e5\u8be2\u5de6\u8fb9\u591a\u51fa\u7684\u70b9\n            if (ainfo[i] + binfo[x] &gt;= k) {\n                res++;\n            }\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) { // \u66b4\u529b\u67e5\u8be2\u53f3\u8fb9\u591a\u51fa\u7684\u70b9\n            if (ainfo[i] + binfo[y] &gt;= k) {\n                res++;\n            }\n        }\n        for (int i = x + 1 ; i &lt;= y - 1 ; i++) { // \u66b4\u529b\u67e5\u8be2\u4e2d\u95f4\u6240\u6709\u5b8c\u6574\u5757\n            res += ed[i] - (lower_bound(begin(sorted) + st[i], begin(sorted) + ed[i] + 1, k - binfo[i]) - begin(sorted)) + 1;\n        }\n        return res;\n    }\n};\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    Block&lt;int, int&gt; b(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        b.ainfo[i] = x;\n    }\n    for (int i = 1 ; i &lt;= b.B ; i++) {\n        b.sort(i);\n    }\n    while (q--) {\n        char ch;\n        int L, R, k;\n        cin &gt;&gt; ch &gt;&gt; L &gt;&gt; R &gt;&gt; k;\n        if (ch == 'M') {\n            b.modify(L, R, k);\n        } else {\n            cout &lt;&lt; b.query(L, R, k) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/block/#_3","title":"\u6811\u5206\u5757","text":"\u4f8b\u9898 <p>P6177 Count on a tree II/\u3010\u6a21\u677f\u3011\u6811\u5206\u5757 - \u6d1b\u8c37</p> <p>\u4e00\u68f5\u6811, \u6bcf\u4e2a\u70b9\u90fd\u6709\u70b9\u6743, \u591a\u6b21\u67e5\u8be2 \\(u\\) \u548c \\(v\\), \u95ee \\(u\\) \u5230 \\(v\\) \u8def\u5f84\u4e0a\u7684\u989c\u8272\u6570, \u5f3a\u5236\u5728\u7ebf</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nbitset&lt;40000&gt; bs[205][205], res;\nvector&lt;int&gt; adj[40005];\nint a[40005];\nint deep[40005], fa[40005][17], mxdeep[40005];\nint id[40005], rev[205], tot;\nvoid dfs(int u, int p) {\n    mxdeep[u] = deep[u] = deep[p] + 1;\n    fa[u][0] = p;\n    for (int i = 1 ; (1 &lt;&lt; i) &lt;= deep[u] ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        mxdeep[u] = max(mxdeep[u], mxdeep[to]);\n    }\n    // \u9009\u62e9\u70b9\u4e2a\u6570\u8d85\u8fc7 200 \u7684\u4f5c\u4e3a\u5173\u952e\u70b9, \u4ee5\u4fdd\u8bc1\u671f\u671b\u8ddd\u79bb &lt;= 200\n    if (mxdeep[u] - deep[u] &gt;= 200 &amp;&amp; u != 1) {\n        id[u] = ++tot;\n        rev[tot] = u;\n        mxdeep[u] = deep[u];\n    }\n}\nint ttot, top, st[40005], up[40005];\nvoid build(int u, int p) {\n    if (id[u] != 0) {\n        // u \u662f\u5173\u952e\u70b9\n        top = fa[u][0];\n        bs[st[ttot]][id[u]][a[u]] = 1;\n        while (id[top] == 0 &amp;&amp; top != 0) {\n            // \u66b4\u529b\u8df3\u5230\u4e0a\u4e00\u4e2a\u5173\u952e\u70b9\u6216\u8005\u8df3\u51fa\u53bb\u4e3a\u6b62\n            bs[st[ttot]][id[u]][a[top]] = 1;\n            top = fa[top][0];\n        }\n        if (top != 0) {\n            bs[st[ttot]][id[u]][a[top]] = 1;\n        }\n        // bs[a][b] \u8868\u793a\u4ece\u5173\u952e\u70b9 b \u5230\u5173\u952e\u70b9 a \u8def\u5f84\u7684\u989c\u8272(\u5305\u542b\u70b9 a \u548c\u70b9 b)\n        up[u] = rev[st[ttot]]; // up[u] \u8868\u793a\u70b9 u \u7684\u4e0a\u4e00\u4e2a\u5173\u952e\u70b9\n        st[++ttot] = id[u]; // \u628a\u5f53\u524d\u5173\u952e\u70b9 u \u5165\u6808\n        for (int i = ttot - 2 ; i &gt;= 1 ; i--) { // \u524d\u7f00\u548c\u5904\u7406\u4ece\u5f53\u524d\u5173\u952e\u70b9 u \u5230\u5b83\u524d\u65b9\u5173\u952e\u70b9\u7684\u989c\u8272\n            // bs[st[i]][st[ttot - 1]] \u8868\u793a\u5173\u952e\u70b9 u \u7684\u524d\u4e00\u4e2a\u5173\u952e\u70b9\u5230\u524d\u65b9\u5173\u952e\u70b9 st[i] \u7684\u989c\u8272\n            // bs[st[ttot - 1]][id[u]] \u8868\u793a\u5173\u952e\u70b9 u \u5230\u524d\u4e00\u4e2a\u5173\u952e\u70b9\u7684\u989c\u8272\n            // bs[st[i]][id[u]]        \u8868\u793a\u5173\u952e\u70b9 u \u5230\u524d\u65b9\u5173\u952e\u70b9 st[i] \u7684\u989c\u8272\n            bs[st[i]][id[u]] = bs[st[i]][st[ttot - 1]] | bs[st[ttot - 1]][id[u]];\n        }\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        build(to, u);\n    }\n    if (id[u] != 0) {\n        // \u5173\u952e\u70b9 u \u51fa\u6808\n        ttot--;\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 16 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 16 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    id[1] = ++tot;\n    rev[tot] = 1;\n    dfs(1, 0);\n    build(1, 0);\n    int ans = 0;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x ^= ans;\n        int z = LCA(x, y);\n        res.reset();\n        while (id[x] == 0 &amp;&amp; x != z) {\n            // \u66b4\u529b\u8df3\u5230\u4e0a\u4e00\u4e2a\u5173\u952e\u70b9\u6216\u8005 z \u4e3a\u6b62\n            res[a[x]] = 1;\n            x = fa[x][0];\n        }\n        while (id[y] == 0 &amp;&amp; y != z) {\n            // \u66b4\u529b\u8df3\u5230\u4e0a\u4e00\u4e2a\u5173\u952e\u70b9\u6216\u8005 z \u4e3a\u6b62\n            res[a[y]] = 1;\n            y = fa[y][0];\n        }\n        if (x != z) {\n            int k = x;\n            while (deep[up[x]] &gt;= deep[z]) {\n                // \u66b4\u529b\u8df3\u5230\u79bb z \u6700\u8fd1\u4e14\u5728z\u4e0b\u65b9\u7684\u5173\u952e\u70b9\n                x = up[x];\n            }\n            if (k != x) {\n                // \u5c0f\u4f18\u5316, \u5982\u679c\u6ca1\u6709\u8df3\u5c31\u4e0d\u7528\u64cd\u4f5c\n                res |= bs[id[x]][id[k]];\n            }\n            while (x != z) {\n                // \u66b4\u529b\u8df3\u5230 z\n                res[a[x]] = 1;\n                x = fa[x][0];\n            }\n        }\n        if (y != z) {\n            int k = y;\n            while (deep[up[y]] &gt;= deep[z]) {\n                // \u66b4\u529b\u8df3\u5230\u79bb z \u6700\u8fd1\u4e14\u5728z\u4e0b\u65b9\u7684\u5173\u952e\u70b9\n                y = up[y];\n            }\n            if (k != y) {\n                // \u5c0f\u4f18\u5316, \u5982\u679c\u6ca1\u6709\u8df3\u5c31\u4e0d\u7528\u64cd\u4f5c\n                res |= bs[id[y]][id[k]];\n            }\n            while (y != z) {\n                // \u66b4\u529b\u8df3\u5230 z\n                res[a[y]] = 1;\n                y = fa[y][0];\n            }\n        }\n        // \u52a0\u4e0a z\n        res[a[z]] = 1;\n        ans = res.count();\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/chtholly-tree/","title":"\u73c2\u6735\u8389\u6811","text":"\u6a21\u7248 C++<pre><code>template&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void update(K L, K R) { // \u533a\u95f4\u66f4\u65b0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            // Do what you want to do\n            it = next(it);\n        }\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\n// \u57fa\u4e8e map \u5b9e\u73b0\u7684\u73c2\u6735\u8389\u6811\n// K \u4ee3\u8868\u533a\u95f4\u7c7b\u578b, int \u6216 long long\n// V \u4ee3\u8868\u5b58\u7684\u503c\n</code></pre> \u4f8b\u9898 CF896CCF817F <p>Problem - C - Codeforces</p> <p>\u64cd\u4f5c\u4e00, \u533a\u95f4\u52a0</p> <p>\u64cd\u4f5c\u4e8c, \u533a\u95f4\u8d4b\u503c</p> <p>\u64cd\u4f5c\u4e09, \u8f93\u51fa\u533a\u95f4\u7b2ck\u5927</p> <p>\u64cd\u4f5c\u56db, \u8f93\u51fa\u533a\u95f4x\u6b21\u5e42\u7684\u548c\u6a21y</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void add(K L, K R, V val) { // \u533a\u95f4\u52a0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V &amp;v = it -&gt; second; // \u533a\u95f4\u503c\n            v += val;\n            it = next(it);\n        }\n    }\n    V kth(K L, K R, K rk) { // \u533a\u95f4\u7b2ck\u5927\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        vector&lt;pair&lt;V, K&gt;&gt; res;\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            res.push_back({v, r - l + 1});\n            it = next(it);\n        }\n        sort(begin(res), end(res));\n        for (auto &amp;[x, y] : res) {\n            rk -= y;\n            if (rk &lt;= 0) return x;\n        }\n        return -1;\n    }\n    V query(K L, K R, V x, V mod) { // \u533a\u95f4\u66f4\u65b0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        V res = 0;\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            res = (res + qpow(v % mod, x, mod) * (r - l + 1) % mod) % mod;\n            it = next(it);\n        }\n        return res;\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\nint seed;\nint rnd() {\n    int res = seed;\n    seed = (1LL * seed * 7 + 13) % 1000000007;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, vmax;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;\n    ODT&lt;int, long long&gt; odt(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int a = rnd() % vmax + 1;\n        odt[i] = a;\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int op, L, R, x, y;\n        op = rnd() % 4 + 1;\n        L = rnd() % n + 1;\n        R = rnd() % n + 1;\n        if (L &gt; R) swap(L, R);\n        if (op == 3) {\n            x = rnd() % (R - L + 1) + 1;\n        } else {\n            x = rnd() % vmax + 1;\n        }\n        if (op == 4) {\n            y = rnd() % vmax + 1;\n        }\n        if (op == 1) {\n            odt.add(L, R, x);\n        } else if (op == 2) {\n            odt.assign(L, R, x);\n        } else if (op == 3) {\n            cout &lt;&lt; odt.kth(L, R, x) &lt;&lt; \"\\n\";\n        } else if (op == 4) {\n            cout &lt;&lt; odt.query(L, R, x, y) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u64cd\u4f5c\u4e00, \u6dfb\u52a0\u533a\u95f4</p> <p>\u64cd\u4f5c\u4e8c, \u5220\u9664\u533a\u95f4</p> <p>\u64cd\u4f5c\u4e09, \u53cd\u8f6c\u533a\u95f4, \u5b58\u5728\u7684\u5220\u9664, \u4e0d\u5b58\u5728\u7684\u6dfb\u52a0</p> \u4ee3\u7801 C++<pre><code>template&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void reverse(K L, K R) { // \u533a\u95f4\u53cd\u8f6c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V &amp;v = it -&gt; second; // \u533a\u95f4\u503c\n            v ^= 1;\n            it = next(it);\n        }\n    }\n    K query() { // \u67e5\u8be2\n        for (auto &amp;[x, y] : odt) {\n            if (y == 0) {\n                return x;\n            }\n        }\n        return -1;\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\n// \u57fa\u4e8e map \u5b9e\u73b0\u7684\u73c2\u6735\u8389\u6811\n// K \u4ee3\u8868\u533a\u95f4\u7c7b\u578b, int \u6216 long long\n// V \u4ee3\u8868\u5b58\u7684\u503c\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ODT&lt;long long, int&gt; odt(1000000000000000000LL);\n    odt.assign(1LL, 1000000000000000000LL, 0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op;\n        long long L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 1) {\n            odt.assign(L, R, 1);\n        } else if (op == 2) {\n            odt.assign(L, R, 0);\n        } else if (op == 3) {\n            odt.reverse(L, R);\n        }\n        cout &lt;&lt; odt.query() &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/disjunction-tree/","title":"\u6790\u5408\u6811","text":"\u6a21\u7248 \u65e0\u5efa\u6811\u5efa\u6811 C++<pre><code>const int N = 300005;\nint n, a[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            int le = query(1, 1, n), now = ++cnt;\n            L[now] = R[now] = i;\n            siz[now] = 1;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    siz[k]++;\n                    now = st3[tp3];\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    siz[cnt] = 2;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    now = cnt;\n                } else {\n                    int tot = 0;\n                    do {\n                        tp3--;\n                        tot++;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[++cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    now = cnt;\n                    siz[cnt] = tot + 1;\n\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n    }\n}; // DisjunctionTree\n</code></pre> C++<pre><code>const int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n        dfs2(rt, 0);\n    }\n}; // DisjunctionTree\n</code></pre> \u4f8b\u9898 CF526FCF997E\u6d1b\u8c37P4747 <p>Problem - F - Codeforces</p> <p>\u6c42\u6392\u5217\u4e2d\u6709\u591a\u5c11\u6bb5\\(\\max-\\min=R-L+1\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 300005;\nint n, a[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            int le = query(1, 1, n), now = ++cnt;\n            L[now] = R[now] = i;\n            siz[now] = 1;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    siz[k]++;\n                    now = st3[tp3];\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    siz[cnt] = 2;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    now = cnt;\n                } else {\n                    int tot = 0;\n                    do {\n                        tp3--;\n                        tot++;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[++cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    now = cnt;\n                    siz[cnt] = tot + 1;\n\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y;\n    }\n    using DisjunctionTree::build;\n    using DisjunctionTree::cnt;\n    using DisjunctionTree::typ;\n    using DisjunctionTree::siz;\n    build();\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= cnt ; i++) {\n        if (typ[i]) {\n            ans += 1LL * siz[i] * (siz[i] - 1) / 2;\n        } else {\n            ans++;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>Problem - E - Codeforces</p> <p>\u6c42\u6392\u5217\u4e2d\u6709\u591a\u5c11\u6bb5\\(\\max-\\min=R-L+1\\)\uff0c\u533a\u95f4\u67e5\u8be2</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], pre[N &lt;&lt; 1], suf[N &lt;&lt; 1], siz[N &lt;&lt; 1], sum[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1], rk[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        long long temp = 0;\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n            pre[to] = temp + (typ[u] == 1 ? Cn2(i) : 0);\n            temp += siz[to];\n            sum[to] = temp;\n            rk[to] = i + 1;\n        }\n        temp = 0;\n        for (int i = (int)adj[u].size() - 1 ; i &gt;= 0 ; i--) {\n            int to = adj[u][i];\n            suf[to] = temp + (typ[u] == 1 ? Cn2((int)adj[u].size() - 1 - i) : 0);\n            temp += siz[to];\n        }\n    }\n    void dfs2(int u, int p) {\n        pre[u] += pre[p];\n        suf[u] += suf[p];\n        for (auto &amp;to : adj[u]) {\n            dfs2(to, u);\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    long long query(int L, int R) {\n        L--;\n        R++;\n        int z = LCA(idx[L], idx[R]);\n        int x = jump(idx[L], z), y = jump(idx[R], z);\n        long long res = (pre[idx[R]] - pre[y]) + (suf[idx[L]] - suf[x]) + sum[y] - sum[x] - siz[y] + (typ[z] == 1 ? Cn2(rk[y] - rk[x] - 1) : 0);\n        return res;\n    }\n    long long queryPre(int R) {\n        R++;\n        int x = jump(idx[R], rt);\n        long long res = (pre[idx[R]] - pre[x]) + (sum[x] - siz[x]) + (typ[rt] == 1 ? Cn2(rk[x] - 1) : 0);\n        return res;\n    }\n    long long querySuf(int L) {\n        L--;\n        int x = jump(idx[L], rt);\n        long long res = (suf[idx[L]] - suf[x]) + (sum[adj[rt].back()] - sum[x]) + (typ[rt] == 1 ? Cn2((int)adj[rt].size() - rk[x]) : 0);\n        return res;\n    }\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n        dfs2(rt, 0);\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    using DisjunctionTree::rt;\n    using DisjunctionTree::siz;\n    using DisjunctionTree::build;\n    using DisjunctionTree::querySuf;\n    using DisjunctionTree::queryPre;\n    using DisjunctionTree::query;\n    build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        if (L == 1 &amp;&amp; R == n) {\n            cout &lt;&lt; siz[rt] &lt;&lt; \"\\n\";\n        } else if (L == 1 &amp;&amp; R != n) {\n            cout &lt;&lt; queryPre(R) &lt;&lt; \"\\n\";\n        } else if (L != 1 &amp;&amp; R == n) {\n            cout &lt;&lt; querySuf(L) &lt;&lt; \"\\n\";\n        } else {\n            cout &lt;&lt; query(L, R) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>P4747 [CERC2017] Intrinsic Interval - \u6d1b\u8c37</p> <p>\u6c42\u5305\u542b\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u8fde\u7eed\u533a\u95f4\\((\\max-\\min=R-L)\\)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n    }\n    pair&lt;int, int&gt; query(int L, int R) {\n        int x = idx[L], y = idx[R];\n        int z = LCA(x, y);\n        if (typ[z] == 1) {\n            L = DisjunctionTree::L[jump(x, z)];\n            R = DisjunctionTree::R[jump(y, z)];\n        } else {\n            L = DisjunctionTree::L[z];\n            R = DisjunctionTree::R[z];\n        }\n        return {L, R};\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    using DisjunctionTree::rt;\n    using DisjunctionTree::siz;\n    using DisjunctionTree::build;\n    using DisjunctionTree::query;\n    build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        tie(L, R) = query(L, R);\n        cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/dsu/","title":"\u5e76\u67e5\u96c6","text":"\u6a21\u7248 \u8def\u5f84\u538b\u7f29\u5e26\u6743 C++<pre><code>struct DSU {\n    vector&lt;int&gt; f;\n    DSU(int N) : f(N) {\n        iota(begin(f), end(f), 0);\n    }\n    void merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        f[y] = x;\n    }\n    int find(const int x) {\n        if (f[x] == x) return x;\n        find(f[x]);\n        return f[x] = f[f[x]];\n    }\n    int&amp; operator[](int pos) {\n        return f[pos];\n    }\n}; // DSU\n</code></pre> C++<pre><code>struct Vector {\n    int val;\n    Vector() = default;\n    Vector(int val) : val(val) {}\n    Vector operator-() const {\n        return Vector(-val);\n    }\n    friend Vector operator+(const Vector &amp;lhs, const Vector &amp;rhs) {\n        int x = lhs.val + rhs.val;\n        return Vector(x);\n    }\n};\nstruct DSU {\n    vector&lt;int&gt; f;\n    vector&lt;Vector&gt; val;\n    DSU(int N) : f(N), val(N) {\n        iota(begin(f), end(f), 0);\n    }\n    void merge(int x, int y, Vector v) {\n        int tx = find(x);\n        int ty = find(y);\n        if (tx == ty) return;\n        val[tx] = val[y] + -val[x] + v;\n        f[ty] = ty;\n    }\n    int find(const int x) {\n        if (f[x] == x) return x;\n        find(f[x]);\n        val[x] = val[x] + val[f[x]];\n        return f[x] = f[f[x]];\n    }\n    Vector query(int x, int y) {\n        int tx = find(x);\n        int ty = find(y);\n        assert(tx == ty);\n        return val[x] + -val[y];\n    }\n    Vector&amp; operator[](int pos) {\n        return val[pos];\n    }\n}; // DSU\n</code></pre>"},{"location":"template/data-structure/fenwick-tree/","title":"\u6811\u72b6\u6570\u7ec4","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4\u6743\u503c\u6811\u72b6\u6570\u7ec4-\u5168\u5c40\u7b2c k \u5c0f \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 500005;\nint n = N - 1, sum[N];\nusing B = int;\nB query(int x) {\n    B res = 0;\n    while (x) {\n        res += sum[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    while (x &lt;= n) {\n        sum[x] += k;\n        x += lowbit(x);\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum, sumX;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n        sumX.resize(0);\n        sumX.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            res += (x + 1) * sum[i] - sumX[i];\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        T kx = k * x;\n        while (x &lt;= size) {\n            sum[x] += k;\n            sumX[x] += kx;\n            x += lowbit(x);\n        }\n    }\n    void add(int L, int R, T k) {\n        add(L, k);\n        add(R + 1, -k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 1000005;\nlong long sum[N], sumX[N];\nint n = N - 1;\nusing B = long long;\nB query(int x) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        res += (x + 1) * sum[i] - sumX[i];\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    B kx = k * x;\n    while (x &lt;= n) {\n        sum[x] += k;\n        sumX[x] += kx;\n        x += lowbit(x);\n    }\n}\nvoid add(int L, int R, B k) {\n    add(L, k);\n    add(R + 1, -k);\n}\n</code></pre> \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(sizeX + 1);\n        for (int i = 1 ; i &lt;= sizeX ; i++) {\n            sum[i].resize(sizeY + 1);\n        }\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n            }\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nint n = N - 1, m = M - 1;\nusing B = long long;\nB sum[N][M];\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n        }\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum, sumX, sumY, sumXY;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        sumY.resize(n + 1);\n        sumXY.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n            sumX[i].resize(m + 1);\n            sumY[i].resize(m + 1);\n            sumXY[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        resize(0, 0);\n        resize(sizeX, sizeY);\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        T kx = k * x;\n        T ky = k * y;\n        T kxy = kx * y;\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n                sumX[i][j] += kx;\n                sumY[i][j] += ky;\n                sumXY[i][j] += kxy;\n            }\n        }\n    }\n    void add(int x1, int y1, int x2, int y2, T k) {\n        add(x1, y1, k);\n        add(x1, y2 + 1, -k);\n        add(x2 + 1, y1, -k);\n        add(x2 + 1, y2 + 1, k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nusing B = long long;\nB sum[N][M], sumX[N][M], sumY[N][M], sumXY[N][M];\nint n = N - 1, m = M - 1;\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    B kx = k * x;\n    B ky = k * y;\n    B kxy = kx * y;\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n            sumX[i][j] += kx;\n            sumY[i][j] += ky;\n            sumXY[i][j] += kxy;\n        }\n    }\n}\nvoid add(int x1, int y1, int x2, int y2, B k) {\n    add(x1, y1, k);\n    add(x1, y2 + 1, -k);\n    add(x2 + 1, y1, -k);\n    add(x2 + 1, y2 + 1, k);\n}\n</code></pre> C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n    T kth(int rk) {\n        int res = 0, now = 0;\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            int k = 1 &lt;&lt; i;\n            if (now + k &lt;= size &amp;&amp; res + sum[now + k] &lt; rk) {\n                now += k;\n                res += sum[now];\n            }\n        }\n        return now + 1;\n    }\n}; // FenwickTree\n</code></pre> \u4f8b\u9898 \u4e00\u7ef4\u4e8c\u7ef4 \u6d1b\u8c37P3374(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ132(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>P3374 \u3010\u6a21\u677f\u3011\u6811\u72b6\u6570\u7ec4 1 - \u6d1b\u8c37</p> <p>#132. \u6811\u72b6\u6570\u7ec4 3 \uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> LOJ133(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ135(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>#133. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 1\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> <p>#135. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 3\uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> \u4e60\u9898 \u6d1b\u8c37P2163(\u4e8c\u7ef4\u6570\u70b9)\u725b\u5ba276609F(\u6309\u7167\u6392\u5217\u5faa\u73af/\u5355\u70b9\u4fee\u6539/\u6c42\u4e0d\u540c\u4e2a\u6570)\u851a\u84dd\u7cfb\u5217\u8d5b Round 2\uff1a\u539f\u795e\u4e3b\u9898\u8d5b \u8499\u5fb7D <p>P2163 [SHOI2007] \u56ed\u4e01\u7684\u70e6\u607c - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2\u77e9\u5f62\u4e2d\u70b9\u7684\u6570\u91cf\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt; struct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(const int n) {\n        init(n);\n    }\n    void init(const int n) {\n        size = n;\n        sum.assign(n + 1, 0);\n    }\n    void clear() {\n        sum.clear();\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(const int L, const int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, const T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idxX, idxY;\n    vector&lt;int&gt; aX(n), aY(n), bX(m &lt;&lt; 1), bY(m &lt;&lt; 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; aX[i] &gt;&gt; aY[i];\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; bX[i] &gt;&gt; bY[i] &gt;&gt; bX[i + m] &gt;&gt; bY[i + m];\n        bX[i]--;\n        bY[i]--;\n    }\n    idxX.emplace_back(-100);\n    idxY.emplace_back(-100);\n    copy(make_move_iterator(begin(aX)), make_move_iterator(end(aX)), back_inserter(idxX));\n    copy(make_move_iterator(begin(bX)), make_move_iterator(end(bX)), back_inserter(idxX));\n    copy(make_move_iterator(begin(aY)), make_move_iterator(end(aY)), back_inserter(idxY));\n    copy(make_move_iterator(begin(bY)), make_move_iterator(end(bY)), back_inserter(idxY));\n    auto Unique = [&amp;](auto&amp; res) -&gt; void {\n        sort(begin(res), end(res));\n        res.resize(unique(begin(res), end(res)) - begin(res));\n    };\n    auto get = [&amp;](auto&amp; res, int val) {\n        return lower_bound(begin(res), end(res), val) - begin(res);\n    };\n    Unique(idxX);\n    Unique(idxY);\n    int lenX = idxX.size(), lenY = idxY.size();\n    vector&lt;int&gt; X1[lenX], X2[lenX], X3[lenX], ans(m);\n    for (int i = 0 ; i &lt; n ; i++) {\n        aX[i] = get(idxX, aX[i]);\n        aY[i] = get(idxY, aY[i]);\n        X1[aX[i]].emplace_back(i);\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        bX[i] = get(idxX, bX[i]);\n        bY[i] = get(idxY, bY[i]);\n        bX[i + m] = get(idxX, bX[i + m]);\n        bY[i + m] = get(idxY, bY[i + m]);\n        X2[bX[i]].emplace_back(i);\n        X3[bX[i + m]].emplace_back(i);\n    }\n    FenwickTree&lt;int&gt; ft(lenY);\n    for (int i = 1 ; i &lt; lenX ; i++) {\n        for (auto&amp; pos : X1[i]) {\n            ft.add(aY[pos], 1);\n        }\n        for (auto&amp; pos : X2[i]) {\n            ans[pos] += ft.query(bY[pos]) - ft.query(bY[pos + m]);\n        }\n        for (auto&amp; pos : X3[i]) {\n            ans[pos] += ft.query(bY[pos + m]) - ft.query(bY[pos]);\n        }\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>F-\u5c0f\u7ea2\u7684\u597d\u5b50\u4e32\u8be2\u95ee_\u725b\u5ba2\u5468\u8d5b Round 36</p> <p>\u4e00\u4e2a\u4e32(\u53ea\u5305\u542br,e,d)</p> <p>\u597d\u4e32\u4e3a\u6309\u7167\u6392\u5217\u5faa\u73af\\(\\{red,rde,erd,edr,der,dre\\}\\)</p> <p>\u64cd\u4f5c\\(1\\),\u7b2c \\(x\\) \u4e2a\u5b57\u7b26\u4fee\u6539\u4e3a \\(ch\\)\u3002</p> <p>\u64cd\u4f5c\\(2\\),\u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u4fee\u6539\u591a\u5c11\u4e2a\u5b57\u7b26\u53ef\u4ee5\u53d8\u4e3a\u597d\u4e32\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 100005;\nint lowbit(int x) {\n    return x &amp; -x;\n}\nint sum[6][N];\nint n;\nvoid add(int idx, int x, int k) {\n    while (x &lt;= n) {\n        sum[idx][x] += k;\n        x += lowbit(x);\n    }\n}\nint query(int idx, int x) {\n    int res = 0;\n    while (x) {\n        res += sum[idx][x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nstring s[] = {\n    \"red\", \"rde\",\n    \"erd\", \"edr\",\n    \"der\", \"dre\"\n};\nstring str;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int q;\n    cin &gt;&gt; n &gt;&gt; q;\n    cin &gt;&gt; str;\n    str = \" \" + str;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; 6 ; j++) {\n            if (s[j][(i - 1) % 3] != str[i]) {\n                add(j, i, 1);\n            }\n        }\n    }\n    while (q--) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int x;\n            char ch;\n            cin &gt;&gt; x &gt;&gt; ch;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                if (s[j][(x - 1) % 3] != str[x]) {\n                    add(j, x, -1);\n                }\n            }\n            str[x] = ch;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                if (s[j][(x - 1) % 3] != str[x]) {\n                    add(j, x, 1);\n                }\n            }\n        } else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            int ans = 0x7fffffff;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                ans = min(ans, query(j, R) - query(j, L - 1));\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p></p> <p>\u53ef\u4ee5\u77e5\u9053\u5bf9\u4e8e\u6bcf\u4e2a\u6570, \u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u533a\u95f4 \\(L\\in [pos_{x,i - 1}+1,pos_{x,i}],R\\in[pos_{x,i+x-1},pos_{x,i+x}-1]\\)</p> <p>\u6211\u4eec\u901a\u8fc7\u679a\u4e3e\u5de6\u7aef\u70b9 \\(L\\), \u4f7f\u7528\u5dee\u5206\u6811\u72b6\u6570\u7ec4\u6765\u7ef4\u62a4 \\(R\\), \u5373\u53ef\u6c42\u89e3</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[1000005];\nvector&lt;int&gt; pos[1000005];\ni64 sum[1000005];\nint lowbit(int x) {\n    return x &amp; -x;\n}\nvoid add(int x, i64 k) {\n    while (x &lt;= 1000000) {\n        sum[x] += k;\n        x += lowbit(x);\n    }\n}\ni64 query(int x) {\n    i64 res = 0;\n    while (x) {\n        res += sum[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        pos[a[i]].push_back(i);\n    }\n    vector&lt;array&lt;int, 4&gt;&gt; qu;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        qu.push_back({L, R, i, 0});\n    }\n    for (int x = 1 ; x &lt;= n ; x++) {\n        for (int i = 0 ; i + x - 1 &lt; (int) pos[x].size() ; i++) {\n            // L in [pos[i - 1] + 1, pos[i]]\n            // R in [pos[i + x - 1], pos[i + x] - 1]\n            int L1 = 0;\n            if (i - 1 &gt;= 0) {\n                L1 = pos[x][i - 1] + 1;\n            }\n            int R1 = pos[x][i];\n            int L2 = pos[x][i + x - 1];\n            int R2 = n + 1;\n            if (i + x &lt; (int) pos[x].size()) {\n                R2 = pos[x][i + x] - 1;\n            }\n            qu.push_back({L1, L2, 0, x});\n            qu.push_back({L1, R2 + 1, 0, -x});\n            qu.push_back({R1 + 1, L2, 0, -x});\n            qu.push_back({R1 + 1, R2 + 1, 0, x});\n        }\n    }\n    sort(begin(qu), end(qu));\n    vector&lt;i64&gt; ans(m + 1);\n    for (auto &amp;[L, R, idx, val] : qu) {\n        if (idx == 0) {\n            add(R, val);\n        } else {\n            ans[idx] = query(R);\n        }\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/heap/","title":"\u5806","text":""},{"location":"template/data-structure/heap/#_2","title":"\u5bf9\u9876\u5806","text":"\u4f8b\u9898 \u6d1b\u8c37SP16254 <p>RMID2 - Running Median Again - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nvoid solve() {\n    int x;\n    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;\n    auto check = [&amp;](){\n        int k = a.top();\n        a.pop();\n        return k;\n    };\n    auto adjust = [&amp;]() {\n        int A = a.size(), B = b.size();\n        int len = (A + B + 1) / 2;\n        if (A &gt; len) {\n            b.emplace(a.top()); a.pop();\n        } else if (A &lt; len) {\n            a.emplace(b.top()); b.pop();\n        }\n    };\n    auto push = [&amp;](int k) {\n        if (a.empty() || k &lt;= a.top()) {\n            a.emplace(k);\n        } else {\n            b.emplace(k);\n        }\n    };\n    while (cin &gt;&gt; x) {\n        if (x == 0) {\n            break;\n        }\n        if (x == -1) {\n            cout &lt;&lt; check() &lt;&lt; \"\\n\";\n        } else {\n            push(x);\n        }\n        adjust();\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/mo-query/","title":"\u83ab\u961f","text":""},{"location":"template/data-structure/mo-query/#_2","title":"\u666e\u901a\u83ab\u961f","text":"\u4f8b\u9898 <p>P1494 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u5c0f Z \u7684\u889c\u5b50 - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2, \u6bcf\u6b21\u67e5\u8be2\u4ece\u533a\u95f4 \\([L,R]\\) \u5185\u4efb\u9009\u4e24\u4e2a\u6570, \u6570\u76f8\u540c\u7684\u6982\u7387.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[50005], st[50005], ed[50005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        if (belong[x.L] &amp; 1) {\n            return x.R &lt; y.R;\n        }\n        return x.R &gt; y.R;\n    }\n};\nint c[50005], cnt[50005];\ni64 sum = 0;\nvoid add(int x) {\n    sum += cnt[x];\n    cnt[x]++;\n}\nvoid del(int x) {\n    cnt[x]--;\n    sum -= cnt[x];\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; c[i];\n    }\n    vector&lt;MO&gt; mo;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;array&lt;i64, 2&gt;&gt; ans(m);\n    int L = 1, R = 0;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        if (QL == QR) {\n            ans[idx] = {0, 1};\n            continue;\n        }\n        while (L &gt; QL) {\n            add(c[--L]);\n        }\n        while (R &lt; QR) {\n            add(c[++R]);\n        }\n        while (L &lt; QL) {\n            del(c[L++]);\n        }\n        while (R &gt; QR) {\n            del(c[R--]);\n        }\n        i64 a = sum, b = 1LL * (R - L + 1) * (R - L) / 2;\n        i64 d = __gcd(a, b);\n        a /= d;\n        b /= d;\n        ans[idx] = {a, b};\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i][0] &lt;&lt; \"/\" &lt;&lt; ans[i][1] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/mo-query/#_3","title":"\u5e26\u4fee\u83ab\u961f","text":"\u4f8b\u9898 \u6d1b\u8c37P1903CF940F <p>P1903 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u6570\u989c\u8272 / \u7ef4\u62a4\u961f\u5217 - \u6d1b\u8c37</p> <p>\u5355\u70b9\u4fee\u6539</p> <p>\u533a\u95f4\u67e5\u8be2\u989c\u8272\u6570</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[1000005], st[1000005], ed[1000005];\nstruct MO {\n    int L, R, idx, time;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        if (belong[x.R] == belong[y.R]) {\n            return x.time &lt; y.time;\n        }\n        if (belong[x.L] &amp; 1) {\n            return x.R &lt; y.R;\n        }\n        return x.R &gt; y.R;\n    }\n};\nint c[1000005], cnt[1000005];\nvector&lt;array&lt;int, 2&gt;&gt; change(1);\nvector&lt;MO&gt; mo;\nint sum;\nvoid add(int x) {\n    if (cnt[x]++ == 0) {\n        sum++;\n    }\n}\nvoid del(int x) {\n    if (cnt[x]-- == 1) {\n        sum--;\n    }\n}\nvoid modify(int now, int L, int R) {\n    if (change[now][0] &gt;= L &amp;&amp; change[now][0] &lt;= R) {\n        del(c[change[now][0]]);\n        add(change[now][1]);\n    }\n    swap(c[change[now][0]], change[now][1]);\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    {\n        int B = pow(n, 0.3333333333);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; c[i];\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        char ch;\n        int a, b;\n        cin &gt;&gt; ch &gt;&gt; a &gt;&gt; b;\n        if (ch == 'Q') {\n            mo.push_back({a, b, (int) mo.size(), (int) change.size() - 1});\n        } else {\n            change.push_back({a, b});\n        }\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;int&gt; ans(mo.size());\n    int L = 1, R = 0, now = 0;\n    for (auto &amp;[QL, QR, idx, time] : mo) {\n        while (L &gt; QL) {\n            add(c[--L]);\n        }\n        while (R &lt; QR) {\n            add(c[++R]);\n        }\n        while (L &lt; QL) {\n            del(c[L++]);\n        }\n        while (R &gt; QR) {\n            del(c[R--]);\n        }\n        while (now &gt; time) {\n            modify(now--, QL, QR);\n        }\n        while (now &lt; time) {\n            modify(++now, QL, QR);\n        }\n        ans[idx] = sum;\n    }\n    for (int i = 0 ; i &lt; (int) ans.size() ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u5355\u70b9\u4fee\u6539</p> <p>\u533a\u95f4\u67e5\u8be2\u989c\u8272\u6570\u7684 \\(MEX\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[100005];\nstruct MO {\n    int L, R, idx, time;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        if (belong[x.R] == belong[y.R]) {\n            return x.time &lt; y.time;\n        }\n        if (belong[x.L] &amp; 1) {\n            return x.R &lt; y.R;\n        }\n        return x.R &gt; y.R;\n    }\n};\nint a[100005], cnt[200005], mex[100005];\nvector&lt;array&lt;int, 2&gt;&gt; change(1);\nvector&lt;MO&gt; mo;\nint sum;\nvoid add(int x) {\n    mex[cnt[x]]--;\n    cnt[x]++;\n    mex[cnt[x]]++;\n}\nvoid del(int x) {\n    mex[cnt[x]]--;\n    cnt[x]--;\n    mex[cnt[x]]++;\n}\nvoid modify(int now, int L, int R) {\n    if (change[now][0] &gt;= L &amp;&amp; change[now][0] &lt;= R) {\n        del(a[change[now][0]]);\n        add(change[now][1]);\n    }\n    swap(a[change[now][0]], change[now][1]);\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int B = pow(n, 0.6666666666);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        belong[i] = i / B;\n    }\n    vector&lt;int&gt; idx(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int op, a, b;\n        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;\n        if (op == 1) {\n            mo.push_back({a, b, (int) mo.size(), (int) change.size() - 1});\n        } else {\n            change.push_back({a, b});\n            idx.push_back(b);\n        }\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (auto &amp;[_, x] : change) {\n        x = lower_bound(begin(idx), end(idx), x) - begin(idx);\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;int&gt; ans(mo.size());\n    int L = 1, R = 0, now = 0;\n    for (auto &amp;[QL, QR, idx, time] : mo) {\n        while (L &gt; QL) {\n            add(a[--L]);\n        }\n        while (R &lt; QR) {\n            add(a[++R]);\n        }\n        while (L &lt; QL) {\n            del(a[L++]);\n        }\n        while (R &gt; QR) {\n            del(a[R--]);\n        }\n        while (now &gt; time) {\n            modify(now--, QL, QR);\n        }\n        while (now &lt; time) {\n            modify(++now, QL, QR);\n        }\n        ans[idx] = 1;\n        while (mex[ans[idx]]) {\n            ans[idx]++;\n        }\n    }\n    for (int i = 0 ; i &lt; (int) ans.size() ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/mo-query/#_4","title":"\u56de\u6eda\u83ab\u961f","text":""},{"location":"template/data-structure/mo-query/#_5","title":"\u4e0d\u5220\u9664\u83ab\u961f","text":"\u4f8b\u9898 \u6d1b\u8c37P5906JOISC2014C <p>P5906 \u3010\u6a21\u677f\u3011\u56de\u6eda\u83ab\u961f&amp;\u4e0d\u5220\u9664\u83ab\u961f - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2\u533a\u95f4\u5185\u6570\u503c\u76f8\u540c\u7684\u4e0b\u6807\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u7684\u6700\u5927\u503c</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[200005], st[200005], ed[200005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        return x.R &lt; y.R;\n    }\n};\nint a[200005];\narray&lt;int, 2&gt; tcnt[200005], cnt[200005];\nint sum = 0;\nvoid addL(int idx) {\n    if (tcnt[a[idx]][1] == 0) {\n        tcnt[a[idx]][1] = idx;\n    }\n    tcnt[a[idx]][0] = idx;\n    sum = max(sum, max(cnt[a[idx]][1], tcnt[a[idx]][1]) - tcnt[a[idx]][0]);\n}\nvoid addR(int idx) {\n    if (cnt[a[idx]][0] == 0) {\n        cnt[a[idx]][0] = idx;\n    }\n    cnt[a[idx]][1] = idx;\n    sum = max(sum, cnt[a[idx]][1] - cnt[a[idx]][0]);\n}\nvoid del(int idx) {\n    cnt[a[idx]] = {0, 0};\n}\nvoid rollBack(int idx) {\n    tcnt[a[idx]] = {0, 0};\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    vector&lt;int&gt; idx(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    int m;\n    cin &gt;&gt; m;\n    vector&lt;MO&gt; mo;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;int&gt; ans(mo.size());\n    int lst = belong[mo[0].L], R = ed[lst], L = R + 1;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        if (belong[QL] == belong[QR]) { // \u5728\u4e00\u4e2a\u5757\u5185, \u66b4\u529b\u67e5\u8be2\n            int temp = 0;\n            for (int j = QL ; j &lt;= QR ; j++) {\n                if (tcnt[a[j]][0] == 0) {\n                    tcnt[a[j]][0] = j;\n                }\n                tcnt[a[j]][1] = j;\n                temp = max(temp, tcnt[a[j]][1] -tcnt[a[j]][0]);\n            }\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]] = {0, 0};\n            }\n            ans[idx] = temp;\n            continue;\n        }\n        if (lst != belong[QL]) {\n            // \u5982\u679c\u5f53\u524d\u4e0d\u5728\u67e5\u8be2\u5757\u5185, \u5219\u5c06 L \u548c R \u79fb\u81f3\u5757\u5185\n            while (R &gt; ed[belong[QL]]) {\n                del(R--);\n            }\n            while (L &lt; ed[belong[QL]] + 1) {\n                del(L++);\n            }\n            sum = 0;\n            lst = belong[QL];\n        }\n        while (R &lt; QR) { // \u5411\u53f3\u6269, \u76f4\u81f3 R = QR\n            addR(++R);\n        }\n        int temp = sum, L1 = L;\n        while (L1 &gt; QL) { // \u65b0\u5f00\u5411\u5de6\u6269, \u76f4\u81f3 L1 = QL\n            addL(--L1);\n        }\n        ans[idx] = sum;\n        while (L1 &lt; L) { // \u56de\u6eda\u5de6\u7aef\u70b9\n            rollBack(L1++);\n        }\n        sum = temp;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>C - \u6b74\u53f2\u306e\u7814\u7a76 </p> <p>\u591a\u6b21\u67e5\u8be2\u533a\u95f4 \\(a_i*cnt_{a_i}\\) \u7684\u6700\u5927\u503c</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[100005], st[100005], ed[100005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        return x.R &lt; y.R;\n    }\n};\nint a[100005];\nint tcnt[100005], cnt[100005];\ni64 sum = 0;\nvector&lt;int&gt; ind(1);\nvoid add(int idx) {\n    cnt[a[idx]]++;\n    sum = max(sum, 1LL * cnt[a[idx]] * ind[a[idx]]);\n}\nvoid del(int idx) {\n    cnt[a[idx]]--;\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        ind.push_back(a[i]);\n    }\n    sort(begin(ind), end(ind));\n    ind.resize(unique(begin(ind), end(ind)) - begin(ind));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(ind), end(ind), a[i]) - begin(ind);\n    }\n    vector&lt;MO&gt; mo;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;i64&gt; ans(mo.size());\n    int lst = belong[mo[0].L], R = ed[lst], L = R + 1;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        if (belong[QL] == belong[QR]) { // \u5728\u4e00\u4e2a\u5757\u5185, \u66b4\u529b\u67e5\u8be2\n            i64 temp = 0;\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]++;\n                temp = max(temp, 1LL * tcnt[a[j]] * ind[a[j]]);\n            }\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]--;\n            }\n            ans[idx] = temp;\n            continue;\n        }\n        if (lst != belong[QL]) {\n            // \u5982\u679c\u5f53\u524d\u4e0d\u5728\u67e5\u8be2\u5757\u5185, \u5219\u5c06 L \u548c R \u79fb\u81f3\u5757\u5185\n            while (R &gt; ed[belong[QL]]) {\n                del(R--);\n            }\n            while (L &lt; ed[belong[QL]] + 1) {\n                del(L++);\n            }\n            sum = 0;\n            lst = belong[QL];\n        }\n        while (R &lt; QR) { // \u5411\u53f3\u6269, \u76f4\u81f3 R = QR\n            add(++R);\n        }\n        i64 temp = sum;\n        int L1 = L;\n        while (L1 &gt; QL) { // \u65b0\u5f00\u5411\u5de6\u6269, \u76f4\u81f3 L1 = QL\n            add(--L1);\n        }\n        ans[idx] = sum;\n        while (L1 &lt; L) { // \u56de\u6eda\u5de6\u7aef\u70b9\n            del(L1++);\n        }\n        sum = temp;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/mo-query/#_6","title":"\u4e0d\u589e\u52a0\u83ab\u961f","text":"\u4f8b\u9898 <p>P4137 Rmq Problem / mex - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[200005], st[200005], ed[200005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        return x.R &gt; y.R;\n    }\n};\nint a[200005];\nint cnt[200005], tcnt[200005];\nint sum = 0;\nvoid add(int idx) {\n    cnt[a[idx]]++;\n}\nvoid del(int idx) {\n    if (cnt[a[idx]]-- == 1) {\n        sum = min(sum, a[idx]);\n    }\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        cnt[a[i]]++;\n    }\n    while (cnt[sum]) {\n        sum++;\n    }\n    vector&lt;MO&gt; mo;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;int&gt; ans(mo.size());\n    int L = 1, R = n, lst = 0;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        // cout &lt;&lt; QL &lt;&lt; \" \" &lt;&lt;QR &lt;&lt; \" \" &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n        if (belong[QL] == belong[QR]) { // \u5728\u4e00\u4e2a\u5757\u5185, \u66b4\u529b\u67e5\u8be2\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]++;\n            }\n            i64 temp = 0;\n            while (tcnt[temp]) {\n                temp++;\n            }\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]--;\n            }\n            ans[idx] = temp;\n            continue;\n        }\n        if (lst != belong[QL]) {\n            // \u5982\u679c\u5f53\u524d\u4e0d\u5728\u67e5\u8be2\u5757\u5185, \u5219\u5c06 R \u79fb\u81f3\u6700\u540e, L \u79fb\u81f3\u5f53\u524d\u5757\u7684\u7b2c\u4e00\u4e2a\u70b9\n            while (R &lt; n) {\n                add(++R);\n            }\n            while (L &lt; st[belong[QL]]) {\n                del(L++);\n            }\n            int temp = 0;\n            while (cnt[temp]) {\n                temp++;\n            }\n            sum = temp;\n            lst = belong[QL];\n        }\n        while (R &gt; QR) { // R \u79fb\u81f3 QR\n            del(R--);\n        }\n        int temp = sum, L1 = L;\n        while (L1 &lt; QL) { // L1 \u79fb\u81f3 QL\n            del(L1++);\n        }\n        ans[idx] = sum;\n        while (L1 &gt; L) { // L1 \u79fb\u56de\u6765\n            add(--L1);\n        }\n        sum = temp;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/monotonic-queue/","title":"\u5355\u8c03\u961f\u5217","text":"\u6a21\u7248 C++<pre><code>// \u6c42 [i-m+1, i] \u7684\u6700\u503c\ndeque&lt;int&gt; que;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &gt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mi.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mi[i] &lt;&lt; \" \\n\"[i == n - m];\ndeque&lt;int&gt;().swap(que);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &lt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mx.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mx[i] &lt;&lt; \" \\n\"[i == n - m];\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1886 <p>P1886 \u3010\u6a21\u677f\u3011\u5355\u8c03\u961f\u5217 - \u6d1b\u8c37</p>"},{"location":"template/data-structure/monotonic-stack/","title":"\u5355\u8c03\u6808","text":"\u6a21\u7248 C++<pre><code>// \u6c42 i \u540e\u9762\u4e00\u4e2a\u6bd4 a[i] \u5927\u7684\u6570\u7684\u4e0b\u6807\nstack&lt;int&gt; st;\nvector&lt;int&gt; ans(n + 1);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!st.empty() &amp;&amp; a[st.top()] &lt; a[i]) {\n        ans[st.top()] = i;\n        st.pop();\n    }\n    st.emplace(i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5788 <p>P5788 \u3010\u6a21\u677f\u3011\u5355\u8c03\u6808 - \u6d1b\u8c37</p>"},{"location":"template/data-structure/segment-tree/","title":"\u7ebf\u6bb5\u6811","text":"\u6a21\u7248 \u4e0d\u5e26\u61d2\u6807\u8bb0\u5e26\u61d2\u6807\u8bb0 \u4ee3\u7801 C++<pre><code>i64 a[100005];\ntemplate&lt;class Info, class T&gt;\nstruct SegmentTree {\n    int N;\n    vector&lt;Info&gt; tr;\n    SegmentTree(int n) {\n        init(n);\n    }\n    void init(int n) {\n        N = n;\n        n &lt;&lt;= 2;\n        tr.resize(0);\n        tr.resize(n);\n    }\n    void build() {\n        build(1, 1, N);\n    }\n    void build(int p, int L, int R) {\n        if (L == R) {\n            tr[p] = buildInit(L);\n            return;\n        }\n        int mid = (L + R) &gt;&gt; 1;\n        build(p &lt;&lt; 1, L, mid);\n        build(p &lt;&lt; 1 | 1, mid + 1, R);\n        pushup(p);\n    }\n    void pushup(int p) {\n        tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n    }\n    void rangeModify(int QL, int QR, T x) {\n        return rangeModify(1, QL, QR, x);\n    }\n    void rangeModify(int p, int QL, int QR, T x) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            pushtag(p, x);\n            return;\n        }\n        int mid = (tr[p].L + tr[p].R) &gt;&gt; 1;\n        if (QL &lt;= mid) rangeModify(p &lt;&lt; 1, QL, QR, x);\n        if (QR &gt;= mid + 1) rangeModify(p &lt;&lt; 1 | 1, QL, QR, x);\n        pushup(p);\n    }\n    Info rangeQuery(int QL, int QR) {\n        return rangeQuery(1, QL, QR);\n    }\n    Info rangeQuery(int p, int QL, int QR) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            return tr[p];\n        }\n        int mid = (tr[p].L + tr[p].R) &gt;&gt; 1;\n        if (QR &lt;= mid) return rangeQuery(p &lt;&lt; 1, QL, QR);\n        if (QL &gt;= mid + 1) return rangeQuery(p &lt;&lt; 1 | 1, QL, QR);\n        return merge(rangeQuery(p &lt;&lt; 1, QL, QR), rangeQuery(p &lt;&lt; 1 | 1, QL, QR));\n    }\n    // \u5efa\u6811\u521d\u59cb\u5316\n    Info buildInit(int L) {\n        return {L, L, a[L] % P};\n    }\n    // \u4e24\u8282\u70b9\u5408\u5e76\n    Info merge(const Info &amp;lhs, const Info &amp;rhs) {\n        return {lhs.L, rhs.R, (lhs.sum + rhs.sum) % P};\n    }\n    // \u8282\u70b9\u6253\u6807\u8bb0\n    void pushtag(int p, T x) {\n        tr[p] = x;\n    }\n}; // SegmentTree\nstruct Info {\n    int L, R;\n    i64 sum;\n};\n</code></pre> \u4ee3\u7801 C++<pre><code>i64 P;\ni64 a[100005];\ntemplate&lt;class Info, class Lazy, class T&gt;\nstruct SegmentTree {\n    int N;\n    vector&lt;Info&gt; tr;\n    vector&lt;Lazy&gt; tag;\n    SegmentTree(int n) {\n        init(n);\n    }\n    void init(int n) {\n        N = n;\n        n &lt;&lt;= 2;\n        tr.resize(0);\n        tr.resize(n);\n        tag.resize(0);\n        tag.resize(n);\n    }\n    void build() {\n        build(1, 1, N);\n    }\n    void build(int p, int L, int R) {\n        if (L == R) {\n            tr[p] = buildInit(L);\n            return;\n        }\n        int mid = (L + R) &gt;&gt; 1;\n        build(p &lt;&lt; 1, L, mid);\n        build(p &lt;&lt; 1 | 1, mid + 1, R);\n        pushup(p);\n    }\n    void pushup(int p) {\n        tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n    }\n    void pushdown(int p) {\n        pushtag(p &lt;&lt; 1, tag[p]);\n        pushtag(p &lt;&lt; 1 | 1, tag[p]);\n        tag[p] = Lazy();\n    }\n    void rangeModify(int QL, int QR, T x) {\n        return rangeModify(1, QL, QR, x);\n    }\n    void rangeModify(int p, int QL, int QR, T x) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            pushtag(p, x);\n            return;\n        }\n        pushdown(p);\n        int mid = (tr[p].L + tr[p].R) &gt;&gt; 1;\n        if (QL &lt;= mid) rangeModify(p &lt;&lt; 1, QL, QR, x);\n        if (QR &gt;= mid + 1) rangeModify(p &lt;&lt; 1 | 1, QL, QR, x);\n        pushup(p);\n    }\n    Info rangeQuery(int QL, int QR) {\n        return rangeQuery(1, QL, QR);\n    }\n    Info rangeQuery(int p, int QL, int QR) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            return tr[p];\n        }\n        pushdown(p);\n        int mid = (tr[p].L + tr[p].R) &gt;&gt; 1;\n        if (QR &lt;= mid) return rangeQuery(p &lt;&lt; 1, QL, QR);\n        if (QL &gt;= mid + 1) return rangeQuery(p &lt;&lt; 1 | 1, QL, QR);\n        return merge(rangeQuery(p &lt;&lt; 1, QL, QR), rangeQuery(p &lt;&lt; 1 | 1, QL, QR));\n    }\n    // \u5efa\u6811\u521d\u59cb\u5316\n    Info buildInit(int L) {\n        return {L, L, a[L] % P};\n    }\n    // \u4e24\u8282\u70b9\u5408\u5e76\n    Info merge(const Info &amp;lhs, const Info &amp;rhs) {\n        Info res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        res.sum = (lhs.sum + rhs.sum) % P;\n        return res;\n        return {lhs.L, rhs.R, (lhs.sum + rhs.sum) % P};\n    }\n    // \u8282\u70b9\u6253\u6807\u8bb0\n    void pushtag(int p, T lazy) {\n        if (lazy.prod != 1) {\n            tag[p].prod = tag[p].prod * lazy.prod % P;\n            tag[p].add = tag[p].add * lazy.prod % P;\n            tr[p].sum = tr[p].sum * lazy.prod % P;\n        }\n        if (lazy.add != 0) {\n            tag[p].add = (tag[p].add + lazy.add) % P;\n            tr[p].sum = (tr[p].sum + (tr[p].R - tr[p].L + 1) * lazy.add % P) % P;\n        }\n    }\n}; // SegmentTree\nstruct Info {\n    int L, R;\n    i64 sum;\n};\nstruct Lazy {\n    i64 add, prod;\n    // \u61d2\u6807\u8bb0\u521d\u59cb\u5316\n    Lazy() {\n        add = 0;\n        prod = 1;\n    }\n};\n</code></pre>"},{"location":"template/data-structure/segment-tree/#_2","title":"\u7ebf\u6bb5\u6811\u5408\u5e76","text":"\u4f8b\u9898 \u6d1b\u8c37P4556 <p>\u6811\uff0c\u6bcf\u6b21\u64cd\u4f5c\u7ed9x\u5230y\u4e0a\u53d1\u4e00\u4e2a\u7c7b\u578b\u4e3az\u7684\u7269\u54c1</p> <p>\u95ee\u6700\u7ec8\u6bcf\u4e2a\u70b9\u5b58\u653e\u6570\u91cf\u6700\u591a\u7684\u7269\u54c1\u7684\u7c7b\u578b\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 100005;\nvector&lt;int&gt; adj[N];\nint fa[N][22], deep[N], tot;\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; i &lt;= 21 ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint Ls[N &lt;&lt; 8], Rs[N &lt;&lt; 8], sum[N &lt;&lt; 8], typ[N &lt;&lt; 8];\nvoid pushup(int p) {\n    if (sum[Ls[p]] &gt;= sum[Rs[p]]) {\n        sum[p] = sum[Ls[p]];\n        typ[p] = typ[Ls[p]];\n    } else {\n        sum[p] = sum[Rs[p]];\n        typ[p] = typ[Rs[p]];\n    }\n}\nint change(int &amp;p, int pos, int k, int L = 1, int R = N) {\n    if (p == 0) p = ++tot;\n    if (L == R) {\n        sum[p] += k;\n        typ[p] = pos;\n        return p;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) change(Ls[p], pos, k, L, mid);\n    else change(Rs[p], pos, k, mid + 1, R);\n    pushup(p);\n    return p;\n}\nint merge(int rtL, int rtR, int L = 1, int R = N) {\n    if (rtL == 0 || rtR == 0) return rtL + rtR;\n    if (L == R) {\n        sum[rtL] += sum[rtR];\n        typ[rtL] = L;\n        return rtL;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Ls[rtL] = merge(Ls[rtL], Ls[rtR], L, mid);\n    Rs[rtL] = merge(Rs[rtL], Rs[rtR], mid + 1, R);\n    pushup(rtL);\n    return rtL;\n}\nint ans[N];\nint root[N];\nvoid solve(int u, int p) {\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        solve(to, u);\n        root[u] = merge(root[u], root[to]);\n    }\n    if (sum[root[u]]) {\n        ans[u] = typ[root[u]];\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        int k = LCA(x, y);\n        root[x] = change(root[x], z, 1);\n        root[y] = change(root[y], z, 1);\n        root[k] = change(root[k], z, -1);\n        if (fa[k][0]) {\n            root[fa[k][0]] = change(root[fa[k][0]], z, -1);\n        }\n    }\n    solve(1, 0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 CF526F(\u533a\u95f4\u6392\u5217)\u725b\u5ba261657L(\u533a\u95f4\u6700\u957f\u8fde\u7eed\u76f8\u540c\u5b57\u7b26)\u84dd\u68659991 <p>Problem - F - Codeforces</p> <p>n\u6392\u5217\u4e2d\uff0c\u6c42\u6240\u6709\u6ee1\u8db3 \\(\\max-\\min=R-L\\) \u7684\u533a\u95f4\uff0c(\u6b64\u4ee3\u7801\u53ef\u4ee5\u6c42\u91cd\u590d\u6392\u5217)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 300005;\nint n, a[N];\nint st1[N], t1, st2[N], t2;\nmap &lt;int, int&gt; last;\nstruct Info {\n    int L, R, mi, cnt;\n    int lazy;\n} tr[N&lt;&lt;2];\nvoid build(int p, int L, int R) {\n    tr[p].L = L;\n    tr[p].R = R;\n    tr[p].cnt = R - L + 1;\n    if (L == R) {\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n}\nvoid pushup(int p) {\n    tr[p].mi = min(tr[p &lt;&lt; 1].mi, tr[p &lt;&lt; 1 | 1].mi);\n    tr[p].cnt = (tr[p].mi == tr[p &lt;&lt; 1].mi ? tr[p &lt;&lt; 1].cnt : 0) + (tr[p].mi == tr[p &lt;&lt; 1 | 1].mi ? tr[p &lt;&lt; 1 | 1].cnt : 0);\n}\nvoid pushtag(int p, int tag) {\n    tr[p].mi += tag;\n    tr[p].lazy += tag;\n}\nvoid pushdown(int p) {\n    if (tr[p].lazy) {\n        pushtag(p &lt;&lt; 1, tr[p].lazy);\n        pushtag(p &lt;&lt; 1 | 1, tr[p].lazy);\n        tr[p].lazy = 0;\n    }\n}\nvoid modify(int p, int QL, int QR, int k) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        pushtag(p, k);\n        return;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QR &lt;= mid) modify(p &lt;&lt; 1, QL, QR, k);\n    else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    else {\n        modify(p &lt;&lt; 1, QL, QR, k);\n        modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    }\n    pushup(p);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1, x, y; i &lt;= n; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y;\n    }\n    build(1, 1, n);\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        while (t1 &amp;&amp; a[st1[t1]] &lt; a[i]) { // \u7ef4\u62a4 max\n            modify(1, st1[t1 - 1] + 1, st1[t1], -a[st1[t1]]); // \u64a4\u9500\n            t1--;\n        }\n        while (t2 &amp;&amp; a[st2[t2]] &gt; a[i]) { // \u7ef4\u62a4 min\n            modify(1, st2[t2 - 1] + 1, st2[t2], a[st2[t2]]); // \u64a4\u9500\n            t2--;\n        }\n        modify(1, last[a[i]] + 1, i, -1);\n        last[a[i]] = st1[++t1] = st2[++t2] = i;\n        modify(1, st1[t1 - 1] + 1, i, a[i]);\n        modify(1, st2[t2 - 1] + 1, i, -a[i]);\n        ans += tr[1].cnt;\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>L-\u6700\u957f\u8fde\u7eed\u76f8\u540c\u5b57\u7b26_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u4e8c\uff09\u573a\uff1a\u6cb3\u5357\u5de5\u4e1a\u5927\u5b66</p> <p>\u5982\u9898\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int MAXN = 100000;\nstring str;\nint Lmx[MAXN &lt;&lt; 4], Rmx[MAXN &lt;&lt; 4], mx[MAXN &lt;&lt; 4], Lc[MAXN &lt;&lt; 4], Rc[MAXN &lt;&lt; 4];\nvoid push(const int p, const int L, const int R, const int mid) {\n    const int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n    Lmx[p] = Lmx[x];\n    Rmx[p] = Rmx[y];\n    if (Lmx[x] == mid - L + 1 &amp;&amp; str[mid] == str[mid + 1]) {\n        Lmx[p] += Lmx[y];\n    }\n    if (Rmx[y] == R - mid &amp;&amp; str[mid] == str[mid + 1]) {\n        Rmx[p] += Rmx[x];\n    }\n    if (mx[x] &gt;= mx[y]) {\n        mx[p] = mx[x];\n        Lc[p] = Lc[x];\n        Rc[p] = Rc[x];\n    } else {\n        mx[p] = mx[y];\n        Lc[p] = Lc[y];\n        Rc[p] = Rc[y];\n    }\n    if (str[mid] == str[mid + 1]) {\n        if (mx[p] &lt; Rmx[x] + Lmx[y]) {\n            mx[p] = Rmx[x] + Lmx[y];\n            Lc[p] = mid - Rmx[x] + 1;\n            Rc[p] = mid + Lmx[y];\n        } else if (mx[p] == Rmx[x] + Lmx[y]) {\n            if (Lc[p] &gt; mid - Rmx[x] + 1) {\n                Lc[p] = mid - Rmx[x] + 1;\n                Rc[p] = mid + Lmx[y];\n            }\n        }\n    }\n}\nvoid build(const int p, const int L, const int R) {\n    if (L == R) {\n        Lmx[p] = Rmx[p] = mx[p] = 1;\n        Lc[p] = Rc[p] = L;\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    push(p, L, R, mid);\n}\nvoid modify(const int p, const int pos, const char ch, const int L, const int R) {\n    if (R &lt; pos || L &gt; pos) {\n        return;\n    }\n    if (L == R) {\n        str[L] = ch;\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, pos, ch, L, mid);\n    modify(p &lt;&lt; 1 | 1, pos, ch, mid + 1, R);\n    push(p, L, R, mid);\n}\npair&lt;int, int&gt; query(const int p, const int QL, const int QR, const int L, const int R) {\n    if (QR &lt; L || QL &gt; R) {\n        return {1, 0};\n    }\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return {Lc[p], Rc[p]};\n    }\n    const int mid = L + R &gt;&gt; 1;\n    auto resL = query(p &lt;&lt; 1, QL, QR, L, mid);\n    pair&lt;int, int&gt; resMid = {1, 0};\n    if (str[mid] == str[mid + 1] &amp;&amp; mid &gt;= QL &amp;&amp; mid + 1 &lt;= QR) {\n        resMid = {max(QL, mid - Rmx[p &lt;&lt; 1] + 1), min(QR, mid + Lmx[p &lt;&lt; 1 | 1])};\n    }\n    if (resL.second - resL.first + 1 &lt; resMid.second - resMid.first + 1) {\n        resL = resMid;\n    }\n    auto resR = query(p &lt;&lt; 1 | 1, QL, QR, mid + 1, R);\n    if (resL.second - resL.first + 1 &lt; resR.second - resR.first + 1) {\n        resL = resR;\n    }\n    return resL;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    cin &gt;&gt; str;\n    str = \" \" + str;\n    build(1, 1, n);\n    for (int i = 0 ; i &lt; m ; i++) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            if (L == 0) L = 1;\n            auto [x, y] = query(1, L, R, 1, n);\n            cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";\n        } else {\n            int x;\n            char ch;\n            cin &gt;&gt; x &gt;&gt; ch;\n            modify(1, x, ch, 1, n);\n        }\n    }\n    return 0;\n}\n</code></pre> <p>\u9b54\u672f\u5e08\u3010\u7b97\u6cd5\u8d5b\u3011 - \u84dd\u6865\u4e91\u8bfe</p> <p></p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 100000 + 5;\n// const int M = 1 &lt;&lt; __lg(N + 5) + 1;\nconst int M = N &lt;&lt; 4;\nconst long long mod = 998244353;\n\nstruct Node {\n    int L, R;\n    long long sum[3];\n    Node() {\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            sum[i] = 0;\n        }\n    }\n    friend Node operator+ (const Node &amp;lhs, const Node &amp;rhs) {\n        Node res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.sum[i] = (lhs.sum[i] + rhs.sum[i]) % mod;\n        }\n        return res;\n    }\n\n} tr[M];\nstruct Tag {\n    int to[3];\n    long long mul[3];\n    Tag() {\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            to[i] = i;\n            mul[i] = 1;\n        }\n    }\n} lazy[M];\n\nint a[N];\n\nvoid pushtag(int p, Tag tag) {\n    {\n        Node res;\n        res.L = tr[p].L;\n        res.R = tr[p].R;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.sum[tag.to[i]] = (res.sum[tag.to[i]] + tag.mul[i] * tr[p].sum[i] % mod) % mod;\n        }\n        tr[p] = res;\n    }\n    {\n        Tag res;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.to[i] = tag.to[lazy[p].to[i]];\n            res.mul[i] = lazy[p].mul[i] * tag.mul[lazy[p].to[i]] % mod;    \n        }\n        lazy[p] = res;\n    }\n}\n// \nvoid pushdown(int p) {\n    pushtag(p &lt;&lt; 1, lazy[p]);\n    pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n    lazy[p] = Tag();\n}\nint n;\nvoid build(int p = 1, int L = 1, int R = n) {\n    tr[p].L = L;\n    tr[p].R = R;\n    if (L == R) {\n        tr[p].sum[a[L]] = 1;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\n\nvoid modify(int p, int QL, int QR, Tag tag) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        pushtag(p, tag);\n        return;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(p &lt;&lt; 1, QL, QR, tag);\n    if (QR &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, QL, QR, tag);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        a[i]--;\n    }\n    build();\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, op;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; op;\n        Tag tag;\n        if (op == 1) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            x--;\n            y--;\n            tag.to[x] = y;\n            tag.to[y] = x;\n        }\n        if (op == 2) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            x--;\n            y--;\n            tag.to[x] = y;\n        }\n        if (op == 3) {\n            int x;\n            cin &gt;&gt; x;\n            x--;\n            tag.mul[x] = 2;\n        }\n        modify(1, L, R, tag);\n        cout &lt;&lt; tr[1].sum[0] &lt;&lt; \" \" &lt;&lt; tr[1].sum[1] &lt;&lt; \" \" &lt;&lt; tr[1].sum[2] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/sparse-table/","title":"ST\u8868","text":"<p>\\(O(n\\log n)\\)</p> <p>\u89e3\u51b3 RMQ \u95ee\u9898\uff0c\u5982\u9759\u6001\u533a\u95f4\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u548c \\(\\gcd\\)</p> \u6a21\u7248 C++<pre><code>template&lt;class T&gt;\nstruct SparseTable {\n    vector&lt;vector&lt;T&gt;&gt; st;\n    vector&lt;int&gt; lg;\n    // \u4f20\u5165\u7684 vector \u7684\u4e0b\u6807\u5fc5\u987b\u4ee5 1 \u4e3a\u57fa\u7840\n    SparseTable(const vector&lt;T&gt; &amp;s) {\n        const int n = s.size() - 1;\n        st.assign(n + 1, vector&lt;T&gt;(22, 0));\n        lg.resize(n + 1);\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            st[i][0] = s[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n    }\n    T query(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(st[L][k], st[R - (1 &lt;&lt; k) + 1][k]);\n    }\n}; // SparseTable\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3865 <p>P3865 \u3010\u6a21\u677f\u3011ST \u8868 - \u6d1b\u8c37</p>"},{"location":"template/data-structure/balanced-tree/treap/","title":"Treap","text":"\u6a21\u7248 \u65cb\u8f6c\u65e0\u65cb C++<pre><code>namespace _Treap {\n    template&lt;class T&gt;\n    struct Info {\n        int L, R, rnd, cnt, size;\n        T val;\n        Info() = default;\n        Info(T val) : val(val) {\n            L = R = 0;\n            cnt = size = 1;\n            rnd = rand();\n        }\n    };\n    template&lt;class T&gt;\n    struct Treap {\n        vector&lt;Info&lt;T&gt;&gt; info;\n        int tot, root;\n        Treap() {\n            init(0);\n        }\n        Treap(int N) {\n            init(N);\n        }\n        void init(int N) {\n            tot = root = 0;\n            info.resize(N + 1);\n        }\n        void push(int p) {\n            info[p].size = info[info[p].L].size + info[info[p].R].size + info[p].cnt;\n        }\n        void LRotate(int &amp;p) {\n            int temp = info[p].R;\n            info[p].R = info[temp].L;\n            info[temp].L = p;\n            info[temp].size = info[p].size;\n            push(p);\n            p = temp;\n        }\n        void RRotate(int &amp;p) {\n            int temp = info[p].L;\n            info[p].L = info[temp].R;\n            info[temp].R = p;\n            info[temp].size = info[p].size;\n            push(p);\n            p = temp;\n        }\n        void build(int &amp;p, T x) {\n            p = ++tot;\n            assert(p &lt; (int) info.size());\n            info[p] = Info(x);\n        }\n        void insert(T x) {\n            insert(root, x);\n        }\n        void insert(int &amp;p, T x) {\n            if (p == 0) {\n                build(p, x);\n                return;\n            }\n            info[p].size++;\n            if (info[p].val == x) {\n                info[p].cnt++;\n            } else if (info[p].val &lt; x) {\n                insert(info[p].R, x);\n                if (info[info[p].R].rnd &lt; info[p].rnd) {\n                    LRotate(p);\n                }\n            } else {\n                insert(info[p].L, x);\n                if (info[info[p].L].rnd &lt; info[p].rnd) {\n                    RRotate(p);\n                }\n            }\n        }\n        bool erase(T x) {\n            return erase(root, x);\n        }\n        bool erase(int &amp;p, T x) {\n            if (p == 0) {\n                return false;\n            }\n            if (info[p].val == x) {\n                if (info[p].cnt &gt; 1) {\n                    info[p].cnt--;\n                    info[p].size--;\n                    return true;\n                }\n                if (info[p].L == 0 || info[p].R == 0) {\n                    p = info[p].L + info[p].R;\n                    return true;\n                } else if (info[info[p].L].rnd &lt; info[info[p].R].rnd) {\n                    RRotate(p);\n                    return erase(p, x);\n                } else {\n                    LRotate(p);\n                    return erase(p, x);\n                }\n            } else if (info[p].val &lt; x) {\n                bool succ = erase(info[p].R, x);\n                if (succ) info[p].size--;\n                return succ;\n            } else {\n                bool succ = erase(info[p].L, x);\n                if (succ) info[p].size--;\n                return succ;\n            }\n        }\n        int rank(T x) {\n            return rank(root, x);\n        }\n        int rank(int p, T x) {\n            if (p == 0) return 0;\n            if (info[p].val == x) {\n                return info[info[p].L].size + 1;\n            } else if (info[p].val &lt; x) {\n                return info[info[p].L].size + info[p].cnt + rank(info[p].R, x);\n            } else {\n                return rank(info[p].L, x);\n            }\n        }\n        T kth(int x) {\n            return kth(root, x);\n        }\n        T kth(int p, int x) {\n            if (p == 0) return 0;\n            if (x &lt;= info[info[p].L].size) {\n                return kth(info[p].L, x);\n            } else if (x &gt; info[info[p].L].size + info[p].cnt) {\n                return kth(info[p].R, x - info[info[p].L].size - info[p].cnt);\n            } else {\n                return info[p].val;\n            }\n        }\n        T prev(T x) {\n            int p = prev(root, x);\n            p = max(p, 0);\n            return info[p].val;\n        }\n        int prev(int p, T x) {\n            if (p == 0) return -1;\n            if (info[p].val &lt; x) {\n                int res = prev(info[p].R, x);\n                if (res != -1) return res;\n                return p;\n            }\n            return prev(info[p].L, x);\n        }\n        T next(T x) {\n            return info[next(root, x)].val;\n        }\n        int next(int p, T x) {\n            if (p == 0) return -1;\n            if (info[p].val &gt; x) {\n                int res = next(info[p].L, x);\n                if (res != -1) return res;\n                return p;\n            } else {\n                return next(info[p].R, x);\n            }\n        }\n        T&amp; operator[](int p) {\n            return info[p].val;\n        }\n    }; // Treap\n    // insert(T x) \u63d2\u5165 1 \u4e2a x\n    // erase(T x) \u5220\u9664 1 \u4e2a x\n    // rank(T x) \u67e5\u627e x \u7684\u6392\u540d\n    // kth(int x) \u67e5\u627e\u7b2c x \u5c0f\n    // prev(T x) \u67e5\u627e x \u7684\u524d\u9a71\n    // next(T x) \u67e5\u627e x \u7684\u540e\u7ee7\n};\nusing _Treap::Treap;\n</code></pre> C++<pre><code>namespace _Treap {\n    template&lt;class T&gt;\n    struct Node {\n        Node *child[2];\n        T val;\n        int rnd, cnt, size;\n        Node(T val) : val(val) {\n            cnt = size = 1;\n            rnd = rand();\n            child[0] = child[1] = nullptr;\n        }\n        void push() {\n            size = cnt;\n            if (child[0] != nullptr) {\n                size += child[0] -&gt; size;\n            }\n            if (child[1] != nullptr) {\n                size += child[1] -&gt; size;\n            }\n        }\n    };\n    template&lt;class T&gt;\n    struct Treap {\n        Node&lt;T&gt; *root = nullptr;\n        pair&lt;Node&lt;T&gt;*, Node&lt;T&gt;*&gt; split(Node&lt;T&gt; *cur, T key) {\n            if (cur == nullptr) return {nullptr, nullptr};\n            if (cur -&gt; val &lt;= key) {\n                auto temp = split(cur -&gt; child[1], key);\n                cur -&gt; child[1] = temp.first;\n                cur -&gt; push();\n                return {cur, temp.second};\n            } else {\n                auto temp = split(cur -&gt; child[0], key);\n                cur -&gt; child[0] = temp.second;\n                cur -&gt; push();\n                return {temp.first, cur};\n            }\n        }\n        tuple&lt;Node&lt;T&gt;*, Node&lt;T&gt;*, Node&lt;T&gt;*&gt; splitByRank(Node&lt;T&gt; *cur, int rank) {\n            if (cur == nullptr) return {nullptr, nullptr, nullptr};\n            int ls_size = cur -&gt; child[0] == nullptr ? 0 : cur -&gt; child[0] -&gt; size;\n            if (rank &lt;= ls_size) {\n                Node&lt;T&gt; *L, *mid, *R;\n                tie(L, mid, R) = splitByRank(cur -&gt; child[0], rank);\n                cur -&gt; child[0] = R;\n                cur -&gt; push();\n                return {L, mid, cur};\n            } else if (rank &lt;= ls_size + cur -&gt; cnt) {\n                Node&lt;T&gt; *lt = cur -&gt; child[0], *rt = cur -&gt; child[1];\n                cur -&gt; child[0] = cur -&gt; child[1] = nullptr;\n                return {lt, cur, rt};\n            } else {\n                Node&lt;T&gt; *L, *mid, *R;\n                tie(L, mid, R) = splitByRank(cur -&gt; child[1], rank - ls_size - cur -&gt; cnt);\n                cur -&gt; child[1] = L;\n                cur -&gt; push();\n                return {cur, mid, R};\n            }\n        }\n        Node&lt;T&gt;* merge(Node&lt;T&gt; *a, Node&lt;T&gt; *b) {\n            if (a == nullptr) return b;\n            if (b == nullptr) return a;\n            if (a -&gt; rnd &lt; b -&gt; rnd) {\n                a -&gt; child[1] = merge(a -&gt; child[1], b);\n                a -&gt; push();\n                return a;\n            } else {\n                b -&gt; child[0] = merge(a, b -&gt; child[0]);\n                b -&gt; push();\n                return b;\n            }\n        }\n        void insert(T x) {\n            auto temp = split(root, x);\n            auto l_tr = split(temp.first, x - 1);\n            Node&lt;T&gt; *res;\n            if (l_tr.second == nullptr) {\n                res = new Node(x);\n            } else {\n                l_tr.second -&gt; cnt++;\n                l_tr.second -&gt; push();\n            }\n            Node&lt;T&gt; *l_tr_combined = merge(l_tr.first, l_tr.second == nullptr ? res : l_tr.second);\n            root = merge(l_tr_combined, temp.second);\n        }\n        void erase(T x) {\n            auto temp = split(root, x);\n            auto l_tr = split(temp.first, x - 1);\n            if (l_tr.second -&gt; cnt &gt; 1) {\n                l_tr.second -&gt; cnt--;\n                l_tr.second -&gt; push();\n                l_tr.first = merge(l_tr.first, l_tr.second);\n            } else {\n                if (temp.first == l_tr.second) {\n                    temp.first = nullptr;\n                }\n                delete l_tr.second;\n                l_tr.second = nullptr;\n            }\n            root = merge(l_tr.first, temp.second);\n        }\n        int rank(T val) {\n            return rank(root, val);\n        }\n        int rank(Node&lt;T&gt; *&amp;cur, T val) {\n            auto temp = split(cur, val - 1);\n            int res = (temp.first == nullptr ? 0 : temp.first -&gt; size) + 1;\n            root = merge(temp.first, temp.second);\n            return res;\n        }\n        T kth(int rank) {\n            return kth(root, rank);\n        }\n        T kth(Node&lt;T&gt;* &amp;cur, int rank) {\n            Node&lt;T&gt; *L, *mid, *R;\n            tie(L, mid, R) = splitByRank(cur, rank);\n            T res = mid -&gt; val;\n            root = merge(merge(L, mid), R);\n            return res;\n        }\n        T prev(T val) {\n            auto temp = split(root, val - 1);\n            T res = kth(temp.first, temp.first -&gt; size);\n            root = merge(temp.first, temp.second);\n            return res;\n        }\n        T next(T val) {\n            auto temp = split(root, val);\n            int res = kth(temp.second, 1);\n            root = merge(temp.first, temp.second);\n            return res;\n        }\n    }; // Treap\n    // insert(T x) \u63d2\u5165 1 \u4e2a x\n    // erase(T x) \u5220\u9664 1 \u4e2a x\n    // rank(T x) \u67e5\u627e x \u7684\u6392\u540d\n    // kth(int x) \u67e5\u627e\u7b2c x \u5c0f\n    // prev(T x) \u67e5\u627e x \u7684\u524d\u9a71\n    // next(T x) \u67e5\u627e x \u7684\u540e\u7ee7\n}\nusing _Treap::Treap;\n</code></pre> \u4f8b\u9898 LibreOJ#104 \u666e\u901a\u5e73\u8861\u6811LibreOJ#105 \u6587\u827a\u5e73\u8861\u6811 <p>#104. \u666e\u901a\u5e73\u8861\u6811 - LibreOJ</p> <p>#105. \u6587\u827a\u5e73\u8861\u6811 - LibreOJ</p> \u4ee3\u7801 C++<pre><code>namespace _Treap {\n    template&lt;class T&gt;\n    struct Node {\n        Node *child[2];\n        T val;\n        int rnd, cnt, size;\n        bool rev;\n        Node(const T&amp; val) : val(val), cnt(1), size(1), rev(false) {\n            rnd = rand();\n            child[0] = child[1] = nullptr;\n        }\n        void push() {\n            size = cnt;\n            if (child[0] != nullptr) {\n                size += child[0] -&gt; size;\n            }\n            if (child[1] != nullptr) {\n                size += child[1] -&gt; size;\n            }\n        }\n        void down() {\n            swap(child[0], child[1]);\n            if (child[0] != nullptr) {\n                child[0] -&gt; rev ^= 1;\n            }\n            if (child[1] != nullptr) {\n                child[1] -&gt; rev ^= 1;\n            }\n            rev = false;\n        }\n        void check() {\n            if (rev) {\n                down();\n            }\n        }\n    };\n    template&lt;class T&gt;\n    struct Treap {\n        Node&lt;T&gt; *root = nullptr;\n        pair&lt;Node&lt;T&gt;*, Node&lt;T&gt;*&gt; split(Node&lt;T&gt; *cur, T key) {\n            if (cur == nullptr) return {nullptr, nullptr};\n            cur -&gt; check();\n            int sz = cur -&gt; child[0] == nullptr ? 0 : cur -&gt; child[0] -&gt; size;\n            if (sz &lt; key) {\n                auto temp = split(cur -&gt; child[1], key - sz - 1);\n                cur -&gt; child[1] = temp.first;\n                cur -&gt; push();\n                return {cur, temp.second};\n            } else {\n                auto temp = split(cur -&gt; child[0], key);\n                cur -&gt; child[0] = temp.second;\n                cur -&gt; push();\n                return {temp.first, cur};\n            }\n        }\n        Node&lt;T&gt;* merge(Node&lt;T&gt; *a, Node&lt;T&gt; *b) {\n            if (a == nullptr) return b;\n            if (b == nullptr) return a;\n            a -&gt; check();\n            b -&gt; check();\n            if (a -&gt; rnd &lt; b -&gt; rnd) {\n                a -&gt; child[1] = merge(a -&gt; child[1], b);\n                a -&gt; push();\n                return a;\n            } else {\n                b -&gt; child[0] = merge(a, b -&gt; child[0]);\n                b -&gt; push();\n                return b;\n            }\n        }\n        void insert(T x) {\n            auto temp = split(root, x);\n            auto l_tr = split(temp.first, x - 1);\n            Node&lt;T&gt; *res;\n            if (l_tr.second == nullptr) {\n                res = new Node(x);\n            } else {\n                l_tr.second -&gt; cnt++;\n                l_tr.second -&gt; push();\n            }\n            Node&lt;T&gt; *l_tr_combined = merge(l_tr.first, l_tr.second == nullptr ? res : l_tr.second);\n            root = merge(l_tr_combined, temp.second);\n        }\n        void seg_rev(int L, int R) {\n            auto less = split(root, L - 1);\n            auto more = split(less.second, R - L + 1);\n            more.first -&gt; rev = true;\n            root = merge(less.first, merge(more.first, more.second));\n        }\n        void print() {\n            print(root);\n        }\n        void print(Node&lt;T&gt;* cur) {\n            if (cur == nullptr) {\n                return;\n            }\n            cur -&gt; check();\n            print(cur -&gt; child[0]);\n            cout &lt;&lt; cur -&gt; val &lt;&lt; \" \";\n            print(cur -&gt; child[1]);\n        }\n    }; // Treap\n}\nusing _Treap::Treap;\n</code></pre>"},{"location":"template/data-structure/persistent/segment-tree/","title":"\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811","text":"\u4f8b\u9898 \u6d1b\u8c37P3919 <p>P3919 \u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 1\uff08\u53ef\u6301\u4e45\u5316\u6570\u7ec4\uff09 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 1000005;\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[N &lt;&lt; 5];\nint tot;\nint a[N];\nint build(int L, int R) {\n    int now = ++tot;\n    if (L == R) {\n        tr[now].sum = a[L];\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    tr[now].Lrt = build(L, mid);\n    tr[now].Rrt = build(mid + 1, R);\n    return now;\n}\nint update(int old, int L, int R, int pos, int k) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    if (L == R) {\n        tr[now].sum = k;\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos, k);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos, k);\n    }\n    return now;\n}\nint query(int old, int L, int R, int pos) {\n    if (L == R) {\n        return tr[old].sum;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        return query(tr[old].Lrt, L, mid, pos);\n    } else {\n        return query(tr[old].Rrt, mid + 1, R, pos);\n    }\n}\nint rt[N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    rt[0] = build(1, n);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int v, op, loc;\n        cin &gt;&gt; v &gt;&gt; op &gt;&gt; loc;\n        if (op == 1) {\n            int value;\n            cin &gt;&gt; value;\n            rt[i] = update(rt[v], 1, n, loc, value);\n        } else {\n            rt[i] = rt[v];\n            cout &lt;&lt; query(rt[i], 1, n, loc) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/persistent/segment-tree/#_2","title":"\u4e3b\u5e2d\u6811","text":""},{"location":"template/data-structure/persistent/segment-tree/#k","title":"\u9759\u6001\u533a\u95f4\u7b2c k \u5c0f","text":"\u4f8b\u9898 <p>P3834 \u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 2 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 200005;\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[N &lt;&lt; 5];\nint tot;\nint a[N];\nint update(int old, int L, int R, int pos) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    tr[now].sum++;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos);\n    }\n    return now;\n}\nint query(int QL, int QR, int L, int R, int pos) {\n    if (L == R) {\n        return L;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int cnt = tr[tr[QR].Lrt].sum - tr[tr[QL].Lrt].sum;\n    if (pos &lt;= cnt) {\n        return query(tr[QL].Lrt, tr[QR].Lrt, L, mid, pos);\n    } else {\n        return query(tr[QL].Rrt, tr[QR].Rrt, mid + 1, R, pos - cnt);\n    }\n}\nint rt[N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx(1, -1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        rt[i] = update(rt[i - 1], 1, n, a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, k;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; k;\n        cout &lt;&lt; idx[query(rt[L - 1], rt[R], 1, n, k)] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/persistent/segment-tree/#_3","title":"\u9759\u6001\u533a\u95f4\u6570\u7684\u6392\u4f4d","text":"\u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 200005;\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[N &lt;&lt; 5];\nint tot;\nint a[N];\nint update(int old, int L, int R, int pos) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    tr[now].sum++;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos);\n    }\n    return now;\n}\nvector&lt;int&gt; idx(1, -1);\nint query(int QL, int QR, int L, int R, int pos) {\n    if (R &lt; pos) {\n        return tr[QR].sum - tr[QL].sum;\n    }\n    if (L == R) {\n        return 0;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int rk = 0;\n    if (pos &gt;= L) {\n        rk += query(tr[QL].Lrt, tr[QR].Lrt, L, mid, pos);\n    }\n    if (pos &gt;= mid + 1) {\n        rk += query(tr[QL].Rrt, tr[QR].Rrt, mid + 1, R, pos);\n    }\n    return rk;\n}\nint rt[N];\narray&lt;int, 3&gt; q[N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, k;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; k;\n        q[i] = {L, R , k};\n        idx.push_back(k);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    int len = idx.size() - 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        q[i][2] = lower_bound(begin(idx), end(idx), q[i][2]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        rt[i] = update(rt[i - 1], 1, len, a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        auto [L, R, k] = q[i];\n        cout &lt;&lt; query(rt[L - 1], rt[R], 1, len, k) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/persistent/segment-tree/#uv","title":"\u9759\u6001\u533a\u95f4[u,v]\u7684\u4e2a\u6570","text":"\u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 200005;\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[N &lt;&lt; 5];\nint tot;\nint a[N];\nint update(int old, int L, int R, int pos) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    tr[now].sum++;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos);\n    }\n    return now;\n}\nint query(int QL, int QR, int L, int R, int VL, int VR) {\n    if (VL &lt;= L &amp;&amp; R &lt;= VR) {\n        return tr[QR].sum - tr[QL].sum;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int res = 0;\n    if (VL &lt;= mid) {\n        res += query(tr[QL].Lrt, tr[QR].Lrt, L, mid, VL, VR);\n    }\n    if (VR &gt;= mid + 1) {\n        res += query(tr[QL].Rrt, tr[QR].Rrt, mid + 1, R, VL, VR);\n    }\n    return res;\n}\nint rt[N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        rt[i] = update(rt[i - 1], 1, n, a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, VL, VR;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; VL &gt;&gt; VR;\n        cout &lt;&lt; query(rt[L - 1], rt[R], 1, n, VL, VR) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/data-structure/persistent/segment-tree/#_4","title":"\u9759\u6001\u533a\u95f4\u989c\u8272\u6570","text":"\u4f8b\u9898 <p>P1972 [SDOI2009] HH\u7684\u9879\u94fe - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 1000005;\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[N &lt;&lt; 5];\nint tot;\nint a[N];\nint update(int old, int L, int R, int pos, int k) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    tr[now].sum += k;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos, k);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos, k);\n    }\n    return now;\n}\nint query(int rt, int L, int R, int pos) {\n    if (L == R) {\n        return tr[rt].sum;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        return query(tr[rt].Lrt, L, mid, pos) + tr[tr[rt].Rrt].sum;\n    }\n    if (pos &gt;= mid + 1) {\n        return query(tr[rt].Rrt, mid + 1, R, pos);\n    }\n}\nint rt[N];\nint last[N];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int temp = rt[i - 1];\n        if (last[a[i]] != 0) {\n            temp = update(rt[i - 1], 1, n, last[a[i]], -1);\n        }\n        rt[i] = update(temp, 1, n, i, 1);\n        last[a[i]] = i;\n    }\n    int m;\n    cin &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        cout &lt;&lt; query(rt[R], 1, n, L) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/default/builtin/","title":"__builtin","text":"\u51fd\u6570 \u63cf\u8ff0 __builtin_ctz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero __builtin_ctzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero long long __builtin_clz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero __builtin_clzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero long long __builtin_popcount(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count __builtin_popcountll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count long long __builtin_parity(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u7684\u5947\u5076\u6027(1, 0) parity __builtin_parityll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u5947\u5076\u6027(1, 0) parity long long __builtin_ffs(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat __builtin_ffsll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat long long __builtin_sqrt(double x) \u8fd4\u56de  \\(\\sqrt {double\\ x}\\)  \u7684\u503c sqrt __builtin_sqrtf(float x) \u8fd4\u56de  \\(\\sqrt {float\\ x}\\)  \u7684\u503c sqrt float"},{"location":"template/default/fast-io/","title":"\u5feb\u8bfb","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; inline void read(T &amp;k) {\n    T x = 0, f = 1; \n    char ch = getchar(); \n    while (ch &lt; '0' || ch &gt; '9') {\n        if (ch == '-') {\n            f = -1;\n        }\n        ch = getchar();\n    }\n    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\n        ch = getchar();\n    }\n    k = x * f;\n}\ntemplate&lt;class T&gt; inline void write(T x) {\n    if (x &lt; 0) {\n        putchar('-'), x = -x;\n    }\n    if (x &gt; 9) {\n        write(x / 10);\n    }\n    putchar(x % 10 + '0');\n}\n</code></pre>"},{"location":"template/default/hash/","title":"\u54c8\u5e0c\u8868\u91cd\u5199\u54c8\u5e0c\u51fd\u6570","text":"\u6a21\u7248 \u6574\u6570pair C++<pre><code>struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ x &gt;&gt; 30) * 0xbf58476d1ce4e5b9;\n        x = (x ^ x &gt;&gt; 27) * 0x94d049bb133111eb;\n        return x ^ x &gt;&gt; 31;\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nunordered_map&lt;int, int, custom_hash&gt; safe_map;\n</code></pre> C++<pre><code>struct pair_hash {\n    template&lt;class T1, class T2&gt;\n    size_t operator() (const pair&lt;T1, T2&gt;&amp; pair) const {\n        return hash&lt;T1&gt;()(pair.first) ^ hash&lt;T2&gt;()(pair.second);\n    }\n};\nunordered_map&lt;pair&lt;int, int&gt;, int, pair_hash&gt; safe_map;\n</code></pre>"},{"location":"template/default/high-accuracy/","title":"\u9ad8\u7cbe\u5ea6","text":"\u6a21\u7248 C++<pre><code>namespace _BigInt {\n    using i64 = long long;\n    vector&lt;int&gt; pow2 = []() -&gt; vector&lt;int&gt; {\n        vector&lt;int&gt; pow2(31);\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= 30 ; i++) {\n            pow2[i] = pow2[i - 1] * 2;\n        }\n        return pow2;\n    }();\n    struct BigInt {\n        static const int BASE = 100000000;\n        static const int WIDTH = 8;\n        bool sign = true;\n        vector&lt;int&gt; num;\n        BigInt() : num(1), sign(true) {}\n        BigInt(int x) {\n            if (x &lt; 0) {\n                x = -x;\n                sign = false;\n            }\n            do {\n                num.push_back(x % BASE);\n                x /= BASE;\n            } while (x);\n            check(*this);\n        }\n        BigInt(i64 x) {\n            if (x &lt; 0) {\n                x = -x;\n                sign = false;\n            }\n            do {\n                num.push_back(x % BASE);\n                x /= BASE;\n            } while (x);\n            check(*this);\n        }\n        BigInt(string x) {\n            reverse(begin(x), end(x));\n            if (x.back() == '-') {\n                sign = false;\n                x.pop_back();\n            }\n            int len = x.size();\n            len = (len + WIDTH - 1) / WIDTH;\n            x.resize(len * WIDTH, '0');\n            for (int i = 0 ; i &lt; len ; i++) {\n                int res = 0;\n                for (int j = (i + 1) * WIDTH - 1 ; j &gt;= i * WIDTH ; j--) {\n                    res = res * 10 + (x[j] - '0');\n                }\n                num.push_back(res);\n            }\n            check(*this);\n        }\n        friend BigInt operator+(BigInt x, BigInt y) {\n            if (x.sign != y.sign) {\n                x.sign = !x.sign;\n                return x - y;\n            };\n            int len = max(x.size(), y.size());\n            x.resize(len); y.resize(len);\n            int k = 0;\n            for (int i = 0 ; i &lt; len ; i++) {\n                x[i] += y[i] + k;\n                k = 0;\n                if (x[i] &gt;= BASE) {\n                    k = 1;\n                    x[i] -= BASE;\n                }\n            }\n            if (k) x.push_back(k);\n            return check(x), x;\n        }\n        friend BigInt operator-(BigInt x, BigInt y) {\n            if (x.sign != y.sign) {\n                x.sign = !x.sign;\n                return x + y;\n            }\n            if (abs_equal(x, y) == -1) {\n                swap(x, y);\n                x.sign = !x.sign;\n            }\n            int len = max(x.size(), y.size());\n            x.resize(len); y.resize(len);\n            int k = 0;\n            for (int i = 0 ; i &lt; len ; i++) {\n                x[i] -= y[i] + k;\n                k = 0;\n                if (x[i] &lt; 0) {\n                    x[i] += BASE;\n                    k = 1;\n                }\n            }\n            while (x.size() &gt; 1 &amp;&amp; x.back() == 0) {\n                x.pop_back();\n            }\n            return check(x), x;\n        }\n        friend BigInt operator*(BigInt x, BigInt y) {\n            int lenx = x.size(), leny = y.size();\n            BigInt res; res.resize(lenx + leny);\n            for (int i = 0 ; i &lt; lenx ; i++) {\n                for (int j = 0 ; j &lt; leny ; j++) {\n                    i64 k = (i64) x[i] * y[j] + res[i + j];\n                    res[i + j] = k % BASE;\n                    res[i + j + 1] += k / BASE;\n                }\n            }\n            while (res.size() &gt; 1 &amp;&amp; res.back() == 0) {\n                res.pop_back();\n            }\n            return res.sign = x.sign == y.sign, check(res), res;\n        }\n        friend BigInt operator/(BigInt x, BigInt y) {\n            return Div(x, y).first;\n        }\n        friend BigInt operator%(BigInt x, BigInt y) {\n            return Div(x, y).second;\n        }\n        friend bool operator&lt;(const BigInt &amp;x, const BigInt &amp;y) {\n            if (x.sign != y.sign) {\n                return x.sign == false;\n            }\n            int k = abs_equal(x, y);\n            return (x.sign == true &amp;&amp; k == -1) || (x.sign == false &amp;&amp; k == 1);\n        }\n        friend bool operator&gt;(const BigInt &amp;x, const BigInt &amp;y) {\n            if (x.sign != y.sign) {\n                return x.sign == true;\n            }\n            int k = abs_equal(x, y);\n            return (x.sign == true &amp;&amp; k == 1) || (x.sign == false &amp;&amp; k == -1);\n        }\n        friend bool operator!=(const BigInt &amp;x, const BigInt &amp;y) {\n            return !(x == y);\n        }\n        friend bool operator==(const BigInt &amp;x, const BigInt &amp;y) {\n            int lenx = x.size(), leny = y.size();\n            if (lenx == leny) {\n                for (int i = lenx - 1 ; i &gt;= 0 ; i--) {\n                    if (x[i] == y[i]) continue;\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n        friend BigInt&amp; operator+=(BigInt &amp;x, BigInt y) {\n            return x = x + y;\n        }\n        friend BigInt&amp; operator-=(BigInt &amp;x, BigInt y) {\n            return x = x - y;\n        }\n        friend BigInt&amp; operator*=(BigInt &amp;x, BigInt y) {\n            return x = x * y;\n        }\n        friend BigInt&amp; operator/=(BigInt &amp;x, BigInt y) {\n            return x = x / y;\n        }\n        friend BigInt&amp; operator%=(BigInt &amp;x, BigInt y) {\n            return x = x % y;\n        }\n        static pair&lt;BigInt, BigInt&gt; Div(BigInt x, BigInt y) {\n            int k = abs_equal(x, y);\n            if (k == 0) {\n                return {1, 0};\n            }\n            if (k == -1) {\n                return {0, x};\n            }\n            int len = x.size() - y.size() + 1;\n            BigInt q; q.resize(len);\n            BigInt r = x;\n            int z = __lg(BASE);\n            for (int i = len - 1 ; i &gt;= 0 ; i--) {\n                BigInt t1; t1.resize(y.size() + i);\n                for (int j = 0 ; j &lt; (int) y.size() ; j++) {\n                    t1[j + i] = y[j];\n                }\n                for (int j = z ; j &gt;= 0 ; j--) {\n                    BigInt t2 = t1 * pow2[j];\n                    if (abs_equal(r, t2) &gt;= 0) {\n                        q[i] += pow2[j];\n                        r -= t2;\n                    }\n                }\n            }\n            while (q.size() &gt; 1 &amp;&amp; q.back() == 0) {\n                q.pop_back();\n            }\n            check(q); check(r);\n            return {q, r};\n        }\n        // \u6bd4\u8f83\u7edd\u5bf9\u503c\u5927\u5c0f\n        // -1 (x &lt; y)\n        // 0 (x = y)\n        // 1 (x &gt; y)\n        static int abs_equal(const BigInt &amp;x, const BigInt &amp;y) {\n            int lenx = x.size(), leny = y.size();\n            if (lenx == leny) {\n                for (int i = lenx - 1 ; i &gt;= 0 ; i--) {\n                    if (x[i] == y[i]) continue;\n                    return x[i] &lt; y[i] ? -1 : 1;\n                }\n                return 0;\n            }\n            return lenx &lt; leny ? -1 : 1;\n        }\n        static void check(BigInt &amp;x) {\n            if (x.size() == 1 &amp;&amp; x.back() == 0) {\n                x.sign = true;\n            }\n        }\n        void print() const {\n            if (sign == false) cout &lt;&lt; \"-\";\n            cout &lt;&lt; num.back();\n            for (int i = (int) num.size() - 2 ; i &gt;= 0 ; i--) {\n                cout &lt;&lt; setfill('0') &lt;&lt; setw(WIDTH) &lt;&lt; num[i];\n            }\n        }\n        int&amp; back() {\n            return num.back();\n        }\n        void pop_back() {\n            num.pop_back();\n        }\n        void push_back(int x) {\n            num.push_back(x);\n        }\n        void resize(int len) {\n            return num.resize(len);\n        }\n        int size() const {\n            return num.size();\n        }\n        int&amp; operator[](int pos) {\n            return num[pos];\n        }\n        int operator[](int pos) const {\n            return num[pos];\n        }\n        friend istream&amp; operator&gt;&gt;(istream &amp;is, BigInt &amp;x) {\n            string str;\n            is &gt;&gt; str;\n            return x = BigInt(str), is;\n        }\n        friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const BigInt &amp;x) {\n            return x.print(), os;\n        }\n    }; // BigInt\n}\nusing _BigInt::BigInt;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1932 <p>P1932 A+B A-B A*B A/B A%B Problem - \u6d1b\u8c37</p>"},{"location":"template/default/mod-int/","title":"ModInt","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; constexpr T qpow(T a, long long b) {\n    T res = 1;\n    while (b) {\n        if (b &amp; 1) res *= a;\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate &lt;class T&gt; struct _MInt {\n    T value;\n    constexpr _MInt() : value() {}\n    constexpr _MInt(T value) : value(normal(value % getMod())) {}\n    static int _mod;\n    constexpr static int getMod() {\n        return _mod;\n    }\n    constexpr T normal(T x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr _MInt inv() const {\n        return qpow(*this, getMod() - 2);\n    }\n    constexpr _MInt operator-() const {\n        _MInt res;\n        res.value = normal(getMod() - value);\n        return res;\n    }\n    constexpr _MInt &amp;operator*=(_MInt rhs) &amp; {\n        if (is_same&lt;T, long long&gt;::value) {\n            value = (__int128) value * rhs.x % getMod();\n        } else {\n            value = (long long) value * rhs.x % getMod();\n        }\n        return *this;\n    }\n    constexpr _MInt &amp;operator+=(_MInt rhs) &amp; {\n        value = normal(value + rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator-=(_MInt rhs) &amp; {\n        value = normal(value - rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator/=(_MInt rhs) &amp; {\n        return *this *= rhs.inv(); \n    }\n    friend constexpr _MInt operator*(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator+(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr _MInt operator-(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator/(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr istream &amp;operator&gt;&gt;(istream &amp;is, _MInt &amp;a) {\n        long long v;\n        is &gt;&gt; v;\n        a = _MInt(v);\n        return is;\n    }\n    friend constexpr ostream &amp;operator&lt;&lt;(ostream &amp;os, const _MInt &amp;a) {\n        return os &lt;&lt; a.value;\n    }\n    friend constexpr bool operator==(_MInt lhs, _MInt rhs) {\n        return lhs.value == rhs.value;\n    }\n    friend constexpr bool operator!=(_MInt lhs, _MInt rhs) {\n        return lhs.value != rhs.value;\n    }\n};\ntemplate &lt;&gt; int _MInt&lt;int&gt;::_mod = 998244353;\nusing MInt = _MInt&lt;int&gt;;\n</code></pre>"},{"location":"template/default/sort/","title":"\u6392\u5e8f","text":"\u6a21\u7248 \u5feb\u901f\u6392\u5e8f\\(O(n\\log n)\\)\u5f52\u5e76\u6392\u5e8f \\(O(n\\log n)\\)\u63d2\u5165\u6392\u5e8f \\(O(n^2)\\)\u5192\u6ce1\u6392\u5e8f \\(O(n^2)\\)\u9009\u62e9\u6392\u5e8f \\(O(n^2)\\)\u5e0c\u5c14\u6392\u5e8f \\(O(n\\log n)\\) C++<pre><code>void quickSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    int i = L - 1, j = R + 1;\n    int k = a[L + R &gt;&gt; 1];\n    while (i &lt; j) {\n        do i++; while (a[i] &lt; k);\n        do j--; while (a[j] &gt; k);\n        if (i &lt; j) swap(a[i], a[j]);\n    }\n    quickSort(a, L, j);\n    quickSort(a, j + 1, R);\n}\n</code></pre> C++<pre><code>int cnt = 0;\nvoid mergeSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    vector&lt;int&gt; b(R - L + 1);\n    int mid = L + R &gt;&gt; 1;\n    mergeSort(a, L, mid);\n    mergeSort(a, mid + 1, R);\n    int i = L, j = mid + 1, k = 0;\n    while (i &lt;= mid &amp;&amp; j &lt;= R) {\n        if (a[i] &lt;= a[j]) {\n            b[k++] = a[i++];\n        } else {\n            b[k++] = a[j++];\n            cnt += mid - i + 1;\n        }\n    }\n    while (i &lt;= mid) b[k++] = a[i++];\n    while (j &lt;= R) {\n        b[k++] = a[j++];\n        cnt += mid - i + 1;\n    }\n    for (int i = L ; i &lt;= R ; i++) a[i] = b[i - L];\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L + 1 ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - 1;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + 1] = a[j];\n            --j;\n        }\n        a[j + 1] = v;\n    }\n}\n</code></pre> C++<pre><code>void bubbleSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt;= R ; i++) {\n        for (int j = R ; j &gt; i ; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                swap(a[j - 1], a[j]);\n            }\n        }\n    }\n}\n</code></pre> C++<pre><code>void selectSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt; R ; i++) {\n        int t = i;\n        for (int j = i ; j &lt;= R ; j++) {\n            if (a[j] &lt; a[t]) {\n                t = j;\n            }\n        }\n        swap(a[t], a[i]);\n    }\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R, int g) {\n    for (int i = L + g ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - g;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + g] = a[j];\n            j -= g;\n        }\n        a[j + g] = v;\n    }\n}\nvoid shellSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    vector&lt;int&gt; g;\n    for (int h = 1 ; h &lt;= R ; h = 3 * h + 1 ) g.emplace_back(h);\n    reverse(begin(g), end(g));\n    for (auto &amp;i : g) insertSort(a, L, R, i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1177\u6d1b\u8c37U232725 <p>P1177 \u3010\u6a21\u677f\u3011\u6392\u5e8f - \u6d1b\u8c37</p> <p>U232725 \u3010\u6a21\u677f\u3011\u5f52\u5e76\u6392\u5e8f - \u6d1b\u8c37</p>"},{"location":"template/dynamic-programming/digit/","title":"\u6570\u4f4ddp","text":"\u4f8b\u9898 CF1811ECF535B\u725b\u5ba262880L\u6d1b\u8c37P2602ABC317F <p>Problem - E - Codeforces</p> <p>\u6c42\u7b2c \\(k\\) \u4e2a\u6570\u4f4d\u4e0d\u5305\u542b \\(4\\) \u7684\u6b63\u6574\u6570\u3002</p> <p>\u4e8c\u5206\u7b54\u6848\uff0c\u4f7f\u7528\u6570\u4f4ddp\u7edf\u8ba1 \\([1,mid]\\) \u5305\u542b\u7684\u4e2a\u6570\u5373\u53ef\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nlong long dp[20];\nint num[20];\nlong long dfs(int x, bool lim) {\n    if (x == -1) return 1LL;\n    if (lim == false &amp;&amp; dp[x] != -1) {\n        return dp[x];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        if (i == 4) continue; // \u542b\u6709 4\n        res += dfs(x - 1, lim &amp;&amp; i == mx);\n    }\n    if (lim == false) dp[x] = res;\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        dp[cnt] = -1;\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, true);\n}\nvoid solve() {\n    long long x;\n    cin &gt;&gt; x;\n    long long L = 1, R = 1e18;\n    while (L &lt; R) {\n        long long mid = L + R &gt;&gt; 1;\n        if (get(mid) &gt;= x + 1) {\n            R = mid;\n        } else {\n            L = mid + 1;\n        }\n    }\n    cout &lt;&lt; L &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>Problem - B - Codeforces</p> <p>\u7ed9\u51fa\u4e00\u4e2a\u53ea\u5305\u542b4\u548c7\u7684\u6570\u5b57\uff0c\u95ee\u5b83\u662f\u7b2c\u51e0\u4e2a\u53ea\u5305\u542b4\u548c7\u7684\u6b63\u6574\u6570\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nlong long dp[20];\nint num[20];\nlong long dfs(int x, bool lim) {\n    if (x == -1) return 1LL;\n    if (lim == false &amp;&amp; dp[x] != -1) {\n        return dp[x];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        if (!(lim &amp;&amp; i == 0) &amp;&amp; i != 4 &amp;&amp; i != 7) continue; // \u4e0d\u662f 4 \u6216 7 \u6216\u8005\u4e0d\u662f\u524d\u5bfc 0\n        res += dfs(x - 1, lim &amp;&amp; i == mx);\n    }\n    if (lim == false) dp[x] = res;\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        dp[cnt] = -1;\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, true);\n}\nint main() {\n    long long n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; get(n) - 1;\n    return 0;\n}\n</code></pre> <p>L-7\u662f\u5927\u5956\uff1f_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u56db\uff09\u573a\uff1a\u6cb3\u5357\u5927\u5b66</p> <p>\u95ee \\([L,R]\\) \u6570\u4f4d\u4e2d\u6bcf\u5b58\u5728\u4e00\u4e2a \\(7\\)\uff0c\u8d21\u732e \\(3\\)\uff0c\u6570\u4f4d\u4e2d\u6bcf\u5b58\u5728\u4e00\u4e2a \\(5\\)\uff0c\u8d21\u732e \\(1\\)\uff0c\u5b58\u5728\u8fde\u7eed\u7684 \\(7\\) \u4e2a \\(7\\)\uff0c\u8d21\u732e \\(300\\)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nlong long dp[20][2][20][20][20];\nint num[20];\nlong long dfs(int x, bool has, int len7, int cnt5, int cnt7, bool lim) {\n    has |= len7 &gt;= 7;\n    if (x == -1) return cnt5 + cnt7 * 3 + 300 * has;\n    if (lim == false &amp;&amp; dp[x][has][len7][cnt5][cnt7] != -1) {\n        return dp[x][has][len7][cnt5][cnt7];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        res += dfs(\n            x - 1, \n            has, \n            i == 7 ? len7 + 1 : 0, \n            cnt5 + (i == 5), \n            cnt7 + (i == 7),\n            lim &amp;&amp; i == mx\n        );\n    }\n    if (lim == false) dp[x][has][len7][cnt5][cnt7] = res;\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, false, 0, 0, 0, true);\n}\nvoid solve() {\n    long long L, R;\n    cin &gt;&gt; L &gt;&gt; R;\n    cout &lt;&lt; get(R) - get(L - 1) &lt;&lt; \"\\n\";\n}\nint main() {\n    memset(dp, -1, sizeof dp);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>P2602 [ZJOI2010] \u6570\u5b57\u8ba1\u6570 - \u6d1b\u8c37</p> <p>\u5bf9\u6bcf\u4e2a\u6570\u5b57\u8fdb\u884c \\(2\\) \u6b21\u6570\u4f4ddp\u5373\u53ef\u3002\\(0\\) \u8981\u7279\u5224\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nlong long dp[20][20][2];\nint num[20];\nint d;\nlong long dfs(int x, int cnt, bool lead0, bool lim) {\n    if (x == -1) return cnt;\n    if (lead0 == false &amp;&amp; lim == false &amp;&amp; dp[x][cnt][d != 0] != -1) {\n        return dp[x][cnt][d != 0];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        int temp = cnt + (i == d);\n        if (lead0 &amp;&amp; d == 0 &amp;&amp; i == 0) { // \u7edf\u8ba1\u6570\u5b57\u4e3a 0, \u542b\u6709\u524d\u5bfc 0 \u6ca1\u6709\u8d21\u732e\u3002\n            temp = 0;\n        }\n        res += dfs(x - 1, temp, lead0 &amp;&amp; i == 0, lim &amp;&amp; i == mx);\n    }\n    if (lead0 == false &amp;&amp; lim == false) dp[x][cnt][d != 0] = res;\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, 0, true, true);\n}\nint main() {\n    long long L, R;\n    cin &gt;&gt; L &gt;&gt; R;\n    for (int i = 0 ; i &lt; 10 ; i++) {\n        memset(dp, -1, sizeof dp);\n        d = i;\n        cout &lt;&lt; get(R) - get(L - 1) &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>F - Nim</p> <p>\u7ed9\u5b9a\u56db\u4e2a\u6b63\u6574\u6570 \\(N,A_1,A_2,A_3\\)\uff0c\u8bd5\u6c42\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u7684\u4e09\u5143\u7ec4 \\((X_1,X_2,X_3)\\) \u7684\u5bf9\u6570\uff0c\u5bf9 \\(998244353\\) \u53d6\u6a21\u3002</p> <p>\\(1\\leq X_i\\leq N\\)</p> <p>\\(X_i \\% A_i = 0\\)</p> <p>\\((X_1\\oplus X_2)\\oplus x_3=0\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint A1, A2, A3;\nlong long dp[63][10][10][10][2][2][2][2][2][2];\nint num[63];\nconst long long mod = 998244353;\nlong long dfs(int x, int p1, int p2, int p3, bool lim1, bool lim2, bool lim3, bool x1, bool x2, bool x3) {\n    if (x == -1) {\n        return (!p1) &amp;&amp; (!p2) &amp;&amp; (!p3) &amp;&amp; x1 &amp;&amp; x2 &amp;&amp; x3;\n    }\n    if (dp[x][p1][p2][p3][lim1][lim2][lim3][x1][x2][x3] != -1) {\n        return dp[x][p1][p2][p3][lim1][lim2][lim3][x1][x2][x3];\n    }\n    int mx1 = lim1 ? num[x] : 1;\n    int mx2 = lim2 ? num[x] : 1;\n    int mx3 = lim3 ? num[x] : 1;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx1 ; i++) {\n        for (int j = 0 ; j &lt;= mx2 ; j++) {\n            if ((i ^ j) &lt;= mx3) {\n                int k = i ^ j;\n                res = (res + dfs(\n                    x - 1,\n                    (p1 * 2 + i) % A1,\n                    (p2 * 2 + j) % A2,\n                    (p3 * 2 + k) % A3,\n                    lim1 &amp;&amp; i == num[x],\n                    lim2 &amp;&amp; j == num[x],\n                    lim3 &amp;&amp; k == num[x],\n                    x1 | i,\n                    x2 | j,\n                    x3 | k\n                )) % mod;\n            }\n        }\n    }\n    return dp[x][p1][p2][p3][lim1][lim2][lim3][x1][x2][x3] = res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        num[cnt++] = x % 2;\n        x /= 2;\n    }\n    return dfs(cnt - 1, 0, 0, 0, true, true, true, false, false, false);\n}\nint main() {\n    memset(dp, -1, sizeof dp);\n    long long n;\n    cin &gt;&gt; n &gt;&gt; A1 &gt;&gt; A2 &gt;&gt; A3;\n    cout &lt;&lt; get(n);\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P8766CF104053M <p>P8766 [\u84dd\u6865\u676f 2021 \u56fd AB] \u5f02\u6216\u4e09\u89d2 - \u6d1b\u8c37</p> <p>\u56e0\u4e3a \\(a\\oplus b\\oplus c=0\\)\uff0c\u6240\u4ee5 \\(a=b\\oplus c\\)\u3002</p> <p>\u56e0\u4e3a\u8981\u6784\u6210\u4e09\u89d2\u5f62\uff0c\u4ee4 \\(a\\) \u4e3a\u6700\u5927\u7684\u8fb9\uff0c\u5219\u6709 \\(a&lt; b+c\\)\uff0c\u5373 \\(b\\oplus c&lt; b+c\\)</p> <p>\u6613\u77e5\u5bf9\u4e8e\u4efb\u610f \\(b,c\\) \u6709 \\(b\\oplus c&lt; b+c\\)\u3002</p> <p>\u5982\u679c\u60f3\u8981 \\(b\\oplus c&lt; b+c\\)\uff0c\u5219 \\(b,c\\) \u4e8c\u8fdb\u5236\u67d0\u4e00\u4f4d\u4e00\u5b9a\u90fd\u662f \\(1\\)\u3002</p> <p>\u6240\u4ee5\u6570\u4f4ddp\u5373\u53ef\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nlong long dp[31][2][2][2][2];\nint num[31];\nlong long dfs(int x, bool lim1, bool lim2, bool lim3, bool flag) {\n    if (x == -1) {\n        return flag;\n    }\n    if (dp[x][lim1][lim2][lim3][flag] != -1) {\n        return dp[x][lim1][lim2][lim3][flag];\n    }\n    int mx1 = lim1 ? num[x] : 1;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx1 ; i++) {\n        int mx2 = lim2 ? i : 1;\n        int mx3 = lim3 ? i : 1;\n        for (int j = 0 ; j &lt;= mx2 ; j++) {\n            int k = (i ^ j);\n            if (k &lt;= mx3) {\n                res += dfs(\n                    x - 1, \n                    lim1 &amp;&amp; i == num[x], \n                    lim2 &amp;&amp; j == i, \n                    lim3 &amp;&amp; k == i,\n                    flag || (j + k == 2)\n                );\n            }\n        }\n    }\n    dp[x][lim1][lim2][lim3][flag] = res;\n    return res;\n}\nlong long get(int x) {\n    int cnt = 0;\n    while (x) {\n        num[cnt++] = x % 2;\n        x /= 2;\n    }\n    return dfs(cnt - 1, true, true, true, false) * 3;\n}\nvoid solve() {\n    memset(dp, -1, sizeof dp);\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; get(n) &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>Problem - M - Codeforces</p> <p>\u6570\u4f4ddp\u679a\u4e3e\u4e8c\u8fdb\u5236\u768401, \u5b58s\u4e3a\u6709\u591a\u5c11\u4f4d\u662flim, \u5b58sum\u8868\u793a\u5bf9\u6570\u5217\u4e24\u4e24\u4e4b\u95f4\u7684\u5f02\u6216\u548c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();//\nconst i64 P = 1000000007;\ni64 c[62][62];\ni64 C(int n, int m) {\n    if (n &lt; m &amp;&amp; m &lt; 0) return 0;\n    return c[n][m];\n}\ni64 n, m;\nint k;\nint num[62];\nmap&lt;i64, i64&gt; dp[62][62];\ni64 dfs(int x, int s = k, i64 sum = 0) {\n    if (sum &gt; n) return 0LL;\n    if (x == -1) {\n        return sum == n;\n    }\n    int k1 = k / 2, k2 = k - k1;\n    if (sum + ((1LL &lt;&lt; x + 1) - 1) * k1 * k2 &lt; n) {\n        return 0LL;\n    }\n    if (dp[x][s].count(sum)) {\n        return dp[x][s][sum];\n    }\n    i64 res = 0;\n    if (num[x] == 1) {\n        for (int i = 0 ; i &lt;= s ; i++) {\n            for (int j = 0 ; j &lt;= k - s ; j++) {\n                res = (res + C(s, i) * C(k - s, j) % P * dfs(x - 1, i, sum + (1LL &lt;&lt; x) * (k - i - j) * (i + j)) % P) % P;\n            }\n        }\n    } else {\n        for (int i = 0 ; i &lt;= k - s ; i++) {\n            res = (res + C(k - s, i) * dfs(x - 1, s, sum + (1LL &lt;&lt; x) * (k - i) * i) % P) % P;\n        }\n    }\n    dp[x][s][sum] = res;\n    return res;\n}\ni64 get(i64 x) {\n    int cnt = 0;\n    do {\n        num[cnt++] = x % 2;\n        x /= 2;\n    } while (x);\n    return dfs(cnt - 1);\n}\nint main() {\n    c[0][0] = 1;\n    for (int i = 1 ; i &lt; 62 ; i++) {\n        c[i][0] = 1;\n        for (int j = 1 ; j &lt;= i ; j++) {\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;\n        }\n    }\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    cout &lt;&lt; get(m);\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/knapsack/","title":"\u80cc\u5305","text":""},{"location":"template/dynamic-programming/knapsack/#0-1","title":"0-1\u80cc\u5305","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - w[i]] + d[i]);\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + d[i - 1]);\n        }\n    }\n    cout &lt;&lt; dp[N][M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P2871(\u6c42\u6700\u4f18\u503c)AcWing278(\u6c42\u4f53\u79ef\u6070\u597d\u4e3aM\u7684\u65b9\u6848\u6570)AcWing11(\u6c42\u6700\u4f18\u65b9\u6848\u6570)AcWing12(\u6c42\u5177\u4f53\u65b9\u6848) <p>P2871 [USACO07DEC] Charm Bracelet S - \u6d1b\u8c37</p> <p>278. \u6570\u5b57\u7ec4\u5408 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; v[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    dp[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= v[i] ; j--) {\n            dp[j] = dp[j] + dp[j - v[i]];\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>11. \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst long long mod = 1000000007;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;long long&gt; dp(M + 1), g(M + 1);\n    g[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            long long k;\n            long long temp = dp[j - w[i]] + v[i];\n            if (dp[j] &lt; temp) {\n                g[j] = g[j - w[i]];\n                dp[j] = temp;\n            } else if (dp[j] == temp) {\n                g[j] = (g[j] + g[j - w[i]]) % mod;\n            }\n        }\n    }\n    long long res = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        res = max(res, dp[i]);\n    }\n    long long ans = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        if (dp[i] == res) {\n            ans = (ans + g[i]) % mod;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>12. \u80cc\u5305\u95ee\u9898\u6c42\u5177\u4f53\u65b9\u6848 - AcWing</p> \u7f16\u53f7\u6b63\u5e8f\u7f16\u53f7\u9006\u5e8f C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = N - 1 ; i &gt;= 0 ; i--) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i + 1][j];\n        }\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + v[i]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = 0, j = M ; i &lt; N ; i++) {\n        if (j &gt;= w[i] &amp;&amp; dp[i][j] == dp[i + 1][j - w[i]] + v[i]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = N - 1, j = M ; i &gt;= 0 ; i--) {\n        if (j &gt;= w[i] &amp;&amp; dp[i + 1][j] - v[i] == dp[i][j - w[i]]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/knapsack/#_2","title":"\u5b8c\u5168\u80cc\u5305","text":"\u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; w(n), v(n), dp(m + 1);\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = w[i] ; j &lt;= m ; j++) {\n            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n        }\n    }\n    cout &lt;&lt; dp[m];\n    return 0;\n}\n</code></pre> \u4f8b\u9898 AcWing3(\u6c42\u6700\u4f18\u503c) <p>3. \u5b8c\u5168\u80cc\u5305\u95ee\u9898 - AcWing</p>"},{"location":"template/dynamic-programming/knapsack/#_3","title":"\u591a\u91cd\u80cc\u5305","text":"\u6a21\u7248 \u4e8c\u8fdb\u5236\u4f18\u5316\u5355\u8c03\u961f\u5217\u4f18\u5316 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n), w(n), s(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    }\n    vector&lt;long long&gt; nv, nw;\n    for (int i = 0 ; i &lt; n ; i++) {\n        long long temp = 1;\n        long long k = s[i];\n        while (k &gt; temp) {\n            k -= temp;\n            nv.emplace_back(v[i] * temp);\n            nw.emplace_back(w[i] * temp);\n            temp &lt;&lt;= 1;\n        }\n        if (k) {\n            nv.emplace_back(v[i] * k);\n            nw.emplace_back(w[i] * k);\n        }\n    }\n    vector&lt;long long&gt; dp(m + 1);\n    int len = nv.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        for (int j = m ; j &gt;= nw[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - nw[i]] + nv[i]);\n        }\n    }\n    cout &lt;&lt; dp[m] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint q[1000005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n), w(n), s(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(2, vector&lt;long long&gt;(m + 1));\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; w[i] ; j++) {\n            int L = 0, R = -1;\n            for (int k = j ; k &lt;= m ; k += w[i]) {\n                while (L &lt;= R &amp;&amp; k - 1LL * s[i] * w[i] &gt; q[L]) {\n                    L++;\n                }\n                while (L &lt;= R &amp;&amp; dp[i &amp; 1][q[R]] + (k - q[R]) / w[i] * v[i] &lt;= dp[i &amp; 1][k]) {\n                    R--;\n                }\n                q[++R] = k;\n                dp[i &amp; 1 ^ 1][k] = dp[i &amp; 1][q[L]] + (k - q[L]) / w[i] * v[i];\n            }\n        }\n    }\n    cout &lt;&lt; dp[n &amp; 1][m] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 AcWing5(\u4e8c\u8fdb\u5236\u4f18\u5316)AcWing6(\u5355\u8c03\u961f\u5217\u4f18\u5316) <p>5. \u591a\u91cd\u80cc\u5305\u95ee\u9898 II - AcWing</p> <p>6. \u591a\u91cd\u80cc\u5305\u95ee\u9898 III - AcWing</p>"},{"location":"template/dynamic-programming/knapsack/#_4","title":"\u4e8c\u7ef4\u8d39\u7528\u80cc\u5305","text":"<p>\u540c 0-1 \u80cc\u5305</p> \u4f8b\u9898 \u6d1b\u8c37P1855 <p>P1855 \u69a8\u53d6kkksc03 - \u6d1b\u8c37</p>"},{"location":"template/dynamic-programming/knapsack/#_5","title":"\u5206\u7ec4\u80cc\u5305","text":"\u4f8b\u9898 \u6d1b\u8c37P1757 <p>P1757 \u901a\u5929\u4e4b\u5206\u7ec4\u80cc\u5305 - \u6d1b\u8c37</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; M &gt;&gt; N;\n    map&lt;int, vector&lt;int&gt;&gt; v, w;\n    for (int i = 0 ; i &lt; N ; i++) {\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        w[z].emplace_back(x);\n        v[z].emplace_back(y);\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (auto&amp; [g, ww] : w) {\n        auto&amp; vv = v[g];\n        for (int i = M ; i &gt;= 0 ; i--) {\n            int len = ww.size();\n            for (int j = 0 ; j &lt; len ; j++) {\n                if (i &gt;= ww[j]) {\n                    dp[i] = max(dp[i], dp[i - ww[j]] + vv[j]);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[M];\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/knapsack/#k","title":"\u591a\u4eba\u80cc\u5305(k\u4f18\u89e3)","text":"\u4f8b\u9898 \u6d1b\u8c37P1858 <p>P1858 \u591a\u4eba\u80cc\u5305 - \u6d1b\u8c37</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int k, m, n;\n    cin &gt;&gt; k &gt;&gt; m &gt;&gt; n;\n    vector&lt;int&gt; w(n), v(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(m + 1, 0x7fffffff + 1));\n    vector&lt;int&gt; re(k);\n    dp[0][0] = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = m ; j &gt;= w[i] ; j--) {\n            int a = 0, b = 0, t = 0;\n            while (t &lt; k) {\n                if (dp[a][j] &gt;= dp[b][j - w[i]] + v[i]) {\n                    re[t++] = dp[a++][j];\n                } else {\n                    re[t++] = dp[b++][j - w[i]] + v[i];\n                }\n            }\n            for (int L = 0 ; L &lt; k ; L++) {\n                dp[L][j] = re[L];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; k ; i++) ans += dp[i][m];\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/longest-common-subsequence/","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217","text":"<p>P1439 \u3010\u6a21\u677f\u3011\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 - \u6d1b\u8c37</p> <p>#6564. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 - LibreOJ</p> \u6a21\u7248 dp \\(O(n^2)\\)\u4e8c\u5206 \\(O(n*\\log n)\\)(\u4ec5\u9002\u7528\u4e8e\u6392\u5217)bitset \\(O(n*\\log n)\\) <p>\\(dp[i][j]\\) \u8868\u793a\u4ee5 \\(a[i]\\) \u548c \\(b[j]\\) \u7ed3\u5c3e\u7684\u6700\u957f\u957f\u5ea6</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 5005;\nint a[N], b[N];\nint dp[N][N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= m ; j++) {\n            if (a[i] == b[j]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    cout &lt;&lt; dp[n][m] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>\\(a\\) \u5bf9 \\(b\\) \u7684\u4f4d\u7f6e\u505a\u6700\u957f\u4e0d\u4e0b\u964d\u5b50\u5e8f\u5217</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 100005;\nint a[N], b[N];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    map&lt;int, int&gt; pos;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; b[i];\n        pos[b[i]] = i;\n    }\n    vector&lt;int&gt; f(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x = pos[a[i]];\n        auto it = upper_bound(begin(f), end(f), x);\n        if (it == end(f)) {\n            f.emplace_back(x);\n        } else {\n            *it = x;\n        }\n    }\n    cout &lt;&lt; f.size() - 1;\n    return 0;\n}\n</code></pre> <p>bitset \u4f18\u5316</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 70010;\nconst int B = 63;\nconst int M = N / B + 1;\nusing u64 = unsigned long long;\nu64 f[M], bs[N][M];\nint a[N], b[N];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    int k = (n + B - 1) / B;\n    for (int i = 0 ; i &lt; n ; i++) {\n        bs[a[i]][i / B] |= 1ULL &lt;&lt; i % B;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        u64 c = 1;\n        for (int j = 0 ; j &lt; k ; j++) {\n            u64 x = f[j];\n            u64 y = f[j] | bs[b[i]][j];\n            x &lt;&lt;= 1;\n            x += c + ((~y) &amp; ((1ULL &lt;&lt; B) - 1));\n            f[j] = x &amp; y;\n            c = x &gt;&gt; B;\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; k ; i++) {\n        ans += __builtin_popcountll(f[i]);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/longest-increasing-subsequence/","title":"\u6700\u957f\u4e0d\u4e0b\u964d\u5b50\u5e8f\u5217 (LIS)","text":"\u6a21\u7248 <p>\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n*\\log n)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\n    using namespace std;\n    using i64 = long long;\n    int __OneWan_2024 = [](){\n        ios::sync_with_stdio(0);\n        cin.tie(0);\n        cout.tie(0);\n        return 0;\n    }();\n    int main() {\n        int n;\n        cin &gt;&gt; n;\n        vector&lt;int&gt; a(n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            cin &gt;&gt; a[i];\n        }\n        vector&lt;int&gt; f;\n        for (int i = 0 ; i &lt; n ; i++) {\n            auto it = upper_bound(begin(f), end(f), a[i]);\n            if (it == end(f)) {\n                f.push_back(a[i]);\n            } else {\n                *it = a[i];\n            }\n        }\n        cout &lt;&lt; f.size();\n        return 0;\n    }\n</code></pre> \u4f8b\u9898 <p>U290681 \u3010\u6a21\u677f\u3011\u6700\u957f\u4e0d\u4e0b\u964d\u5b50\u5e8f\u5217 - \u6d1b\u8c37</p>"},{"location":"template/dynamic-programming/problem-set/","title":"\u4e60\u9898","text":"\u4e60\u9898\u4e00 CF10D(LCIS) <p>Problem - D - Codeforces</p> <p>\u7ed9\u51fa\u4e24\u4e2a\u5e8f\u5217 \\(a,b\\), \u6c42\u6700\u957f\u516c\u5171\u4e0a\u5347\u5b50\u5e8f\u5217.</p> <p>\\(dp_{i,j}\\) \u8868\u793a \\(a\\) \u4e2d\u524d \\(i\\) \u4e2a, \u4ee5 \\(b_j\\) \u7ed3\u5c3e\u7684\u6700\u957f\u516c\u5171\u4e0a\u5347\u5b50\u5e8f\u5217.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[505], b[505];\nint dp[505][505], pre[505][505];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    int m;\n    cin &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    int ans = 0, x = 0, y = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int res = 0, pos = 0;\n        for (int j = 1 ; j &lt;= m ; j++) {\n            if (a[i] == b[j]) {\n                // \u9009\n                dp[i][j] = res + 1;\n                pre[i][j] = pos;\n                if (ans &lt; dp[i][j]) {\n                    ans = dp[i][j];\n                    x = i;\n                    y = j;\n                }\n            } else {\n                // \u4e0d\u9009\n                dp[i][j] = dp[i - 1][j];\n                if (b[j] &lt; a[i] &amp;&amp; dp[i - 1][j] &gt; res) {\n                    res = dp[i - 1][j];\n                    pos = j;\n                }\n            }\n        }\n    }\n    vector&lt;int&gt; r;\n    while (ans &gt; 1) {\n        r.push_back(b[y]);\n        for (int i = x - 1 ; i &gt;= 1 ; i--) {\n            if (dp[i][pre[x][y]] == ans - 1 &amp;&amp; a[i] == b[pre[x][y]]) {\n                y = pre[x][y];\n                x = i;\n                ans--;\n                break;\n            }\n        }\n    }\n    if (y &gt; 0) {\n        r.push_back(b[y]);\n    }\n    reverse(begin(r), end(r));\n    cout &lt;&lt; r.size() &lt;&lt; \"\\n\";\n    for (auto &amp;x : r) {\n        cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/sum-over-subsets/","title":"SOSDP","text":"\u4f8b\u9898 \u725b\u5ba252244GCF165E <p>G-A Xor B Problem again</p> <p>\u5df2\u77e5\u6570\u7ec4 \\(a\\), \u6c42 \\(a_i\\&amp;a_j=0\\) \u7684\u4e2a\u6570.</p> <p>\u5c06 \\(a\\) \u6309\u4f4d\u53d6\u53cd, \u4f7f\u7528 SOSDP \u7edf\u8ba1\u67d0\u4e8c\u8fdb\u5236\u7684\u8d85\u96c6\u548c.</p> <p>\u7b54\u6848\u4e3a \\(\\sum(f[a_i])\\).</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int B = 20;\nconst int N = 1 &lt;&lt; B;\nconst int M = N - 1;\ni64 f[N];\nint a[100005];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        f[M &amp; ~a[i]]++;\n    }\n    for (int i = 0 ; i &lt; B ; i++) {\n        for (int mask = 0 ; mask &lt;= M ; mask++) {\n            if (mask &amp; 1LL &lt;&lt; i) {\n                f[mask ^ 1LL &lt;&lt; i] += f[mask];\n            }\n        }\n    }\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        ans += f[a[i]];\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>Problem - E - Codeforces</p> <p>\u5df2\u77e5\u6570\u7ec4 \\(a\\), \\(a_i\\&amp;a_j=0\\) \u6c42 \\(a[j]\\).</p> <p>\u53ef\u4ee5\u5bf9\u6240\u6709 \\(~a[i]\\) \u505a SOSDP, \u9884\u5904\u7406\u4e8c\u8fdb\u5236\u5bf9\u5e94\u4f4d\u7f6e\u4e3a1\u4e00\u5b9a\u662f \\(a[i]\\) \u7684\u5b50\u96c6.</p> <p>\u6700\u540e \\(f[a[i]]\\) \u4e3a \\(a[i]\\) \u7684\u7b54\u6848.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int B = 22;\nconst int N = 1 &lt;&lt; B;\nconst int M = N - 1;\ni64 f[N];\nint a[1000005];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        f[M &amp; ~a[i]] = a[i];\n    }\n    for (int i = 0 ; i &lt; B ; i++) {\n        for (int mask = 0 ; mask &lt;= M ; mask++) {\n            if (mask &amp; 1LL &lt;&lt; i) {\n                if (f[mask] != 0) {\n                    f[mask ^ 1LL &lt;&lt; i] = f[mask];\n                }\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (f[a[i]] == 0) f[a[i]] = -1;\n        cout &lt;&lt; f[a[i]] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 ARC100CCF1208FABC349F <p>E - Or Plus Max</p> <p>\u5df2\u77e5\u6570\u7ec4 \\(a\\), \\(i|j\u2264k\\) \u6c42 \\(max(a_i+a_j)\\).</p> <p>\u679a\u4e3e \\(k\\), SOSDP \u5904\u7406 \\(k\\) \u7684\u4e8c\u8fdb\u5236\u5b50\u96c6\u4e2d\u6700\u5927\u503c\u548c\u6b21\u5927\u503c.</p> <p>\u6700\u540e\u5faa\u73af\u8f93\u51fa\u6700\u5927\u503c\u4e0e\u6b21\u5927\u503c\u4e4b\u548c\u5373\u53ef.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int D = 20;\nconst int N = 1 &lt;&lt; D;\nconst int M = N - 1;\narray&lt;int, 2&gt; f[N];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    n = 1 &lt;&lt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; f[i][0];\n        f[i][1] = 0x7fffffff + 1;\n    }\n    for (int i = 0 ; i &lt; D ; i++) {\n        for (int mask = 0 ; mask &lt; n ; mask++) {\n            if (mask &amp; 1LL &lt;&lt; i) {\n                auto x = f[mask];\n                auto y = f[mask ^ 1LL &lt;&lt; i];\n                if (x &lt; y) swap(x, y);\n                x[1] = max(x[1], y[0]);\n                f[mask] = x;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt; n ; i++) {\n        ans = max(ans, f[i][0] + f[i][1]);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u5df2\u77e5 \\(i&lt;j&lt;k\\) \u6c42 \\(max(a_i|(a_j\\&amp;a_k))\\)</p> <p>\u4ee5 \\(f_{i,j}\\) \u8868\u793a\u4e3a \u4e8c\u8fdb\u5236\u4e3a \\(i\\) \u7684\u7b2c \\(j\\) \u5c0f\u7684\u4e0b\u6807, \u56e0\u4e3a\u8fd9\u91cc\u53ea\u6709 \\(a_j\\&amp;a_k\\) \u6240\u4ee5\u53ea\u9700\u8981\u6700\u5c0f\u7684 \\(2\\) \u4e2a\u503c.</p> <p>\u7136\u540e\u505a\u5b50\u96c6\u524d\u7f00\u548c, \u6700\u540e\u4ece\u5c0f\u5230\u5927\u679a\u4e3e \\(i\\), \u518d\u5927\u5230\u5c0f\u679a\u4e3e \\(a_i\\) \u4e8c\u8fdb\u5236\u4e3a \\(0\\) \u7684\u4f4d, \u68c0\u67e5\u662f\u5426\u5b58\u5728 \\(a_j\\&amp;a_k\\) \u7684\u8fd9\u4e00\u4f4d\u4e3a1.</p> <p>\u7b54\u6848\u53d6 \\(max(a_i|(a_j\\&amp;a_k))\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int B = 21;\nconst int N = 1 &lt;&lt; B;\nconst int M = N - 1;\narray&lt;int, 2&gt; f[N];\nint a[N];\nvoid add(int x, int val) {\n    if (val &gt; f[x][0]) {\n        swap(val, f[x][0]);\n    }\n    if (val &gt; f[x][1]) {\n        swap(val, f[x][1]);\n    }\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    fill(f, f + N + 1, array&lt;int, 2&gt;{-1, -1});\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        add(a[i], i);\n    }\n    for (int i = 0 ; i &lt; B ; i++) {\n        for (int mask = 0 ; mask &lt;= M ; mask++) {\n            if (mask &amp; 1LL &lt;&lt; i) {\n                add(mask ^ 1LL &lt;&lt; i, f[mask][0]);\n                add(mask ^ 1LL &lt;&lt; i, f[mask][1]);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n - 2 ; i++) {\n        int res = 0;\n        for (int j = B - 1 ; j &gt;= 0 ; j--) {\n            if (a[i] &amp; 1LL &lt;&lt; j) continue;\n            if (f[res ^ 1LL &lt;&lt; j][1] &gt; i) {\n                res ^= 1LL &lt;&lt; j;\n            }\n            ans = max(ans, res | a[i]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>F - Subsequence LCM (atcoder.jp)</p> <p>\\(n\\) \u4e2a\u6570(\\(1\\leq a_i\\leq10^{16}\\)), \u95ee\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u6ee1\u8db3 \\(lcm=m\\)\u3002</p> <p>\u5148\u8003\u8651 \\(m=1\\)\uff0c\u6b64\u65f6\u7b54\u6848\u4e3a \\(2^k-1\\)\uff0c\\(k\\) \u4e3a \\(a_i=1\\) \u7684\u4e2a\u6570\u3002</p> <p>\u7136\u540e \\(m&gt;1\\)\uff0c\\(10^{16}\\) \u6700\u591a\u662f \\(15\\) \u4e2a\u4e0d\u540c\u7684\u8d28\u6570\u7684\u4e58\u79ef\u3002</p> <p>\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5904\u7406 \\(a_i\\)\u3002</p> <p>\u5982\u679c \\(cnt_j(a_i)=cnt_j(m)\\)\uff0c\u5219\u4e8c\u8fdb\u5236\u7b2c \\(j\\) \u4f4d\u4e3a1\u3002</p> <p>\u5982\u679c \\(cnt_j(a_i)&gt;cnt_j(m)\\)\uff0c\u5219 \\(a_i\\) \u6ca1\u6709\u8d21\u732e\u3002</p> <p>\u5982\u679c \\(cnt_j(a_i)&lt;cnt_j(m)\\)\uff0c\u5219\u8bf4\u660e\u53ef\u9009\u53ef\u4e0d\u9009\uff0c\u4e8c\u8fdb\u5236\u7b2c \\(j\\) \u4f4d\u4e3a0\u3002</p> <p>\u901a\u8fc7 SOSDP \u53ef\u4ee5\u6c42\u5f97\u5b50\u96c6\u524d\u7f00\u548c\uff0c\u7136\u540e\u901a\u8fc7\u5b50\u96c6\u53cd\u6f14\uff0c\u5bb9\u65a5\u51fa\u6070\u597d\u6bcf\u4e2a\u8d28\u56e0\u6570\u90fd\u6ee1\u8db3\u6761\u4ef6\u7684\u4e2a\u6570\u3002</p> \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) res = res * a % P;\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 dp[1 &lt;&lt; 16];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    i64 m;\n    cin &gt;&gt; m;\n    vector&lt;i64&gt; a;\n    vector&lt;pair&lt;i64, int&gt;&gt; prime;\n    i64 temp = m;\n    for (i64 i = 2 ; i * i &lt;= temp ; i++) {\n        if (temp % i == 0) {\n            int cnt = 0;\n            while (temp % i == 0) {\n                temp /= i;\n                cnt++;\n            }\n            prime.push_back({i, cnt});\n        }\n    }\n    if (temp &gt; 1) {\n        prime.push_back({temp, 1});\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        i64 a;\n        cin &gt;&gt; a;\n        if (m % a != 0) continue;\n        int res = 0;\n        bool flag = true;\n        for (int j = 0 ; j &lt; (int) prime.size() ; j++) {\n            int cnt = 0;\n            while (a %  prime[j].first == 0) {\n                a /= prime[j].first;\n                cnt++;\n            }\n            if (cnt &gt; prime[j].second) {\n                flag = false;\n                break;\n            }\n            if (cnt == prime[j].second) {\n                res |= 1 &lt;&lt; j;\n\n            }\n        }\n        if (flag &amp;&amp; a == 1) {\n            dp[res]++;\n        }\n    }\n    if (m == 1LL) {\n        cout &lt;&lt; (qpow(2, dp[0]) - 1 + P) % P &lt;&lt; \"\\n\";\n        return 0;\n    }\n    int k = prime.size();\n    for (int i = 0 ; i &lt; k ; i++) {\n        for (int mask = 0 ; mask &lt; 1 &lt;&lt; k ; mask++) {\n            if (mask &amp; 1 &lt;&lt; i) {\n                dp[mask] = (dp[mask ^ 1 &lt;&lt; i] + dp[mask]) % P;\n            }\n        }\n    }\n    i64 ans = 0;\n    for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n        dp[i] = qpow(2, dp[i]);\n        ans = (ans + ((k - __builtin_popcount(i)) &amp; 1 ? P - 1 : 1) * dp[i] % P) % P;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/tree/","title":"\u6811\u5f62dp","text":"\u4e60\u9898 \u6d1b\u8c37P2458(\u4fdd\u5b89\u7ad9\u5c97)\u6d1b\u8c37P1352(\u4e0a\u53f8\u7684\u821e\u4f1a)\u725b\u5ba228258F(\u6743\u503c\u6700\u5927\u7684\u94fe)\u6d1b\u8c37P2014(\u6811\u4e0a\u80cc\u5305) <p>P2458 [SDOI2006] \u4fdd\u5b89\u7ad9\u5c97 - \u6d1b\u8c37</p> <p>\u6bcf\u4e2a\u70b9\u90fd\u5fc5\u987b\u88ab\u770b\u5b88\uff0c\u82b1\u8d39 \\(v_i\\) \u5728\u70b9 \\(i\\) \u653e\u7f6e\u4e00\u4e2a\u4fdd\u5b89\uff0c\u4fdd\u5b89\u53ef\u4ee5\u770b\u5b88\u8fd9\u4e2a\u70b9\u53ca\u8fd9\u4e2a\u70b9\u6240\u6709\u76f8\u90bb\u7684\u70b9</p> <p>\u95ee\u4f7f\u6240\u6709\u70b9\u88ab\u770b\u5b88\u7684\u82b1\u8d39\u7684\u6700\u5c0f\u503c</p> \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; adj[1505];\nint dp[1505][3];\n// 0 \u8868\u793a\u81ea\u8eab\u8282\u70b9\n// 1 \u8868\u793a\u5b50\u8282\u70b9\n// 2 \u8868\u793a\u7236\u8282\u70b9\nvoid dfs(int u, int p) {\n    int res = 0x7fffffff;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        // \u5982\u679c\u5b50\u8282\u70b9\u6709, \u90a3\u4e48\u4e00\u5b9a\u8981\u4fdd\u8bc1\u4e00\u4e2a\u5b50\u8282\u70b9\u6709.\n        // \u5982\u679c\u5b50\u8282\u70b9\u6709\u7684\u672c\u6765\u5c31\u5c0f, \u90a3\u4e48\u65e0\u9700\u9009\u62e9. \u5426\u5219\u6211\u4eec\u9009\u62e9\u51cf\u53bb\u5b59\u5b50\u8282\u70b9\uff0c\u52a0\u4e0a\u5b50\u8282\u70b9.\n        res = min(res, dp[to][0] - min(dp[to][0], dp[to][1]));\n        // \u5982\u679c\u81ea\u8eab\u8282\u70b9\u6709, \u90a3\u4e48\u53ef\u4efb\u610f\u9009\n        dp[u][0] += min({dp[to][0], dp[to][1], dp[to][2]});\n        // \u5982\u679c\u5b50\u8282\u70b9\u6709, \u90a3\u4e48\u5148\u9009\u5b50\u8282\u70b9\u548c\u5b59\u5b50\u8282\u70b9\u7684\u6700\u5c0f\n        dp[u][1] += min(dp[to][0], dp[to][1]);\n        // \u5982\u679c\u7236\u8282\u70b9\u6709, \u90a3\u4e48\u53ef\u9009\u5b50\u8282\u70b9\u6216\u5b59\u5b50\u8282\u70b9\u7684\u6700\u5c0f\n        dp[u][2] += min(dp[to][0], dp[to][1]);\n    }\n    dp[u][1] += res;\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int p, m;\n        cin &gt;&gt; p &gt;&gt; dp[p][0] &gt;&gt; m;\n        for (int j = 0 ; j &lt; m ; j++) {\n            int x;\n            cin &gt;&gt; x;\n            adj[p].emplace_back(x);\n            adj[x].emplace_back(p);\n        }\n    }\n    dfs(1, 0);\n    cout &lt;&lt; min(dp[1][0], dp[1][1]);\n    return 0;\n}\n</code></pre> <p>P1352 \u6ca1\u6709\u4e0a\u53f8\u7684\u821e\u4f1a - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4ef7\u503c \\(v_i\\)\uff0c\u9009\u62e9\u70b9 \\(i\\) \u5219\u4e0d\u80fd\u9009\u62e9\u8be5\u70b9\u7684\u513f\u5b50\u3002</p> <p>\u95ee\u4ef7\u503c\u548c\u7684\u6700\u5927\u3002</p> \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; a;\nvector&lt;vector&lt;int&gt;&gt; dp, adj;\nvoid dfs(int u) {\n    dp[u][0] = 0;\n    dp[u][1] = a[u];\n    for (auto &amp;i : adj[u]) {\n        dfs(i);\n        dp[u][0] += max(dp[i][0], dp[i][1]);\n        dp[u][1] += dp[i][0];\n    }\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    a.resize(n + 1);\n    adj.resize(n + 1);\n    dp.resize(n + 1, vector&lt;int&gt;(2));\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n    vector vis(n + 1, 0);\n    for (int i = 1 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        adj[y].emplace_back(x);\n        vis[x] = 1;\n    }\n    int root = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (vis[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n    dfs(root);\n    cout &lt;&lt; max(dp[root][0], dp[root][1]);\n    return 0;\n}\n</code></pre> <p>F-\u6811\u4e0a\u5b50\u94fe_\u725b\u5ba2\u7ade\u8d5b\u52a8\u6001\u89c4\u5212\u4e13\u9898\u73ed\u6811\u578bdp\u4f8b\u9898</p> <p>\u4e00\u68f5\u6811, \u70b9\u6743\u6709\u6b63\u6709\u8d1f, \u95ee\u5b50\u94fe\u6743\u503c\u548c\u7684\u6700\u5927</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nvector&lt;int&gt; adj[100005];\nlong long dp[100005];\nlong long a[100005];\nlong long ans = -1e18;\nvoid dfs(int u, int p) {\n    dp[u] = a[u];\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        ans = max(ans, dp[u] + dp[to]);\n        dp[u] = max(dp[u], a[u] + dp[to]);\n    }\n    ans = max(ans, dp[u]);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>P2014 [CTSC1997] \u9009\u8bfe - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; adj[305];\nint val[305];\nint dp[305][305];\nint n, m;\nint dfs(int u) {\n    int p = 1;\n    dp[u][1] = val[u];\n    for (auto &amp;v : adj[u]) {\n        int cnt = dfs(v);\n        for (int i = min(p, m + 1) ; i &gt; 0 ; i--) {\n            for (int j = 1 ; j &lt;= cnt &amp;&amp; i + j &lt;= m + 1 ; j++) {\n                dp[u][i + j] = max(dp[u][i + j], dp[u][i] + dp[v][j]);\n            }\n        }\n        p += cnt;\n    }\n    return p;\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int s;\n        cin &gt;&gt; s &gt;&gt; val[i];\n        adj[s].emplace_back(i);\n    }\n    dfs(0);\n    cout &lt;&lt; dp[0][m + 1];\n    return 0;\n}\n</code></pre>"},{"location":"template/dynamic-programming/optimize/monotonic-queue/","title":"\u5355\u8c03\u961f\u5217\u4f18\u5316dp","text":"\u4f8b\u9898 <p>U226418 \u70fd\u706b\u4f20\u9012 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint dp[200005];\nint a[200005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    deque&lt;int&gt; que;\n    que.emplace_back(0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int idx = 0;\n        while (!que.empty() &amp;&amp; que.front() &lt; i - m) {\n            que.pop_front();\n        }\n        if (!que.empty()) {\n            idx = que.front();\n        }\n        dp[i] = dp[idx] + a[i];\n        while (!que.empty() &amp;&amp; dp[que.back()] &gt;= dp[i]) {\n            que.pop_back();\n        }\n        que.emplace_back(i);\n    }\n    int ans = 0x7fffffff;\n    for (int i = n - m + 1 ; i &lt;= n ; i++) {\n        ans = min(ans, dp[i]);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/2-SAT/","title":"2-SAT","text":"<p>\\(a\\vee b\\)</p> <p>\u5efa\u8fb9 \\(!a-&gt;b\\) \u548c \\(!b-&gt;a\\)\u3002</p> <p>\u5f53\u4e00\u4e2a\u70b9\u7684\u4e24\u4e2a\u72b6\u6001\u5c5e\u4e8e\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u65f6\uff0c\u65e0\u89e3\u3002</p> <p>\u9009\u62e9\u5f3a\u8054\u901a\u5206\u91cf\u5e8f\u53f7\u5c0f\u7684\u65b9\u6848\u3002</p> <p>Tarjan</p> \u4f8b\u9898 <p>P4782 \u3010\u6a21\u677f\u30112-SAT \u95ee\u9898 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>{ Tarjan \u6a21\u7248 }\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int a, b, c, d;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        adj[a + n * (b ^ 1)].emplace_back(c + n * d);\n        adj[c + n * (d ^ 1)].emplace_back(a + n * b);\n    }\n    for (int i = 1 ; i &lt;= 2 * n ; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (belong[i] == belong[i + n]) {\n            cout &lt;&lt; \"IMPOSSIBLE\";\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"POSSIBLE\\n\";\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (belong[i] &gt; belong[i + n]) cout &lt;&lt; 1 &lt;&lt; \" \";\n        else cout &lt;&lt; 0 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 <p>P5782 [POI2001] \u548c\u5e73\u59d4\u5458\u4f1a - \u6d1b\u8c37</p> <p>\u5982\u679c \\(x\\) \u548c \\(y\\) \u6709\u51b2\u7a81\uff0c\u90a3\u4e48 \\(x\\) \u53ea\u80fd\u548c \\(y\\) \u7684\u4f19\u4f34\u4e00\u8d77\uff0c\u6216 \\(x\\) \u7684\u4f19\u4f34\u548c \\(y\\) \u4e00\u8d77\u3002</p> <p>\\(2i-1\\) \u548c \\(2i\\) \u5fc5\u987b\u4e0d\u5728\u540c\u4e00\u5f3a\u8fde\u901a\u5206\u91cf</p> \u4ee3\u7801 C++<pre><code>{ Tarjan \u6a21\u7248 }\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x--;\n        y--;\n        adj[x].emplace_back(y ^ 1);\n        adj[y].emplace_back(x ^ 1);\n        if ((x ^ 1) == y) {\n            cout &lt;&lt; \"NIE\\n\";\n        }\n    }\n    for (int i = 0 ; i &lt; 2 * n ; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n    for (int i = 0 ; i &lt; 2 * n ; i += 2) {\n        if (belong[i] == belong[i + 1]) {\n            cout &lt;&lt; \"NIE\";\n            return 0;\n        }\n    }\n    for (int i = 0 ; i &lt; 2 * n ; i += 2) {\n        if (belong[i] &lt; belong[i + 1]) cout &lt;&lt; i + 1 &lt;&lt; \"\\n\";\n        else cout &lt;&lt; i + 2 &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/bipartite-graph/","title":"\u4e8c\u5206\u56fe","text":""},{"location":"template/graph/bipartite-graph/#_2","title":"\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d","text":"\u6a21\u7248 Hungarian \\(O(nm)\\) C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;int&gt; adj[505];\nint vis[505], mat[505];\nint tag;\nbool check(int x) {\n    if (vis[x] == tag) return false;\n    vis[x] = tag;\n    for (auto &amp;to : adj[x]) {\n        if ((mat[to] == 0) || check(mat[to])) {\n            mat[to] = x;\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    int n, m, e;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;\n    for (int i = 0 ; i &lt; e ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n    }\n    int cnt = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (check(tag = i)) {\n            cnt++;\n        }\n    }\n    cout &lt;&lt; cnt;\n    return 0;\n}\n</code></pre> \u4f8b\u9898 <p>P3386 \u3010\u6a21\u677f\u3011\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d - \u6d1b\u8c37</p>"},{"location":"template/graph/euler-graph/","title":"\u6b27\u62c9\u56fe","text":""},{"location":"template/graph/euler-graph/#_2","title":"\u6b27\u62c9\u56fe\u5224\u522b\u6cd5","text":"<ul> <li>\u6b27\u62c9\u56de\u8def\uff1a\u901a\u8fc7\u56fe\u4e2d\u6bcf\u6761\u8fb9\u6070\u597d\u4e00\u6b21\u7684\u56de\u8def</li> <li>\u6b27\u62c9\u901a\u8def\uff1a\u901a\u8fc7\u56fe\u4e2d\u6bcf\u6761\u8fb9\u6070\u597d\u4e00\u6b21\u7684\u901a\u8def</li> <li>\u6b27\u62c9\u56fe\uff1a\u5177\u6709\u6b27\u62c9\u56de\u8def\u7684\u56fe</li> <li>\u534a\u6b27\u62c9\u56fe\uff1a\u5177\u6709\u6b27\u62c9\u901a\u8def\u4f46\u4e0d\u5177\u6709\u6b27\u62c9\u56de\u8def\u7684\u56fe</li> </ul> <p>\u2460\u65e0\u5411\u56fe\u662f\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u8fde\u901a\u7684</li> <li>\u9876\u70b9\u7684\u5ea6\u6570\u90fd\u662f\u5076\u6570</li> </ul> <p>\u2461\u65e0\u5411\u56fe\u662f\u534a\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u8fde\u901a\u7684</li> <li>\u6070\u67092\u4e2a\u5947\u5ea6\u9876\u70b9</li> </ul> <p>\u2462\u6709\u5411\u56fe\u662f\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u5f3a\u8fde\u901a\u7684</li> <li>\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u7b49\u4e8e\u51fa\u5ea6</li> </ul> <p>\u2463\u6709\u5411\u56fe\u662f\u534a\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u5f31\u8fde\u901a\u7684</li> <li>1\u4e2a\u9876\u70b9\u7684\u51fa\u5ea6\u4e0e\u5165\u5ea6\u4e4b\u5dee\u4e3a1</li> <li>1\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u4e0e\u51fa\u5ea6\u4e4b\u5dee\u4e3a1</li> <li>\u5176\u4ed6\u9876\u70b9\u7684\u5165\u5ea6\u548c\u51fa\u5ea6\u76f8\u7b49</li> </ul> \u4f8b\u9898 \u6d1b\u8c37P7771(\u6709\u5411\u56fe)\u6d1b\u8c37P2731(\u65e0\u5411\u56fe) <p>P7771 \u3010\u6a21\u677f\u3011\u6b27\u62c9\u8def\u5f84 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nvector&lt;int&gt; adj[100005];\nint cnt[100005], indeg[100005], outdeg[100005];\nstack&lt;int&gt; ans;\nvoid Hierholzer(int x) {\n    for (int &amp;i = cnt[x] ; i &lt; int(adj[x].size()) ; ) {\n        i++;\n        Hierholzer(adj[x][i - 1]);\n    }\n    ans.emplace(x);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        outdeg[u]++;\n        indeg[v]++;\n    }\n    int idx = 1, scnt = 0, ecnt = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (indeg[i] - outdeg[i] == 1) {\n            ecnt++;\n        } else if (outdeg[i] - indeg[i] == 1) {\n            idx = i;\n            scnt++;\n        } else if (indeg[i] != outdeg[i]) {\n            cout &lt;&lt; \"No\\n\";\n            return 0;\n        }\n    }\n\n    if (!(ecnt == 0 &amp;&amp; scnt == 0) &amp;&amp; !(ecnt == 1 &amp;&amp; scnt == 1)) {\n        cout &lt;&lt; \"NO\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (adj[i].empty()) continue;\n        sort(begin(adj[i]), end(adj[i]));\n    }\n    Hierholzer(idx);\n    while (!ans.empty()) {\n        cout &lt;&lt; ans.top() &lt;&lt; \" \";\n        ans.pop();\n    }\n    return 0;\n}\n</code></pre> <p>P2731 [USACO3.3]\u9a91\u9a6c\u4fee\u6805\u680f Riding the Fences - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nstruct Node {\n    int to, rev;\n    bool exist;\n    Node() = default;\n    Node(const int to) : to(to), rev(0), exist(true) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return to &lt; x.to;\n    }\n};\nstack&lt;int&gt; ans;\nvector&lt;Node&gt; adj[1025];\nint cnt[1025], deg[1025], top[1025];\nvoid Hierholzer(const int x) {\n    for (int &amp;i = cnt[x] ; i &lt; int(adj[x].size()) ; ) {\n        if (adj[x][i].exist) {\n            Node temp = adj[x][i];\n            adj[x][i].exist = false;\n            adj[temp.to][temp.rev].exist = false;\n            i++;\n            Hierholzer(temp.to);\n        } else {\n            i++;\n        }\n    }\n    ans.emplace(x);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    n = 500;\n    cin &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n        deg[u]++;\n        deg[v]++;\n    }\n    int vcnt = 0, idx = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (deg[i] &amp; 1) {\n            vcnt++;\n            if (idx == 0) idx = i;\n        }\n    }\n    if (vcnt != 0 &amp;&amp; vcnt != 2) {\n        return 0;\n    }\n    if (idx == 0) idx = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (adj[i].empty()) continue;\n        sort(begin(adj[i]), end(adj[i]));\n        for (auto &amp;k : adj[i]) {\n            k.rev = top[k.to]++;\n        }\n    }\n    Hierholzer(idx);\n    while (!ans.empty()) {\n        cout &lt;&lt; ans.top() &lt;&lt; \"\\n\";\n        ans.pop();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/minimum-spanning-tree/","title":"\u6700\u5c0f\u751f\u6210\u6811","text":""},{"location":"template/graph/minimum-spanning-tree/#prim","title":"Prim","text":"<p>\\(O(n\\log n)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int to, val;\n    Node() = default;\n    Node(const int to, const int val) : to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;vector&lt;Node&gt;&gt; adj;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    adj.assign(n + 1, vector&lt;Node&gt;());\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n        adj[v].emplace_back(u, val);\n    }\n    vector&lt;int&gt; dist(n + 1, 0x7fffffff), vis(n + 1);\n    priority_queue&lt;Node&gt; que;\n    que.emplace(1, 0);\n    int res = 0;\n    int cnt = 0;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [to, val] = que.top();\n        que.pop();\n        if (vis[to] == true) continue;\n        vis[to] = true;\n        cnt++;\n        res += val;\n        for (auto &amp;[to, val] : adj[to]) {\n            if (val &lt; dist[to]) {\n                dist[to] = val;\n                que.emplace(to, val);\n            }\n        }\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"template/graph/minimum-spanning-tree/#kruskal","title":"Kruskal","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int from, to, val;\n    Node() = default;\n    Node(const int from, const int to, const int val) : from(from), to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint f[5005];\nint find(const int x) {\n    return f[x] == x ? x : f[x] = find(f[x]);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;Node&gt; edge(m);\n    iota(f, f + n + 1, 0);\n    priority_queue&lt;Node&gt; que;\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].val;\n        que.emplace(edge[i]);\n    }\n    vector&lt;int&gt; vis(n + 1);\n    int res = 0;\n    int cnt = 1;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [from, to, val] = que.top();\n        que.pop();\n        from = find(from);\n        to = find(to);\n        if (from == to) continue;\n        f[from] = to;\n        cnt++;\n        res += val;\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"template/graph/minimum-spanning-tree/#_2","title":"\u6700\u5c0f\u5f02\u6216\u751f\u6210\u6811","text":"\u4f8b\u9898 CF888G <p>Problem - G - Codeforces</p> <p>\\(n\\) \u4e2a\u70b9\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a \\(a_i\\), \u70b9 \\(i\\) \u548c \\(j\\) \u7684\u8fb9\u7684\u6743\u503c\u7b49\u4e8e \\(a_i\\oplus\u2009a_j\\)\uff0c\u95ee\u6700\u5c0f\u751f\u6210\u6811\u7684\u6743\u503c(\u6240\u6709\u8fb9\u6743\u4e4b\u548c)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint tot = 0;\nconst int N = 200000 * 31;\nvector&lt;int&gt; e[N];\nint nxt[N][2];\nvoid insert(int x) {\n    int index = 0;\n    for (int i = 30 ; i &gt;= 0 ; i--) {\n        int k = x &gt;&gt; i &amp; 1;\n        if (nxt[index][k] == 0) {\n            nxt[index][k] = ++tot;\n        }\n        index = nxt[index][k];\n        e[index].emplace_back(x);\n    }\n}\nint query(int index, int d, int x) {\n    if (d &lt; 0) {\n        return 0;\n    }\n    int k = x &gt;&gt; d &amp; 1;\n    if (nxt[index][k]) {\n        return query(nxt[index][k], d - 1, x);\n    }\n    return query(nxt[index][k ^ 1], d - 1, x) + (1 &lt;&lt; d);\n}\nlong long ans = 0;\nvoid solve(int index, int d) {\n    int L = nxt[index][0], R = nxt[index][1];\n    if (L &amp;&amp; R) {\n        if (e[L].size() &gt; e[R].size()) swap(L, R);\n        int mi = 1 &lt;&lt; 30;\n        for (auto &amp;x : e[L]) {\n            mi = min(mi, query(R, d - 1, x));\n        }\n        ans += mi + (1 &lt;&lt; d);\n    }\n    if (L) {\n        solve(L, d - 1);\n    }\n    if (R) {\n        solve(R, d - 1);\n    }\n\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        insert(a[i]);\n    }\n    solve(0, 30);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/shortest-path/","title":"\u6700\u77ed\u8def","text":""},{"location":"template/graph/shortest-path/#floyed","title":"Floyed \u7b97\u6cd5","text":"<p>\\(O(n^3)\\)</p> \u6a21\u7248 C++<pre><code>for (int k = 1 ; k &lt;= n ; k++) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= n ; j++) {\n            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n        }\n    }\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3647 <p>B3647 \u3010\u6a21\u677f\u3011Floyd \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"template/graph/shortest-path/#bellman-ford","title":"Bellman-Ford \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nint n;\nvoid bellman_ford(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n    }\n    dist[s] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        bool flag = false;\n        for (int p = 1 ; p &lt;= n ; p++) {\n            if (dist[p] == 0x7fffffff) {\n                continue;\n            }\n            for (auto &amp;[to, val] : adj[p]) {\n                if (dist[p] + val &lt; dist[to]) {\n                    dist[to] = dist[p] + val;\n                    flag = true;\n                }\n            }\n        }\n        if (flag == false) {\n            break;\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    bellman_ford(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"template/graph/shortest-path/#spfa","title":"Spfa \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nint dist[10005];\nbool vis[10005];\nvector&lt;Node&gt; adj[10005];\nint n;\nvoid spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    spfa(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \\n\"[i == n];\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371\u6d1b\u8c37P3385 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p> <p>P3385 \u3010\u6a21\u677f\u3011\u8d1f\u73af - \u6d1b\u8c37</p> <p>\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af(\u8def\u5f84\u548c\u4e3a\u8d1f\u6570\u7684\u73af)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nlong long dist[2005];\nbool vis[2005];\nint cnt[2005];\nvector&lt;Node&gt; adj[2005];\nint n;\nbool spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffffffffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nbool solve() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        adj[i].clear();\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        if (val &gt;= 0) {\n            adj[v].emplace_back(u, val);\n        }\n        adj[u].emplace_back(v, val);\n    }\n    return spfa(1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        cout &lt;&lt; (solve() ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/shortest-path/#dijkstra","title":"Dijkstra \u7b97\u6cd5","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nbool vis[200005];\nint n;\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    dijkstra(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P4779 <p>P4779 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"template/graph/shortest-path/#johnson","title":"Johnson \u5168\u6e90\u6700\u77ed\u8def\u5f84\u7b97\u6cd5","text":"<p>\\(O(nm\\log m)\\)</p> <p>\u8dd1\u4e00\u904d spfa \u5224\u8d1f\u73af\uff0c\u540e\u8dd1 n \u904d dijkstra</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint h[3005];\nint dist[3005];\nint cnt[3005];\nbool vis[3005];\nvector&lt;Node&gt; adj[3005];\nint n;\nbool spfa() {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        h[i] = 0x7fffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n        adj[0].emplace_back(i, 0);\n    }\n    queue&lt;int&gt; que;\n    que.emplace(0);\n    h[0] = 0;\n    vis[0] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (h[p] + val &lt; h[to]) {\n                h[to] = h[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    if (spfa()) {\n        cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (auto &amp;[to, val] : adj[i]) {\n            val += h[i] - h[to];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dijkstra(i);\n        long long ans = 0;\n        for (int j = 1 ; j &lt;= n ; j++) {\n            if (dist[j] == 0x7fffffff) {\n                ans += j * 1000000000L;\n            } else {\n                ans += 1LL * j * (dist[j] + h[j] - h[i]);\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5905 <p>P5905 \u3010\u6a21\u677f\u3011Johnson \u5168\u6e90\u6700\u77ed\u8def - \u6d1b\u8c37</p>"},{"location":"template/graph/connectivity/strongly-connected-components/","title":"\u5f3a\u8054\u901a\u5206\u91cf","text":""},{"location":"template/graph/connectivity/strongly-connected-components/#tarjan","title":"Tarjan","text":"\u6a21\u7248 C++<pre><code>vector&lt;int&gt; adj[10005];\nint dfn[10005], belong[10005], sz[10005], tot = 0;\nvoid tarjan(int x) {\n    static stack&lt;int&gt; st;\n    static bool in[10005];\n    static int low[10005], cnt = 0;\n    dfn[x] = low[x] = ++cnt;\n    st.emplace(x);\n    in[x] = true;\n    for (auto &amp;y : adj[x]) {\n        if (!dfn[y]) {\n            tarjan(y);\n            low[x] = min(low[x], low[y]);\n        } else if (in[y]) {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        ++tot;\n        while (true) {\n            int y = st.top();\n            st.pop();\n            in[y] = false;\n            belong[y] = tot;\n            sz[tot]++;\n            if (x == y) {\n                break;\n            }\n        }\n    }\n}\n</code></pre> \u4f8b\u9898 <p>B3609 [\u56fe\u8bba\u4e0e\u4ee3\u6570\u7ed3\u6784 701] \u5f3a\u8fde\u901a\u5206\u91cf - \u6d1b\u8c37</p> C++<pre><code>{ Tarjan \u6a21\u7248 }\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n\n    vector a(tot + 1, vector&lt;int&gt;());\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[belong[i]].push_back(i);\n    }\n    vector&lt;bool&gt; vis(tot + 1);\n    cout &lt;&lt; tot &lt;&lt; \"\\n\";\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (vis[belong[i]]) continue;\n        vis[belong[i]] = true;\n        sort(begin(a[belong[i]]), end(a[belong[i]]));\n        for (auto &amp;x : a[belong[i]]) {\n            cout &lt;&lt; x &lt;&lt; \" \";\n        }\n        cout &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 <p>P2341 [USACO03FALL / HAOI2006] \u53d7\u6b22\u8fce\u7684\u725b G - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u70b9, \\(m\\) \u6761\u6709\u5411\u8fb9\u3002</p> <p>\u95ee\u80fd\u88ab\u6240\u6709\u70b9\u5230\u8fbe\u7684\u70b9\u6709\u591a\u5c11\u4e2a\uff1f</p> \u4ee3\u7801 C++<pre><code>{ Tarjan \u6a21\u7248 }\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n    vector&lt;int&gt; deg(tot + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (auto &amp;to : adj[i]) {\n            if (belong[i] != belong[to]) {\n                deg[belong[i]]++;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt;= tot ; i++) {\n        if (deg[i] == 0) {\n            if (ans &gt; 0) {\n                ans = 0;\n                break;\n            }\n            ans = sz[i];\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/flow/cost/","title":"\u8d39\u7528\u6d41","text":"\u4f8b\u9898 <p>P3381 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T&gt;\nstruct MCF {\n    struct Edge {\n        int to;\n        T cost, flow;\n    };\n    const int n;\n    vector&lt;Edge&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;T&gt; h, dist;\n    vector&lt;int&gt; pre;\n    MCF(int n) : n(n), adj(n) {}\n    bool dijkstra(int s, int t) {\n        dist.assign(n, numeric_limits&lt;T&gt;::max());\n        pre.assign(n, -1);\n        priority_queue&lt;pair&lt;T, int&gt;, vector&lt;pair&lt;T, int&gt;&gt;, greater&lt;&gt;&gt; q;\n        dist[s] = 0;\n        q.push({0, s});\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (dist[u] &lt; d) {\n                continue;\n            }\n            for (auto &amp;idx : adj[u]) {\n                auto [to, cost, flow] = edges[idx];\n                if (cost &gt; 0 &amp;&amp; dist[to] &gt; d + h[u] - h[to] + flow) {\n                    dist[to] = d + h[u] - h[to] + flow;\n                    pre[to] = idx;\n                    q.push({dist[to], to});\n                }\n            }\n        }\n        return dist[t] != numeric_limits&lt;T&gt;::max();\n    }\n    void add(int x, int y, int flow, int cost) {\n        if (cost &lt; 0) { // ** \u5220\u9664 &lt;=&gt; \u6700\u5927\u6d41\n            adj[x].push_back(edges.size());\n            edges.push_back({y, 0, cost});\n            adj[y].push_back(edges.size());\n            edges.push_back({x, flow, -cost});\n        } else // **\n            adj[x].push_back(edges.size()),\n            edges.push_back({y, flow, cost}),\n            adj[y].push_back(edges.size()),\n            edges.push_back({x, 0, -cost});\n    }\n    pair&lt;T, T&gt; work(int s, int t) {\n        int flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t)) {\n            for (int i = 0 ; i &lt; n ; ++i) {\n                h[i] += dist[i];\n            }\n            T aug = numeric_limits&lt;T&gt;::max();\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                aug = std::min(aug, edges[pre[i]].cost);\n            }\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                edges[pre[i]].cost -= aug;\n                edges[pre[i] ^ 1].cost += aug;\n            }\n            flow += aug;\n            cost += T(aug) * h[t];\n        }\n        return {flow, cost};\n    }\n}; // MCF\nint main() {\n    int n, m, s, t;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    MCF&lt;i64&gt; mcf(n + 1);\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, w, c;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;\n        mcf.add(u, v, w, c);\n    }\n    auto [flow, cost] = mcf.work(s, t);\n    cout &lt;&lt; flow &lt;&lt; \" \" &lt;&lt; cost &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P3358\u6d1b\u8c37P2770 <p>P3358 \u6700\u957fk\u53ef\u91cd\u533a\u95f4\u96c6\u95ee\u9898 - \u6d1b\u8c37</p> <p>\u5df2\u77e5 \\(k\\) \u548c \\(n\\) \u4e2a\u5f00\u533a\u95f4, \\((L_i,R_i)\\), \u6bcf\u4e2a\u70b9\u81f3\u591a\u88ab \\(k\\) \u4e2a\u533a\u95f4\u8986\u76d6</p> <p>\u95ee\u4efb\u9009\u5f00\u533a\u95f4\u6240\u80fd\u5f97\u5230\u7684\u533a\u95f4\u957f\u5ea6\u7684\u548c\u7684\u6700\u5927\u503c.</p> <p></p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T&gt;\nstruct MCF {\n    struct Edge {\n        int to;\n        T cost, flow;\n    };\n    const int n;\n    vector&lt;Edge&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;T&gt; h, dist;\n    vector&lt;int&gt; pre;\n    MCF(int n) : n(n), adj(n) {}\n    bool dijkstra(int s, int t) {\n        dist.assign(n, numeric_limits&lt;T&gt;::max());\n        pre.assign(n, -1);\n        priority_queue&lt;pair&lt;T, int&gt;, vector&lt;pair&lt;T, int&gt;&gt;, greater&lt;&gt;&gt; q;\n        dist[s] = 0;\n        q.push({0, s});\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (dist[u] &lt; d) {\n                continue;\n            }\n            for (auto &amp;idx : adj[u]) {\n                auto [to, cost, flow] = edges[idx];\n                if (cost &gt; 0 &amp;&amp; dist[to] &gt; d + h[u] - h[to] + flow) {\n                    dist[to] = d + h[u] - h[to] + flow;\n                    pre[to] = idx;\n                    q.push({dist[to], to});\n                }\n            }\n        }\n        return dist[t] != numeric_limits&lt;T&gt;::max();\n    }\n    void add(int x, int y, int flow, int cost) {\n        adj[x].push_back(edges.size()),\n        edges.push_back({y, flow, cost}),\n        adj[y].push_back(edges.size()),\n        edges.push_back({x, 0, -cost});\n    }\n    pair&lt;T, T&gt; work(int s, int t) {\n        int flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t)) {\n            for (int i = 0 ; i &lt; n ; ++i) {\n                h[i] += dist[i];\n            }\n            T aug = numeric_limits&lt;T&gt;::max();\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                aug = std::min(aug, edges[pre[i]].cost);\n            }\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                edges[pre[i]].cost -= aug;\n                edges[pre[i] ^ 1].cost += aug;\n            }\n            flow += aug;\n            cost += T(aug) * h[t];\n        }\n        return {flow, cost};\n    }\n}; // MCF\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;array&lt;int, 2&gt;&gt; a(n + 1);\n    vector&lt;int&gt; idx(1, 0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        a[i] = {L, R};\n        idx.push_back(L);\n        idx.push_back(R);\n    }\n\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    int len = idx.size() - 1;\n    int s = len + 1, t = s + 1;\n    MCF&lt;int&gt; mcf(t + 1);\n    mcf.add(s, 1, k, 0);\n    for (int i = 1 ; i &lt; len ; i++) {\n        mcf.add(i, i + 1, 999999LL, 0);\n    }\n    mcf.add(len, t, 999999LL, 0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int L = a[i][1] - a[i][0];\n        int x = lower_bound(begin(idx), end(idx), a[i][0]) - begin(idx);\n        int y = lower_bound(begin(idx), end(idx), a[i][1]) - begin(idx);\n        mcf.add(x, y, 1, -L);\n    }\n    auto [flow, cost] = mcf.work(s, t);\n    cout &lt;&lt; -cost;\n    return 0;\n}\n</code></pre> <p>P2770 \u822a\u7a7a\u8def\u7ebf\u95ee\u9898 - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u70b9, \\(m\\) \u6761\u65e0\u5411\u8fb9, \u95ee\u4ece \\(1\\) \u5230 \\(n\\) \u518d\u56de\u5230 \\(1\\) \u4e14\u4e0d\u80fd\u7ecf\u8fc7\u9664\u4e86 \\(1\\) \u4e4b\u5916\u7684\u70b9\u4e24\u6b21\u7684\u6700\u957f\u8def\u5f84.</p> <p>\u5bf9\u6bcf\u4e2a\u70b9\u5206\u4e3a\u51fa\u70b9\u548c\u5165\u70b9,</p> <p>\u5bf9\u4e8e\u6bcf\u4e2a\u70b9, \u81ea\u5df1\u7684\u5165\u70b9\u8fde\u63a5\u81ea\u5df1\u7684\u51fa\u70b9, \u5bb9\u91cf\u4e3a \\(1\\), \u8d39\u7528\u4e3a \\(1\\), \u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u5bb9\u91cf\u4e3a \\(2\\),</p> <p>\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u51fa\u70b9\u8fde\u63a5\u5165\u70b9, \u5bb9\u91cf\u4e3a \\(1\\), \u8d39\u7528\u4e3a \\(0\\), \u8dd1\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41.</p> <p>\u6700\u5927\u6d41\u4e3a \\(2\\), \u8bf4\u660e\u4ece \\(1\\) \u5230 \\(n\\) \u6709\u4e24\u6761\u4e0d\u76f8\u4ea4\u7684\u8def\u5f84,</p> <p>\u6700\u5927\u6d41\u4e3a \\(1\\) \u65f6, \u8981\u7279\u5224\u662f\u5426\u6709\u76f4\u63a5\u4ece \\(1\\) \u5230 \\(n\\) \u7684\u8fb9,</p> <p>\u5176\u4f59\u60c5\u51b5\u5747\u4e3a\u65e0\u89e3.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T&gt;\nstruct MCF {\n    struct Edge {\n        int to;\n        T cost, flow;\n    };\n    const int n;\n    vector&lt;Edge&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;T&gt; h, dist;\n    vector&lt;int&gt; pre;\n    MCF(int n) : n(n), adj(n) {}\n    bool dijkstra(int s, int t) {\n        dist.assign(n, numeric_limits&lt;T&gt;::max());\n        pre.assign(n, -1);\n        priority_queue&lt;pair&lt;T, int&gt;, vector&lt;pair&lt;T, int&gt;&gt;, greater&lt;&gt;&gt; q;\n        dist[s] = 0;\n        q.push({0, s});\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (dist[u] &lt; d) {\n                continue;\n            }\n            for (auto &amp;idx : adj[u]) {\n                auto [to, cost, flow] = edges[idx];\n                if (cost &gt; 0 &amp;&amp; dist[to] &gt; d + h[u] - h[to] + flow) {\n                    dist[to] = d + h[u] - h[to] + flow;\n                    pre[to] = idx;\n                    q.push({dist[to], to});\n                }\n            }\n        }\n        return dist[t] != numeric_limits&lt;T&gt;::max();\n    }\n    void add(int x, int y, int flow, int cost) {\n        adj[x].push_back(edges.size()),\n        edges.push_back({y, flow, cost}),\n        adj[y].push_back(edges.size()),\n        edges.push_back({x, 0, -cost});\n    }\n    pair&lt;T, T&gt; work(int s, int t) {\n        int flow = 0;\n        T cost = 0;\n        h.assign(n, 0);\n        while (dijkstra(s, t)) {\n            for (int i = 0 ; i &lt; n ; ++i) {\n                h[i] += dist[i];\n            }\n            T aug = numeric_limits&lt;T&gt;::max();\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                aug = std::min(aug, edges[pre[i]].cost);\n            }\n            for (int i = t ; i != s ; i = edges[pre[i] ^ 1].to) {\n                edges[pre[i]].cost -= aug;\n                edges[pre[i] ^ 1].cost += aug;\n            }\n            flow += aug;\n            cost += T(aug) * h[t];\n        }\n        return {flow, cost};\n    }\n}; // MCF\nstring a[105];\nmap&lt;string, int&gt; rev;\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        rev[a[i]] = i;\n    }\n    int s = 1, t = n + n;\n    MCF&lt;int&gt; mcf(t + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        mcf.add(i, n + i, 1 + (i == 1 || i == n), -1);\n    }\n    bool flag = false;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        string su, sv;\n        cin &gt;&gt; su &gt;&gt; sv;\n        int u = rev[su], v = rev[sv];\n        if (u &gt; v) swap(u, v);\n        if (u == 1 &amp;&amp; v == n) {\n            flag = true;\n        }\n        mcf.add(n + u, v, 1, 0);\n    }\n    auto [flow, cost] = mcf.work(s, t);\n    cost = -cost;\n    if (flow == 1 &amp;&amp; flag) {\n        cout &lt;&lt; 2 &lt;&lt; \"\\n\";\n        cout &lt;&lt; a[1] &lt;&lt; \"\\n\" &lt;&lt; a[n] &lt;&lt; \"\\n\" &lt;&lt; a[1] &lt;&lt; \"\\n\";\n    } else if (flow == 2) {\n        cout &lt;&lt; cost - 2 &lt;&lt; \"\\n\";\n        vector&lt;bool&gt; vis(2 * n + 1);\n        function&lt;void(int)&gt; dfs = [&amp;](int u) {\n            vis[u] = true;\n            cout &lt;&lt; a[u - n] &lt;&lt; \"\\n\";\n            for (auto &amp;idx : mcf.adj[u]) {\n                auto [to, flow, cost] = mcf.edges[idx];\n                if (to == u - n) continue;\n                if (flow != 0) continue;\n                if (to &gt; n) continue;\n                dfs(to + n);\n                break;\n            }\n        };\n        dfs(1 + n);\n        dfs = [&amp;](int u) {\n            for (auto &amp;idx : mcf.adj[u]) {\n                auto [to, flow, cost] = mcf.edges[idx];\n                if (to == u - n) continue;\n                if (vis[to + n]) continue;\n                if (flow != 0) continue;\n                if (to &gt; n) continue;\n                dfs(to + n);\n                break;\n            }\n            cout &lt;&lt; a[u - n] &lt;&lt; \"\\n\";\n        };\n        dfs(1 + n);\n    } else {\n        cout &lt;&lt; \"No Solution!\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/flow/max-flow/","title":"\u6700\u5927\u6d41","text":"\u4f8b\u9898 <p>#101. \u6700\u5927\u6d41 - LibreOJ</p> Edmonds-Karp \\(O(n*m^2)\\)Dinic \\(O(n^2*m)\\) \u4ee3\u7801 C++<pre><code>template &lt;class T&gt;\nstruct Flow {\n    const int n;\n    vector&lt;pair&lt;int, T&gt;&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;pair&lt;int, int&gt;&gt; pre;\n    vector&lt;T&gt; f;\n    Flow(int n) : n(n), adj(n) {}\n    T bfs(int s, int t) {\n        pre.assign(n, {-1, -1});\n        f.assign(n, 0);\n        f[s] = numeric_limits&lt;T&gt;::max();\n        queue&lt;int&gt; que;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            if (u == t) {\n                break;\n            }\n            for (auto &amp;idx : adj[u]) {\n                auto [to, w] = edges[idx];\n                if (to == s) continue;\n                if (w &lt;= 0) continue;\n                if (pre[to].second != -1) continue;\n                pre[to] = {idx, u};\n                f[to] = min(f[u], w);\n                que.push(to);\n            }\n        }\n        if (pre[t].second == -1) return -1;\n        return f[t];\n    }\n    void add(int u, int v, T c) {\n        adj[u].push_back(edges.size());\n        edges.push_back({v, c});\n        adj[v].push_back(edges.size());\n        edges.push_back({u, 0});\n    }\n\n    T edmondsKarp(int s, int t) {\n        T ans = 0;\n        while (true) {\n            T flow = bfs(s, t);\n            if (flow == -1) {\n                break;\n            }\n            int cur = t;\n            while (cur != s) {\n                auto [idx, fa] = pre[cur];\n                edges[idx].second -= flow;\n                edges[idx ^ 1].second += flow;\n                cur = fa;\n            }\n            ans += flow;\n        }\n        return ans;\n    }\n}; // Flow\n</code></pre> \u4ee3\u7801 C++<pre><code>template &lt;class T&gt;\nstruct Flow {\n    const int n;\n    vector&lt;pair&lt;int, T&gt;&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;int&gt; cur, dep;\n    Flow(int n) : n(n), adj(n) {}\n    bool bfs(int s, int t) {\n        dep.assign(n, -1);\n        queue&lt;int&gt; q;\n        dep[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (auto &amp;idx : adj[u]) {\n                auto [to, w] = edges[idx];\n                if (w &gt; 0 &amp;&amp; dep[to] == -1) {\n                    dep[to] = dep[u] + 1;\n                    if (to == t) {\n                        return true;\n                    }\n                    q.push(to);\n                }\n            }\n        }\n        return false;\n    }\n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        T res = f;\n        for (int &amp;i = cur[u] ; i &lt; (int) adj[u].size() ; i++) {\n            int idx = adj[u][i];\n            auto [to, w] = edges[idx];\n            if (w &gt; 0 and dep[to] == dep[u] + 1) {\n                T out = dfs(to, t, min(res, w));\n                edges[idx].second -= out;\n                edges[idx ^ 1].second += out;\n                res -= out;\n                if (res == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - res;\n    }\n    void add(int u, int v, T c) {\n        adj[u].push_back(edges.size());\n        edges.push_back({v, c});\n        adj[v].push_back(edges.size());\n        edges.push_back({u, 0});\n    }\n\n    T dinic(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, numeric_limits&lt;T&gt;::max());\n        }\n        return ans;\n    }\n}; // Flow\n</code></pre>"},{"location":"template/graph/flow/min-cut/","title":"\u6700\u5c0f\u5272","text":"\u4e60\u9898 \u6d1b\u8c37P2762\u6d1b\u8c37P1361 <p>P2762 \u592a\u7a7a\u98de\u884c\u8ba1\u5212\u95ee\u9898 - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u5b9e\u9a8c \\(m\\) \u4e2a\u4eea\u5668, \u505a\u7b2c \\(i\\) \u4e2a\u5b9e\u9a8c\u9700\u8981\u82e5\u5e72\u4e2a\u4eea\u5668, \u5956\u91d1 \\(p_i\\).</p> <p>\u8d2d\u4e70\u7b2c \\(i\\) \u4e2a\u4eea\u5668\u9700\u8981 \\(w_i\\), \u6c42\u6700\u5927\u51c0\u6536\u76ca, \u4ee5\u53ca\u5177\u4f53\u65b9\u6848.</p> <p></p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate &lt;class T&gt;\nstruct Flow {\n    const int n;\n    vector&lt;pair&lt;int, T&gt;&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;int&gt; cur, dep;\n    Flow(int n) : n(n), adj(n) {}\n    bool bfs(int s, int t) {\n        dep.assign(n, -1);\n        queue&lt;int&gt; q;\n        dep[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (auto &amp;idx : adj[u]) {\n                auto [to, w] = edges[idx];\n                if (w &gt; 0 &amp;&amp; dep[to] == -1) {\n                    dep[to] = dep[u] + 1;\n                    if (to == t) {\n                        return true;\n                    }\n                    q.push(to);\n                }\n            }\n        }\n        return false;\n    }\n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        T res = f;\n        for (int &amp;i = cur[u] ; i &lt; (int) adj[u].size() ; i++) {\n            int idx = adj[u][i];\n            auto [to, w] = edges[idx];\n            if (w &gt; 0 and dep[to] == dep[u] + 1) {\n                T out = dfs(to, t, min(res, w));\n                edges[idx].second -= out;\n                edges[idx ^ 1].second += out;\n                res -= out;\n                if (res == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - res;\n    }\n    void add(int u, int v, T c) {\n        adj[u].push_back(edges.size());\n        edges.push_back({v, c});\n        adj[v].push_back(edges.size());\n        edges.push_back({u, 0});\n    }\n\n    T dinic(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, numeric_limits&lt;T&gt;::max());\n        }\n        return ans;\n    }\n}; // Flow\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    Flow&lt;i64&gt; flow(n + m + 5);\n    i64 ans = 0;\n    int s = n + m + 1, t = n + m + 2;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        i64 value;\n        cin &gt;&gt; value;\n        ans += value;\n        flow.add(s, i, value);\n        string str;\n        getline(cin, str);\n        stringstream ss(str);\n        while (ss &gt;&gt; value) {\n            flow.add(i, n + value, numeric_limits&lt;i64&gt;::max());\n        }\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        i64 cost;\n        cin &gt;&gt; cost;\n        flow.add(n + i, t, cost);\n    }\n    ans -= flow.dinic(s, t);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (flow.dep[i] &gt; 0) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n    for (int i = 1 ; i &lt;= m ; i++) {\n        if (flow.dep[n + i] &gt; 0) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P1361 \u5c0fM\u7684\u4f5c\u7269 - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u4f5c\u7269, \u7b2c \\(i\\) \u4e2a\u4f5c\u7269\u79cd\u690d\u5728 \\(A\\) \u53ef\u5f97\u6536\u76ca \\(a_i\\), \u79cd\u690d\u5728 \\(B\\) \u53ef\u5f97\u6536\u76ca \\(b_i\\)</p> <p>\u6709 \\(m\\) \u79cd\u7ec4\u5408, \u7ec4\u5408\u5185\u7684\u4f5c\u7269\u5171\u540c\u79cd\u5728 \\(A\\) \u53ef\u6536\u76ca \\(c_1\\), \u5171\u540c\u79cd\u5728 \\(B\\) \u53ef\u6536\u76ca \\(c_2\\), \u6c42\u6700\u5927\u6536\u76ca.</p> <p></p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate &lt;class T&gt;\nstruct Flow {\n    const int n;\n    vector&lt;pair&lt;int, T&gt;&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    vector&lt;int&gt; cur, dep;\n    Flow(int n) : n(n), adj(n) {}\n    bool bfs(int s, int t) {\n        dep.assign(n, -1);\n        queue&lt;int&gt; q;\n        dep[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (auto &amp;idx : adj[u]) {\n                auto [to, w] = edges[idx];\n                if (w &gt; 0 &amp;&amp; dep[to] == -1) {\n                    dep[to] = dep[u] + 1;\n                    if (to == t) {\n                        return true;\n                    }\n                    q.push(to);\n                }\n            }\n        }\n        return false;\n    }\n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        T res = f;\n        for (int &amp;i = cur[u] ; i &lt; (int) adj[u].size() ; i++) {\n            int idx = adj[u][i];\n            auto [to, w] = edges[idx];\n            if (w &gt; 0 and dep[to] == dep[u] + 1) {\n                T out = dfs(to, t, min(res, w));\n                edges[idx].second -= out;\n                edges[idx ^ 1].second += out;\n                res -= out;\n                if (res == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - res;\n    }\n    void add(int u, int v, T c) {\n        adj[u].push_back(edges.size());\n        edges.push_back({v, c});\n        adj[v].push_back(edges.size());\n        edges.push_back({u, 0});\n    }\n\n    T dinic(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, numeric_limits&lt;T&gt;::max());\n        }\n        return ans;\n    }\n}; // Flow\nint a[1005], b[1005];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        ans += a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; b[i];\n        ans += b[i];\n    }\n    int m;\n    cin &gt;&gt; m;\n    Flow&lt;i64&gt; flow(n + 2 * m + 4);\n    int s = n + 1, t = n + 2;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        flow.add(s, i, a[i]);\n        flow.add(i, t, b[i]);\n    }\n    int x1 = n + 3; // \u5728 A \u7684\u7ec4\u5408\n    int x2 = n + 3 + m; // \u5728 B \u7684\u7ec4\u5408\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int k, c1, c2;\n        cin &gt;&gt; k &gt;&gt; c1 &gt;&gt; c2;\n        flow.add(s, x1 + i, c1);\n        flow.add(x2 + i, t, c2);\n        ans += c1 + c2;\n        for (int j = 0 ; j &lt; k ; j++) {\n            int x;\n            cin &gt;&gt; x;\n            flow.add(x1 + i, x, numeric_limits&lt;i64&gt;::max());\n            flow.add(x, x2 + i, numeric_limits&lt;i64&gt;::max());\n        }\n    }\n    cout &lt;&lt; ans - flow.dinic(s, t);\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/tree/heavy-light%20decomposition/","title":"\u6811\u94fe\u5256\u5206","text":"\u6a21\u7248 C++<pre><code>const int N = 100005;\nvector&lt;int&gt; adj[N];\nint low[N], son[N], fa[N], deep[N];\nint top[N], dfn[N], revdfn[N], tot;\nvoid dfs1(int u, int p) {\n    deep[u] = deep[p] + 1;\n    fa[u] = p;\n    low[u] = -1;\n    son[u] = 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs1(to, u);\n        son[u] += son[to];\n        if (low[u] == -1 || son[to] &gt; son[low[u]]) {\n            low[u] = to;\n        }\n    }\n}\nvoid dfs2(int u, int p) {\n    top[u] = p;\n    dfn[u] = ++tot;\n    revdfn[tot] = u;\n    if (low[u] == -1) {\n        return;\n    }\n    dfs2(low[u], p);\n    for (auto &amp;to : adj[u]) {\n        if (to == low[u] || to == fa[u]) {\n            continue;\n        }\n        dfs2(to, to);\n    }\n}\nint LCA(int x, int y) {\n    while (top[x] != top[y]) {\n        if (deep[top[x]] &lt; deep[top[y]]) {\n            swap(x, y);\n        }\n        x = fa[top[x]];\n    }\n    if (deep[x] &gt; deep[y]) {\n        swap(x, y);\n    }\n    return x;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3384 <p>P3384 \u3010\u6a21\u677f\u3011\u91cd\u94fe\u5256\u5206/\u6811\u94fe\u5256\u5206 - \u6d1b\u8c37</p> <p>\u64cd\u4f5c\u4e00, \u6811\u4e0a\u4e24\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c\u52a0</p> <p>\u64cd\u4f5c\u4e8c, \u67e5\u8be2\u6811\u4e0a\u4e24\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c\u4e4b\u548c</p> <p>\u64cd\u4f5c\u4e09, \u6811\u4e0a\u4ee5\u67d0\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u5185\u7684\u8282\u70b9\u52a0</p> <p>\u64cd\u4f5c\u56db, \u67e5\u8be2\u6811\u4e0a\u4ee5\u67d0\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6743\u503c\u548c</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 100005;\nvector&lt;int&gt; adj[N];\nint low[N], son[N], fa[N], deep[N];\nint top[N], dfn[N], revdfn[N], tot;\nvoid dfs1(int u, int p) {\n    deep[u] = deep[p] + 1;\n    fa[u] = p;\n    low[u] = -1;\n    son[u] = 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs1(to, u);\n        son[u] += son[to];\n        if (low[u] == -1 || son[to] &gt; son[low[u]]) {\n            low[u] = to;\n        }\n    }\n}\nvoid dfs2(int u, int p) {\n    top[u] = p;\n    dfn[u] = ++tot;\n    revdfn[tot] = u;\n    if (low[u] == -1) {\n        return;\n    }\n    dfs2(low[u], p);\n    for (auto &amp;to : adj[u]) {\n        if (to == low[u] || to == fa[u]) {\n            continue;\n        }\n        dfs2(to, to);\n    }\n}\nint LCA(int x, int y) {\n    while (top[x] != top[y]) {\n        if (deep[top[x]] &lt; deep[top[y]]) {\n            swap(x, y);\n        }\n        x = fa[top[x]];\n    }\n    if (deep[x] &gt; deep[y]) {\n        swap(x, y);\n    }\n    return x;\n}\nint a[N];\nint P;\nstruct Node {\n    int L, R;\n    i64 sum;\n} tr[N &lt;&lt; 2];\ni64 lazy[N &lt;&lt; 2];\nvoid pushup(int p) {\n    tr[p].sum = (tr[p &lt;&lt; 1].sum + tr[p &lt;&lt; 1 | 1].sum) % P;\n}\nvoid pushtag(int p, i64 k) {\n    tr[p].sum = (tr[p].sum + (tr[p].R - tr[p].L + 1) * k % P) % P;\n    lazy[p] = (lazy[p] + k) % P;\n}\nvoid pushdown(int p) {\n    if (lazy[p] != 0) {\n        pushtag(p &lt;&lt; 1, lazy[p]);\n        pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n        lazy[p] = 0;\n    }\n}\nvoid build(int p, int L, int R) {\n    tr[p].L = L;\n    tr[p].R = R;\n    if (L == R) {\n        tr[p].sum = a[revdfn[L]];\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    pushup(p);\n}\nvoid modify(int p, int QL, int QR, i64 k) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        pushtag(p, k);\n        return;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) {\n        modify(p &lt;&lt; 1, QL, QR, k);\n    }\n    if (QR &gt;= mid + 1) {\n        modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    }\n    pushup(p);\n}\ni64 query(int p, int QL, int QR) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        return tr[p].sum;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    i64 res = 0;\n    if (QL &lt;= mid) {\n        res = (res + query(p &lt;&lt; 1, QL, QR)) % P;\n    }\n    if (QR &gt;= mid + 1) {\n        res = (res + query(p &lt;&lt; 1 | 1, QL, QR)) % P;\n    }\n    return res;\n}\nvoid addPath(int x, int y, int k) {\n    while (top[x] != top[y]) {\n        if (deep[top[x]] &lt; deep[top[y]]) {\n            swap(x, y);\n        }\n        modify(1, dfn[top[x]], dfn[x], k);\n        x = fa[top[x]];\n    }\n    if (deep[x] &gt; deep[y]) {\n        swap(x, y);\n    }\n    modify(1, dfn[x], dfn[y], k);\n}\ni64 queryPath(int x, int y) {\n    i64 res = 0;\n    while (top[x] != top[y]) {\n        if (deep[top[x]] &lt; deep[top[y]]) {\n            swap(x, y);\n        }\n        res = (res + query(1, dfn[top[x]], dfn[x])) % P;\n        x = fa[top[x]];\n    }\n    if (deep[x] &gt; deep[y]) {\n        swap(x, y);\n    }\n    res = (res + query(1, dfn[x], dfn[y])) % P;\n    return res;\n}\nvoid addSon(int x, int k) {\n    modify(1, dfn[x], dfn[x] + son[x] - 1, k);\n}\ni64 querySon(int x) {\n    return query(1, dfn[x], dfn[x] + son[x] - 1);\n}\nint main() {\n    int n, m, rt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; P;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs1(rt, 0);\n    dfs2(rt, rt);\n    build(1, 1, n);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int x, y, z;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n            addPath(x, y, z);\n        } else if (op == 2) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            cout &lt;&lt; queryPath(x, y) % P &lt;&lt; \"\\n\";\n        } else if (op == 3) {\n            int x, z;\n            cin &gt;&gt; x &gt;&gt; z;\n            addSon(x, z);\n        } else {\n            int x;\n            cin &gt;&gt; x;\n            cout &lt;&lt; querySon(x) % P &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/tree/lowest-common-ancestor/","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148","text":""},{"location":"template/graph/tree/lowest-common-ancestor/#_2","title":"\u500d\u589e","text":"\u6a21\u7248 \u6811\u4e0a\u500d\u589e\u6b27\u62c9\u5e8fst\u8868 <p>\u9884\u5904\u7406 \\(O(n*\\log n)\\)\uff0c\u67e5\u8be2 \\(O(\\log n)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 500005;\nvector&lt;int&gt; adj[N];\nint fa[N][22], deep[N];\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; i &lt;= 21 ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, rt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(rt, 0);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; LCA(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>\u9884\u5904\u7406 \\(O(n*\\log n)\\)\uff0c\u67e5\u8be2 \\(O(1)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 500005;\nvector&lt;int&gt; adj[N];\nint fa[N &lt;&lt; 1][22], dfn[N], deep[N], tot, que[N &lt;&lt; 1], lg[N &lt;&lt; 1];\nvoid dfs(int u, int p) {\n    dfn[u] = ++tot;\n    que[tot] = u;\n    deep[u] = deep[p] + 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        que[++tot] = u;\n    }\n}\nvoid initLCA() {\n    lg[0] = -1;\n    for (int i = 1 ; i &lt;= tot ; i++) {\n        fa[i][0] = que[i];\n        lg[i] = lg[i &gt;&gt; 1] + 1;\n    }\n    for (int j = 1 ; j &lt;= 21 ; j++) {\n        for (int i = 1 ; i + (1 &lt;&lt; j) &lt;= tot ; i++) {\n            int x = fa[i][j - 1], y = fa[i + (1 &lt;&lt; j - 1)][j - 1];\n            fa[i][j] = deep[x] &lt; deep[y] ? x : y;\n        }\n    }\n}\nint LCA(int x, int y) {\n    if (dfn[x] &gt; dfn[y]) swap(x, y);\n    x = dfn[x];\n    y = dfn[y];\n    int k = lg[y - x + 1];\n    x = fa[x][k];\n    y = fa[y - (1 &lt;&lt; k) + 1][k];\n    return deep[x] &lt; deep[y] ? x : y;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, rt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(rt, 0);\n    initLCA();\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; LCA(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3379 <p>P3379 \u3010\u6a21\u677f\u3011\u6700\u8fd1\u516c\u5171\u7956\u5148\uff08LCA\uff09 - \u6d1b\u8c37</p>"},{"location":"template/graph/tree/tree-divide/","title":"\u6811\u5206\u6cbb","text":"\u4f8b\u9898 \u6d1b\u8c37P3806\u6d1b\u8c37P4178\u6d1b\u8c37P2634\u6d1b\u8c37P5306\u6d1b\u8c37P3060 <p>P3806 \u3010\u6a21\u677f\u3011\u70b9\u5206\u6cbb 1 - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2\u662f\u5426\u5b58\u5728\u8ddd\u79bb\u4e3a \\(k\\) \u7684\u70b9\u5bf9</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;array&lt;int, 2&gt;&gt; adj[10005];\nint son[10005], dp[10005];\nbool vis[10005];\nint rt, sumn;\nvoid root(int u, int p) { // \u6c42\u91cd\u5fc3\u5e76\u8bbe\u4e3a\u6839\n    dp[u] = 0;\n    son[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        root(to, u);\n        son[u] += son[to];\n        dp[u] = max(dp[u], son[to]);\n    }\n    dp[u] = max(dp[u], sumn - son[u]);\n    if(dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint dist[10005], rev[10005], tot;\nbool flag[10000005];\nint q[105], ans[105];\nint st[10005];\nint n, m;\nvoid update(int u, int p) { // \u66f4\u65b0\u5b50\u6811\u4fe1\u606f\n    if (dist[u] &lt;= 10000000) { // \u53ea\u9700\u8981\u5230\u6839\u8282\u70b9\u8ddd\u79bb&lt;=10^7\u7684\u70b9\n        rev[++tot] = dist[u];\n    }\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = dist[u] + w;\n        update(to, u);\n    }\n}\nvoid work(int u) {\n    int top = 0;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        tot = 0;\n        dist[to] = w;\n        update(to, u);\n        for (int i = 1 ; i &lt;= tot ; i++) { // \u904d\u5386\u5b50\u6811\n            for (int j = 1 ; j &lt;= m ; j++) { // \u904d\u5386\u6240\u6709\u67e5\u8be2\n                if (q[j] &gt;= rev[i]) {\n                    ans[j] |= flag[q[j] - rev[i]];\n                }\n            }\n        }\n        for (int i = 1 ; i &lt;= tot ; i++) { // \u8bb0\u5f55\u5b50\u6811 to \u7684\u8ddd\u79bb\n            st[++top] = rev[i];\n            flag[rev[i]] = true;\n        }\n    }\n    for (int i = 1 ; i &lt;= top ; i++) { // \u6e05\u7a7a\u5f53\u524d\u6240\u6709\u64cd\u4f5c\n        flag[st[i]] = false;\n    }\n}\nvoid divide(int u) {\n    vis[u] = flag[0] = true;\n    dist[u] = 0;\n    work(u); // \u5bf9\u70b9 u \u6c42\u89e3\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        sumn = son[to];\n        dp[0] = n;\n        rt = 0;\n        root(to, u); // \u67e5\u8be2\u5b50\u6811 to \u7684\u91cd\u5fc3\n        divide(rt); // \u70b9\u5206\u6cbb\n    }\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n    }\n    dp[0] = sumn = n;\n    root(1, 0); // \u521d\u59cb\u5316\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; q[i];\n    }\n    divide(rt); // \u70b9\u5206\u6cbb\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cout &lt;&lt; (ans[i] ? \"AYE\" : \"NAY\") &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P4178 Tree - \u6d1b\u8c37</p> <p>\u6c42\u6811\u4e0a\u70b9\u5bf9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e \\(k\\) \u7684\u6570\u91cf</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;array&lt;int, 2&gt;&gt; adj[40005];\nint son[40005], dp[40005];\nbool vis[40005];\nint rt, sumn;\nvoid root(int u, int p) { // \u6c42\u91cd\u5fc3\u5e76\u8bbe\u4e3a\u6839\n    dp[u] = 0;\n    son[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        root(to, u);\n        son[u] += son[to];\n        dp[u] = max(dp[u], son[to]);\n    }\n    dp[u] = max(dp[u], sumn - son[u]);\n    if(dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint dist[40005], rev[40005], tot;\nint k, ans;\nint n;\nvoid update(int u, int p) {  // \u66f4\u65b0\u5b50\u6811\u4fe1\u606f\n    if (dist[u] &lt;= k) { // \u53ea\u9700\u8981\u5230\u6839\u8282\u70b9\u8ddd\u79bb&lt;=k\u7684\u70b9\n        rev[++tot] = dist[u];\n    }\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = dist[u] + w;\n        update(to, u);\n    }\n}\nint work(int u, int w) {\n    tot = 0;\n    update(u, 0); // \u66f4\u65b0\u8ddd\u79bb\n    sort(rev + 1, rev + tot + 1); // \u6392\u5e8f\u53cc\u6307\u9488\u6c42\u89e3\n    int L = 1, R = tot, res = 0;\n    while (L &lt;= R) {\n        if (rev[L] + rev[R] &lt;= k) {\n            res += R - L;\n            L++;\n        } else {\n            R--;\n        }\n    }\n    return res;\n}\nvoid divide(int u) {\n    vis[u] = true;\n    dist[u] = 0;\n    ans += work(u, 0); // \u8ba1\u7b97\u70b9 u \u7684\u7b54\u6848\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        dist[to] = w;\n        ans -= work(to, w); // \u5bf9\u70b9 to \u5bb9\u65a5, \u5220\u53bb\u91cd\u590d\u8ba1\u7b97\u7684\u70b9\n        sumn = son[to];\n        dp[0] = n;\n        rt = 0;\n        root(to, u); // \u67e5\u8be2\u5b50\u6811 to \u7684\u91cd\u5fc3\n        divide(rt); // \u70b9\u5206\u6cbb\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n    }\n    dp[0] = sumn = n;\n    root(1, 0); // \u521d\u59cb\u5316\n    cin &gt;&gt; k;\n    divide(rt); // \u70b9\u5206\u6cbb\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>\u6c42\u6811\u4e0a\u70b9\u5bf9\u8ddd\u79bb\u4e3a \\(3\\) \u7684\u500d\u6570\u7684\u6570\u91cf</p> <p>P2634 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u806a\u806a\u53ef\u53ef - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;array&lt;int, 2&gt;&gt; adj[40005];\nint son[40005], dp[40005];\nbool vis[40005];\nint rt, sumn;\nvoid root(int u, int p) { // \u6c42\u91cd\u5fc3\u5e76\u8bbe\u4e3a\u6839\n    dp[u] = 0;\n    son[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        root(to, u);\n        son[u] += son[to];\n        dp[u] = max(dp[u], son[to]);\n    }\n    dp[u] = max(dp[u], sumn - son[u]);\n    if(dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint dist[40005], s[3], tot;\nint ans;\nint n;\nvoid update(int u, int p) {  // \u66f4\u65b0\u5b50\u6811\u4fe1\u606f\n    s[dist[u] % 3]++;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = dist[u] + w;\n        update(to, u);\n    }\n}\nint work(int u) {\n    tot = 0;\n    s[0] = s[1] = s[2] = 0;\n    update(u, 0); // \u66f4\u65b0\u8ddd\u79bb\n    return s[2] * s[1] * 2 + s[0] * s[0];\n}\nvoid divide(int u) {\n    vis[u] = true;\n    dist[u] = 0;\n    ans += work(u); // \u8ba1\u7b97\u70b9 u \u7684\u7b54\u6848\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        dist[to] = w;\n        ans -= work(to); // \u5bf9\u70b9 to \u5bb9\u65a5, \u5220\u53bb\u91cd\u590d\u8ba1\u7b97\u7684\u70b9\n        sumn = son[to];\n        dp[0] = n;\n        rt = 0;\n        root(to, u); // \u67e5\u8be2\u5b50\u6811 to \u7684\u91cd\u5fc3\n        divide(rt); // \u70b9\u5206\u6cbb\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n    }\n    dp[0] = sumn = n;\n    root(1, 0); // \u521d\u59cb\u5316\n    divide(rt); // \u70b9\u5206\u6cbb\n    int fm = n * n;\n    int k = __gcd(ans, fm);\n    ans /= k;\n    fm /= k;\n    cout &lt;&lt; ans &lt;&lt; \"/\" &lt;&lt; fm &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P5306 [COCI2018-2019#5] Transport - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u57ce\u5e02, \\(n-1\\) \u6761\u8def, \u6bcf\u6761\u8def\u90fd\u6709\u6d88\u8017 \\(w\\) \u5355\u4f4d\u6cb9, \u6bcf\u4e2a\u57ce\u5e02\u90fd\u53ef\u4ee5\u52a0 \\(v\\) \u5355\u4f4d\u6cb9.</p> <p>\u95ee\u6709\u591a\u5c11\u6709\u5e8f\u5bf9 \\((u,v)\\) \u6ee1\u8db3, \u8d77\u59cb\u6cb9\u91cf\u4e3a \\(0\\) \u7684\u8f66, \u53ef\u4ee5\u4ece \\(u\\) \u51fa\u53d1, \u62b5\u8fbe \\(v\\).</p> <p>\u70b9\u5206\u6cbb</p> <p>\u5f53\u4ee5 \\(rt\\) \u4e3a\u6839\u65f6, \\(w_i\\) \u8868\u793a \\(rt\\) \u5230 \\(i\\) \u7684\u70b9\u6743\u548c, \\(d_i\\) \u8868\u793a \\(rt\\) \u5230 \\(i\\) \u7684\u8fb9\u6743\u548c</p> <p>\u2460\u4ece \\(i\\) \u5230 \\(rt\\), \u5bf9\u8def\u5f84\u4e0a\u4efb\u610f\u70b9 \\(j\\) \u90fd\u6709 \\(w_i-w_j\\ge d_i-d_j\\).</p> <p>\u53ef\u4ee5\u628a\u5f0f\u5b50\u5316\u4e3a \\(w_i-d_i-(w_j-d_j)\\ge0\\) \u7b49\u4ef7\u4e8e \\(w_i-d_i-\\max(w_j-d_j)\\ge0\\)</p> <p>\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u5b50\u6811\u4e2d\u6700\u5927\u7684 \\(w_j-d_j\\) \u5373\u53ef.</p> <p>\u2461\u4ece \\(rt\\) \u5230 \\(i\\), \u6b64\u65f6\u8d77\u70b9\u4e0d\u4e00\u5b9a\u662f \\(rt\\), \u53ef\u4ee5\u662f\u5176\u4ed6\u5b50\u6811\u7684\u4e00\u4e2a\u70b9 \\(k\\), \u8bbe\u4ece \\(k\\) \u5230 \\(rt\\) \u5269\u4f59 \\(x\\) \u5355\u4f4d\u6cb9, \u5219 \u5bf9\u8def\u5f84\u4e0a\u4efb\u610f\u70b9 \\(j\\) \u90fd\u6709 \\(x+w_{fa_j}\\ge d_j\\), \u53d8\u6362\u4e00\u4e0b\u5f97 \\(x+w_{fa_j}-d_j\\ge0\\), \u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u5b50\u6811\u4e2d\u7684\u6700\u5c0f\u7684 \\(w_{fa_j}-d_j\\) \u5373\u53ef.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;array&lt;int, 2&gt;&gt; adj[100005];\nint son[100005], dp[100005];\nbool vis[100005];\nint rt, sumn;\nvoid root(int u, int p) { // \u6c42\u91cd\u5fc3\u5e76\u8bbe\u4e3a\u6839\n    dp[u] = 0;\n    son[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        root(to, u);\n        son[u] += son[to];\n        dp[u] = max(dp[u], son[to]);\n    }\n    dp[u] = max(dp[u], sumn - son[u]);\n    if(dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\ni64 d[100005], w[100005];\ni64 st1[100005], tot1, st2[100005], tot2;\nint n;\nint a[100005];\nvoid update(int u, int p, i64 mx, i64 mi) { // \u66f4\u65b0\u5b50\u6811\u4fe1\u606f\n    if (w[u] - d[u] &gt;= mx) { // \u5408\u6cd5\u624d\u8bb0\u5f55\n        st1[++tot1] = w[u] - d[u];\n    }\n    st2[++tot2] = mi;\n    for (auto &amp;[to, z] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        d[to] = d[u] + z;\n        w[to] = w[u] + a[to];\n        update(to, u, max(mx, w[u] - d[u]), min(mi, w[u] - d[to]));\n    }\n}\ni64 st3[100005], tot3, st4[100005], tot4;\ni64 ans = 0;\nvoid work(int u) {\n    tot3 = tot4 = 0;\n    d[u] = 0;\n    w[u] = a[u];\n    for (auto &amp;[to, z] : adj[u]) {\n        if (vis[to]) continue;\n        tot1 = tot2 = 0;\n        d[to] = z;\n        w[to] = w[u] + a[to];\n        update(to, u, w[u] - d[u], w[u] - d[to]);\n        sort(st1 + 1, st1 + tot1 + 1);\n        sort(st2 + 1, st2 + tot2 + 1);\n        int L = 1;\n        for (int i = tot2 ; i &gt;= 1 ; i--) {\n            while (L &lt;= tot1 &amp;&amp; st1[L] + st2[i] - a[u] &lt; 0) {\n                L++;\n            }\n            ans -= tot1 - L + 1;\n        }\n        for (int i = 1 ; i &lt;= tot1 ; i++) {\n            st3[++tot3] = st1[i];\n        }\n        for (int i = 1 ; i &lt;= tot2 ; i++) {\n            st4[++tot4] = st2[i];\n        }\n    }\n    sort(st3 + 1, st3 + tot3 + 1);\n    sort(st4 + 1, st4 + tot4 + 1);\n    int L = 1;\n    for (int i = tot4 ; i &gt;= 1 ; i--) {\n        if (st4[i] &gt;= 0) {\n            ans++;\n        }\n        while (L &lt;= tot3 &amp;&amp; st3[L] + st4[i] - a[u] &lt; 0) {\n            L++;\n        }\n        ans += tot3 - L + 1;\n    }\n    ans += tot3;\n}\nvoid divide(int u) {\n    vis[u] = true;\n    work(u); // \u5bf9\u70b9 u \u6c42\u89e3\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        sumn = son[to];\n        dp[0] = n;\n        rt = 0;\n        root(to, u); // \u67e5\u8be2\u5b50\u6811 to \u7684\u91cd\u5fc3\n        divide(rt); // \u70b9\u5206\u6cbb\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n    }\n    dp[0] = sumn = n;\n    root(1, 0); // \u521d\u59cb\u5316\n    divide(rt); // \u70b9\u5206\u6cbb\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P3060 [USACO12NOV] Balanced Trees G - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u70b9\u7684\u6811, \u6bcf\u4e2a\u70b9\u6709\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7, \u5728\u4e00\u6761\u7b80\u5355\u8def\u5f84\u7684\u62ec\u53f7\u80fd\u5339\u914d\u7684\u60c5\u51b5\u4e0b, \u6700\u5927\u5d4c\u5957\u5c42\u6570\u662f\u591a\u5c11?</p> <p>\u8003\u8651\u4ece \\(i\\) \u5230 \\(rt\\), \u6709\u4e24\u79cd, \u6b64\u65f6\u8bb0\u5de6\u62ec\u53f7\u6743\u503c\u4e3a \\(1\\), \u53f3\u62ec\u53f7\u6743\u503c\u4e3a \\(-1\\)</p> <p>\u2460\u4ee5\u5de6\u62ec\u53f7\u5f00\u5934, \u7b26\u5408\u6761\u4ef6\u7684\u4e00\u5b9a\u8981\u6bcf\u4e2a\u524d\u7f00\u90fd \\(ge0\\), \u6211\u4eec\u9700\u8981\u7ef4\u62a4\u8fd9\u4e2a\u524d\u7f00\u7684\u6700\u5c0f\u503c \\(Lmi\\), \u6bcf\u6b21\u53d6 \\(\\min(Lmi+a_{to},0)\\) \u5373\u53ef. \u4e3a\u4e86\u8ba1\u7b97\u7b54\u6848\u6211\u4eec\u9700\u8981\u5de6\u62ec\u53f7\u7684\u6700\u957f\u524d\u7f00 \\(Lmx\\) \u548c\u5de6\u62ec\u53f7\u591a\u7684\u6570\u91cf \\(Ldis\\).</p> <p>\u2461\u4ee5\u53f3\u62ec\u53f7\u5f00\u5934, \u6211\u4eec\u5c06\u524d\u7f00\u7684\u503c\u53d6\u53cd, \u7b26\u5408\u6761\u4ef6\u7684\u4e00\u5b9a\u8981\u6bcf\u4e2a\u524d\u7f00\u90fd \\(ge0\\), \u6211\u4eec\u9700\u8981\u7ef4\u62a4\u8fd9\u4e2a\u524d\u7f00\u7684\u6700\u5c0f\u503c \\(Rmi\\), \u6bcf\u6b21\u53d6 \\(\\min(Rmi-a_{to},0)\\) \u5373\u53ef. \u4e3a\u4e86\u8ba1\u7b97\u7b54\u6848\u6211\u4eec\u9700\u8981\u5de6\u62ec\u53f7\u7684\u6700\u957f\u524d\u7f00 \\(Rmx\\) \u548c\u53f3\u62ec\u53f7\u591a\u7684\u6570\u91cf \\(Rdis\\).</p> <p>\u8003\u8651\u8ba1\u7b97\u7b54\u6848, \u4e00\u5b9a\u662f \\(Ldis=Rdis\\) \u7684\u60c5\u51b5\u4e0b \\(\\max(Lmx,Ldis+Rmx)\\)</p> \u4ee3\u7801 C++<pre><code>            #include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvector&lt;int&gt; adj[40005];\nint son[40005], dp[40005];\nbool vis[40005];\nint rt, sumn;\nvoid root(int u, int p) { // \u6c42\u91cd\u5fc3\u5e76\u8bbe\u4e3a\u6839\n    dp[u] = 0;\n    son[u] = 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        root(to, u);\n        son[u] += son[to];\n        dp[u] = max(dp[u], son[to]);\n    }\n    dp[u] = max(dp[u], sumn - son[u]);\n    if(dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint n;\nint a[40005];\narray&lt;int, 2&gt; st1[40005], st2[40005];\nint tot1, tot2;\narray&lt;int, 2&gt; flag[40005];\nvoid update(int u, int p, int Ldis, int Rdis, int Lmx, int Rmx, int Lmi, int Rmi) { // \u66f4\u65b0\u5b50\u6811\u4fe1\u606f\n    // Ldis \u4e3a\u5de6\u94fe \u5de6\u62ec\u53f7\u591a\u7684\u6570\u91cf\n    // Rdis \u4e3a\u53f3\u94fe \u53f3\u62ec\u53f7\u591a\u7684\u6570\u91cf\n    // Lmx \u4e3a\u5de6\u94fe \u5de6\u62ec\u53f7\u6700\u957f\u524d\u7f00\n    // Rmx \u4e3a\u53f3\u94fe \u5de6\u62ec\u53f7\u6700\u957f\u524d\u7f00\n    // Lmi \u4e3a\u5de6\u94fe \u5de6\u62ec\u53f7\u6700\u5c0f\u524d\u7f00\n    // Rmi \u4e3a\u5de6\u94fe \u53f3\u62ec\u53f7\u6700\u5c0f\u524d\u7f00\n    if (Lmi &gt;= 0) {\n        st1[++tot1] = {Ldis, Lmx};\n    }\n    if (Rmi &gt;= 0) {\n        st2[++tot2] = {Rdis, Rmx};\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        update(to, u, Ldis + a[to], Rdis - a[to], max(Lmx + a[to], a[to]), max(Rmx, -Rdis + a[to]), min(Lmi + a[to], 0), min(Rmi - a[to], 0));\n    }\n}\nint ans = 0;\nvoid work(int u) {\n    tot1 = tot2 = 0;\n    for (auto &amp;to : adj[u]) {\n        if (vis[to]) continue;\n        int last1 = tot1, last2 = tot2;\n        update(to, u, a[to], -(a[u] + a[to]), a[to], max({0, a[u], a[u] + a[to]}), min(a[to], 0), min(-(a[u] + a[to]), 0));\n        for (int i = last2 + 1 ; i &lt;= tot2 ; i++) {\n            if (flag[st2[i][0]][0]) {\n                // flag[st2[i][0]][1] \u4e3a  \u5de6\u94fe\u6700\u957f\u524d\u7f00\n                // st2[i][0] \u4e3a \u5de6\u94fe\u7684\u548c\n                // st2[i][1] \u4e3a \u5de6\u94fe\u6700\u957f\u524d\u7f00\n                ans = max({ans, flag[st2[i][0]][1], st2[i][0] + st2[i][1]});\n            }\n        }\n        for (int i = last1 + 1 ; i &lt;= tot1 ; i++) {\n            flag[st1[i][0]][0] = 1;\n            flag[st1[i][0]][1] = max(flag[st1[i][0]][1], st1[i][1]);\n        }\n    }\n    if (a[u] == -1) {\n        ans = max(ans, flag[1][1]);\n    } else {\n        for (int i = 1 ; i &lt;= tot2 ; i++) {\n            if (st2[i][0] == 0) {\n                ans = max(ans, st2[i][1]);\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= tot1 ; i++) {\n        flag[st1[i][0]] = {0, 0};\n    }\n    tot1 = tot2 = 0;\n    for (int _ = (int) adj[u].size() - 1 ; _ &gt;= 0 ; _--) {\n        int to = adj[u][_];\n        if (vis[to]) continue;\n        int last1 = tot1, last2 = tot2;\n        update(to, u, a[to], -(a[u] + a[to]), a[to], max({0, a[u], a[u] + a[to]}), min(a[to], 0), min(-(a[u] + a[to]), 0));\n        for (int i = last2 + 1 ; i &lt;= tot2 ; i++) {\n            if (flag[st2[i][0]][0]) {\n                ans = max({ans, flag[st2[i][0]][1], st2[i][0] + st2[i][1]});\n            }\n        }\n        for (int i = last1 + 1 ; i &lt;= tot1 ; i++) {\n            flag[st1[i][0]][0] = 1;\n            flag[st1[i][0]][1] = max(flag[st1[i][0]][1], st1[i][1]);\n        }\n    }\n    if (a[u] == -1) {\n        ans = max(ans, flag[1][1]);\n    } else {\n        for (int i = 1 ; i &lt;= tot2 ; i++) {\n            if (st2[i][0] == 0) {\n                ans = max(ans, st2[i][1]);\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= tot1 ; i++) {\n        flag[st1[i][0]] = {0, 0};\n    }\n}\nvoid divide(int u) {\n    vis[u] = true;\n    work(u); // \u5bf9\u70b9 u \u6c42\u89e3\n    for (auto &amp;to : adj[u]) {\n        if (vis[to]) continue;\n        sumn = son[to];\n        dp[0] = n;\n        rt = 0;\n        root(to, u); // \u67e5\u8be2\u5b50\u6811 to \u7684\u91cd\u5fc3\n        divide(rt); // \u70b9\u5206\u6cbb\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 2 ; i &lt;= n ; i++) {\n        int p;\n        cin &gt;&gt; p;\n        adj[p].push_back(i);\n        adj[i].push_back(p);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        char ch;\n        cin &gt;&gt; ch;\n        if (ch == '(') {\n            a[i] = 1;\n        } else {\n            a[i] = -1;\n        }\n    }\n    dp[0] = sumn = n;\n    root(1, 0); // \u521d\u59cb\u5316\n    divide(rt); // \u70b9\u5206\u6cbb\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/graph/tree/tree-hash/","title":"\u6811\u54c8\u5e0c","text":"\u6a21\u7248 C++<pre><code>const long long mod = 1000000007;\nconst long long base = std::chrono::steady_clock::now().time_since_epoch().count() % mod + 1;\nlong long get(long long x) {\n    x = x * x % mod;\n    x = (x + base) % mod;\n    x = x * x % mod;\n    return x;\n}\nvector&lt;int&gt; adj[100005];\nlong long hashd[100005];\nlong long dfs(int u, int p) {\n    hashd[u] = 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        auto h = get(dfs(to, u));\n        hashd[u] = (hashd[u] + h) % mod;\n    }\n    return hashd[u];\n}\n</code></pre> \u4f8b\u9898 UOJ763QOJ499 <p>\u6811\u54c8\u5e0c - Universal Online Judge</p> <p>\u6811 Hash - QOJ.ac</p>"},{"location":"template/math/balanced-ternary/","title":"\u5e73\u8861\u4e09\u8fdb\u5236","text":"<p>\u4e5f\u79f0\u4e3a\u5bf9\u79f0\u4e09\u8fdb\u5236\u3002\u6570\u5b57\u7531 -1, 0, 1 \u6784\u6210\u7684\u3002</p> \u6a21\u7248 <p>\u5148\u5c06\u5341\u8fdb\u5236\u8f6c\u5316\u4e3a\u666e\u901a\u4e09\u8fdb\u5236\uff0c\u518d\u4ece\u4f4e\u4f4d\u5f00\u59cb\uff0c\u9047\u5230 2 \u5219 \u6539\u4e3a -1 \u4e14\u5c06\u4e0b\u4e00\u4f4d +1\uff0c\u9047\u5230 3 \u5219 \u6539\u4e3a 0 \u4e14\u5c06\u4e0b\u4e00\u4f4d + 1</p> C++<pre><code>int n;\ncin &gt;&gt; n;\nbool sign = true;\nif (n &lt; 0) {\n    sign = false;\n    n = -n;\n}\nvector&lt;int&gt; nums;\nint temp = n;\nwhile (temp) {\n    nums.emplace_back(temp % 3);\n    temp /= 3;\n}\nnums.emplace_back(0);\nint len = nums.size();\nfor (int i = 0 ; i &lt; len ; i++) {\n    if (nums[i] == 3) {\n        nums[i] = 0;\n        nums[i + 1]++;\n    } else if (nums[i] == 2) {\n        nums[i] = -1;\n        nums[i + 1]++;\n    }\n}\nreverse(begin(nums), end(nums));\nif (sign == false) {\n    for (int i = 0 ; i &lt; len ; i++) {\n        nums[i] = -nums[i];\n    }\n}\nbool has = false;\nfor (int i = 0 ; i &lt; len ; i++) {\n    if (nums[i] == 0) {\n        if (has || i == len - 1) {\n            cout &lt;&lt; nums[i] &lt;&lt; \" \";\n        }\n    } else {\n        has = true;\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n}\n</code></pre> \u4f8b\u9898 <p>U313611 \u3010\u6a21\u677f\u3011\u5e73\u8861\u4e09\u8fdb\u5236 - \u6d1b\u8c37</p>"},{"location":"template/math/berlekamp-massey/","title":"Berlekamp-Massey\u7b97\u6cd5","text":"\u6a21\u7248 \u66b4\u529b\u591a\u9879\u5f0f <p>\u6c42\u89e3\u9012\u63a8 \\(O(n*k)\\)</p> <p>\u67e5\u8be2 \\(O(k^2\\log m)\\)</p> \u4ee3\u7801 C++<pre><code>const i64 P = 998244353;\nnamespace BerlekampMassey {\n    using i64 = long long;\n    vector&lt;int&gt; v, a, d;\n    vector&lt;i64&gt; res, tempc, tempd, base;\n    i64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n        while (b) {\n            if (b &amp; 1) res = res * a % P;\n            a = a * a % P;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    vector&lt;int&gt; berlekamp_massey() {\n        vector&lt;int&gt; v, last;\n        int k = -1, delta = 0;\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            int temp = 0;\n            for (int j = 0 ; j &lt; (int) v.size() ; j++) {\n                temp = (temp + 1LL * a[i - j - 1] * v[j]) % P;\n            }\n            if (a[i] == temp) continue;\n            if (k &lt; 0) {\n                k = i;\n                delta = (a[i] - temp + P) % P;\n                v = vector&lt;int&gt;(i + 1);\n                continue;\n            }\n            vector&lt;int&gt; u = v;\n            i64 val = (a[i] - temp + P) % P * qpow(delta) % P;\n            if ((int) v.size() &lt; (int) last.size() + i - k) {\n                v.resize((int) last.size() + i - k);\n            }\n            v[i - k - 1] = (v[i - k - 1] + val) % P;\n            for (int j = 0 ; j &lt; (int) last.size() ; j++) {\n                v[i - k + j] = (v[i - k + j] - val * last[j] % P + P) % P;\n            }\n            if ((int) u.size() - i &lt; (int) last.size() - k) {\n                last = u;\n                k = i;\n                delta = (a[i] - temp + P) % P;\n            }\n        }\n        return v;\n    }\n    void init(const vector&lt;int&gt; &amp;a) {\n        Linear_Solve::a = a;\n        int n = a.size() + 1;\n        res.assign(n, 0);\n        base.assign(n, 0);\n        tempc.assign(n, 0);\n        tempd.assign(n, 0);\n        v = berlekamp_massey();\n        while (v.size() &gt; 1 &amp;&amp; v.back() == 0) v.pop_back();\n    }\n    void mul(vector&lt;i64&gt; &amp;a, vector&lt;i64&gt; &amp;b, int k) {\n        fill(begin(tempc), begin(tempc) + k * 2, 0);\n        for (int i = 0 ; i &lt; k ; i++) {\n            if (a[i]) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    tempc[i + j] = (tempc[i + j] + a[i] * b[j]) % P;\n                }\n            }\n        }\n        for (int i = (k * 2) - 1 ; i &gt;= k ; i--) {\n            if (tempc[i]) {\n                for (int j = 0 ; j &lt; (int) d.size() ; j++) {\n                    tempc[i - k + d[j]] = (tempc[i - k + d[j]] - tempc[i] * tempd[d[j]] % P + P) % P;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            a[i] = tempc[i];\n        }\n    }\n    i64 get(i64 n) {\n        i64 ans = 0, cnt = 0;\n        int k = v.size();\n        vector&lt;int&gt; b = a;\n        b.resize(k);\n        for (int i = 0 ; i &lt; k ; i++) {\n            tempd[k - 1 - i] = -v[i];\n        }\n        tempd[k] = 1;\n        d.clear();\n        for (int i = 0 ; i &lt; k ; i++) {\n            if (tempd[i]) {\n                d.emplace_back(i);\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            res[i] = base[i] = 0;\n        }\n        res[0] = 1;\n        while (1LL &lt;&lt; cnt &lt;= n) cnt++;\n        for (int i = cnt ; i &gt;= 0 ; i--) {\n            mul(res, res, k);\n            if (n &gt;&gt; i &amp; 1) {\n                for (int j = k - 1 ; j &gt;= 0 ; j--) {\n                    res[j + 1] = res[j];\n                }\n                res[0] = 0;\n                for (auto &amp;j : d) {\n                    res[j] = (res[j] - res[k] * tempd[j]) % P;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            ans = (ans + res[i] * b[i]) % P;\n        }\n        return ans;\n    }\n} // BerlekampMassey\n</code></pre> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> <p>\u67e5\u8be2 \\(O(n\\log n\\log m)\\)</p> \u4ee3\u7801 C++<pre><code>Poly BerlekampMassey(const Poly &amp;a) {\n    int n = a.size();\n    Poly temp(n + 1), f(n + 1), g(n + 1);\n    int k = 0, last_k = 0, last_delta, last = -1;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int delta = P - a[i];\n        for (int j = 1 ; j &lt;= k ; j++) {\n            mod_add(delta, mod_mul_t(f[j], a[i - j]));\n        }\n        if (delta == 0) continue;\n        if (last == -1) {\n            k = i + 1;\n        } else {\n            int t = mod_mul_t(delta, qpow(last_delta));\n            mod_add(temp[i - last], t);\n            for (int j = 1 ; j &lt;= last_k ; j++) {\n                mod_sub(temp[i - last + j], mod_mul_t(t, g[j]));\n            }\n            int p = last_k;\n            last_k = k;\n            k = max(k, i - last + p);\n            for (int j = 1 ; j &lt;= last_k ; j++) {\n                g[j] = f[j];\n            }\n            for (int j = 1 ; j &lt;= k ; j++) {\n                f[j] = temp[j];\n            }\n        }\n        last_delta = delta;\n        last = i;\n    }\n    return f.resize(k + 1), f;\n}\ni64 LinearRec(const Poly &amp;a, const Poly &amp;r, i64 n) {\n    Poly F(begin(a), begin(a) + r.size() - 1), R = -r;\n    R[0] = 1;\n    F *= R;\n    F.resize(R.size() - 1);\n    for ( ; n ; n /= 2) {\n        Poly rR = R;\n        for (int i = 0 ; i &lt; (int) rR.size() ; i += 2) {\n            rR[i] = mod_sub_t(P, rR[i]);\n        }\n        Poly FR = F * rR, RR = R * rR;\n        F.resize(0); R.resize(0);\n        for (int i = (n &amp; 1) ; i &lt; (int) FR.size() ; i+= 2) {\n            F.push_back(FR[i]);\n        }\n        for (int i = 0 ; i &lt; (int) RR.size() ; i += 2) {\n            R.push_back(RR[i]);\n        }\n    }\n    return F.empty() ? 0 : mod_mul_t(F[0],qpow(R[0]));\n}\n</code></pre> \u4f8b\u9898 <p>P5487 \u3010\u6a21\u677f\u3011Berlekamp\u2013Massey \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"template/math/common-formula-theorem/","title":"\u5e38\u89c1\u516c\u5f0f\u53ca\u5b9a\u7406","text":"<p>\\(\\ln(x+1)=\\sum_{n=1}^\\infty\\dfrac{(-1)^{n+1}}{n}x^n\\)</p> <p>\\(\\ln(1-x)=\\sum_{n=1}^\\infty\\dfrac{-1}{n}x^n\\)</p> <p>\\(\\sum_{i=1}^ni^2=\\dfrac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\)</p> <p>\\(\\sum_{i=1}^ni^3=[\\dfrac{n\\cdot(n+1)}{2}]^2\\)</p> <p>\\(\\int_{0}^{1}{\\left(x-x^{2}\\right)^{n}}\\mathrm{d}x=\\sum_{i=0}^n(-1)^n*\\dfrac{C_n^i}{n+i+1}=\\dfrac{(n!)^2}{(2n+1)!}\\)</p>"},{"location":"template/math/game-theory/","title":"\u535a\u5f08\u8bba","text":""},{"location":"template/math/game-theory/#_2","title":"\u5c3c\u59c6\u6e38\u620f","text":"<p>\\(n\\) \u5806\u77f3\u5b50\uff0c\u6bcf\u6b21\u53d6 \\(\\geq1\\) \u9897\uff0c\u53ea\u80fd\u53d6 \\(1\\) \u5806\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6 \\([a_1\\oplus a_2\\oplus...\\oplus a_n==0]\\) </p> <p>\\(n\\) \u5806\u77f3\u5b50\uff0c\u6bcf\u6b21\u53d6 \\([1,m]\\) \u9897\uff0c\u53ea\u80fd\u53d6 \\(1\\) \u5806\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6 \\([\\left(a_1\\mod(m+1)\\oplus a_2\\mod(m+1)\\oplus...\\oplus a_n\\mod(m+1)\\right)==0]\\) </p> <p>\\(n\\) \u5806\u77f3\u5b50\uff0c\u6bcf\u6b21\u53d6 \\(\\geq1\\) \u9897\uff0c\u53ea\u80fd\u53d6 \\([1, k]\\) \u5806\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6 \u5c06 \\(a\\) \u4e8c\u8fdb\u5236\u5206\u89e3\uff0c\u6bcf\u4e00\u4f4d\u7684 \\(1\\) \u7684\u6570\u91cf\u6a21 \\(k+1\\) \u4e3a \\(0\\)</p>"},{"location":"template/math/game-theory/#_3","title":"\u5a01\u4f50\u592b\u6e38\u620f","text":"<p>\\(2\\) \u5806\u77f3\u5b50\uff0c\u6bcf\u6b21\u5728\u4efb\u610f \\(1\\) \u5806\u4e2d\u53d6 \\(\\geq1\\) \u9897\uff0c\u6216\u540c\u65f6\u4ece \\(2\\) \u5806\u4e2d\u90fd\u53d6 \\(\\ge1\\) \u9897\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6\u4e3a \\((\\lfloor\\dfrac{1+\\sqrt{5}}{2}\\cdot{}k\\rfloor,\\lfloor\\dfrac{3+\\sqrt{5}}{2}\\cdot{}k\\rfloor)\\) \\(k\\geq1\\)</p> \u4f8b\u9898 hdu1527hdu2177 <p>Problem - 1527 (hdu.edu.cn)</p> \u4ee3\u7801 C++<pre><code>int a, b;\nwhile (cin &gt;&gt; a &gt;&gt; b) {\n    if (a &gt; b) swap(a, b);\n    int k = (b - a) * (1 + sqrt(5)) / 2;\n    if (a == k) {\n        cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n    } else {\n        cout &lt;&lt; 1 &lt;&lt; \"\\n\";\n    }\n}\n</code></pre> <p>Problem - 2177 (hdu.edu.cn)</p> \u4ee3\u7801 C++<pre><code>int a, b;\nwhile (cin &gt;&gt; a &gt;&gt; b) {\n    if (a == 0) break;\n    if (a &gt; b) swap(a, b);\n    int k = (b - a) * (1 + sqrt(5)) / 2;\n    if (a == k) {\n        cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n    } else {\n        cout &lt;&lt; 1 &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= a ; i++) {\n            int n = a - i, m = b - i;\n            if (n == k) {\n                cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; m &lt;&lt; \"\\n\";\n            }\n        }\n        for (int i = b ; i &gt;= 0 ; i--) {\n            int n = a, m = i;\n            if (n &gt; m) swap(n, m);\n            k = (m - n) * (1 + sqrt(5)) / 2;\n            if (n == k) {\n                cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; m &lt;&lt; \"\\n\";\n            }\n        }\n    }\n}\n</code></pre> <p>\\(2\\) \u5806\u77f3\u5b50\uff0c\u6bcf\u6b21\u5728\u4efb\u610f \\(1\\) \u5806\u4e2d\u53d6 \\(\\geq1\\) \u9897\uff0c\u6216\u5728\u7b2c \\(1\\) \u5806\u62ff \\(x\\) \u9897\uff0c\u5728\u7b2c \\(2\\) \u5806\u62ff \\(y\\) \u9897\uff0c\u4e14 \\(|x-y|&lt; d\\)\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6\u4e3a \\((\\lfloor\\dfrac{2-d+\\sqrt{d^2+4}}{2}\\cdot{}k\\rfloor,\\lfloor\\dfrac{2+d+\\sqrt{d^2+4}}{2}\\cdot{}k\\rfloor)\\)</p> \u4f8b\u9898 hdu6869 <p>Problem - 6869 (hdu.edu.cn)</p>"},{"location":"template/math/game-theory/#_4","title":"\u6590\u6ce2\u90a3\u5951\u535a\u5f08","text":"<p>\\(1\\) \u5806\u77f3\u5b50\uff0c\u5148\u624b\u7b2c\u4e00\u6b21\u53d6 \\([1,n)\\) \u9897\uff0c\u4ee4\u524d\u4e00\u6b21\u53d6\u4e86 \\(m\\) \u9897\uff0c\u63a5\u4e0b\u6765\u6bcf\u6b21\u53d6 \\([1,2*m]\\) \u9897\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6\u4e3a\u6590\u6ce2\u90a3\u5951\u6570\u3002</p>"},{"location":"template/math/game-theory/#_5","title":"\u9636\u68af\u535a\u5f08","text":"<p>\u9636\u68af\u5c3c\u59c6\u535a\u5f08: \\(n\\) \u5806\u77f3\u5934\uff0c\u6bcf\u6b21\u53ef\u4ee5\u53d6\u8d70\u7b2c \\(i\\) \u5806 \\(\\geq1\\) \u9897\u77f3\u5b50\uff0c\u5e76\u653e\u5230 \\(i-1\\) \u5806\uff0c\u5982\u679c\u662f\u7b2c \\(1\\) \u5806\uff0c\u5219\u76f4\u63a5\u53d6\u8d70\u3002\u5148\u624b\u5fc5\u8d25\u6761\u4ef6\u4e3a\u5bf9\u7f16\u53f7\u4e3a\u5947\u6570\u7684\u5806\u505a\u5c3c\u59c6\u6e38\u620f\uff0c\u5373\\([a_1\\oplus a_3\\oplus...\\oplus a_n==0]\\) </p>"},{"location":"template/math/combinatorics/bell/","title":"\u8d1d\u5c14\u6570","text":""},{"location":"template/math/combinatorics/bell/#_2","title":"\u5b9a\u4e49","text":"<p>\\(B_n\\) \u662f\u5c06 \\(n\\) \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u5212\u5206\u4e3a \u4e24\u4e24\u4e0d\u76f8\u4ea4\u7684\u975e\u7a7a\u5b50\u96c6\u7684\u65b9\u6848\u3002</p>"},{"location":"template/math/combinatorics/bell/#_3","title":"\u516c\u5f0f","text":"\\[ \\begin{align} B_{n+1}&amp;=\\sum_{i=0}^nC_n^i*B_i\\\\ B_n&amp;=\\sum_{i=0}^nS_2(n,i) \\end{align} \\] \u6a21\u7248 \u9012\u63a8\\(O(n^2)\\)\u591a\u9879\u5f0f\\(O(n*\\log n)\\) C++<pre><code>for (int i = 1 ; i &lt;= n ; i++) {\n    B[i][0] = B[i - 1][i - 1];\n    for (int j = 1 ; j &lt;= i ; j++) {\n        B[i][j] = B[i - 1][j - 1] + B[i][j - 1];\n    }\n}\n</code></pre> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> C++<pre><code>Poly Bell(int n) {\n    vector&lt;int&gt; fact(n + 1), invfact(n + 1);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        fact[i] = mod_mul_t(fact[i - 1], i);\n    }\n    invfact[n] = qpow(fact[n]);\n    for (int i = n ; i &gt;= 1 ; i--) {\n        invfact[i - 1] = mod_mul_t(invfact[i], i);\n    }\n    Poly a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = invfact[i];\n    }\n    a = Exp(a);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        mod_mul(a[i], fact[i]);\n    }\n    return a;\n}\n</code></pre>"},{"location":"template/math/combinatorics/cantor/","title":"\u5eb7\u6258\u5c55\u5f00","text":""},{"location":"template/math/combinatorics/cantor/#_2","title":"\u5b9a\u4e49","text":"<p>\u6c42\u4e00\u4e2a \\(n\\) \u6392\u5217\u7684\u6392\u4f4d</p>"},{"location":"template/math/combinatorics/cantor/#_3","title":"\u6b63\u5eb7\u6258\u5c55\u5f00","text":"\u6a21\u7248 \u66b4\u529b\u6811\u72b6\u6570\u7ec4 \u4e0d\u53ef\u91cd\u590d\u53ef\u91cd\u590d C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 fact[1000005]; // \u9700\u8981\u9884\u5904\u7406\u9636\u4e58\ni64 cantor(const vector&lt;int&gt; &amp;p) {\n    int n = p.size();\n    i64 rk = 1;\n    vector&lt;int&gt; cnt(n + 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cnt[p[i]]++;\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; p[i] ; j++) {\n            if (cnt[j] == 0) continue;\n            rk = (rk + fact[n - 1 - i]) % P;\n        }\n        cnt[p[i]]--;\n    }\n    return rk;\n}\n</code></pre> C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 fact[1000005]; // \u9700\u8981\u9884\u5904\u7406\u9636\u4e58\ni64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) res = res * a % P;\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 cantor(const vector&lt;int&gt; &amp;p) {\n    int n = p.size();\n    i64 rk = 1;\n    vector&lt;int&gt; cnt(n + 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cnt[p[i]]++;\n    }\n    i64 cur = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cur = cur * cnt[i] % P;\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; p[i] ; j++) {\n            if (cnt[j] == 0) continue;\n            cur = cur * qpow(fact[cnt[j]]);\n            cnt[j]--;\n            cur = cur * fact[cnt[j]];\n            rk = (rk + fact[n - 1 - i] * qpow(cur) % P) % P;\n            cur = cur * qpow(fact[cnt[j]]);\n            cnt[j]++;\n            cur = cur * fact[cnt[j]];\n        }\n        cur = cur * qpow(fact[cnt[p[i]]]);\n        cnt[p[i]]--;\n        cur = cur * fact[cnt[p[i]]];\n    }\n    return rk;\n}\n</code></pre> C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\nusing i64 = long long;\nconst i64 P = 998244353;\ni64 fact[1000005]; // \u9700\u8981\u9884\u5904\u7406\u9636\u4e58\ni64 cantor(const vector&lt;int&gt; &amp;p) {\n    int n = p.size();\n    i64 rk = 1;\n    FenwickTree&lt;int&gt; cnt(n + 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cnt.add(p[i], 1);\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        rk = (rk + fact[n - 1 - i] * cnt.query(p[i] - 1) % P) % P;\n        cnt.add(p[i], -1);\n    }\n    return rk;\n}\n</code></pre>"},{"location":"template/math/combinatorics/cantor/#_4","title":"\u9006\u5eb7\u6258\u5c55\u5f00","text":"\u6a21\u7248(\u5747\u4e3a\u4e0d\u53ef\u91cd\u590d) \u66b4\u529b\u5e73\u8861\u6811 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 fact[1000005]; // \u9700\u8981\u9884\u5904\u7406\u9636\u4e58\nvector&lt;int&gt; decantor(vector&lt;int&gt; p, i64 rk) {\n    rk--;\n    int n = p.size();\n    vector&lt;int&gt; a(n), b(n);\n    sort(begin(p), end(p));\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i] = rk / fact[n - i - 1];\n        rk %= fact[n - i - 1];\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        b[i] = p[a[i]];\n        p.erase(lower_bound(begin(p), end(p), b[i]));\n    }\n    return b;\n}\n</code></pre> C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 fact[1000005]; // \u9700\u8981\u9884\u5904\u7406\u9636\u4e58\nvector&lt;int&gt; decantor(const vector&lt;int&gt; &amp;p, i64 rk) {\n    rk--;\n    int n = p.size();\n    Treap&lt;int&gt; treap(n + 1);\n    vector&lt;int&gt; a(n), b(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        treap.insert(p[i]);\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i] = rk / fact[n - i - 1];\n        rk %= fact[n - i - 1];\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        b[i] = treap.kth(a[i] + 1);\n        treap.erase(b[i]);\n    }\n    return b;\n}\n</code></pre> \u4f8b\u9898 <p>P3014 [USACO11FEB] Cow Line S - \u6d1b\u8c37</p>"},{"location":"template/math/combinatorics/cantor/#_5","title":"\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u7684\u6392\u5217","text":"\u4ee3\u7801 C++<pre><code>// \u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e sum \u7684 f(x) \u7684\u6392\u5217\n// cnt[i] \u4e3a f(x) \u4e2d i \u7684\u4e2a\u6570\nvector&lt;int&gt; getUpper(i64 sum) {\n    vector&lt;int&gt; num;\n    i64 temp = sum;\n    while (temp) {\n        num.push_back(temp % 10);\n        temp /= 10;\n    }\n    reverse(begin(num), end(num));\n    array&lt;int, 10&gt; cur = cnt;\n    int pos = -1; // \u6700\u957f\u8fde\u7eed\u80fd\u53d8\u5927\u7684\u6570\u4f4d\u7684\u4e0b\u6807\n    for (int i = 0 ; i &lt;= (int) num.size() ; i++) {\n        if (i &lt; (int) num.size()) {\n            bool flag = false;\n            for (int j = num[i] + 1 ; j &lt;= 9 ; j++) {\n                if (cur[j]) { // f(x) \u6392\u5217\u4e2d\u6709\u6bd4\u7b2c i \u4f4d\u5927\u7684\u6570\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                pos = i; // \u8bb0\u5f55\u4e0b\u6807\n            }\n            // f(x) \u6392\u5217\u4e2d\u5fc5\u987b\u4e24\u4e2a\u6570\u90fd\u6709\u624d\u80fd\u66ff\u6362\n            if (cur[num[i]] == 0) break;\n            cur[num[i]]--;\n        } else {\n            pos = i;\n        }\n    }\n    if (pos == -1) return {};\n    vector&lt;int&gt; res(num.size());\n    cur = cnt;\n    for (int i = 0 ; i &lt; (int) num.size() ; i++) {\n        if (i &lt; pos) {\n            res[i] = num[i];\n        } else if (i == pos) {\n            for (int j = num[i] + 1 ; j &lt;= 9 ; j++) {\n                if (cur[j]) {\n                    res[i] = j;\n                    break;\n                }\n            }\n        } else {\n            for (int j = 0 ; j &lt;= 9 ; j++) {\n                if (cur[j]) {\n                    res[i] = j;\n                    break;\n                }\n            }\n        }\n        cur[res[i]]--;\n    }\n    return res;\n}\n</code></pre>"},{"location":"template/math/combinatorics/cantor/#_6","title":"\u67e5\u627e\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e\u7684\u6392\u5217","text":"\u4ee3\u7801 C++<pre><code>// \u67e5\u627e\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e sum \u7684 f(x) \u7684\u6392\u5217 \n// cnt[i] \u4e3a f(x) \u4e2d i \u7684\u4e2a\u6570\nvector&lt;int&gt; getLower(i64 sum) {\n    vector&lt;int&gt; num;\n    i64 temp = sum;\n    while (temp) {\n        num.push_back(temp % 10);\n        temp /= 10;\n    }\n    reverse(begin(num), end(num));\n    array&lt;int, 10&gt; cur = cnt;\n    int pos = -1; // \u6700\u957f\u8fde\u7eed\u80fd\u53d8\u5c0f\u7684\u6570\u4f4d\u7684\u4e0b\u6807\n    for (int i = 0 ; i &lt;= (int) num.size() ; i++) {\n        if (i &lt; (int) num.size()) {\n            bool flag = false;\n            for (int j = num[i] - 1 ; j &gt;= 0 ; j--) {\n                if (cur[j]) { // f(x) \u6392\u5217\u4e2d\u6709\u6bd4\u7b2c i \u4f4d\u5c0f\u7684\u6570\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                pos = i; // \u8bb0\u5f55\u4e0b\u6807\n            }\n            // f(x) \u6392\u5217\u4e2d\u5fc5\u987b\u4e24\u4e2a\u6570\u90fd\u6709\u624d\u80fd\u66ff\u6362\n            if (cur[num[i]] == 0) break;\n            cur[num[i]]--;\n        } else {\n            pos = i;\n        }\n    }\n    if (pos == -1) return {};\n    vector&lt;int&gt; res(num.size());\n    cur = cnt;\n    for (int i = 0 ; i &lt; (int) num.size() ; i++) {\n        if (i &lt; pos) {\n            res[i] = num[i];\n        } else if (i == pos) {\n            for (int j = num[i] - 1 ; j &gt;= 0 ; j--) {\n                if (cur[j]) {\n                    res[i] = j;\n                    break;\n                }\n            }\n        } else {\n            for (int j = 9 ; j &gt;= 0 ; j--) {\n                if (cur[j]) {\n                    res[i] = j;\n                    break;\n                }\n            }\n        }\n        cur[res[i]]--;\n    }\n    return res;\n}\n</code></pre>"},{"location":"template/math/combinatorics/catalan/","title":"\u5361\u7279\u5170\u6570","text":"<ol> <li>\u6709 \\(2n\\) \u4e2a\u4eba\u6392\u6210\u4e00\u884c\u8fdb\u5165\u5267\u573a\u3002\u5165\u573a\u8d39 \\(5\\) \u5143\u3002\u5176\u4e2d\u53ea\u6709 \\(n\\) \u4e2a\u4eba\u6709\u4e00\u5f20 \\(5\\) \u5143\u949e\u7968\uff0c\u53e6\u5916 \\(n\\) \u4eba\u53ea\u6709 \\(10\\) \u5143\u949e\u7968\uff0c\u5267\u9662\u65e0\u5176\u5b83\u949e\u7968\uff0c\u95ee\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\u4f7f\u5f97\u53ea\u8981\u6709 \\(10\\) \u5143\u7684\u4eba\u4e70\u7968\uff0c\u552e\u7968\u5904\u5c31\u6709 \\(5\\) \u5143\u7684\u949e\u7968\u627e\u96f6\uff1f</li> <li>\u4e00\u4f4d\u5927\u57ce\u5e02\u7684\u5f8b\u5e08\u5728\u5979\u4f4f\u6240\u4ee5\u5317 \\(n\\) \u4e2a\u8857\u533a\u548c\u4ee5\u4e1c \\(n\\) \u4e2a\u8857\u533a\u5904\u5de5\u4f5c\u3002\u6bcf\u5929\u5979\u8d70 \\(n\\) \u4e2a\u8857\u533a\u53bb\u4e0a\u73ed\u3002\u5982\u679c\u4ed6\u4ece\u4e0d\u7a7f\u8d8a\uff08\u4f46\u53ef\u4ee5\u78b0\u5230) \u4ece\u5bb6\u5230\u529e\u516c\u5ba4\u7684\u5bf9\u89d2\u7ebf\uff0c\u90a3\u4e48\u6709\u591a\u5c11\u6761\u53ef\u80fd\u7684\u9053\u8def\uff1f</li> <li>\u5728\u5706\u4e0a\u9009\u62e9 \\(2n\\) \u4e2a\u70b9\uff0c\u5c06\u8fd9\u4e9b\u70b9\u6210\u5bf9\u8fde\u63a5\u8d77\u6765\u4f7f\u5f97\u6240\u5f97\u5230\u7684 \\(n\\) \u6761\u7ebf\u6bb5\u4e0d\u76f8\u4ea4\u7684\u65b9\u6cd5\u6570\uff1f</li> <li>\u5bf9\u89d2\u7ebf\u4e0d\u76f8\u4ea4\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\u533a\u57df\u5206\u6210\u4e09\u89d2\u5f62\u533a\u57df\u7684\u65b9\u6cd5\u6570\uff1f</li> <li>\u4e00\u4e2a\u6808\uff08\u65e0\u7a77\u5927\uff09\u7684\u8fdb\u6808\u5e8f\u5217\u4e3a \\(1,2,3,4,\u2026,n\\) \u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u51fa\u6808\u5e8f\u5217\uff1f</li> <li>\\(n\\) \u4e2a\u7ed3\u70b9\u53ef\u6784\u9020\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u4e8c\u53c9\u6811\uff1f</li> <li>\\(n\\) \u4e2a \\(+1\\) \u548c \\(n\\) \u4e2a \\(-1\\) \u6784\u6210 \\(2n\\) \u9879  \\(a_1,a_2, \\cdots ,a_{2n}\\)\uff0c\u5176\u90e8\u5206\u548c\u6ee1\u8db3 \\(a_1+a_2+ \\cdots +a_k \\geq 0(k=1,2,3, \\cdots ,2n)\\) \u5bf9\u4e0e\u8be5 \\(n\\) \u6570\u5217\u4e3a\uff1f</li> </ol> \\(H_0\\) \\(H_1\\) \\(H_2\\) \\(H_3\\) \\(H_4\\) \\(H_5\\) \\(H_6\\) \u2026 1 1 2 5 14 42 132 \u2026"},{"location":"template/math/combinatorics/catalan/#_2","title":"\u516c\u5f0f","text":"\\[ H_n=\\frac{C_{2n}^n}{n+1}\\ (n\u22652,n\u2208N_+) \\] \\[ H_n=\\begin{cases} \\sum_{i=1}^nH_{i-1}H_{n-i}&amp;n\u22652,n\u2208N_+\\\\ 1&amp;n=0,1 \\end{cases} \\] \\[ H_n=\\frac{H_{n-1}\\cdot(4n-2)}{n+1}\\\\ \\] \\[ H_n=C_{2n}^n-C_{2n}^{n-1} \\] \u6a21\u7248 \u65e0\u6a21\u6570\u6709\u6a21\u6570 <p>P1754 \u7403\u8ff7\u8d2d\u7968\u95ee\u9898 - \u6d1b\u8c37</p> C++<pre><code>i64 ans = 1;\nfor (int i = 2 ; i &lt;= n ; i++) {\n    ans = ans * (4 * i - 2) / (i + 1);\n}\n</code></pre> <p>\u7ec4\u5408\u6570\u6a21\u7248</p> C++<pre><code>using Combination::C;\ni64 ans = (C(2*n,n) - C(2*n,n-1) + mod) % mod;\n</code></pre>"},{"location":"template/math/combinatorics/catalan/#_3","title":"\u8def\u5f84\u8ba1\u6570\u95ee\u9898","text":"<ol> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((m,n)\\) \u7684\u975e\u964d\u8def\u5f84\u6570\u7b49\u4e8e \\(m\\) \u4e2a \\(x\\) \u548c \\(n\\) \u4e2a \\(y\\) \u7684\u6392\u5217\u6570\uff0c\u5373\\(C_{n+m}^m\\)\u3002</p> </li> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((n,n)\\) \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u63a5\u89e6\u76f4\u7ebf \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a\u5148\u8003\u8651 \\(y=x\\) \u4e0b\u65b9\u7684\u8def\u5f84\uff0c\u90fd\u662f\u4ece\u51fa \\((0,0)\\) \u53d1\uff0c\u7ecf\u8fc7 \\((1,0)\\) \u53ca \\((n,n-1)\\) \u5230 \\((n,n)\\) \uff0c\u53ef\u4ee5\u770b\u505a\u662f \\((1,0)\\) \u5230 \\((n,n-1)\\) \u4e0d\u63a5\u89e6 \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\u3002\u6240\u6709\u7684\u7684\u975e\u964d\u8def\u5f84\u6709 \\(C_{2n-2}^{n-1}\\) \u6761\u3002\u5bf9\u4e8e\u8fd9\u91cc\u9762\u4efb\u610f\u4e00\u6761\u63a5\u89e6\u4e86 \\(y=x\\) \u7684\u8def\u5f84\uff0c\u53ef\u4ee5\u628a\u5b83\u6700\u540e\u79bb\u5f00\u8fd9\u6761\u7ebf\u7684\u70b9\u5230 \\((1,0)\\) \u4e4b\u95f4\u7684\u90e8\u5206\u5173\u4e8e \\(y=x\\) \u5bf9\u79f0\u53d8\u6362\uff0c\u5c31\u5f97\u5230\u4ece \\((0,1)\\) \u5230 \\((n,n-1)\\) \u7684\u4e00\u6761\u975e\u964d\u8def\u5f84\u3002\u53cd\u4e4b\u4e5f\u6210\u7acb\u3002\u4ece\u800c \\(y=x\\) \u4e0b\u65b9\u7684\u975e\u964d\u8def\u5f84\u6570\u662f \\(C_{2n-2}^{n-1}-C_{2n-2}^{n}\\) \u3002\u6839\u636e\u5bf9\u79f0\u6027\u53ef\u77e5\u6240\u6c42\u7b54\u6848\u4e3a \\(2(C_{2n-2}^{n-1}-C_{2n-2}^{n})=\\dfrac{2C_{2n-2}^{n-1}}{n}\\)\u3002</p> </li> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((n,n)\\) \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u7a7f\u8fc7\u76f4\u7ebf \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a\u7528\u7c7b\u4f3c\u7684\u65b9\u6cd5\u53ef\u4ee5\u5f97\u5230\uff1a\\(\\frac{2C_{2n}^n}{n+1}\\)</p> </li> </ol>"},{"location":"template/math/combinatorics/catalan/#_4","title":"\u7ecf\u5178\u95ee\u9898","text":""},{"location":"template/math/combinatorics/catalan/#1-1","title":"\u524d\u7f00\u548c\u975e\u8d1f\u7684+1/-1\u6570\u5217\u4e2a\u6570","text":"<p>\u5df2\u77e5 \\(n\\) \u4e2a \\(+1\\) \u548c \\(n\\) \u4e2a \\(-1\\) \u6784\u6210\u6570\u5217 \\(a_1,a_2,\u2026,a_{2n}\\), \u4e14\u524d\u7f00\u548c\u6ee1\u8db3 \\(a_1+a_2+\u2026+a_k\\ge0(k=1,2,\u2026,2n)\\)\uff0c\u5219\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u5217\u4e2a\u6570 \\(f(n)\\) \u4e3a\uff1f</p> <p>\u89e3:</p> <p>\u5f53\u6570\u5217\u4e0d\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u4e00\u5b9a\u5b58\u5728 \\(-1\\) \u7684\u4e2a\u6570\u6bd4 \\(+1\\) \u7684\u4e2a\u6570\u6070\u597d\u591a \\(1\\) \u7684\u70b9, \u5c06\u8fd9\u4e2a\u70b9\u540e\u9762\u7684 \\(+1\\) \u548c \\(-1\\), \u7b26\u53f7\u53d6\u53cd, \u5219\u53d8\u6210\u4e86\u4e00\u4e2a\u6709 \\(n+1\\) \u4e2a \\(-1\\) \u548c \\(n-1\\) \u4e2a \\(+1\\) \u7684\u6570\u5217, \u53ef\u4ee5\u77e5\u9053\u8fd9\u662f\u4e00\u4e00\u5bf9\u5e94\u7684, \u6240\u4ee5\u4e0d\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u5217\u6709 \\(C_{2n}^{n+1}\\) \u4e2a\uff0c\u6240\u4ee5\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u5217\u6709 \\(C_{2n}^n-C_{2n}^{n+1}=\\dfrac{C_{2n}^n}{n+1}\\)\u4e2a </p>"},{"location":"template/math/combinatorics/catalan/#_5","title":"\u4e0d\u540c\u6784\u771f\u4e8c\u53c9\u6811\u7684\u4e2a\u6570","text":"<p>\u7531 \\(n\\) \u4e2a\u5185\u90e8\u8282\u70b9\u7ec4\u6210\u7684\u4e0d\u540c\u6784\u771f\u4e8c\u53c9\u6811\u7684\u79cd\u6570 \\(f(n)\\) \u4e3a\uff1f</p> <p>\u771f\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8282\u70b9\u7684\u5b69\u5b50\u6570\u8981\u4e48\u4e3a \\(0\\)\uff0c\u8981\u4e48\u4e3a \\(2\\).</p> <p></p> <p>\u53ef\u4ee5\u8f6c\u5316\u4e3a\u5148\u5e8f\u904d\u5386\u4e8c\u53c9\u6811, \u8bbf\u95ee\u5230\u5de6\u513f\u5b50 \\(+1\\), \u8bbf\u95ee\u5230\u53f3\u513f\u5b50 \\(-1\\), \u53ef\u4ee5\u8f6c\u4e3a \u524d\u7f00\u548c\u975e\u8d1f\u7684+1/-1\u6570\u5217\u4e2a\u6570</p>"},{"location":"template/math/combinatorics/derangement/","title":"\u9519\u4f4d\u6392\u5217","text":"<p>\\(D_n=(n-1)*(D_{n-1}+D_{n-2})\\)</p> <p>\\(D_n=n*D_{n-1}+{(-1)}^n\\)</p> \u725b\u5ba254484B(\\(n\\leq10^9\\)) <p>B-\u5199\u4fe1_\u534e\u4e2d\u519c\u4e1a\u5927\u5b662023\u5e74\u5341\u4e8c\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08\u540c\u6b65\u8d5b\uff09</p> \u6253\u8868\u4ee3\u7801\u4ee3\u7801 C++<pre><code>const long long mod = 1000000007;\nlong long ans = 0;\nint block = 1000000;\nfor (int i = 0 ; i &lt;= k ; i++) {\n    ans = ans * i % mod;\n    if (i &amp; 1) {\n        ans--;\n    } else {\n        ans++;\n    }\n    ans = (ans + mod) % mod;\n    if (i % block == 0) {\n        cout &lt;&lt; ans &lt;&lt; \", \";\n    }\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int block = 1000000;\nconst long long mod = 1000000007;\nconst long long res[] = {\u6253\u8868\u51fa\u6765\u7684};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin &gt;&gt; k;\n    long long ans = res[k / block];\n    for (int i = k / block + 1 ; i &lt;= k ; i++) {\n        ans = ans * i % mod;\n        if (i &amp; 1) {\n            ans--;\n        } else {\n            ans++;\n        }\n        ans = (ans + mod) % mod;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"template/math/combinatorics/fibonacci/","title":"\u6590\u6ce2\u90a3\u5951","text":""},{"location":"template/math/combinatorics/fibonacci/#_2","title":"\u516c\u5f0f","text":"\\[ \\begin{align} F_0=0,F_1=1\\\\ F_N=F_{n-1}+F_{n-2} \\end{align} \\] \\[ F_n=\\left[\\frac{\\dfrac{(1+\\sqrt5)^n}{2}-\\dfrac{(1-\\sqrt5)^n}{2}}{\\sqrt5}\\right] \\] \\[ S_n=F_{n+2}-1 \\] \u6a21\u7248 \u6c42 \\(F_n\\mod P\\) \\((n\\leq10^{18})\\)\u6c42 \\(F_n\\mod P\\) \\((n\\) \u65e0\u9650\u5236 \\()\\) <p>\\(O(\\log(n))\\)</p> C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\npair&lt;i64, i64&gt; fib(i64 n) {\n    if (n == 0) {\n        return {0, 1};\n    }\n    auto [a, b] = fib(n / 2);\n    i64 c = a * (2 * b - a + P) % P, d = (a * a + b * b) % P;\n    if (n &amp; 1) {\n        return {d, (c + d) % P};\n    }\n    return {c, d};\n}\n</code></pre> <p>P4000 \u6590\u6ce2\u90a3\u5951\u6570\u5217 - \u6d1b\u8c37</p> <p>\\(O(\\sqrt P)\\)</p> <p>\u968f\u673a\u7b97\u6cd5\uff0c\u6709\u9519\u8bef\u7684\u53ef\u80fd\u3002</p> C++<pre><code>using i64 = long long;\nusing u64 = unsigned long long;\ni64 P;\nnamespace Fibonacci {\n    struct Mat {\n        i64 a[2][2];\n        Mat(bool flag = true) {\n            a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0;\n            if (flag == true) {\n                a[0][0] = a[1][1] = 1;\n            }\n        }\n        i64* operator[](int x) {\n            return a[x];\n        }\n        friend Mat operator*(Mat x, Mat y) {\n            Mat res(false);\n            for (int i = 0 ; i &lt; 2 ; i++) {\n                for (int k = 0 ; k &lt; 2 ; k++) {\n                    i64 r = x[i][k];\n                    for (int j = 0 ; j &lt; 2 ; j++) {\n                        res[i][j] += r * y[k][j];\n                    }\n                }\n            }\n            for (int i = 0 ; i &lt; 2 ; i++) {\n                for (int j = 0 ; j &lt; 2 ; j++) {\n                    res[i][j] %= P;\n                }\n            }\n            return res;\n        }\n    };\n    const int M = 20;\n    const int N = (1 &lt;&lt; M) - 1;\n    array&lt;Mat, 2&gt; mat[N + 1];\n    i64 len = 0;\n    void init() {\n        mt19937_64 rnd(time(nullptr));\n        Mat base(false);\n        base[0][0] = 0;\n        base[0][1] = base[1][0] = base[1][1] = 1;\n        for (int i = 1 ; i &lt;= N ; i++) {\n            mat[i][0] = mat[i - 1][0] * base;\n        }\n        Mat base2 = mat[N][0] * base;\n        for (int i = 1 ; i &lt;= N ; i++) {\n            mat[i][1] = mat[i - 1][1] * base2;\n        }\n        map&lt;u64, i64&gt; loop;\n        while (true) {\n            i64 a = rnd() &lt;&lt; 28 &gt;&gt; 28;\n            Mat res = mat[a &amp; N][0] * mat[a &gt;&gt; M][1];\n            u64 val = ((u64) res[0][0] &lt;&lt; 32) | res[0][1];\n            if (loop.find(val) != end(loop)) {\n                len = llabs(loop[val] - a);\n                break;\n            }\n            loop[val] = a;\n        }\n\n    }\n    i64 get(const string &amp;str) {\n        assert(len != 0);\n        i64 n = 0;\n        for (auto &amp;ch : str) {\n            n = (n * 10 + ch - 48) % len;\n        }\n        return (mat[n &amp; N][0] * mat[n &gt;&gt; M][1])[0][1];\n    }\n} // Fibonacci\n</code></pre>"},{"location":"template/math/combinatorics/fibonacci/#_3","title":"\u5362\u5361\u65af","text":"\\[ L_n=(\\dfrac{1+\\sqrt5}{2})^n+(\\dfrac{1-\\sqrt5}{2})^n \\] \\[ L_n^2-5F_n^2=-4 \\]"},{"location":"template/math/combinatorics/inclusion-exclusion/","title":"\u5bb9\u65a5\u539f\u7406","text":""},{"location":"template/math/combinatorics/inclusion-exclusion/#_2","title":"\u4e0d\u5b9a\u65b9\u7a0b\u975e\u8d1f\u6574\u6570\u89e3\u8ba1\u6570","text":"<p>\\(f(x)\\) \u4e3a \\(a_0\\cdot b_0+a_1\\cdot b_1+\u2026a_k\\cdot b_k=x\\) \u7684\u6240\u6709\u65b9\u6848\u6570\uff0c\\(a_i\\) \u4e3a\u5e38\u6570\uff0c\\(b_i\\) \u4e3a\u53d8\u91cf</p> \u4f8b\u9898 \u6d1b\u8c37P1450 <p>P1450 [HAOI2008] \u786c\u5e01\u8d2d\u7269 - \u6d1b\u8c37</p> <p>\u5148\u505a\u5b8c\u5168\u80cc\u5305\u5904\u7406\u65b9\u6848\u6570\u3002</p> <p>\u7136\u540e\u4e8c\u8fdb\u5236\u679a\u4e3e\uff0c\u7b2c \\(i\\) \u679a\u786c\u5e01\u8d85\u8fc7\u6570\u91cf\u9650\u5236(\u6070\u597d\u7528\u4e86 \\(d[i]+1\\) \u679a)\uff0c\u8fdb\u884c\u5bb9\u65a5</p> <p>\u4ece\u800c\u8ba1\u7b97\u51fa\u8d85\u8fc7\u6570\u91cf\u4e0a\u9650\u7684\u65b9\u6848\u6570\u3002</p> <p>\u7b54\u6848\u4e3a \u603b\u65b9\u6848\u6570\u51cf\u53bb\u8d85\u8fc7\u6570\u91cf\u7684\u65b9\u6848\u6570\u3002</p> \u4ee3\u7801 C++<pre><code>using i64 = long long;\ni64 f[100005];\nint main() {\n    f[0] = 1;\n    vector&lt;int&gt; c(4);\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        cin &gt;&gt; c[i];\n        for (int j = 0 ; j &lt;= 100000 ; j++) {\n            if (j - c[i] &gt;= 0) {\n                f[j] += f[j - c[i]];\n            }\n        }\n    }\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        vector&lt;int&gt; d(4);\n        i64 s;\n        for (int j = 0 ; j &lt; 4 ; j++) {\n            cin &gt;&gt; d[j];\n        }\n        cin &gt;&gt; s;\n        i64 res = 0;\n        for (int i = 1 ; i &lt; 1 &lt;&lt; 4 ; i++) {\n            i64 m = s;\n            int sign = -1;\n            for (int j = 0 ; j &lt; 4 ; j++) {\n                if (i &amp; 1 &lt;&lt; j) {\n                    m -= (d[j] + 1) * c[j];\n                    sign = -sign;\n                }\n            }\n            if (m &gt;= 0) {\n                res += sign * f[m];\n            }\n        }\n        cout &lt;&lt; f[s] - res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/combinatorics/partition/","title":"\u5206\u62c6\u6570","text":""},{"location":"template/math/combinatorics/partition/#_2","title":"\u5b9a\u4e49","text":"<p>\u628a\u6b63\u6574\u6570\u5206\u89e3\u6210\u82e5\u5e72\u6b63\u6574\u6570\u7684\u548c</p>"},{"location":"template/math/combinatorics/partition/#_3","title":"\u5b9a\u7406","text":"<p>\u2460 N\u62c6\u5206\u6210\u4e0d\u540c\u6574\u6570\u7684\u548c\u7684\u62c6\u5206\u6570(\u4e0d\u5141\u8bb8\u91cd\u590d) \u7b49\u4e8e N\u62c6\u5206\u6210\u5947\u6570\u7684\u62c6\u5206\u6570(\u5141\u8bb8\u91cd\u590d)</p> <p>\u2461 N\u62c6\u5206\u6210\u4e00\u4e9b\u91cd\u590d\u6b21\u6570\u4e0d\u8d85\u8fc7 k \u6b21\u7684\u6574\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u4e0d\u88ab k+1 \u6574\u9664\u7684\u6570\u7684\u548c\u7684\u62c6\u5206\u6570</p> <p>\u2462 N\u62c6\u5206\u6210k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u6700\u5927\u6570\u4e3ak\u7684\u62c6\u5206\u6570</p> <p>\u2463 N\u62c6\u5206\u6210\u6700\u591a\u4e0d\u8d85\u8fc7k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u6700\u5927\u6570\u4e0d\u8d85\u8fc7k\u7684\u62c6\u5206\u6570</p> <p>\u2464 N\u62c6\u5206\u6210\u4e0d\u8d85\u8fc7k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N+k\u62c6\u5206\u6210\u6070\u597dk\u4e2a\u6570\u7684\u62c6\u5206\u6570</p>"},{"location":"template/math/combinatorics/partition/#_4","title":"\u53ef\u91cd\u590d\u7684\u6574\u6570\u62c6\u5206","text":"\u6a21\u7248 \u66b4\u529b \\(O(n^2)\\)\u4e94\u8fb9\u5f62\u6570\u5b9a\u7406 \\(O(n*\\sqrt n)\\) \u6a21\u6570\u4efb\u610f\u591a\u9879\u5f0f\u6c42\u89e3 \\(O(n*\\log n)\\) C++<pre><code>dp[0] = 1;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    for (int j = i ; j &lt;= n ; j++) {\n        dp[j] += dp[j - i];\n    }\n}\n</code></pre> C++<pre><code>i64 ans[100005], temp[100005];\nint main() {\n    int n, P;\n    cin &gt;&gt; n &gt;&gt; P;\n    int sqr = sqrt(n);\n    ans[0] = temp[0] = 1;\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        for (int k = 0 ; k &lt; 2 ; k++) {\n            for (int j = i ; j &lt;= n - i * i ; j++) {\n                temp[j] = (temp[j] + temp[j - i]) % P;\n            }\n        }\n        for (int j = i * i ; j &lt;= n ; j++) {\n            ans[j] = (ans[j] + temp[j - i * i]) % P;\n        }\n    }\n    cout &lt;&lt; ans[n] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> <p>\u5c06 \\(n\\) \u62c6\u6210 \\(m\\) \u4e2a\u6b63\u6574\u6570</p> C++<pre><code>Poly Partition(int n, int m) {\n    assert(n &gt;= m &amp;&amp; n &lt; (int) inv.size());\n    Poly a(n + 1);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        for (int j = i ; j &lt;= n ; j += i) {\n            mod_add(a[j], P - inv[j / i]);\n        }\n    }\n    a = Inv(Exp(a));\n    return a;\n}\n</code></pre> \u4f8b\u9898 <p>#6268. \u5206\u62c6\u6570 - LibreOJ</p> <p>P6189 [NOI Online #1 \u5165\u95e8\u7ec4] \u8dd1\u6b65 - \u6d1b\u8c37</p>"},{"location":"template/math/combinatorics/partition/#k","title":"k\u90e8\u5206\u62c6\u6570","text":"<p>\u5c06 \\(n\\) \u5206\u6210\u6070\u6709 \\(k\\) \u4e2a\u90e8\u5206\u7684\u5206\u62c6\uff0c\u6210\u4e3a \\(k\\) \u90e8\u5206\u62c6\u6570\uff0c\u8bb0\u4f5c \\(P(n,k)\\) $$ P(n,k)=\\sum_{j=0}^kP(n-k,j) $$</p> \\[ P(n,k)=P(n-1,k-1)+P(n-k,k) \\] \u66b4\u529b\u9012\u63a8 \\(O(n*k)\\) C++<pre><code>P[0][0] = 1;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    for (int j = 1 ; j &lt;= k ; j++) {\n        if (i &gt;= j) {\n            P[i][j] = P[i - j][j] + P[i - 1][j - 1];\n        }\n    }\n}\n</code></pre>"},{"location":"template/math/combinatorics/partition/#_5","title":"\u4e92\u5f02\u62c6\u5206\u6570","text":"<p>\\(pd_n\\) \uff0c\u81ea\u7136\u6570 \\(n\\) \u7684\u5404\u90e8\u5206\u4e92\u4e0d\u76f8\u540c\u7684\u5206\u62c6\u65b9\u6cd5\u6570\u3002</p> \u66b4\u529b \\(O(\\sqrt{n*k})\\) C++<pre><code>int n;\ncin &gt;&gt; n;\nPD[0][0] = 1;\nint ans = 0;\nint mx = sqrt(n) + 100;\nfor (int j = 1 ; j &lt; mx ; j++) {\n    for (int i = 0 ; i &lt; mx ; i++) {\n        PD[i][j &amp; 1] = 0;\n    }\n    for (int i = 0 ; i &lt;= n ; i++) {\n        if (i &gt;= j) {\n            PD[i][j &amp; 1] = PD[i - j][j &amp; 1] + PD[i - j][(j - 1) &amp; 1];\n        }\n    }\n    ans += PD[n][j &amp; 1];\n}\n</code></pre>"},{"location":"template/math/combinatorics/partition/#_6","title":"\u5947\u62c6\u5206\u6570","text":"<p>\\(po_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5947\u6570\u7684\u5206\u62c6\u65b9\u6cd5\u6570\u3002 $$ po_n=pd_n $$ \\(pde_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5076\u6570\u7684\u4e92\u5f02\u5206\u62c6\u65b9\u6cd5\u6570\u3002</p> <p>\\(pdo_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5947\u6570\u7684\u4e92\u5f02\u5206\u62c6\u65b9\u6cd5\u6570\u3002 $$ pd_n=pde_n+pdo_n $$</p>"},{"location":"template/math/combinatorics/perm-comb/","title":"\u6392\u5217\u7ec4\u5408","text":""},{"location":"template/math/combinatorics/perm-comb/#_2","title":"\u7ec4\u5408\u6570","text":"\u6a21\u7248 \u9012\u63a8(\u6a21\u6570\u4efb\u610f)\u9636\u4e58(\u6a21\u6570\u8d28\u6570)\u7b5b\u6cd5(\u6a21\u6570\u4efb\u610f)\u5927\u7ec4\u5408\u6570(\u6a21\u6570\u8d28\u6570) <p>\u5229\u7528 \\(C_n^m=C_{n-1}^{m-1}+C_{n-1}^m\\) \u9012\u63a8\u6c42\u89e3\u3002</p> <p>\u9884\u5904\u7406 \\(O(n^2)\\)\uff0c\u67e5\u8be2 \\(O(1)\\)\u3002</p> \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 1000000007;\nnamespace Combination {\n    i64 c[5001][5001];\n    void init() {\n        c[0][0] = 1;\n        for (int i = 1 ; i &lt;= 5000 ; i++) {\n            c[i][0] = 1;\n            for (int j = 0 ; j &lt;= i ; j++) {\n                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;\n            }\n        }\n    }\n    i64 get(int n, int r) {\n        return c[n][r];\n    }\n} // Combination\n</code></pre> <p>\u9884\u5904\u7406\u9636\u4e58\u548c\u9006\u5143\u6c42\u89e3\u3002</p> <p>\u9884\u5904\u7406 \\(O(n)\\)\uff0c\u67e5\u8be2 \\(O(1)\\)\u3002</p> \u4ee3\u7801 C++<pre><code>using i64 = long long;\ntemplate&lt;const i64 mod = 1000000007&gt;\nstruct Combination {\n    int n;\n    vector&lt;i64&gt; _fac, _invfac, _inv;\n    Combination() : n(0), _fac{1}, _invfac{1}, _inv{0} {}\n    Combination(int n) : Combination() {}\n    void init(int m) {\n        if (m &lt;= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        for (int i = n + 1 ; i &lt;= m ; i++) {\n            _fac[i] = _fac[i - 1] * i % mod;\n        }\n        _invfac[m] = qpow(_fac[m]);\n        for (int i = m ; i &gt; n ; i--) {\n            _invfac[i - 1] = _invfac[i] * i % mod;\n            _inv[i] = _invfac[i] * _fac[i - 1] % mod;\n        }\n        n = m;\n    }\n    i64 fac(int m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _fac[m];\n    }\n    i64 invfac(int m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _invfac[m];\n    }\n    i64 inv(int m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _inv[m];\n    }\n    i64 C(int n, int m) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        return fac(n) * invfac(m) % mod * invfac(n - m) % mod;\n    }\n    i64 operator()(int n, int m) {\n        return C(n, m);\n    }\n    static i64 qpow(i64 a, i64 b = mod - 2, i64 res = 1) {\n        while (b) {\n            if (b &amp; 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n};\nCombination&lt;998244353&gt; C;\n</code></pre> <p>\u7b5b\u51fa \\(n\\) \u4ee5\u5185\u7684\u8d28\u56e0\u6570\uff0c\u679a\u4e3e\u8d28\u56e0\u5b50\u6c42\u89e3\u3002</p> <p>\u9884\u5904\u7406 \\(O(n)\\)\uff0c\u67e5\u8be2 \\(O(prime(n)*\\log p)\\)\u3002</p> \u4ee3\u7801 C++<pre><code>            using i64 = long long;\nnamespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing EulerSieve::prime;\nint __EulerInit = []() {\n    EulerSieve::primeInit(2000005);\n    return 0;\n}();\nnamespace Combination {\n    i64 qpow(i64 a, i64 b, i64 P, i64 res = 1) {\n        while (b) {\n            if (b &amp; 1) res = res * a % P;\n            a = a * a % P;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    i64 C(int n, int m, int P) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        i64 res = 1;\n        for (auto &amp;i : prime) {\n            if (i &gt; n * 2) {\n                break;\n            }\n            int s = 0;\n            int k = n;\n            while (k &gt; 0) {\n                k /= i;\n                s += k;\n            }\n            k = n - m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            k = m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            res = res * qpow(i, s, P) % P;\n        }\n        return res;\n    }\n} // Combination\nusing Combination::C;\n</code></pre> <p>\u5362\u5361\u65af\u5b9a\u7406 \\(C_n^m\\equiv C_{\\lfloor\\frac{n}{p}\\rfloor}^{\\lfloor\\frac{m}{p}\\rfloor}*C_{n\\mod p}^{m\\mod p}\\pmod p\\)</p> <p>\u65e0\u9884\u5904\u7406\uff0c\u67e5\u8be2 \\(O(p*\\log_p(n))\\)</p> <p>\u9884\u5904\u7406 \\(O(p)\\)\uff0c\u67e5\u8be2 \\(O(p+\\log_p(n))\\)</p> \u4ee3\u7801 \u65e0\u9884\u5904\u7406\u9884\u5904\u7406 C++<pre><code>using i64 = long long;\nnamespace Lucas {\n    i64 P = 1000000007;\n    i64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n        while (b) {\n            if (b &amp; 1) res = res * a % P;\n            a = a * a % P;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    i64 C(i64 n, i64 m) {\n        i64 x = 1, y = 1;\n        if (n &lt; m) return 0;\n        else if (n == m) return 1;\n        for (int i = n - m + 1 ; i &lt;= n ; i++) x = x * i % P;\n        for (int i = 1 ; i &lt;= m ; i++) y = y * i % P;\n        return x * qpow(y) % P;\n    }\n    i64 get(i64 n, i64 m) {\n        if (m == 0) return 1;\n        return (C(n % P, m % P) * get(n / P, m / P)) % P;\n    }\n    i64 get(i64 n, i64 m, i64 P) {\n        Lucas::P = P;\n        return get(n, m);\n    }\n} // Lucas\n</code></pre> C++<pre><code>namespace Lucas {\n    const long long mod = 10007;\n    int fact[mod], invf[mod];\n    static long long qinv(long long a) {\n        long long res = 1, b = mod - 2;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    auto _Lucas_Init = []() {\n        fact[0] = 1;\n        for (int i = 1 ; i &lt; mod ; i++) {\n            fact[i] = 1LL * fact[i - 1] * i % mod;\n        }\n        invf[mod - 1] = qinv(fact[mod - 1]);\n        for (int i = mod - 1 ; i &gt; 0 ; i--) {\n            invf[i - 1] = 1LL * invf[i] * i % mod;\n        }\n        return 0;\n    }();\n    long long C(long long n, long long m) {\n        if (n &lt; m) return 0;\n        else if (n == m) return 1;\n        return fact[n] * invf[m] % mod * invf[n - m] % mod;\n    }\n    long long get(long long n, long long m) {\n        if (m == 0) return 1;\n        return (C(n % mod, m % mod) * get(n / mod, m / mod)) % mod;\n    }\n} // Lucas\n</code></pre> \u6a21\u7248 <p>P3807 \u3010\u6a21\u677f\u3011\u5362\u5361\u65af\u5b9a\u7406/Lucas \u5b9a\u7406 - \u6d1b\u8c37</p>"},{"location":"template/math/combinatorics/perm-comb/#_3","title":"\u91cd\u590d\u6392\u5217","text":"<p>\u4ecen\u4e2a\u4e0d\u540c\u7684\u7269\u4f53\u4e2d\uff0c\u5141\u8bb8\u91cd\u590d\u5730\u9009\u53d6r\u4e2a\u7269\u4f53\u7684\u6392\u5217\u6709 \\(n^r\\) \u79cd\u65b9\u6848</p>"},{"location":"template/math/combinatorics/perm-comb/#_4","title":"\u91cd\u590d\u7ec4\u5408","text":"<p>\u4ecen\u4e2a\u4e0d\u540c\u7684\u7269\u4f53\u4e2d\uff0c\u5141\u8bb8\u91cd\u590d\u5730\u9009\u53d6r\u4e2a\u7269\u4f53\u7684\u7ec4\u5408\u6709 \\(C_{n+r-1}^r\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_5","title":"\u4e0d\u5168\u76f8\u5f02\u5168\u6392\u5217","text":"<p>\u7b2c \\(i\\) \u79cd\u7269\u54c1\u6709 \\(n_i\\) \u4e2a\uff0c\u5168\u6392\u5217\u6570\u4e3a \\(\\dfrac{n!}{n_1!\\cdot{n_2!}\\cdot\\cdots\\cdot{n_k!}}\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_6","title":"\u5706\u5468\u6392\u5217","text":"<p>\u4eceN\u4e2a\u5143\u7d20\u4e2d\u53d6\u51faR\u4e2a\u5143\u7d20\u5f62\u6210\u7684\u5706\u5468\u6392\u5217\u65b9\u6848\u6570\u4e3a \\(\\dfrac{A_N^R}{R}\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_7","title":"\u63d2\u677f\u6cd5","text":""},{"location":"template/math/combinatorics/perm-comb/#_8","title":"\u6b63\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u6b63\u6574\u6570\u89e3\u7684\u7ec4\u6570 \\(C_{n-1}^{k-1}\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_9","title":"\u975e\u8d1f\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u975e\u8d1f\u6574\u6570\u89e3\u7684\u7ec4\u6570 \\(C_{n+k-1}^{k-1}\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_10","title":"\u4e0d\u540c\u4e0b\u754c\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u89e3\u7684\u7ec4\u6570\uff0c\u5176\u4e2d \\(x\\geq{}a_i\\)</p> <p>\\(C_{n-\\sum{}a_i+k-1}^{n-\\sum{}a_i}\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_11","title":"\u4e0d\u76f8\u90bb\u7684\u6392\u5217","text":"<p>n \u6392\u5217\u4e2d\u9009 k \u4e2a\u6570\uff0c\u8fd9 k \u4e2a\u6570\u4e2d\u4efb\u4f55\u4e24\u4e2a\u6570\u90fd\u4e0d\u76f8\u90bb\u7684\u7ec4\u5408\u6709 \\(C_{n-k+1}^k\\)</p>"},{"location":"template/math/combinatorics/perm-comb/#_12","title":"\u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5","text":"\u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5 \u7403(n) \u76d2\u5b50(m) \u9650\u5236\u6761\u4ef6 \u65b9\u6848\u6570 1 \u4e0d\u540c \u4e0d\u540c \u65e0 \\(m^n\\) 2 \u4e0d\u540c \u4e0d\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\(A_m^n\\) 3 \u4e0d\u540c \u4e0d\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \\(\\sum_{i=0}^m(-1)^i*{(m-i)}^n*C_m^i\\) \u6216\u8005\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(m!*S_2(n,m)\\) 4 \u4e0d\u540c \u76f8\u540c \u65e0 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(\\sum_{i=1}^mS_2(n,i)\\) 5 \u4e0d\u540c \u76f8\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\([n\\leq{}m]\\) 6 \u4e0d\u540c \u76f8\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(S_2(n,m)\\) 7 \u76f8\u540c \u4e0d\u540c \u65e0 \\(C_{n+m-1}^{m-1}\\) 8 \u76f8\u540c \u4e0d\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\(C_m^n\\) 9 \u76f8\u540c \u4e0d\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \\(C_{n-1}^{m-1}\\) 10 \u76f8\u540c \u76f8\u540c \u65e0 \u5206\u62c6\u6570 \\(F(n)\\) 11 \u76f8\u540c \u76f8\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\([n\\leq{}m]\\) 12 \u76f8\u540c \u76f8\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \u5206\u62c6\u6570 \\(F(n-m)\\) <p>P5824 \u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>i64 n, m;\ni64 solve01() {\n    return qpow(m, n);\n}\ni64 solve02() {\n    i64 res = 1;\n    for (int i = m - n + 1 ; i &lt;= m ; i++) {\n        mod_mul(res, i);\n    }\n    return res;\n}\nPoly S2;\ni64 solve03() {\n    i64 res = C.fac(m);\n    mod_mul(res, S2[m]);\n    return res;\n}\ni64 solve04() {\n    i64 res = 0;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        mod_add(res, S2[i]);\n    }\n    return res;\n}\ni64 solve05() {\n    return n &lt;= m;\n}\ni64 solve06() {\n    return S2[m];\n}\ni64 solve07() {\n    return C(n + m - 1, m - 1);\n}\ni64 solve08() {\n    return C(m, n);\n}\ni64 solve09() {\n    return C(n - 1, m - 1);\n}\nPoly F;\ni64 solve10() {\n    return F[n];\n}\ni64 solve11() {\n    return n &lt;= m;\n}\ni64 solve12() {\n    if (n &lt; m) return 0LL;\n    return F[n - m];\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    S2 = Stirling2ndRow(n);\n    S2.resize(max(n, m) + 1);\n    F = Partition(n, min(n, m));\n    cout &lt;&lt; solve01() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve02() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve03() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve04() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve05() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve06() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve07() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve08() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve09() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve10() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve11() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve12() &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/math/combinatorics/perm-comb/#_13","title":"\u4e8c\u9879\u5f0f\u5b9a\u7406","text":"\\[ (a+b)^n=\\sum_{i=0}^nC_n^i*a^{n-i}*b^i \\nonumber \\]"},{"location":"template/math/combinatorics/perm-comb/#_14","title":"\u4e8c\u9879\u5f0f\u53cd\u6f14","text":"<p>\u8bb0 \\(f_k\\) \u4e3a\u6070\u597d\u4f7f\u7528 \\(k\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u65b9\u6848\u6570\uff0c\\(g_k\\) \u4e3a\u4f7f\u7528\u81f3\u591a \\(k\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u65b9\u6848\u6570\u3002</p> \\[ \\begin{align} \\nonumber g_k&amp;=\\sum_{i=0}^kC_n^i*f_i\\\\ \\nonumber f_k&amp;=\\sum_{i=0}^kC_n^i*(-1)^{n-i}*g_i \\end{align} \\] <p>\u8bb0 \\(f_k\\) \u4e3a\u6070\u597d\u4f7f\u7528 \\(k\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u65b9\u6848\u6570\uff0c\\(g_k\\) \u4e3a\u94a6\u5b9a\u4f7f\u7528 \\(k\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u65b9\u6848\u6570(\u6709\u91cd\u590d\u65b9\u6848)\u3002</p> \\[ \\begin{align} \\nonumber g_k&amp;=\\sum_{i=k}^nC_i^k*f_i\\\\ \\nonumber f_k&amp;=\\sum_{i=k}^nC_i^k*(-1)^{i-k}*g_i \\end{align} \\]"},{"location":"template/math/combinatorics/perm-comb/#_15","title":"\u7ec4\u5408\u6570\u6027\u8d28 | \u4e8c\u9879\u5f0f\u63a8\u8bba","text":"\\[ C_{n+1}^k=C_n^k+C_n^{k-1} \\] \\[ C_n^k=\\dfrac{n}{k}*C_{n-1}^{k-1} \\] \\[ C_{n-1}^k-C_{n-1}^{k-1}=\\dfrac{n-2k}{n}*C_n^k \\] \\[ C_n^i*C_i^m=C_n^m*C_{n-m}^{i-m} \\] \\[ \\sum_{i=0}^nC_n^i=2^n \\] \\[ \\sum_{i=0}^kC_{n+i-1}^i=C_{n+k}^k \\] \\[ \\sum_{i=0}^{n-k}\\dfrac{(-1)^i*(n+1)}{k+i+1}*C_{n-k}^i=\\dfrac{1}{C_n^k} \\] \\[ \\sum_{i=L}^RC_{n+i}^i=C_{n+R+1}^R-C_{n+L}^{L-1} \\] \\[ \\sum_{i=L}^RC_i^n=C_{R+1}^{n+1}-C_L^{n+1} \\] \\[ \\sum_{i=0}^n(C_n^i)^2=C_{2n}^n \\] \\[ \\sum_{i=0}^nC_{a+n-1-i}^{a-1}*C_{b+i-1}^{b-1}=C_{a+b+n-1}^{a+b-1} \\] \\[ \\sum_{i=0}^kC_n^i*C_m^{k-i}=C_{n+m}^k \\] \\[ \\sum_{i=-r}^{s}C_n^{r+i}*C_m^{s-i}=C_{n+m}^{r+s} \\] \\[ \\sum_{i=0}^mC_n^i*C_m^i=C_{n+m}^m \\] \\[ \\sum_{i=1}^nC_n^i*C_n^{i-1}=C_{2n}^{n-1} \\] \\[ (C_{n+k}^k)^2=\\sum_{i=0}^k(C_k^i)^2*C_{n+2k-i}^{2k} \\] \\[ \\sum_{i=0}^n(-1)^i*C_n^i=[n=0] \\] \\[ \\sum_{i=0}^ni*C_n^i=n*2^{n-1} \\] \\[ \\sum_{i=0}^ni^2*C_n^i=n*(n+1)*2^{n-2} \\] \\[ \\sum_{i=0}^nC_i^k=C_{n+1}^{k+1} \\] \\[ \\sum_{i=0}^nC_{n-i}^i=F_{n+1}(\\text{\u6590\u6ce2\u90a3\u5951\u6570\u5217}) \\]"},{"location":"template/math/combinatorics/stirling/","title":"\u65af\u7279\u6797\u6570","text":""},{"location":"template/math/combinatorics/stirling/#_2","title":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570(\u65af\u7279\u6797\u5b50\u96c6\u6570)","text":""},{"location":"template/math/combinatorics/stirling/#_3","title":"\u5b9a\u4e49","text":"<p>\\(S_2(n,k)=\\begin{Bmatrix}n\\\\k\\end{Bmatrix}\\)</p> <p>\u8868\u793a\u5c06 \\(n\\) \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u4e3a \\(k\\) \u4e2a\u4e0d\u533a\u5206\u7684\u96c6\u5408(\u4e0d\u5141\u8bb8\u7a7a\u96c6)\u7684\u65b9\u6848\u6570\u3002</p>"},{"location":"template/math/combinatorics/stirling/#_4","title":"\u9012\u63a8\u516c\u5f0f","text":"\\[ \\begin{align} S_2(0,0)&amp;=1\\nonumber\\\\ S_2(n,k)&amp;=S_2(n-1,k-1)+k*S_2(n-1,k)\\nonumber\\\\ \\end{align} \\]"},{"location":"template/math/combinatorics/stirling/#_5","title":"\u7ec4\u5408\u610f\u4e49","text":"<p>\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u65f6\uff0c\u6709\u4e24\u79cd\u65b9\u6848\uff1a</p> <p>\u2460 \u5c06\u65b0\u5143\u7d20\u5355\u72ec\u653e\u5165\u4e00\u4e2a\u5b50\u96c6\uff0c\u6709 \\(S_2(n-1,k-1)\\) \u79cd\u3002</p> <p>\u2461 \u5c06\u65b0\u5143\u7d20\u653e\u5165\u5df2\u6709\u7684 \\(k\\) \u4e2a\u5b50\u96c6\uff0c\u6709 \\(k*S_2(n-1,k)\\) \u79cd\u3002</p>"},{"location":"template/math/combinatorics/stirling/#_6","title":"\u63a8\u8bba","text":"<p>\u4ee4 \\(G_i\\) \u4e3a\u5c06 \\(n\\) \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u5230 \\(i\\) \u4e2a\u4e0d\u540c\u7684\u96c6\u5408(\u5141\u8bb8\u7a7a\u96c6)\u5185\uff0c\\(F_i\\) \u4e3a\u5c06 \\(n\\) \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u5230 \\(i\\) \u4e2a\u4e0d\u540c\u7684\u96c6\u5408(\u4e0d\u5141\u8bb8\u7a7a\u96c6) \u3002</p> <p>\u5219\u6709 \\(G_i=i^n\\)\uff0c\u663e\u7136\u6709 \\(G_i=\\sum_{j=0}^iC_i^j*F_j\\)</p> <p>\u6839\u636e\u4e8c\u9879\u5f0f\u53cd\u6f14\u6709</p> \\[ \\begin{align} F_i&amp;=\\sum_{j=0}^i(-1)^{i-j}*C_i^j*G_j\\nonumber\\\\ &amp;=\\sum_{j=0}^i(-1)^{i-j}*C_i^j*j^n\\nonumber\\\\ &amp;=\\sum_{j=0}^i\\dfrac{(-1)^{i-j}*i!*j^n}{j!*(i-j)!}\\nonumber\\\\ \\end{align} \\] <p>\u56e0\u4e3a \\(F_i\\) \u4e0e \\(S_2(n,i)\\) \u7684\u533a\u522b\u5728\u4e8e\uff0c\\(F_i\\) \u662f\u6709\u5e8f\u7684\uff0c\u6240\u4ee5 \\(F_i=S_2(n,i)*i!\\)</p> <p>\u6240\u4ee5</p> \\[ S_2(n,m)=\\dfrac{F_m}{m!}=\\sum_{i=0}^m\\frac{(-1)^{m-i}\\cdot{i}^n}{i!\\cdot(m-i)!}\\nonumber \\] \\[ G_i=i^n=\\sum_{j=0}^iC_i^j*F_j=\\sum_{j=0}^i\\left(C_i^j*S_2(n,j)*j!\\right)\\nonumber \\]"},{"location":"template/math/combinatorics/stirling/#_7","title":"\u540c\u4e00\u884c","text":"\u4f8b\u9898 <p>P5395 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\u00b7\u884c - \u6d1b\u8c37</p> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> C++<pre><code>Poly Stirling2ndRow(int n) {\n    Poly a(n + 1), b(n + 1);\n    i64 invf = 1;\n    for (int i = 0 ; i &lt;= n ; i++) {\n        mod_mul(invf, inv[i]);\n        a[i] = mod_mul_t(invf, qpow(i, n));\n        b[i] = mod_mul_t(invf, (i &amp; 1 ? P - 1 : 1));\n    }\n    a *= b;\n    return a.resize(n + 1), a;\n}\n</code></pre>"},{"location":"template/math/combinatorics/stirling/#_8","title":"\u540c\u4e00\u5217","text":"\u4f8b\u9898 <p>P5396 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\u00b7\u5217 - \u6d1b\u8c37</p> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> C++<pre><code>Poly Stirling2ndCol(int k, int n) {\n    int mx = max(k, n);\n    vector&lt;int&gt; fact(mx + 1), invfact(mx + 1);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= mx ; i++) {\n        fact[i] = mod_mul_t(fact[i - 1], i);\n    }\n    invfact[mx] = qpow(fact[mx]);\n    for (int i = mx ; i &gt;= 1 ; i--) {\n        invfact[i - 1] = mod_mul_t(invfact[i], i);\n    }\n    Poly a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = invfact[i];\n    }\n    a = Pow(a, k);\n    for (int i = 0 ; i &lt;= n ; i++) {\n        mod_mul(a[i], mod_mul_t(fact[i], invfact[k]));\n    }\n    return a;\n}\n</code></pre>"},{"location":"template/math/combinatorics/stirling/#_9","title":"\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570(\u65af\u7279\u6797\u8f6e\u6362\u6570)","text":""},{"location":"template/math/combinatorics/stirling/#_10","title":"\u5b9a\u4e49","text":"<p>\\(S_1(n,k)=\\begin{bmatrix}n\\\\k\\end{bmatrix}\\)</p> <p>\u8868\u793a\u5c06 \\(n\\) \u4e2a\u4e24\u4e24\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u4e3a \\(k\\) \u4e2a\u4e0d\u533a\u5206\u7684\u8f6e\u6362(\u975e\u7a7a)\u7684\u65b9\u6848\u6570\u3002</p>"},{"location":"template/math/combinatorics/stirling/#_11","title":"\u9012\u63a8\u516c\u5f0f","text":"\\[ \\begin{align} S_1(0,0)&amp;=1\\nonumber\\\\ S_1(n,k)&amp;=S_1(n-1,k-1)+(n-1)*S_1(n-1,k)\\nonumber\\\\ \\end{align} \\]"},{"location":"template/math/combinatorics/stirling/#_12","title":"\u7ec4\u5408\u610f\u4e49","text":"<p>\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u65f6\uff0c\u6709\u4e24\u79cd\u65b9\u6848\uff1a</p> <p>\u2460 \u5c06\u65b0\u5143\u7d20\u7f6e\u4e8e\u4e00\u4e2a\u5355\u72ec\u7684\u8f6e\u6362\u4e2d\uff0c\u5171\u6709 \\(S_1(n-1,k-1)\\) \u79cd\u3002</p> <p>\u2461 \u5c06\u65b0\u5143\u7d20\u653e\u5165\u5df2\u6709\u7684\u8f6e\u6362\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u5171\u6709 \\((n-1)*S_1(n-1,k)\\) \u79cd\u3002 </p>"},{"location":"template/math/combinatorics/stirling/#_13","title":"\u540c\u4e00\u884c","text":"\u4f8b\u9898 <p>P5408 \u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570\u00b7\u884c - \u6d1b\u8c37</p> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> C++<pre><code>Poly Stirling1stRow(int n) {\n    vector&lt;int&gt; fact(n + 1), invfact(n + 1);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        fact[i] = mod_mul_t(fact[i - 1], i);\n    }\n    invfact[n] = qpow(fact[n]);\n    for (int i = n ; i &gt;= 1 ; i--) {\n        invfact[i - 1] = mod_mul_t(invfact[i], i);\n    }\n    function&lt;Poly(int)&gt; dfs = [&amp;](int n) -&gt; Poly {\n        if (n == 1) {\n            return {0, 1};\n        }\n        if (n &amp; 1) {\n            Poly a = dfs(n - 1);\n            a.resize(n + 1);\n            for (int i = n ; i &gt; 0 ; i--) {\n                mod_mul(a[i], n - 1);\n                mod_add(a[i], a[i - 1]);\n            }\n            mod_mul(a[0], n - 1);\n            return a;\n        } else {\n            Poly a = dfs(n / 2);\n            int len = n / 2;\n            a.resize(len + 1);\n            Poly b(len + 1), c(len + 1);\n            for (int i = 0 ; i &lt;= len ; i++) {\n                b[i] = mod_mul_t(a[len - i], fact[len - i]);\n                c[i] = mod_mul_t(qpow(len, i), invfact[i]);\n            }\n            b *= c;\n            for (int i = 0 ; i &lt;= len ; i++) {\n                c[i] = mod_mul_t(b[len - i], invfact[i]);\n            }\n            a *= c;\n            return a;\n        }\n    };\n    return dfs(n);\n}\n</code></pre>"},{"location":"template/math/combinatorics/stirling/#_14","title":"\u540c\u4e00\u5217","text":"\u4f8b\u9898 <p>P5409 \u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570\u00b7\u5217 - \u6d1b\u8c37</p> <p>\u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248</p> C++<pre><code> Poly Stirling1stCol(int k, int n) {\n    int mx = max(k, n);\n    vector&lt;int&gt; fact(mx + 1), invfact(mx + 1);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= mx ; i++) {\n        fact[i] = mod_mul_t(fact[i - 1], i);\n    }\n    invfact[mx] = qpow(fact[mx]);\n    for (int i = mx ; i &gt;= 1 ; i--) {\n        invfact[i - 1] = mod_mul_t(invfact[i], i);\n    }\n    Poly a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = mod_mul_t(fact[i - 1], invfact[i]);\n    }\n    a = Pow(a, k);\n    for (int i = 0 ; i &lt;= n ; i++) {\n        mod_mul(a[i], mod_mul_t(fact[i], invfact[k]));\n    }\n    return a;\n}\n</code></pre>"},{"location":"template/math/combinatorics/stirling/#_15","title":"\u4e0a\u5347\u5e42\u4e0e\u666e\u901a\u5e42\u7684\u76f8\u4e92\u8f6c\u5316","text":"\\[ \\begin{align} \\nonumber x^\\overline{n}&amp;=\\prod_{i=0}^{n-1}(x+i)=\\sum_{i=0}^nS_1(n,i)*{x^i}\\\\ \\nonumber x^n&amp;=\\sum_{i=0}^{n}S_2(n,i)*(-1)^{n-i}*x^\\overline{i} \\end{align} \\]"},{"location":"template/math/combinatorics/stirling/#_16","title":"\u4e0b\u964d\u5e42\u4e0e\u666e\u901a\u5e42\u7684\u4e92\u76f8\u8f6c\u5316","text":"\\[ \\begin{align} \\nonumber x^\\underline{n}&amp;=\\prod_{i=0}^{n-1}(x-i)=\\sum_{i=0}^nS_1(n,i)*(-1)^{n-i}*x^k\\\\ \\nonumber x^n&amp;=\\sum_{i=0}^{n}S_2(n,i)*x^\\underline{i} \\end{align} \\]"},{"location":"template/math/combinatorics/stirling/#_17","title":"\u6027\u8d28","text":"\\[ \\begin{align} \\nonumber x^\\underline n&amp;=\\dfrac{x!}{(x-n)!}\\\\ \\nonumber C_n^k*k^\\underline m&amp;=C_{n-m}^{k-m}*n^\\underline m\\\\ \\nonumber (-x)^\\overline n&amp;=(-1)^n*x^\\underline n\\\\ \\nonumber (-x)^\\underline n&amp;=(-1)^n*x^\\overline n \\end{align}\\\\ \\]"},{"location":"template/math/linear-algebra/linear-basis/","title":"\u7ebf\u6027\u57fa","text":"\u6a21\u7248 \u666e\u901a\u6807\u53f7\u5b9e\u6570 C++<pre><code>template&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend LinearBasis operator+(LinearBasis x, LinearBasis y) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // LinearBasis\n</code></pre> C++<pre><code>template&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f, idx;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n        idx.assign(M + 1, -1);\n    }\n    bool insert(T x, int id) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (idx[i] == -1) {\n                    idx[i] = id;\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n}; // LinearBasis\n</code></pre> C++<pre><code>template&lt;class T&gt;\nstruct LinearBasis {\n    vector&lt;vector&lt;T&gt;&gt; f;\n    vector&lt;int&gt; idx;\n    const T eps = 1e-5;\n    int cnt = 0;\n    int n, m;\n    LinearBasis(int n, int m) : n(n), m(m) {\n        init();\n    }\n    void init() {\n        f.resize(0);\n        idx.assign(m + 1, -1);\n    }\n    bool insert(vector&lt;T&gt; x, int id) {\n        for (int i = 0 ; i &lt; m ; i++) {\n            if (fabs(x[i]) &lt; eps) continue;\n            if (idx[i] == -1) {\n                idx[i] = cnt;\n                f.push_back(x);\n                cnt++;\n                return true;\n            }\n            T z = x[i] / f[idx[i]][i];\n            for (int j = i ; j &lt; m ; j++) {\n                x[j] -= z * f[idx[i]][j];\n            }\n        }\n        return false;\n    }\n}; // LinearBasis\n</code></pre> \u4f8b\u9898 P3812(\u666e\u901a)P4570(\u6807\u53f7)P3265(\u5b9e\u6570) <p>P3812 \u3010\u6a21\u677f\u3011\u7ebf\u6027\u57fa - \u6d1b\u8c37</p> <p>P4570 [BJWC2011] \u5143\u7d20 - \u6d1b\u8c37</p> <p>P3265 [JLOI2015] \u88c5\u5907\u8d2d\u4e70 - \u6d1b\u8c37</p> \u4e60\u9898 \u6d1b\u8c37P4301LOJ #114(k\u5927\u5f02\u6216\u548c)\u533a\u95f4\u6700\u5927\u5f02\u6216\u548c\u6d1b\u8c37P3292 \u6811\u4e0a\u8def\u5f84\u6700\u5927\u5f02\u6216\u548c\u6d1b\u8c37P4151 \u56fe\u4e0a\u8def\u5f84\u6700\u5927\u5f02\u6216\u548c <p>P4301 [CQOI2013] \u65b0Nim\u6e38\u620f - \u6d1b\u8c37</p> <p>\u5728\u7b2c\u4e00\u4e2a\u56de\u5408\u4e2d\uff0c\u53cc\u65b9\u53ef\u4ee5\u76f4\u63a5\u62ff\u8d70\u82e5\u5e72\u4e2a\u6574\u5806\u7684\u706b\u67f4\u3002\u53ef\u4ee5\u4e00\u5806\u90fd\u4e0d\u62ff\uff0c\u4f46\u4e0d\u53ef\u4ee5\u5168\u90e8\u62ff\u8d70\u3002\u4ece\u7b2c\u4e8c\u4e2a\u56de\u5408\uff08\u53c8\u8f6e\u5230\u7b2c\u4e00\u4e2a\u6e38\u620f\u8005\uff09\u5f00\u59cb\uff0c\u89c4\u5219\u548c Nim \u6e38\u620f\u4e00\u6837\u3002\u5982\u679c\u4f60\u5148\u62ff\uff0c\u600e\u6837\u624d\u80fd\u4fdd\u8bc1\u83b7\u80dc\uff1f\u5982\u679c\u53ef\u4ee5\u83b7\u80dc\u7684\u8bdd\uff0c\u8fd8\u8981\u8ba9\u7b2c\u4e00\u56de\u5408\u62ff\u7684\u706b\u67f4\u603b\u6570\u5c3d\u91cf\u5c0f\u3002</p> <p>\u53ea\u8981\u5f00\u5c40\u5f02\u6216\u548c\u4e0d\u4e3a0\u5c31\u5148\u624b\u5fc5\u80dc\uff0c\u6240\u4ee5\u5229\u7528\u7ebf\u6027\u57fa\uff0c\u5982\u679c\u4e0d\u80fd\u63d2\u5165\uff0c\u5219\u8bf4\u660e\u5f02\u6216\u548c\u53ef\u4ee5\u4e3a0\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u8981\u628a\u4e0d\u80fd\u63d2\u5165\u7684\u90fd\u62ff\u8d70\uff0c\u5bf9\u706b\u67f4\u8fdb\u884c\u964d\u5e8f\u6392\u5e8f\uff0c\u4f9d\u6b21\u63d2\u5165\u7ebf\u6027\u57fa\uff0c\u5bf9\u4e0d\u80fd\u63d2\u5165\u7684\u6c42\u548c\u8f93\u51fa\u5373\u53ef\u3002</p> <p>#114. k \u5927\u5f02\u6216\u548c - LibreOJ</p> <p>\u5c06\u6240\u6709\u5143\u7d20\u63d2\u5165\u7ebf\u6027\u57fa\u5185\uff0c\u7136\u540e\u5904\u7406\u6240\u6709\u53ea\u6709\u7b2ci\u4f4d\u4e3a1\u7684\uff0c\u5c06rank\u4e8c\u8fdb\u5236\u5206\u89e3\u5373\u53ef\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt; struct LinearBasis {\n    int tot;\n    vector&lt;T&gt; f, d;\n    bool flag;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n        d.assign(M + 1, 0);\n        tot = 0;\n        flag = false;\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        flag = true;\n        return false;\n    }\n    void build() {\n        for (int i = 0 ; i &lt;= M ; i++) {\n            for (int j = i + 1 ; j &lt;= M ; j++) {\n                if (f[j] &amp; T(1) &lt;&lt; i) {\n                    f[j] ^= f[i];\n                }\n            }\n            if (f[i]) {\n                d[tot++] = f[i];\n            }\n        }\n    }\n    T query(long long rank) {\n        if (flag) {\n            rank--;\n        }\n        if (rank == 0) return 0;\n        if (rank &gt;= T(1) &lt;&lt; tot) return -1;\n        T ans = 0;\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (rank &amp; T(1) &lt;&lt; i) {\n                ans ^= d[i];\n            }\n        }\n        return ans;\n    }\n}; // LinearBasis\nint main() {\n    LinearBasis&lt;long long, 50&gt; lb;\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        long long x;\n        cin &gt;&gt; x;\n        lb.insert(x);\n    }\n    lb.build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        long long x;\n        cin &gt;&gt; x;\n        cout &lt;&lt; lb.query(x) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> CF1100F \u4e0d\u5e26\u4fee\u6d1b\u8c37P4839 \u5e26\u4fee(\u5355\u70b9\u589e\u52a0)\u6d1b\u8c37P5607 \u5e26\u4fee(\u533a\u95f4\u5f02\u6216) <p>Problem - F - Codeforces</p> <p>q\u6b21\u67e5\u8be2\u533a\u95f4\u6700\u5927\u5f02\u6216\u548c\uff0c\u65e0\u4fee\u6539\u3002</p> <p>\u53ef\u4ee5\u5efa\u7acbn\u4e2a\u524d\u7f00\u7ebf\u6027\u57fa\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u4e8c\u8fdb\u5236\u4f4d\uff0c\u7ef4\u62a4\u6807\u53f7\u6700\u5927</p> <p>\u533a\u95f4 \\([L,R]\\) \u7684\u7b54\u6848\u4e3a\u7b2c \\(R\\) \u4e2a\u7ebf\u6027\u57fa\uff0c\u5bf9\u4e8e\u6807\u53f7\u90fd\u5927\u4e8e\u7b49\u4e8e \\(L\\) \u7684\u67e5\u8be2\u7ed3\u679c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f, idx;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n        idx.assign(M + 1, -1);\n    }\n    bool insert(T x, int id) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (idx[i] == -1) {\n                    idx[i] = id;\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                } else if (id &gt; idx[i]) {\n                    swap(id, idx[i]);\n                    swap(f[i], x);\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(int L) {\n        T ans = 0;\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(ans &amp; T(1) &lt;&lt; i) &amp;&amp; idx[i] &gt;= L) {\n                ans ^= f[i];\n            }\n        }\n        return ans;\n    }\n}; // LinearBasis\nLinearBasis&lt;int, 20&gt; lb[500005];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        lb[i] = lb[i - 1];\n        lb[i].insert(x, i);\n    }\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        cout &lt;&lt; lb[R].query(L) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P4839 P \u54e5\u7684\u6876 - \u6d1b\u8c37</p> <p>\\(m\\) \u4e2a\u6876\uff0c\\(q\\) \u6b21\u64cd\u4f5c\u3002</p> <p>\u64cd\u4f5c \\(1\\) \u5f80\u67d0\u6876\u4e2d\u653e\u5165\u4e00\u4e2a\u6570\u3002</p> <p>\u64cd\u4f5c \\(2\\) \u8fd9\u4e9b\u6876\u4e2d\u7684\u6570\u7684\u6700\u5927\u5f02\u6216\u548c\u3002</p> <p>\u5229\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 \\(m\\) \u4e2a\u7ebf\u6027\u57fa\u5373\u53ef\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend LinearBasis operator+(LinearBasis x, LinearBasis y) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // LinearBasis\nstruct Info {\n    int L, R;\n    LinearBasis&lt;int, 30&gt; lb;\n} tr[50005 &lt;&lt; 2];\nInfo pushup(Info lhs, Info rhs) {\n    Info res;\n    res.L = lhs.L;\n    res.R = rhs.R;\n    res.lb = lhs.lb + rhs.lb;\n    return res;\n}\nlong long a[50005];\nvoid build(int L, int R, int p = 1) {\n    if (L == R) {\n        tr[p].L = L;\n        tr[p].R = R;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(L, mid, p &lt;&lt; 1);\n    build(mid + 1, R, p &lt;&lt; 1 | 1);\n    tr[p] = pushup(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nvoid modify(int QL, int QR, int p = 1) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        tr[p].lb.insert(a[tr[p].L]);\n        return;\n    }\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(QL, QR, p &lt;&lt; 1);\n    if (QR &gt;= mid + 1) modify(QL, QR, p &lt;&lt; 1 | 1);\n    tr[p] = pushup(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\n LinearBasis&lt;int, 30&gt; query(int QL, int QR, int p = 1) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        return tr[p].lb;\n    }\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QR &lt;= mid) return query(QL, QR, p &lt;&lt; 1);\n    else if (QL &gt;= mid + 1) return query(QL, QR, p &lt;&lt; 1 | 1);\n    return query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1);\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    build(1, n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int op, L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 1) {\n            a[L] = R;\n            modify(L, L);\n        } else {\n            auto res = query(L, R);\n            cout &lt;&lt; res.query() &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>P5607 [Ynoi2013] \u65e0\u529b\u56de\u5929 NOI2017 - \u6d1b\u8c37</p> <p>\u64cd\u4f5c\u4e00\uff0c\u533a\u95f4\u5f02\u6216 \u64cd\u4f5c\u4e8c\uff0c\u533a\u95f4\u67e5\u8be2\uff0c\u5f02\u6216\u4e0av\u7684\u6700\u5927\u503c</p> <p>\u4ee4 \\(b[i]=a[i]\\oplus a[i-1]\\)\uff0c\u5219\\(a[L]\\) \u5230 \\(a[R]\\) \u4e4b\u95f4\u7684\u7ebf\u6027\u57fa\u7b49\u4ef7\u4e8e \\(b[L+1]\\) \u5230 \\(b[R]\\) \u7684\u7ebf\u6027\u57fa\u518d\u52a0\u4e0a\u4e00\u4e2a \\(a[L]\\)</p> <p>\u4fee\u6539\u7684\u8bdd\uff0c\u56e0\u4e3a \\(b\\) \u662f\u5dee\u5206\u6570\u7ec4\uff0c\u6240\u4ee5\u53ea\u9700\u8981 \\(b[L]\\oplus =v\\) \u548c \\(b[R+1]\\oplus =v\\) \u5373\u53ef\u3002</p> <p>\u67e5\u8be2\uff0c\u5229\u7528\u7ebf\u6bb5\u6811\u6c42 \\(b[L,R]\\) \u7684\u7ebf\u6027\u57fa\uff0c\u518d\u63d2\u5165 \\(a[L]\\) \u5373\u53ef\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend LinearBasis operator+(LinearBasis x, LinearBasis y) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // LinearBasis\nstruct Info {\n    int L, R;\n    LinearBasis&lt;int, 30&gt; lb;\n} tr[50005 &lt;&lt; 2];\nInfo pushup(Info lhs, Info rhs) {\n    Info res;\n    res.L = lhs.L;\n    res.R = rhs.R;\n    res.lb = lhs.lb + rhs.lb;\n    return res;\n}\nint a[50005];\nvoid build(int L, int R, int p = 1) {\n    if (L == R) {\n        tr[p].L = L;\n        tr[p].R = R;\n        tr[p].lb.insert(a[L]);\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(L, mid, p &lt;&lt; 1);\n    build(mid + 1, R, p &lt;&lt; 1 | 1);\n    tr[p] = pushup(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nvoid modify(int QL, int QR, int k, int p = 1) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        a[tr[p].L] ^= k;\n        tr[p].lb.init();\n        tr[p].lb.insert(a[tr[p].L]);\n        return;\n    }\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(QL, QR, k, p &lt;&lt; 1);\n    if (QR &gt;= mid + 1) modify(QL, QR, k, p &lt;&lt; 1 | 1);\n    tr[p] = pushup(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nLinearBasis&lt;int, 30&gt; query(int QL, int QR, int p = 1) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        return tr[p].lb;\n    }\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QR &lt;= mid) return query(QL, QR, p &lt;&lt; 1);\n    else if (QL &gt;= mid + 1) return query(QL, QR, p &lt;&lt; 1 | 1);\n    return query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1);\n}\nint lowbit(const int x) {\n    return x &amp; -x;\n}\nint n;\nint sum[50005];\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res ^= sum[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nvoid add(int x, int k) {\n    while (x &lt;= 50000) {\n        sum[x] ^= k;\n        x += lowbit(x);\n    }\n}\nint main() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = n ; i &gt; 1 ; i--) {\n        a[i] ^= a[i - 1];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        add(i, a[i]);\n    }\n    build(1, n);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int op, L, R, v;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R &gt;&gt; v;\n        if (op == 1) {\n            add(L, v);\n            modify(L, L, v);\n            if (R + 1 &lt;= n) {\n                add(R + 1, v);\n                modify(R + 1, R + 1, v);\n            }\n        } else {\n            LinearBasis&lt;int&gt; lb;\n            if (L != R) lb = query(L + 1, R);\n            lb.insert(query(L));\n            cout &lt;&lt; lb.query(v) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>P3292 [SCOI2016] \u5e78\u8fd0\u6570\u5b57 - \u6d1b\u8c37</p> <p>\u500d\u589e\uff0c\u5c06\u8def\u5f84\u6240\u6709\u70b9\u653e\u8fdb\u7ebf\u6027\u57fa\u6c42\u89e3</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend LinearBasis operator+(LinearBasis x, LinearBasis y) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // LinearBasis\nLinearBasis&lt;long long, 60&gt; f[20005][16];\nvector&lt;int&gt; adj[20005];\nint fa[20005][16], deep[20005];\nlong long val[20005];\nvoid dfs(int u, int p) {\n    deep[u] = deep[p] + 1;\n    fa[u][0] = p;\n    f[u][0].insert(val[u]);\n    for (int i = 1 ; i &lt;= 15 ; i++) {\n        f[u][i] = f[u][i - 1] + f[fa[u][i - 1]][i - 1];\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nlong long get(int x, int y) {\n    int k = LCA(x, y);\n    LinearBasis&lt;long long, 60&gt; res;\n    res.insert(val[k]);\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &gt;= deep[k]) {\n            res = res + f[x][i];\n            x = fa[x][i];\n        }\n        if (deep[fa[y][i]] &gt;= deep[k]) {\n            res = res + f[y][i];\n            y = fa[y][i];\n        }\n    }\n    return res.query();\n}\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; val[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    while (q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; get(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P4151 [WC2011] \u6700\u5927XOR\u548c\u8def\u5f84 - \u6d1b\u8c37</p> <p>\u95ee\u4ece \\(1\\) \u8d70\u5230 \\(n\\) \u7684\u8def\u5f84\u6743\u503c\u7684\u5f02\u6216\u548c\u6700\u5927\u503c\u3002</p> <p>\u5148\u662f\u4ece \\(1\\) \u76f4\u63a5\u8d70\u5230 \\(n\\)\u3002\u6b64\u65f6\u6743\u503c\u5f02\u6216\u548c\u4e3a \\(dist[n]\\)\u3002</p> <p>\u5728\u8fd9\u4e2a\u57fa\u7840\u4e0a\u589e\u5e7f\uff0c\u5982\u679c\u4e0d\u8d70\u73af\uff0c\u662f\u4e0d\u53ef\u80fd\u5230\u7ec8\u70b9\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u73af\u6765\u589e\u5e7f\u3002</p> <p>\u5982\u679c\u6211\u4eec\u8d70\u4e00\u4e2a\u73af\uff0c\u90a3\u4e48\u76f8\u5f53\u4e8e\u6211\u4eec\u9009\u62e9\u8d70\u8fd9\u4e2a\u73af\u7684\u6743\u503c\u4e3a \\(dist[to]\\oplus dist[u]\\oplus w\\)\u3002</p> <p>\u63d2\u5165\u7ebf\u6027\u57fa\u5373\u53ef\u3002</p> <p>\u672c\u65b9\u6cd5\u4e5f\u53ef\u4ee5\u6c42\u6700\u5c0fXOR\u548c\u8def\u5f84\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ntemplate&lt;class T, const int M = 30&gt;\nstruct LinearBasis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    LinearBasis() {\n        init();\n    }\n    void init() {\n        f.assign(M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend LinearBasis operator+(LinearBasis x, LinearBasis y) {\n        for (int i = M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // LinearBasis\nLinearBasis&lt;long long, 62&gt; LB;\nvector&lt;pair&lt;int, long long&gt;&gt; adj[50005];\nbool vis[50005];\nlong long dist[50005];\nvoid dfs(int u, int p) {\n    vis[u] = true;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) {\n            LB.insert(dist[u] ^ w ^ dist[to]);\n            continue;\n        }\n        dist[to] = dist[u] ^ w;\n        dfs(to, u);\n    }\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        long long w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; LB.query(dist[n]) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/math/linear-algebra/matrix/","title":"\u77e9\u9635","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt;\nstruct Matrix {\n    int N, M;\n    vector&lt;vector&lt;T&gt;&gt; data;\n    Matrix(int n, int m) : N(n), M(m) {\n        data.resize(n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            data[i].resize(m);\n        }\n    }\n    Matrix E() {\n        Matrix&lt;T&gt; mat(N, M);\n        for (int i = 0 ; i &lt; N ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                if (i == j) mat[i][j] = T(1);\n                 else mat[i][j] = T(0);\n            }\n        }\n        return mat;\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; N ; i++) {\n            data[i].resize(0);\n            data[i].resize(M);\n        }\n    }\n    static Matrix qpow(Matrix base, long long b) {\n        assert(base.N == base.M);\n        Matrix res(base.N, base.M);\n        while (b) {\n            if (b &amp; 1) res *= base;\n            base *= base;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    Matrix&amp; operator*=(const Matrix &amp;x) {\n        assert(M == x.N);\n        Matrix res(N, x.M);\n        for (int i = 0 ; i &lt; N ; i++) {\n            for (int k = 0 ; k &lt; M ; k++) {\n                T r = data[i][k];\n                for (int j = 0 ; j &lt; x.M ; j++) {\n                    res[i][j] += r * x.data[k][j];\n                }\n            }\n        }\n        return *this = res;\n    }\n    Matrix operator*(const Matrix &amp;x) {\n        Matrix res = *this;\n        return res *= x;\n    }\n    vector&lt;T&gt;&amp; operator[](int x) {\n        return data[x];\n    }\n    friend istream&amp; operator&gt;&gt;(istream&amp; is, Matrix &amp;mat) {\n        for (int i = 0 ; i &lt; mat.N ; i++) {\n            for (int j = 0 ; j &lt; mat.M ; j++) {\n                is &gt;&gt; mat.data[i][j];\n            }\n        }\n        return is;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,  Matrix &amp;mat) {\n        for (int i = 0 ; i &lt; mat.N ; i++) {\n            for (int j = 0 ; j &lt; mat.M ; j++) {\n                os &lt;&lt; mat.data[i][j] &lt;&lt; \" \";\n            }\n            os &lt;&lt; \"\\n\";\n        }\n        return os;\n    }\n}; // Matrix\n// Matrix \u77e9\u9635\u7c7b\n// \u884c\u5217\u4e0b\u6807\u4ece 0 \u5f00\u59cb\n// \u5b9e\u73b0\u4e86\u77e9\u9635\u7684\u4e58\u6cd5\u8fd0\u7b97\u548c\u5feb\u901f\u5e42\n// \u5b9e\u73b0\u4e86\u77e9\u9635\u7684\u8f93\u5165\u548c\u8f93\u51fa\n</code></pre>"},{"location":"template/math/number-theory/chinese-remainder-theorem/","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"\\[ \\nonumber \\begin{cases} x&amp;\\equiv a_1\\pmod{n_1}\\\\x&amp;\\equiv a_2\\pmod{n_2}\\\\&amp;\\vdots\\\\x&amp;\\equiv a_k\\pmod{n_k} \\end{cases} \\] \\[ \\begin{gather} \\nonumber m_i=\\frac{n}{n_i}\\\\\\nonumber c_i=m_i\\cdot{m_i}^{-1}\\pmod{n}\\\\\\nonumber x=\\sum_{i=1}^ka_i\\cdot{c_i}\\pmod{n} \\end{gather} \\] \u6a21\u7248 C++<pre><code>void Exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\ni64 CRT(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;p) {\n    // p_i \u4e24\u4e24\u4e92\u8d28\n    // ans % p_i = a_i\n    i64 n = 1, ans = 0;\n    int len = a.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        n *= p[i];\n    }\n    for (int i = 0 ; i &lt; len ; i++) {\n        i64 m = n / p[i];\n        i64 x, y;\n        Exgcd(m, p[i], x, y);\n        ans = (ans + (__int128) a[i] * m % n * x % n + n) % n;\n    }\n    return ans;\n}\n</code></pre> \u4f8b\u9898 <p>P1495 \u3010\u6a21\u677f\u3011\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08CRT\uff09/ \u66f9\u51b2\u517b\u732a - \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/chinese-remainder-theorem/#_2","title":"\u62d3\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"\u6a21\u7248 C++<pre><code>i64 Exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    i64 d = Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\ni64 ExCRT(const vector&lt;i64&gt; &amp;a, const vector&lt;i64&gt; &amp;p) {\n    // ans % p_i = a_i\n    i64 n = p[0];\n    __int128 ans = a[0];\n    int len = a.size();\n    for (int i = 1 ; i &lt; len ; i++) {\n        i64 x, y;\n        i64 c = (a[i] - ans % p[i] + p[i]) % p[i];\n        i64 d = Exgcd(n, p[i], x, y);\n        if (c % d != 0) {\n            return -1LL;\n        }\n        i64 g = p[i] / d;\n        x = (__int128) x * c / d % g;\n        ans += x * n;\n        n *= g;\n        ans = (ans % n + n) % n; \n    }\n    return ans;\n}\n</code></pre> \u4f8b\u9898 <p>P4777 \u3010\u6a21\u677f\u3011\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08EXCRT\uff09- \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/default/","title":"\u6570\u8bba\u57fa\u7840","text":""},{"location":"template/math/number-theory/default/#_2","title":"\u6574\u9664","text":"<p>\\(\\lceil\\dfrac{n}{m}\\rceil=\\lfloor\\dfrac{n+m-1}{m}\\rfloor=\\lfloor\\dfrac{n-1}{m}\\rfloor+1\\)</p> <p>\\(\\lfloor\\dfrac{n}{m}\\rfloor=\\dfrac{n}{m}-n\\mod m\\)</p>"},{"location":"template/math/number-theory/default/#_3","title":"\u6700\u5927\u516c\u56e0\u6570","text":"<ul> <li> <p>\u5df2\u77e5 \\(a&gt;1,m&gt;0,n&gt;0\\)\uff0c\u5219 \\(\\gcd(a^m-1,a^n-1)=a^{\\gcd(m,n)}-1\\)</p> </li> <li> <p>\u5df2\u77e5 \\(a&gt;b,\\gcd(a,b)=1\\)\uff0c\u5219 \\(\\gcd(a^m-b^m,a^n-b^n)=a^{\\gcd(m,n)}-b^{\\gcd(m,n)}\\)</p> </li> </ul>"},{"location":"template/math/number-theory/default/#_4","title":"\u88f4\u8700\u5b9a\u7406","text":"<ul> <li> <p>\u82e5 \\(a,b\\) \u662f\u4e0d\u5168\u4e3a \\(0\\) \u7684\u6574\u6570\uff0c\u5219\u5b58\u5728\u6574\u6570 \\(x,y\\) \u4f7f \\(ax+by=\\gcd(a,b)\\) \u6210\u7acb</p> </li> <li> <p>\u82e5 \\(\\gcd(a,b)=1\\) \u5219 \\(C=ab-a-b\\) \u4e3a \\(ax+by\\) \\((x,y\u22650)\\) \u6240\u8868\u793a\u4e0d\u4e86\u7684\u6700\u5927\u6574\u6570</p> </li> <li> <p>\u5728\u4e0a\u4e2a\u6761\u4ef6\u4e0b \u5bf9\u4efb\u610f\u6574\u6570 \\(n\\)\uff0c\\(n\\) \u4e0e \\(C-n\\) \u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u53ef\u4ee5\u88ab\u8868\u793a </p> </li> </ul>"},{"location":"template/math/number-theory/default/#_5","title":"\u8d39\u9a6c\u5c0f\u5b9a\u7406","text":"<ul> <li>\u82e5 \\(p\\) \u4e3a\u7d20\u6570\uff0c\u4e14 \\(\\gcd(a,p)=1\\)\uff0c\u5219 \\(a^{p-1}\\equiv1\\pmod p\\)</li> </ul>"},{"location":"template/math/number-theory/default/#_6","title":"\u5a01\u5c14\u900a\u5b9a\u7406","text":"<ul> <li>\u5bf9\u4e8e\u7d20\u6570 \\(p\\) \u6709 \\((p-1)!\\equiv-1\\pmod p\\)</li> </ul>"},{"location":"template/math/number-theory/default/#_7","title":"\u63a8\u5e7f","text":"<p>\u5bf9\u4e8e\u7d20\u6570 \\(p\\) \u548c\u6b63\u6574\u6570 \\(q\\) \u6709 \\((p^q!)_p\\equiv\\pm1\\pmod {p^q}\\)</p> \\[ (p^q!)_p= \\begin{cases} 1&amp;(p=2)\\cap(q\\geq3)\\\\ -1&amp;else \\nonumber \\end{cases} \\] \u5e94\u7528 \u8ba1\u7b97\u4f59\u6570\u8ba1\u7b97\u9636\u4e58\u4e2dp\u7684\u5e42\u6b21 <p>\\((n!)_p\\) \u8868\u793a \\(n!\\) \u4e2d\u53bb\u6389\u6240\u6709\u56e0\u5b50 \\(p\\) \u4e4b\u540e\u7684\u4e58\u79ef\u6a21 \\(p\\)</p> <p>\\((n!)_p\\pmod p={\\left((p-1)!\\right)}^{\\lfloor\\dfrac{n}{p}\\rfloor}*\\left((n\\mod p)!\\right)*(\\lfloor\\dfrac{n}{p}\\rfloor!)_p\\\\=(-1)^{\\lfloor\\dfrac{n}{p}\\rfloor}*(n\\mod p)!*(\\lfloor\\dfrac{n}{p}\\rfloor!)_p\\)</p> \u6a21\u7248 C++<pre><code>int factmod(int n, int p) {\n    vector&lt;int&gt; f(p);\n    f[0] = 1;\n    for (int i = 1 ; i &lt; p ; i++) {\n        f[i] = f[i - 1] * i % p;\n    }\n    int res = 1;\n    while (n &gt; 1) {\n        if ((n / p) &amp; 1) res = p - res;\n        res = res * f[n % p] % p;\n        n /= p;\n    }\n    return res;\n}\n</code></pre> C++<pre><code>int multiplicity_factorial(int n, int p) {\n  int count = 0;\n  do {\n    n /= p;\n    count += n;\n  } while (n);\n  return count;\n}\n</code></pre> \u4f8b\u9898 hdu2973 <p>Problem - 2973</p> <p>\u5f53 \\(3k+7\\) \u662f\u8d28\u6570\u65f6, \u53ef\u4ee5\u7531\u5a01\u5c14\u900a\u5b9a\u7406\u5f97\u5230 \\(f(i)=1\\) \u5f53 \\(3k+7\\) \u4e0d\u662f\u8d28\u6570\u65f6, \u53ef\u4ee5\u5316\u7b80\u4e3a \\(f(i)=0\\)</p>"},{"location":"template/math/number-theory/default/#_8","title":"\u52a0\u6027\u51fd\u6570","text":"<p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=0\\)\uff0c\u4e14 \\(\\gcd(x,y)=1\\)\uff0c\\(f(x*y)=f(x)+f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u52a0\u6027\u51fd\u6570\u3002</p> <p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=0\\)\uff0c\u4e14 \\(f(x*y)=f(x)+f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u5b8c\u5168\u52a0\u6027\u51fd\u6570</p> <p>\u52a0\u6027\u51fd\u6570\u76f8\u52a0\u8fd8\u662f\u52a0\u6027\u51fd\u6570</p>"},{"location":"template/math/number-theory/default/#_9","title":"\u5e38\u89c1\u7684\u52a0\u6027\u51fd\u6570","text":"<p>\\(\\Omega(n)=\\sum_{p\\in prime}\\sum_{p^k|n}1\\) (\u5b8c\u5168\u52a0\u6027) </p> <p>\u4e92\u5f02\u8d28\u56e0\u5b50\u6570 \\(\\omega(n)=\\sum_{p\\in prime}[p|n]\\) (\u52a0\u6027)</p> <p>\\(a_0(n)=\\sum_{p\\in prime}\\sum_{p^k|n}p\\) (\u5b8c\u5168\u52a0\u6027) </p> <p>\u4e92\u5f02\u8d28\u56e0\u5b50\u548c \\(a_1(n)=\\sum_{p\\in prime}([p|n]*p)\\) (\u52a0\u6027) </p>"},{"location":"template/math/number-theory/default/#_10","title":"\u79ef\u6027\u51fd\u6570","text":"<p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1\\)\uff0c\u4e14 \\(\\gcd(x,y)=1\\)\uff0c\\(f(x*y)=f(x)*f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u79ef\u6027\u51fd\u6570\u3002</p> <p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1\\)\uff0c\u4e14 \\(f(x*y)=f(x)*f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570</p> <p>\u79ef\u6027\u51fd\u6570\u76f8\u4e58\u8fd8\u662f\u79ef\u6027\u51fd\u6570</p> <p>\u82e5 \\(f(x)\\) \u548c \\(g(x)\\) \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u4ee5\u4e0b\u51fd\u6570\u4e5f\u4e3a\u79ef\u6027\u51fd\u6570\uff1a</p> \\[ h(x)=f(x_p)\\\\ h(x)=f^p(x)\\\\ h(x)=f(x)*g(x)\\\\ h(x)=\\sum_{d|x}f(d)*g(\\dfrac{x}{d})\\nonumber \\] <p>\u8bbe \\(x=\\prod p_i^{k_i}\\)\uff0c\u82e5 \\(f(x)\\) \u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219 \\(f(x)=\\prod f(p_i^{k_i})\\)\uff0c\u82e5 \\(f(x)\\) \u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff0c\u5219 \\(f(x)=\\prod f(p_i)^{k_i}\\)\u3002</p>"},{"location":"template/math/number-theory/default/#_11","title":"\u5e38\u89c1\u7684\u79ef\u6027\u51fd\u6570","text":"<p>\u5355\u4f4d\u51fd\u6570 \\(\\varepsilon(n)=[n=1]\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u6052\u7b49\u51fd\u6570 \\(id_k(n)=n^k\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u5e38\u6570\u51fd\u6570 \\(I(n)=1\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u9664\u6570\u51fd\u6570 \\(\\sigma_k(n)=\\sum_{d|n}d^k\\) (\u79ef\u6027)\uff0c\\(\\sigma_0(n)=d(n)\\)</p> <p>\u6b27\u62c9\u51fd\u6570 \\(\\varphi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]\\) (\u79ef\u6027) </p> <p>\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570 \\(\\begin{equation}\\mu(n)=\\begin{cases}1&amp;&amp;n=1\\\\{(-1)}^r&amp;&amp;n=p_1*p_2*\u2026p_r(\\text{\u65e0\u5e73\u65b9\u56e0\u6570})\\\\0&amp;&amp;else\\end{cases}\\nonumber\\end{equation}\\) (\u79ef\u6027\u548c\u52a0\u6027) </p>"},{"location":"template/math/number-theory/default/#_12","title":"\u72c4\u5229\u514b\u96f7\u5377\u79ef","text":"\\[ \\nonumber(f*g)(n)=\\sum_{i*j=n}f(i)*g(j)=\\sum_{d|n}f(d)\\cdot{g(\\frac{n}{d})} \\] <p>\u6ee1\u8db3\u4ea4\u6362\u5f8b\uff0c\u7ed3\u5408\u5f8b\uff0c\u5206\u914d\u5f8b</p> \\[ \\begin{gather} I\\ast I=\\sigma_0\\\\ id_k\\ast I=\\sigma_k\\\\ \\varphi\\ast I=Id_0\\\\ \\sigma_k\\ast\\mu=Id_k\\\\ \\mu\\ast I=\\varepsilon\\\\ \\mu\\ast id_0=\\phi\\\\ id_0\\ast id_0=id_0\\cdot\\sigma_0\\\\ id_k\\ast id_k=id_k\\cdot\\sigma_0\\\\ id_k\\ast id_t=id_k\\cdot\\sigma_{t-k}\\\\ \\end{gather} \\] <p>\u4e24\u4e2a\u79ef\u6027\u51fd\u6570\u7684\u72c4\u5229\u514b\u96f7\u5377\u79ef\u8fd8\u662f\u79ef\u6027\u51fd\u6570</p> <p>\u5b8c\u5168\u79ef\u6027\u51fd\u6570 \\(g\\) \u548c \u79ef\u6027\u51fd\u6570 \\(f\\cdot g\\) \u7684\u5377\u79ef \\(g\\ast(f\\cdot g)=(f\\ast I)\\cdot g\\)</p>"},{"location":"template/math/number-theory/default/#_13","title":"\u516c\u5f0f","text":"<p>A-\u4f60\u4e5f\u559c\u6b22\u6570\u5b66\u5417_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u4e00\uff09\u573a\uff1a\u6cb3\u5357\u519c\u4e1a\u5927\u5b66</p> \\[ \\begin{align} \\sum_{n=1}^{k}\\sum_{i=1}^n\\varphi\\left(i\\right)\\cdot\\lfloor\\dfrac{n}{i}\\rfloor&amp;=\\sum_{n=1}^{k}\\sum_{i=1}^n\\sum_{d|i}\\varphi\\left(d\\right)\\\\ &amp;=\\sum_{n=1}^k\\sum_{i=1}^ni\\\\ &amp;=\\sum_{n=1}^k\\dfrac{n\\cdot{(n+1)}}{2}\\\\ &amp;=\\dfrac{\\sum_{n=1}^kn^2+\\sum_{n=1}^ki}{2}\\\\ &amp;=\\dfrac{\\frac{k\\cdot(k+1)\\cdot(2\\cdot{k}+1)}{6}+\\frac{k\\cdot(k+1)}{2}}{2}\\\\ &amp;=\\dfrac{k\\cdot(k+1)\\cdot(k+2)}{6} \\end{align} \\] \\[ \\sum_{i=a}^{b}C_i^d=\\dfrac{\\prod_{i=b-d+1}^bi!}{{d!}^{b-a+1}\\cdot\\prod_{i=a-d}^{a-1}i!} \\] \\[ d(x\\cdot{y})=\\sum_{i|x}\\sum_{j|y}[\\gcd(i,j)=1] \\]"},{"location":"template/math/number-theory/discrete-logarithm/","title":"\u79bb\u6563\u5bf9\u6570","text":"\\[ \\nonumber A^x\\equiv{B}\\pmod{C} \\] \u6a21\u7248 BSGS \\(O(\\sqrt{p})\\)ExBSGS \\(O(\\log^2p+\\sqrt{p})\\)Pohlig-Hellman \\(O\\left(\\sum_{i=1}^te_i\\sqrt{q _i} + \\log N\\right)\\) <p>C \u4e00\u5b9a\u8981\u4e3a\u8d28\u6570</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 qpow(i64 a, i64 b, i64 c, i64 res = 1) {\n    res %= c;\n    a %= c;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % c;\n        }\n        a = a * a % c;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 BSGS(i64 A, i64 B, i64 C) {\n    int m = ceil(sqrtl(C));\n    A %= C;\n    B %= C;\n    unordered_map&lt;i64, int&gt; vis;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = B * A % C;\n        vis[B] = i;\n    }\n    i64 temp = qpow(A, m, C);\n    B = 1;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = temp * B % C;\n        if (vis.count(B)) {\n            return (1LL * i * m - vis[B] + C) % C;\n        }\n    }\n    return -1;\n}\nint main() {\n    i64 A, B, C;\n    cin &gt;&gt; C &gt;&gt; A &gt;&gt; B;\n    i64 k = BSGS(A, B, C);\n    if (k == -1) {\n        cout &lt;&lt; \"no solution\\n\";\n    } else {\n        cout &lt;&lt; k &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>C \u65e0\u9650\u5236</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 qpow(i64 a, i64 b, i64 c, i64 res = 1) {\n    res %= c;\n    a %= c;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % c;\n        }\n        a = a * a % c;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 BSGS(i64 A, i64 B, i64 C) {\n    int m = ceil(sqrtl(C));\n    A %= C;\n    B %= C;\n    unordered_map&lt;i64, int&gt; vis;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = B * A % C;\n        vis[B] = i;\n    }\n    i64 temp = qpow(A, m, C);\n    B = 1;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = temp * B % C;\n        if (vis.count(B)) {\n            return (1LL * i * m - vis[B] + C) % C;\n        }\n    }\n    return -1;\n}\nvoid Exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\ni64 inv(i64 a, i64 b) {\n    i64 x, y;\n    Exgcd(a, b, x, y);\n    return (x % b + b) % b;\n}\ni64 ExBSGS(i64 A, i64 B, i64 C) {\n    A %= C;\n    B %= C;\n    if (B == 1 || C == 1) return 0;\n    i64 g = __gcd(A, C), na = 1;\n    int k = 0;\n    while (g &gt; 1) {\n        if (B % g != 0) {\n            return -1;\n        }\n        k++;\n        B /= g;\n        C /= g;\n        na = na * (A / g) % C;\n        if (na == B) {\n            return k;\n        }\n        g = __gcd(A, C);\n    }\n    i64 res = BSGS(A, B * inv(na, C) % C, C);\n    if (res == -1) {\n        return -1;\n    }\n    return res + k;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    i64 A, B, C;\n    while (cin &gt;&gt; A &gt;&gt; C &gt;&gt; B) {\n        if (A == B &amp;&amp; B == C &amp;&amp; C == 0) break;\n        i64 k = ExBSGS(A, B, C);\n        if (k == -1) {\n            cout &lt;&lt; \"No Solution\\n\";\n        } else {\n            cout &lt;&lt; k &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>C\u4e00\u5b9a\u8981\u4e3a\u8d28\u6570\u4e14C-1\u8d28\u56e0\u5b50\u6570\u8f83\u5c0f</p> \u4ee3\u7801 C++<pre><code>i64 qpow(i64 a, i64 b) {\n    i64 res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a;\n        }\n        a = a * a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 qpow(__int128 a, i64 b, i64 c, __int128 res = 1) {\n    res %= c;\n    a %= c;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % c;\n        }\n        a = a * a % c;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate&lt;class T&gt; struct Random {\n    mt19937 mt;\n    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    T operator()(T L, T R) {\n        uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n        return dist(mt);\n    }\n};\nRandom&lt;i64&gt; rng;\nnamespace Miller_Rabin {\n    bool Miller_Rabin(i64 n, const vector&lt;i64&gt; &amp;as) {\n        i64 d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        i64 e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            i64 t = d;\n            __int128 y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(i64 n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u8d28\u6570\nnamespace Pollard_rho {\n    template&lt;class T&gt;\n    struct Random {\n        mt19937 mt;\n        Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n        T operator()(T L, T R) {\n            uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n            return dist(mt);\n        }\n    };\n    Random&lt;i64&gt; rng;\n    i64 get(i64 n) {\n        if (n % 2 == 0) {\n            return 2;\n        }\n        if (is_prime(n)) {\n            return n;\n        }\n        i64 R;\n        auto f = [&amp;](__int128 x) {\n            return (x * x + R) % n;\n        };\n        while (true) {\n            i64 x, y, ys, q = 1;\n            R = rng(2, n - 1), y = rng(2, n - 1);\n            i64 g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r *= 2) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        y = f(y);\n                        q = (__int128) q * (((x - y) % n + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    ys = f(ys);\n                    g = __gcd(((x - ys) % n + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;i64&gt; factorize(i64 n) {\n        if (n &lt;= 1) {\n            return {};\n        }\n        i64 p = get(n);\n        if (p == n) {\n            return {n};\n        }\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;i64, int&gt;&gt; prime_factor(i64 n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;i64, int&gt;&gt; res;\n        for (auto &amp;e : ps) {\n            if (!res.empty() &amp;&amp; res.back().first == e) {\n                res.back().second++;\n            } else {\n                res.emplace_back(e, 1);\n            }\n        }\n        return res;\n    }\n    vector&lt;i64&gt; divisors(i64 n) {\n        auto ps = prime_factor(n);\n        int cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            cnt *= t + 1;\n        }\n        vector&lt;i64&gt; res(cnt, 1);\n        cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            i64 pw = 1;\n            for (int i = 1 ; i &lt;= t ; i++) {\n                pw *= p;\n                for (int j = 0 ; j &lt; cnt ; j++) {\n                    res[cnt * i + j] = res[j] * pw;\n                }\n            }\n            cnt *= t + 1;\n        }\n        return res;\n    }\n} // Pollard_rho\nusing Pollard_rho::prime_factor; // \u6240\u6709\u8d28\u56e0\u5b50 (\u8d28\u56e0\u5b50, \u4e2a\u6570)\nusing Pollard_rho::divisors; // \u6240\u6709\u56e0\u5b50\nnamespace Pohlig_Hellman {\n    i64 BSGS(i64 A, i64 B, i64 C, i64 P) {\n        int m = ceil(sqrtl(C));\n        A %= P;\n        B %= P;\n        unordered_map&lt;i64, int&gt; vis;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            B = B * A % P;\n            vis[B] = i;\n        }\n        i64 temp = qpow(A, m, P);\n        B = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            B = temp * B % P;\n            if (vis.count(B)) {\n                return ((__int128) i * m - vis[B] + P) % P;\n            }\n        }\n        return -1;\n    }\n    i64 getK(i64 A, i64 B, i64 prime, i64 cnt, i64 phi, i64 P) {\n        vector&lt;i64&gt; pi;\n        i64 temp = 1;\n        for (int i = 0 ; i &lt;= cnt ; i++) {\n            pi.push_back(temp);\n            temp *= prime;\n        }\n        i64 k = qpow(A, pi[cnt - 1], P);\n        i64 inv = 0;\n        temp = 1;\n        for (int i = cnt - 1 ; i &gt;= 0 ; i--) {\n            i64 tp = qpow(A, pi[cnt] - inv, P);\n            i64 tx = (__int128) temp * BSGS(k, qpow((__int128) B * tp % P, pi[i], P), prime, P);\n            inv += tx;\n            temp *= prime;\n        }\n        return inv;\n    }\n    int getMinRoot(i64 P, i64 phi, const vector&lt;pair&lt;i64, int&gt;&gt;&amp; factors ) {\n        for (int k = 2 ; ; k++) {\n            bool flag = true;\n            for (auto &amp;[x, y] : factors) {\n                if (qpow(k, phi / x, P) == 1LL) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return k;\n        }\n    }\n    void Exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) {\n        if (b == 0) {\n            x = 1;\n            y = 0;\n            return;\n        }\n        Exgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    i64 CRT(const vector&lt;i64&gt; &amp;a, const vector&lt;pair&lt;i64, int&gt;&gt; &amp;factors) {\n        // p_i \u4e24\u4e24\u4e92\u8d28\n        // ans % p_i = a_i\n        i64 n = 1, ans = 0;\n        int len = a.size();\n        vector&lt;i64&gt; p(factors.size());\n        for (int i = 0 ; i &lt; len ; i++) {\n            p[i] = qpow(factors[i].first, factors[i].second);\n            n *= p[i];\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            i64 m = n / p[i];\n            i64 x, y;\n            Exgcd(m, p[i], x, y);\n            ans = (ans + (__int128) a[i] * m % n * x % n + n) % n;\n        }\n        return ans;\n    }\n    i64 getX(i64 A, i64 B, i64 phi, i64 P, const vector&lt;pair&lt;i64, int&gt;&gt; &amp;res) {\n        vector&lt;i64&gt; k;\n        for (auto &amp;[x, y] : res) {\n            i64 z = qpow(x, y);\n            i64 tA = qpow(A, phi / z, P);\n            i64 tB = qpow(B, phi / z, P);\n            k.push_back(getK(tB, tA, x, y, phi, P));\n        }\n        return CRT(k, res);\n    }\n    i64 solve(i64 A, i64 B, i64 P) {\n        if (B == 1LL) {\n            return 0LL;\n        }\n        i64 phi = P - 1;\n        vector&lt;pair&lt;i64, int&gt;&gt; res = Pollard_rho::prime_factor(phi);\n        int rt = getMinRoot(P, phi, res);\n        i64 x = getX(A, rt, phi, P, res), y = getX(B, rt, phi, P, res);\n        i64 a, b;\n        if (x == 0LL) {\n            if (y == 0LL) {\n                return 1LL;\n            } else if (y == 1LL) {\n                return 0LL;\n            }\n            return -1LL;\n        }\n        i64 d = __gcd(x, phi);\n        if (y % d != 0) return -1;\n        x /= d;\n        phi /= d;\n        y /= d;\n        Exgcd(x, phi, a, b);\n        a = ((__int128) a * y % phi + phi) % phi;\n        return a;\n    }\n} // Pohlig_Hellman\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3846(BSGS)\u6d1b\u8c37P4195(ExBSGS) <p>P3846 [TJOI2007] \u53ef\u7231\u7684\u8d28\u6570/\u3010\u6a21\u677f\u3011BSGS - \u6d1b\u8c37</p> <p>P4195 \u3010\u6a21\u677f\u3011\u6269\u5c55 BSGS/exBSGS - \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/du-sieve/","title":"\u675c\u6559\u7b5b","text":""},{"location":"template/math/number-theory/du-sieve/#_2","title":"\u89e3\u51b3\u95ee\u9898","text":"<p>\u8bbe \\(f(n)\\) \u662f\u4e00\u4e2a\u79ef\u6027\u51fd\u6570\uff0c</p> <p>\\(g(n)\\) \u662f\u4e00\u4e2a\u79ef\u6027\u51fd\u6570\u4e14\u80fd\u5feb\u901f\u8ba1\u7b97\u524d\u7f00\u548c\uff0c</p> <p>\\((f\\ast g)(n)\\) \u80fd\u5feb\u901f\u8ba1\u7b97\u524d\u7f00\u548c\u3002</p> <p>\u8ba1\u7b97   \\(S(n)=\\sum_{i=1}^nf(i)\\)</p>"},{"location":"template/math/number-theory/du-sieve/#_3","title":"\u516c\u5f0f","text":"\\[ g(1)\\cdot{S}(n)=\\sum_{i=1}^n(f\\ast{g})(i)-\\sum_{i=2}^ng(i)\\cdot{S}(\\lfloor\\frac{n}{i}\\rfloor) \\] \u63a8\u5bfc\u8fc7\u7a0b \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u524d\u7f00\u548c\u6b27\u62c9\u51fd\u6570\u524d\u7f00\u548c \\[ \\begin{gather} \\text{\u4ee4: }g(n)=1(n)\\\\ \\text{\u5219: }f\\ast{g}=\\mu\\ast1=\\epsilon\\\\ \\end{gather} \\] \\[ \\begin{align} S(n)&amp;=\\sum_{i=1}^n\\epsilon(i)-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor)\\\\ &amp;=1-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor) \\end{align} \\] \\[ \\begin{gather} \\text{\u4ee4: }g(n)=1(n)\\\\ \\text{\u5219: }f\\ast{g}=\\varphi\\ast1=Id_0\\\\ \\end{gather} \\] \\[ \\begin{align} S(n)&amp;=\\sum_{i=1}^nId_0(i)-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor)\\\\ &amp;=\\frac{n\\cdot(n+1)}{2}-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor) \\end{align} \\] \u6a21\u7248 <p>\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n^{\\frac{3}{4}})\\)</p> \u4ee3\u7801 C++<pre><code>namespace DlsSieve {\n    int N;\n    vector&lt;bool&gt; vis;\n    vector&lt;int&gt; mob, prime;\n    vector&lt;i64&gt; phi;\n    unordered_map&lt;i64, i64&gt; mobSums;\n    unordered_map&lt;i64, i64&gt; phiSums;\n    void init(const int N) {\n        vis.resize(0);\n        vis.resize(N + 1);\n        phi.resize(0);\n        phi.resize(N + 1);\n        mob.resize(0);\n        mob.resize(N + 1);\n        DlsSieve::N = N;\n        mob[1] = phi[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n                mob[i] = -1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt; N) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x; \n                    mob[i * x] = 0;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n                mob[i * x] = -mob[i];\n            }\n        }\n        for (int i = 2 ; i &lt;= N ; i++) {\n            phi[i] += phi[i - 1];\n            mob[i] += mob[i - 1];\n        }\n    }\n    i64 gSum(i64 x) {\n        return x;\n    }\n    i64 mobSum(i64 x) {\n        if (x &lt;= N) {\n            return mob[x];\n        }\n        if (mobSums.count(x)) {\n            return mobSums[x];\n        }\n        i64 res = 1;\n        for (i64 L = 2, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            res -= (gSum(R) - gSum(L - 1)) * mobSum(x / L);\n        }\n        return mobSums[x] = res / gSum(1);\n    }\n    i64 phiSum(i64 x) {\n        if (x &lt;= N) {\n            return phi[x];\n        }\n        if (phiSums.count(x)) {\n            return phiSums[x];\n        }\n        i64 res = x * (x + 1) / 2;\n        for (i64 L = 2, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            res -= (gSum(R) - gSum(L - 1)) * phiSum(x / L);\n        }\n        return phiSums[x] = res / gSum(1);\n    }\n} // DlsSieve\n</code></pre> \u4f8b\u9898 <p>P4213 \u3010\u6a21\u677f\u3011\u675c\u6559\u7b5b\uff08Sum\uff09- \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/euclidean/","title":"\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"\u63a8\u5bfc\u8fc7\u7a0b \\(f(a,b,c,n)=\\sum_{i=0}^n\\lfloor\\frac{a*i+b}{c}\\rfloor\\)\\(g(a,b,c,n)=\\sum_{i=0}^ni*\\lfloor\\frac{a*i+b}{c}\\rfloor\\)\\(h(a,b,c,n)=\\sum_{i=0}^n\\left\\lfloor\\frac{a*i+b}{c}\\right\\rfloor^2\\)\u603b\u7ed3 \\(a\\ge c\\text{ \u6216 }b\\ge c\\)\\(a&lt;c\\text{ \u4e14 }b&lt;c\\) \\[ \\begin{align} f(a,b,c,n)&amp;=\\sum_{i=0}^n\\lfloor\\dfrac{a*i+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{\\left(\\lfloor\\frac{a}{c}\\rfloor*c+a\\ mod\\ c\\right)*i+\\left(\\lfloor\\frac{b}{c}\\rfloor*c+b\\ mod\\ c\\right)}{c}\\right\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\left\\lfloor\\lfloor\\frac{a}{c}\\rfloor*i+\\frac{\\left(a\\ mod\\ c\\right)*i}{c}+\\lfloor\\frac{b}{c}\\rfloor+\\frac{\\left(b\\ mod\\ c\\right)}{c}\\right\\rfloor\\\\ &amp;=\\frac{n*(n+1)}{2}*\\lfloor\\frac{a}{c}\\rfloor+(n+1)*\\lfloor{\\frac{b}{c}}\\rfloor+\\sum_{i=0}^n\\left\\lfloor\\frac{(a\\ mod\\ c)*i+(b\\ mod\\ c)}{c}\\right\\rfloor\\\\ &amp;=\\frac{n*(n+1)}{2}*\\lfloor\\frac{a}{c}\\rfloor+(n+1)*\\lfloor{\\frac{b}{c}}\\rfloor+f(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] \\[ \\begin{align} f(a,b,c,n)&amp;=\\sum_{i=0}^n\\lfloor\\dfrac{a*i+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a*i+b}{c}\\rfloor-1}1\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\sum_{i=0}^n\\left[j&lt;\\lfloor\\frac{a*i+b}{c}\\rfloor\\right] \\end{align} \\] \\[ \\begin{align} j&lt;\\lfloor\\frac{a*i+b}{c}\\rfloor\\Longleftrightarrow{j}+1\\leq\\frac{a*i+b}{c}\\Longleftrightarrow{j}*c+c\\le{a}*i+b\\Longleftrightarrow\\left\\lfloor\\frac{j*c+c-b-1}{a}\\right\\rfloor&lt;i \\end{align} \\] \\[ \\begin{align} f(a,b,c,b)&amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\sum_{i=0}^n\\left[\\left\\lfloor\\frac{j*c+c-b-1}{a}\\right\\rfloor&lt;i\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\left(n-\\left\\lfloor\\frac{j*c+c-b-1}{a}\\right\\rfloor\\right)\\\\ &amp;=n*\\lfloor\\frac{a*n+b}{c}\\rfloor-f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1) \\end{align} \\] \\(a\\ge{c}\\text{ \u6216 }b\\ge{c}\\)\\(a&lt;c\\text{ \u4e14 }b&lt;c\\) \\[ \\begin{align} g(a,b,c,n)&amp;=\\sum_{i=0}^ni*\\lfloor\\frac{a*i+b}{c}\\rfloor\\\\ &amp;=\\frac{n*(n+1)*(2n+1)}{6}*\\lfloor\\frac{a}{c}\\rfloor+\\frac{n*(n+1)}{2}*\\lfloor\\frac{b}{c}\\rfloor+g(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] \\[ \\begin{align} g(a,b,c,n)&amp;=\\sum_{i=0}^ni*\\lfloor\\dfrac{a*i+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a*i+b}{c}\\rfloor-1}i\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\sum_{i=0}^ni*\\left[j&lt;\\lfloor\\frac{a*i+b}{c}\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\sum_{i=0}^ni*\\left[\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor&lt;i\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\frac{(\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor+1+n)*(n-\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor)}{2}\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}\\left(\\frac{n^2+n-\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor-(\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor)^2}{2}\\right)\\\\ &amp;=\\frac{1}{2}*n*(n+1)*\\lfloor\\frac{a*n+b}{c}\\rfloor-\\frac{1}{2}*h(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ &amp;-\\frac{1}{2}*f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1) \\end{align} \\] \\(a\\ge{c}\\text{ \u6216 }b\\ge{c}\\)\\(a&lt;c\\text{ \u4e14 }b&lt;c\\) \\[ \\begin{align} h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{a*i+b}{c}\\right\\rfloor^2\\\\ &amp;=(n+1)*\\lfloor\\frac{b}{c}\\rfloor^2+n*(n+1)*\\lfloor\\frac{a}{c}\\rfloor*\\lfloor\\frac{b}{c}\\rfloor+\\frac{n*(n+1)*(2n+1)}{6}*\\lfloor\\frac{a}{c}\\rfloor^2\\\\ &amp;+2*\\lfloor\\frac{b}{c}\\rfloor*f(a\\ mod\\ c,b\\ mod\\ c,c,n) +2*\\lfloor\\frac{a}{c}\\rfloor*g(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] \\[ \\begin{align} n^2&amp;=2*\\frac{n*(n+1)}{2}-n=2*(\\sum_{i=0}^ni)-n\\\\ h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{a*i+b}{c}\\right\\rfloor^2\\\\ &amp;=\\sum_{i=0}^n\\left[2*(\\sum_{j=1}^{\\lfloor\\frac{a*i+b}{c}\\rfloor}j)-\\lfloor\\frac{a*i+b}{c}\\rfloor\\right]\\\\ &amp;=2*(\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor\\frac{a*i+b}{c}\\rfloor}j)-f(a,b,c,n)\\\\ \\sum_{i=0}^n\\sum_{j=1}^{\\lfloor\\frac{a*i+b}{c}\\rfloor}j&amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}j+1\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}(j+1)\\sum_{i=0}^n\\left[j&lt;\\lfloor\\frac{a*i+b}{c}\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}(j+1)\\sum_{i=0}^n[\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor&lt;i]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}(j+1)*(n-\\lfloor\\frac{j*c+c-b-1}{a}\\rfloor)\\\\ &amp;=\\frac{1}{2}*n*\\lfloor\\frac{a*n+b}{c}\\rfloor*(\\lfloor\\frac{a*n+b}{c}\\rfloor+1)-\\sum_{j=0}^{\\lfloor\\frac{a*n+b}{c}\\rfloor-1}(j+1)*\\left\\lfloor\\frac{j*c+c-b-1}{a}\\right\\rfloor\\\\ &amp;=\\frac{1}{2}*n*\\lfloor\\frac{a*n+b}{c}\\rfloor*(\\lfloor\\frac{a*n+b}{c}\\rfloor+1)-g(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ &amp;-f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ h(a,b,c,n)&amp;=n*\\lfloor\\frac{a*n+b}{c}\\rfloor*(\\lfloor\\frac{a*n+b}{c}\\rfloor+1)-2*g(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ &amp;-2*f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)-f(a,b,c,n)\\\\ \\end{align} \\] \\[ f(a,b,c,n)= \\begin{cases} \\frac{n*(n+1)}{2}*\\lfloor\\frac{a}{c}\\rfloor+(n+1)*\\lfloor{\\frac{b}{c}}\\rfloor+f(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ n*\\lfloor\\frac{a*n+b}{c}\\rfloor-f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\] \\[ g(a,b,c,n)= \\begin{cases} \\frac{n*(n+1)*(2n+1)}{6}*\\lfloor\\frac{a}{c}\\rfloor+\\frac{n*(n+1)}{2}*\\lfloor\\frac{b}{c}\\rfloor+g(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ \\frac{1}{2}*n*(n+1)*\\lfloor\\frac{a*n+b}{c}\\rfloor-\\frac{1}{2}*h(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ \\ -\\frac{1}{2}*f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\] \\[ h(a,b,c,n)= \\begin{cases} (n+1)*\\lfloor\\frac{b}{c}\\rfloor^2+n*(n+1)*\\lfloor\\frac{a}{c}\\rfloor*\\lfloor\\frac{b}{c}\\rfloor+\\frac{n*(n+1)*(2n+1)}{6}*\\lfloor\\frac{a}{c}\\rfloor^2\\\\ +2*\\lfloor\\frac{b}{c}\\rfloor*f(a\\ mod\\ c,b\\ mod\\ c,c,n)+2*\\lfloor\\frac{a}{c}\\rfloor*g(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ n*\\lfloor\\frac{a*n+b}{c}\\rfloor*(\\lfloor\\frac{a*n+b}{c}\\rfloor+1)-2*g(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)\\\\ -2*f(c,c-b-1,a,\\lfloor\\frac{a*n+b}{c}\\rfloor-1)-f(a,b,c,n)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\] \u6a21\u7248 f(x)f(x),g(x),h(x) \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nconst i64 i2 = qpow(2);\nconst i64 i6 = qpow(6);\ni64 calc(i64 n, i64 a, i64 b, i64 c) {\n    i64 ac = a / c, bc = b / c;\n    i64 m = (a * n + b) / c;\n    i64 n1 = (n + 1) % P;\n    i64 n_p = n % P, m_p = m % P;\n    if (a == 0) {\n        return bc * n1 % P;\n    }\n    if (a &gt;= c || b &gt;= c) {\n        i64 res = calc(n, a % c, b % c, c);\n        return (n_p * n1 % P * i2 % P * ac % P + bc * n1 % P + res) % P;\n    }\n    i64 res = calc(m - 1, c, c - b - 1, a);\n    return (n_p * m_p % P - res + P) % P;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\ni64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nconst i64 i2 = qpow(2);\nconst i64 i6 = qpow(6);\nstruct Node {\n    i64 f, g, h;\n    Node() = default;\n    Node(i64 f, i64 g, i64 h) : f(f), g(g), h(h) {}\n};\nNode calc(i64 n, i64 a, i64 b, i64 c) {\n    i64 m = (a * n + b) / c;\n    i64 n1 = (n + 1) % P, n2 = (n * 2 + 1) % P;\n    i64 ac = a / c % P, bc = b / c % P;\n    i64 n_p = n % P, m_p = m % P;\n    if (a == 0) {\n        return Node(\n            bc * n1 % P,\n            bc * n_p % P * n1 % P * i2 % P,\n            bc * bc % P * n1 % P\n        );\n    }\n    if (a &gt;= c || b &gt;= c) {\n        Node res = calc(n, a % c, b % c, c);\n        return Node(\n            (n_p * n1 % P * i2 % P * ac % P + bc * n1 % P + res.f) % P,\n            (ac * n_p % P * n1 % P * n2 % P * i6 % P + bc * n_p % P * n1 % P * i2 % P + res.g) % P,\n            (ac * ac % P * n_p % P * n1 % P * n2 % P * i6 % P + bc * bc % P * n1 % P + ac * bc % P * n_p % P * n1 % P + res.h + 2LL * bc * res.f % P + 2LL * ac * res.g % P) % P\n        );\n    }\n    Node res = calc(m - 1, c, c - b - 1, a);\n    long long f = (n_p * m_p % P - res.f + P) % P;\n    return Node(\n        f,\n        ((m_p * n_p % P * n1 % P - res.h - res.f) * i2 % P + P) % P,\n        ((n_p * m_p % P * (m_p + 1) % P - 2LL * res.g - 2LL * res.f - f) % P + P) % P\n    );\n}\n</code></pre> \u4f8b\u9898 <p>P5170 \u3010\u6a21\u677f\u3011\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/euclidean/#_2","title":"\u4e07\u80fd\u6b27\u51e0\u91cc\u5f97","text":"<p>\\(\\sum_{i=0}^n\\frac{a*i+b}{c}\\)</p> \u6a21\u7248 f(x),g(x),h(x) \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\nstruct Node {\n    i64 cntU, cntR;\n    i64 sum, f, g, h;\n    Node() : cntU(0), cntR(0) {\n        sum = f = g = h = 0;\n    }\n    friend Node operator+(Node a, Node b) {\n        Node res;\n        res.cntU = (a.cntU + b.cntU) % P;\n        res.cntR = (a.cntR + b.cntR) % P;\n        res.sum = (a.sum + b.sum + a.cntR * b.cntR % P) % P;\n        res.f = (a.f + b.f + a.cntU * b.cntR % P) % P;\n        res.g = (a.g + b.g + a.cntU * a.cntU % P * b.cntR % P + 2 * a.cntU * b.f % P) % P;\n        res.h = (a.h + b.h + a.cntU * a.cntR % P * b.cntR % P + a.cntU * b.sum % P + a.cntR * b.f % P) % P;\n        return res;\n    }\n};\nNode qpow(Node a, i64 b, Node res = {}) {\n    while (b) {\n        if (b &amp; 1) res = res + a;\n        a = a + a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 S(i64 P, i64 L, i64 R, i64 Q) {\n    return (P * L + R) / Q;\n}\nNode get(i64 P, i64 Q, i64 R, i64 L, Node a, Node b) {\n    if (L == 0LL) return Node();\n    R %= Q;\n    if (P &gt;= Q) {\n        return get(P % Q, Q, R, L, a, qpow(a, P / Q) + b);\n    }\n    i64 m = S(P, L, R, Q);\n    if (m == 0LL) return qpow(b, L);\n    i64 cnt = L - S(Q, m, -R - 1, P);\n    return qpow(b, (Q - R - 1) / P) + a + get(Q, P, (Q - R - 1) % P, m - 1, b, a) + qpow(b, cnt);\n}\nNode solve(i64 a, i64 c, i64 b, i64 n, Node U, Node R) {\n    Node res = qpow(U, b / c) + get(a, c, b, n, U, R);\n    res.f = (res.f + b / c) % P;\n    res.g = (res.g + (b / c) % P * (b / c) % P) % P;\n    return res;\n}\n</code></pre> \u4f8b\u9898 LOJ6440 \u4e07\u80fd\u6b27\u51e0\u91cc\u5f97ABC283H <p>#6440. \u4e07\u80fd\u6b27\u51e0\u91cc\u5f97 - LibreOJ</p> \\[ \\sum_{x=1}^LA^x*B^{\\lfloor\\frac{P*X+R}{Q}\\rfloor} \\] \u4ee3\u7801 C++<pre><code>using i64 = long long;\nconst i64 P = 998244353;\nusing Mat = array&lt;array&lt;i64, 20&gt;, 20&gt;;\nMat operator+(Mat x, Mat y) {\n    Mat res{};\n    for (int i = 0 ; i &lt; 20 ; i++) {\n        for (int j = 0 ; j &lt; 20 ; j++) {\n            res[i][j] = (x[i][j] + y[i][j]) % P;\n        }\n    }\n    return res;\n}\nMat operator*(Mat x, Mat y) {\n    Mat res{};\n    for (int i = 0 ; i &lt; 20 ; i++) {\n        for (int j = 0 ; j &lt; 20 ; j++) {\n            for (int k = 0 ; k &lt; 20 ; k++) {\n                res[i][j] = (res[i][j] + x[i][k] * y[k][j] % P) % P;\n            }\n        }\n    }\n    return res;\n}\nstruct Node {\n    Mat cntU, cntR, sum;\n    Node() {\n        cntU = cntR = sum = array&lt;array&lt;i64, 20&gt;, 20&gt;{};\n        for (int i = 0 ; i &lt; 20 ; i++) {\n            cntU[i][i] = cntR[i][i] = 1;\n        }\n    }\n    Node(Mat cntU, Mat cntR, Mat sum) : cntU(cntU), cntR(cntR), sum(sum) {}\n    friend Node operator+(Node a, Node b) {\n        // a \u662f x \u4e3a [1, a.cntR], (P * x + R) / Q \u4e3a a.cntU\n        // b \u662f x \u4e3a [1, b.cntR], (P * x + R) / Q \u4e3a b.cntU\n        Node res;\n        res.cntU = a.cntU * b.cntU;\n        res.cntR = a.cntR * b.cntR;\n        // sum(A^{x+a.cntR}*B^{s+a.cntU})\n        res.sum = a.sum + a.cntR * b.sum * a.cntU;\n        return res;\n    }\n};\nNode qpow(Node a, i64 b, Node res = {}) {\n    while (b) {\n        if (b &amp; 1) res = res + a;\n        a = a + a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 S(i64 P, i64 L, i64 R, i64 Q) {\n    return ((__int128) P * L + R) / Q;\n}\nNode get(i64 P, i64 Q, i64 R, i64 L, Node a, Node b) {\n    if (L == 0LL) return Node();\n    if (P &gt;= Q) {\n        return get(P % Q, Q, R, L, a, qpow(a, P / Q) + b);\n    }\n    i64 m = S(P, L, R, Q);\n    if (m == 0LL) return qpow(b, L);\n    i64 cnt = L - S(Q, m, -R - 1, P);\n    return qpow(b, (Q - R - 1) / P) + a + get(Q, P, (Q - R - 1) % P, m - 1, b, a) + qpow(b, cnt);\n}\nNode solve(i64 a, i64 c, i64 b, i64 n, Node U, Node R) {\n    // \u5408\u5e76 [0, 0] \u548c [1, n]\n    Node res = qpow(U, b / c) + get(a, c, b % c, n, U, R);\n    return res;\n}\n\nint main() {\n    i64 P, Q, R, L;\n    int n;\n    cin &gt;&gt; P &gt;&gt; Q &gt;&gt; R &gt;&gt; L &gt;&gt; n;\n    Mat A{}, B{}, E{};\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; n ; j++) {\n            cin &gt;&gt; A[i][j];\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; n ; j++) {\n            cin &gt;&gt; B[i][j];\n        }\n    }\n    for (int i = 0 ; i &lt; 20 ; i++) {\n        E[i][i] = 1;\n    }\n    Node u{B, E, Mat{}}, r{E, A, A};\n    auto res = solve(P, Q, R, L, u, r).sum;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; n ; j++) {\n            cout &lt;&lt; res[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Ex - Popcount Sum</p> \\[ \\begin{align} \\sum_{i=1}^{n}[i\\%m==r]*popcount(i)\\\\ \\sum_{i=0}^{\\lfloor\\frac{n-m}{r}\\rfloor}popcount(i*m+r)\\\\ \\sum_{i=0}^{\\lfloor\\frac{n-m}{r}\\rfloor}\\sum_{j=0}^{30}[\\lfloor\\dfrac{i*m+r}{2^j}\\rfloor\\equiv1\\pmod2]\\\\ \\sum_{i=0}^{\\lfloor\\frac{n-m}{r}\\rfloor}\\sum_{j=0}^{30}\\left(\\lfloor\\dfrac{i*m+r}{2^j}\\rfloor-\\lfloor\\dfrac{i*m+r}{2^{j+1}}\\rfloor*2\\right)\\\\ \\sum_{j=0}^{30}\\left(\\sum_{i=0}^{\\lfloor\\frac{n-m}{r}\\rfloor}\\lfloor\\dfrac{i*m+r}{2^j}\\rfloor-\\sum_{i=0}^{\\lfloor\\frac{n-m}{r}\\rfloor}\\lfloor\\dfrac{i*m+r}{2^{j+1}}\\rfloor*2\\right) \\end{align} \\] \u4ee3\u7801 C++<pre><code>using i64 = long long;\nstruct Node {\n    i64 cntU, cntR;\n    i64 f;\n    Node() : cntU(0), cntR(0) {\n        f = 0;\n    }\n    Node(i64 cntU, i64 cntR, i64 f) : cntU(cntU), cntR(cntR), f(f) {}\n    friend Node operator+(Node a, Node b) {\n        Node res;\n        res.cntU = a.cntU + b.cntU;\n        res.cntR = a.cntR + b.cntR;\n        res.f = a.f + b.f + a.cntU * b.cntR;\n        return res;\n    }\n};\nNode qpow(Node a, i64 b, Node res = {}) {\n    while (b) {\n        if (b &amp; 1) res = res + a;\n        a = a + a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 S(i64 P, i64 L, i64 R, i64 Q) {\n    return (P * L + R) / Q;\n}\nNode get(i64 P, i64 Q, i64 R, i64 L, Node a, Node b) {\n    if (L == 0LL) return Node();\n    R %= Q;\n    if (P &gt;= Q) {\n        return get(P % Q, Q, R, L, a, qpow(a, P / Q) + b);\n    }\n    i64 m = S(P, L, R, Q);\n    if (m == 0LL) return qpow(b, L);\n    i64 cnt = L - S(Q, m, -R - 1, P);\n    return qpow(b, (Q - R - 1) / P) + a + get(Q, P, (Q - R - 1) % P, m - 1, b, a) + qpow(b, cnt);\n}\nNode solve(i64 a, i64 c, i64 b, i64 n, Node U, Node R) {\n    Node res = qpow(U, b / c) + get(a, c, b, n, U, R);\n    res.f += b / c;\n    return res;\n}\nvoid solve() {\n    i64 n, m, r;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;\n    i64 ans = 0;\n    Node U = {1, 0, 0}, R = {0, 1, 0};\n    for (int i = 0 ; i &lt;= 30 ; i++) {\n        i64 A = solve(m, 1LL &lt;&lt; i, r, (n - r) / m, U, R).f;\n        i64 B = solve(m, 1LL &lt;&lt; i + 1, r, (n - r) / m, U, R).f * 2;\n        ans += A - B;\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/euler/","title":"\u6b27\u62c9\u51fd\u6570","text":""},{"location":"template/math/number-theory/euler/#_2","title":"\u5b9a\u4e49","text":"<p>\\(\\phi(n)=\\sum^n_{i=1}[\\gcd(i,n)==1]\\)</p>"},{"location":"template/math/number-theory/euler/#_3","title":"\u5b9a\u7406","text":"<p>\u2460 \u82e5 \\(\\gcd(p,q)=1\\) \u5219 \\(\\phi(p\\cdot{q})=\\phi(p)\\cdot\\phi(q)\\)</p> <p>\u2461 \\(n\\) \u4e3a\u6b63\u6574\u6570 \u6709 \\(n=\\sum_{d|n}\\phi(d)\\)</p> <p>\u2462 \\(n=p_1^{a_1}\\cdot p_2^{a_2}\\cdot\u2026\\cdot p_s^{a_s}\\) \u662f\u6b63\u6574\u6570 \\(n\\) \u7684\u8d28\u5e42\u56e0\u5b50\u5206\u89e3 \u5219</p> \\[ \\begin{align} \\phi(n)&amp;=n\\cdot(1-\\frac{1}{p_1})\\cdot(1-\\frac{1}{p_2})\\cdot\u2026\\cdot(1-\\frac{1}{p_s})\\\\ &amp;=n\\cdot\\prod_{i=1}^s(1-\\frac{1}{p_i}) \\end{align} \\]"},{"location":"template/math/number-theory/euler/#_4","title":"\u6c42\u6b27\u62c9\u51fd\u6570","text":"\u6a21\u7248 \u66b4\u529b\\(O(\\sqrt n)\\)\u6b27\u62c9\u7b5b \\(O(n)\\) C++<pre><code>i64 euler_phi(i64 n) {\n    i64 ans = n;\n    for (int i = 2 ; 1LL * i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\n</code></pre> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime, phi;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        phi.resize(n);\n        phi[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"template/math/number-theory/euler/#_5","title":"\u6269\u5c55\u6b27\u62c9\u5b9a\u7406","text":"\\[ a^b\\equiv\\begin{cases} a^{b\\mod\\phi(p)}&amp;\\gcd(a,p)=1\\\\ a^b&amp;\\gcd(a,p)\\neq1,b&lt;\\phi(p)\\\\ a^{b\\mod\\phi(p)+\\phi(p)}&amp;\\gcd(a,p)\\neq1,b\\geq\\phi(p) \\end{cases}\\pmod{p} \\] \u4f8b\u9898 <p>P5091 \u3010\u6a21\u677f\u3011\u6269\u5c55\u6b27\u62c9\u5b9a\u7406 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 euler_phi(i64 n) {\n    i64 ans = n;\n    for (int i = 2 ; 1LL * i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\ni64 qpow(i64 a, i64 b, i64 P, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) res = res * a % P;\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    int a, m;\n    cin &gt;&gt; a &gt;&gt; m;\n    string b;\n    cin &gt;&gt; b;\n    i64 k = euler_phi(m);\n    bool flag = false;\n    i64 res = 0;\n    for (int i = 0 ; i &lt; (int) b.size() ; i++) {\n        res = res * 10 + (b[i] ^ 48);\n        if (res &gt; k) {\n            res %= k;\n            flag = true;\n        }\n    }\n    if (flag) res += k;\n    cout &lt;&lt; qpow(a, res, m);\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P4139\u6d1b\u8c37P3747 <p>P4139 \u4e0a\u5e1d\u4e0e\u96c6\u5408\u7684\u6b63\u786e\u7528\u6cd5 - \u6d1b\u8c37</p> <p>\u5df2\u77e5 \\(a_0=1,a_n=2^{a_{n-1}}\\)\uff0c\u95ee \\(a_n\\mod p\\) \u7684\u503c</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nnamespace EulerSieve {\n    vector&lt;int&gt; prime, phi;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        phi.resize(n);\n        phi[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing EulerSieve::phi;\ni64 qpow(i64 a, i64 b, i64 P, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 get(i64 P) {\n    if (P == 1) return 0;\n    return qpow(2, get(phi[P]) + phi[P], P);\n}\nvoid solve() {\n    int p;\n    cin &gt;&gt; p;\n    cout &lt;&lt; get(p) &lt;&lt; \"\\n\";\n}\nint main() {\n    EulerSieve::primeInit(10000000);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>P3747 [\u516d\u7701\u8054\u8003 2017] \u76f8\u9022\u662f\u95ee\u5019 - \u6d1b\u8c37</p> <p>\u64cd\u4f5c\u4e00: \u533a\u95f4 \\([L,R]\\) \u7684 \\(a_i=c^{a_i}\\)</p> <p>\u64cd\u4f5c\u4e8c: \u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u7684\u548c \u6a21 \\(p\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 50005;\ni64 a[N][60];\nvector&lt;array&lt;i64, 2&gt;&gt; lsp[60];\nvector&lt;int&gt; phi, B;\nint c, P;\ni64 euler_phi(i64 n) {\n    i64 ans = n;\n    for (int i = 2 ; 1LL * i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\ni64 qpow(i64 b, int idx) {\n    i64 k = lsp[idx][b % B[idx]][0] * lsp[idx][b / B[idx]][1];\n    if (k &gt;= phi[idx]) {\n        k = k % phi[idx] + phi[idx];\n    }\n    return k;\n}\ni64 get(i64 x, int cnt, int idx) {\n    if (cnt == 0) {\n        if (x &gt;= phi[idx]) {\n            x = x % phi[idx] + phi[idx];\n        }\n        return x;\n    }\n    if (phi[idx] == 1) {\n        return c ? 1 : 0;\n    }\n    return qpow(get(x, cnt - 1, idx + 1), idx);\n}\nstruct Node {\n    int L, R, cnt;\n    i64 sum;\n} tr[N &lt;&lt; 2];\nNode merge(Node &amp;x, Node &amp;y) {\n    return {x.L, y.R, min(x.cnt, y.cnt), (x.sum + y.sum) % P};\n}\nvoid pushup(int p) {\n    tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nvoid build(int p, int L, int R) {\n    if (L == R) {\n        tr[p] = {L, R, 0, a[L][0]};\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    pushup(p);\n}\nvoid modify(int p, int QL, int QR) {\n    if (tr[p].cnt &gt;= phi.size()) {\n        return;\n    }\n    if (tr[p].L == tr[p].R) {\n        tr[p].cnt++;\n        tr[p].sum = a[tr[p].L][tr[p].cnt];\n        return;\n    }\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(p &lt;&lt; 1, QL, QR);\n    if (QR &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, QL, QR);\n    pushup(p);\n}\ni64 query(int p, int QL, int QR) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        return tr[p].sum % P;\n    }\n    i64 res = 0;\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) {\n        res = (res + query(p &lt;&lt; 1, QL, QR)) % P;\n    }\n    if (QR &gt;= mid + 1) {\n        res = (res + query(p &lt;&lt; 1 | 1, QL, QR)) % P;\n    }\n    return res;\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; P &gt;&gt; c;\n    int tP = P;\n    while (tP != 1) {\n        B.push_back(10000);\n        int idx = phi.size();\n        lsp[idx].resize(B[idx] + 1);\n        lsp[idx][0] = {1, 1};\n        for (int i = 1 ; i &lt;= B[idx] ; i++) {\n            lsp[idx][i][0] = lsp[idx][i - 1][0] * c;\n            if (lsp[idx][i][0] &gt;= tP) {\n                lsp[idx][i][0] = lsp[idx][i][0] % tP + tP;\n            }\n        }\n        for (int i = 1 ; i &lt;= B[idx] ; i++) {\n            lsp[idx][i][1] = lsp[idx][i - 1][1] * lsp[idx][B[idx]][0];\n            if (lsp[idx][i][1] &gt;= tP) {\n                lsp[idx][i][1] = lsp[idx][i][1] % tP + tP;\n            }\n        }\n        phi.push_back(tP);\n        tP = euler_phi(tP);\n    }\n    phi.push_back(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i][0];\n        for (int j = 1 ; j &lt;= (int) phi.size() ; j++) {\n            a[i][j] = get(a[i][0], j, 0) % P;\n        }\n        a[i][0] %= P;\n    }\n    build(1, 1, n);\n    while (m--) {\n        int op, L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 0) {\n            modify(1, L, R);\n        } else {\n            cout &lt;&lt; query(1, L, R) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/inverse-modulo/","title":"\u9006\u5143","text":""},{"location":"template/math/number-theory/inverse-modulo/#_2","title":"\u7ebf\u6027\u9012\u63a8\u516c\u5f0f","text":"\\[ \\nonumber inv(i)=(p-\\dfrac{p}{i})*inv(p\\ mod\\ i)\\ mod\\ p \\]"},{"location":"template/math/number-theory/inverse-modulo/#_3","title":"\u5feb\u901f\u9006\u5143","text":"<p>\u5728 \\(P\\) \u56fa\u5b9a\u7684\u60c5\u51b5\u4e0b\uff0c\u5df2\u77e5\\(a\\)\uff0c\u6c42 \\(\\dfrac{1}{a}\\mod P\\)</p> \u6a21\u7248 \u5e38\u6570\u5c0f, \u67e5\u8be2\u8f83\u6162\u5e38\u6570\u5927\uff0c\u67e5\u8be2\u5feb <p>#110. \u4e58\u6cd5\u9006\u5143 - LibreOJ</p> \u4ee3\u7801 C++<pre><code>struct Inverse {\n    int B, B2, mod;\n    vector&lt;int&gt; inv, pre, suf;\n    vector&lt;pair&lt;int, int&gt;&gt; s;\n    Inverse() = default;\n    Inverse(int mod) : mod(mod) {\n        B = pow(mod, 0.3333333333);\n        B2 = B * B;\n        inv.resize(mod / B + 1);\n        inv[1] = 1;\n        for (int i = 2, j = mod / B ; i &lt;= j ; i++) {\n            inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n        }\n        s.resize(B2 + 1);\n        pre.resize(B2 + 1);\n        suf.resize(B2 + 1);\n        s[0] = {0, 1};\n        s[B2] = {1, 1};\n        pre[B2] = suf[B2] = B2;\n        for (int i = 2 ; i &lt;= B ; i++) {\n            for (int j = 1 ; j &lt; i ; j++) {\n                int pos = 1LL * j * B2 / i;\n                if (pre[pos]) continue;\n                pre[pos] = suf[pos] = pos;\n                s[pos] = {j, i};\n            }\n        }\n        for (int i = 1 ; i &lt;= B2 ; i++) {\n            if (pre[i] == 0) {\n                pre[i] = pre[i - 1];\n            }\n        }\n        for (int i = B2 ; i &gt; 0 ; i--) {\n            if (suf[i] == 0) {\n                suf[i] = suf[i + 1];\n            }\n        }\n    }\n    int calc(int T, pair&lt;int, int&gt; x) {\n        long long pos = 1LL * T * x.second;\n        if (llabs(pos - 1LL * mod * x.first) &gt; mod / B) return -1;\n        pos %= mod;\n        if (pos &lt;= mod / B) return 1LL * x.second * inv[pos] % mod;\n        return mod - 1LL * x.second * inv[mod - pos] % mod;\n    }\n    int operator()(int x) {\n        x %= mod;\n        if (x &lt;= mod / B) return inv[x];\n        int pos = 1LL * x * B2 / mod, res = calc(x, s[pre[pos]]);\n        if (res == -1) res = calc(x, s[suf[pos]]);\n        return res;\n    }\n}; // Inverse\n</code></pre> <p>\u5728\u7ebf O(1) \u9006\u5143 - Problem - QOJ.ac</p> \u4ee3\u7801 C++<pre><code>const int B = 1 &lt;&lt; 10, T = 1 &lt;&lt; 20;\nstruct Inverse {\n    int mod;\n    int f[T + 1], p[T + 1], buf[T * 3 + 3], *I = buf + T;\n    Inverse(int mod) : mod(mod) {\n        for (int i = 1 ; i &lt;= B ; i++) {\n            int s = 0, d = i &lt;&lt; 10;\n            for (int j = 1 ; j &lt;= T ; j++) {\n                if ((s += d) &gt;= mod) s -= mod;\n                if (s &lt;= T) {\n                    if (f[j] == 0) {\n                        f[j] = i;\n                        p[j] = s;\n                    }\n                } else if (s &gt;= mod - T) {\n                    if (f[j] == 0) {\n                        f[j] = i;\n                        p[j] = s - mod;\n                    }\n                } else {\n                    int t = (mod - T - s - 1) / d;\n                    s += t * d;\n                    j += t;\n                }\n            }\n        }\n        I[1] = f[0] = 1;\n        for (int i = 2 ; i &lt;= T &lt;&lt; 1 ; i++) {\n            I[i] = 1LL * (mod - mod / i) * I[mod % i] % mod;\n        }\n        for (int i = -1 ; i &gt;= -T ; i--) {\n            I[i] = mod - I[-i];\n        }\n    }\n    int operator()(int x) {\n        return 1LL * I[p[x &gt;&gt; 10] + (x &amp; 1023) * f[x &gt;&gt; 10]] * f[x &gt;&gt; 10] % mod;\n    }\n}; // Inverse\n</code></pre>"},{"location":"template/math/number-theory/light-speed-pow/","title":"\u5149\u901f\u5e42","text":"<p>\u5728\u56fa\u5b9a \\(a\\) \u548c \\(P\\) \u7684\u60c5\u51b5\u4e0b\uff0c\u5df2\u77e5 \\(b\\)\uff0c \\(O(1)\\) \u6c42 \\(a^b\\mod P\\)</p> \u6a21\u7248 C++<pre><code>struct LightSpeedPow {\n    int mod, a, B, phi;\n    vector&lt;array&lt;int, 2&gt;&gt; lsp;\n    LightSpeedPow() = default;\n    LightSpeedPow(int a, int mod) : a(a), mod(mod) {\n        B = pow(mod, 0.5);\n        lsp.resize(B + 1);\n        lsp[0] = {1, 1};\n        for (int i = 1 ; i &lt;= B ; i++) {\n            lsp[i][0] = 1LL * lsp[i - 1][0] * a % mod;\n        }\n        for (int i = 1 ; i &lt;= B ; i++) {\n            lsp[i][1] = 1LL * lsp[i - 1][1] * lsp[B][0] % mod;\n        }\n        phi = mod;\n        int x = mod;\n        for(int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n            if (x % i == 0) {\n                phi = phi / i * (i - 1);\n                while (x % i == 0) x /= i;\n            }\n        }\n        if (x != 1) phi = phi / x * (x - 1);\n    }\n    int operator()(int b) {\n        if (b &gt; phi) b %= phi;\n        return 1LL * lsp[b % B][0] * lsp[b / B][1] %mod;\n    }\n}; // LightSpeedPow\n</code></pre>"},{"location":"template/math/number-theory/linear-equation/","title":"\u540c\u4f59","text":"<p>\u57fa\u672c\u5b9a\u4e49 \\(a\\ \\%\\ m=b\\ \\%\\ m\\)\uff0c\u540c\u4f59\u5f0f\u4e3a \\(a\\equiv{b}\\pmod{m}\\)</p>"},{"location":"template/math/number-theory/linear-equation/#_2","title":"\u57fa\u672c\u5b9a\u7406","text":"<ol> <li>\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5f53\u4e14\u4ec5\u5f53 \\(m\\ |\\ (a-b)\\)</li> <li>\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6574\u6570 \\(k\\)\uff0c\u4f7f\u5f97 \\(a=b+k\\cdot{m}\\)</li> <li> <p>\u540c\u4f59\u5173\u7cfb\u662f\u7b49\u4ef7\u5173\u7cfb</p> <p>\u81ea\u53cd\uff1a\\(a\\equiv{a}\\pmod{m}\\)</p> <p>\u5bf9\u79f0\u6027\uff1a\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5219 \\(b\\equiv{a}\\pmod{m}\\)</p> <p>\u4f20\u9012\u6027\uff1a\\(a\\equiv{b}\\pmod{m},b\\equiv{c}\\pmod{m}\\)\uff0c\u5219 \\(a\\equiv{c}\\pmod{m}\\)</p> </li> <li> <p>\u82e5 \\(a\\equiv{b}\\pmod{m},c\\equiv{d}\\pmod{m}\\)\uff0c\u5219</p> <p>\\(a*x+c*y\\equiv b*x+d*y\\pmod m\\)</p> <p>\\(a*c\\equiv b*d\\pmod m\\)</p> <p>\\(a^n\\equiv b^n\\pmod m\\)</p> <p>\\(f(a)\\equiv f(b)\\pmod m\\)</p> </li> </ol>"},{"location":"template/math/number-theory/linear-equation/#_3","title":"\u7ed3\u8bba","text":"<p>\uff081\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n^2\\) \u6a21 \\(3\\) \u6216 \\(4\\) \u7684\u7ed3\u679c\u53ea\u80fd\u662f \\(0\\) \u6216 \\(1\\) </p> <p>\uff082\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n^2\\) \u6a21 \\(8\\) \u7684\u7ed3\u679c\u53ea\u80fd\u662f\\(0\\)\u3001\\(1\\) \u6216 \\(4\\)</p> <p>\uff083\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n\\) \u4e0e \\(n\\) \u5404\u6570\u4f4d\u4e0a\u7684\u6570\u5b57\u4e4b\u548c\u6a21 \\(9\\) \u540c\u4f59</p>"},{"location":"template/math/number-theory/linear-equation/#_4","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; T Exgcd(const T a, const T b, T &amp;x, T &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    T d = Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n</code></pre>"},{"location":"template/math/number-theory/linear-equation/#_5","title":"\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b","text":"<p>\\(a*x\\equiv b\\pmod n\\)</p> \u9006\u5143\u6c42\u89e3\u6269\u6b27\u6c42\u89e3 \\[ \\begin{gather} a\\cdot{x}\\equiv{b}\\pmod{n}\\\\ x\\equiv{b}\\cdot{a}^{-1}\\pmod{n} \\nonumber \\end{gather} \\] <p>\u5f53 \\(a\\) \u5728\u6a21 \\(n\\) \u4e0b\u6709\u9006\u5143\u65f6, \u6709\u89e3\u3002</p> <p>\u5f53 \\(\\gcd(a,n)=1\\) \u65f6\uff0c\u4e00\u5b9a\u5b58\u5728\u9006\u5143\u3002\u5426\u5219\u4ee4 \\(g=\\gcd(a,n)\\)</p> <p>\u5f53 \\(g\\ |\\ b\\) \u65f6\uff0c\u65b9\u7a0b\u53ef\u4ee5\u5316\u7b80\u4e3a</p> \\[ \\begin{gather} \\dfrac{a}{g}*x_0\\equiv\\dfrac{b}{g}\\pmod{\\dfrac{n}{g}}\\\\ x_0=\\dfrac{b}{g}*{(\\dfrac{a}{g})}^{-1}\\pmod{\\dfrac{n}{g}}\\\\ x_1=(x_0+k*\\dfrac{n}{g})\\pmod n \\nonumber \\end{gather} \\] \\[ \\begin{gather} a\\cdot{x}\\equiv{b}\\pmod{n}\\\\ a\\cdot{x}+n\\cdot{y}=b\\pmod{n}     \\nonumber \\end{gather} \\] <p>\u4f7f\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51fa \\(x_0,y_0\\)</p> \\[ \\begin{gather} a\\cdot{x}_0+n\\cdot{y}_0=\\gcd(a,n)\\\\ a\\cdot\\dfrac{x_0}{\\gcd(a,n)}+n\\cdot\\dfrac{y_0}{\\gcd(a,n)}=1\\\\ a\\cdot\\dfrac{x_0\\cdot{b}}{\\gcd(a,n)}+n\\cdot\\dfrac{y_0\\cdot{b}}{\\gcd(a,n)}=b\\\\ x_1=\\frac{x_0\\cdot{b}}{\\gcd(a,n)}\\\\ y_1=\\frac{y_0\\cdot{b}}{\\gcd(a,n)}\\\\ x=x_1+k\\cdot\\frac{n}{\\gcd(a,n)}\\\\ y=y_1-k\\cdot\\frac{a}{\\gcd(a,n)} \\end{gather} \\]"},{"location":"template/math/number-theory/meissel-lehmer/","title":"Meissel-Lehmer\u7b97\u6cd5","text":"<p>\u6c42 \\([1,n]\\) \u7684\u8d28\u6570\u4e2a\u6570</p> <p>\\(n\\leq10^{13}\uff0c1s\\)</p> \u6a21\u7248 C++<pre><code>using i64 = long long;\n#define div(a, b) (1.0 * (a) / (b))\n#define half(x) (((x) - 1) / 2)\ni64 Meissel_Lehmer(i64 n) {\n    if (n &lt;= 3) {\n        return max(n - 1, 0LL);\n    }\n    long long v = sqrtl(n);\n    int s = (v + 1) / 2;\n    vector&lt;int&gt; smalls(s), roughs(s);\n    vector&lt;i64&gt; larges(s);\n    for (int i = 0 ; i &lt; s ; i++) {\n        smalls[i] = i;\n    }\n    for (int i = 0 ; i &lt; s ; i++) {\n        roughs[i] = i * 2 + 1;\n    }\n    for (int i = 0 ; i &lt; s ; i++) {\n        larges[i] = half(n / roughs[i]);\n    }\n    vector&lt;bool&gt; skip(v + 1);\n    int pc = 0;\n    for (int p = 3 ; p &lt;= v ; p += 2) {\n        if (skip[p] == false) {\n            i64 q = p * p;\n            if (q * q &gt; n) {\n                break;\n            }\n            skip[p] = true;\n            for (int i = q ; i &lt;= v ; i += 2 * p) {\n                skip[i] = true;\n            }\n            int ns = 0;\n            for (int k = 0 ; k &lt; s ; k++) {\n                int i = roughs[k];\n                if (skip[i]) {\n                    continue;\n                }\n                long long d = 1LL * i * p;\n                larges[ns] = larges[k] - (d &lt;= v ? larges[smalls[d &gt;&gt; 1] - pc] : smalls[half(div(n, d))]) + pc;\n                roughs[ns++] = i;\n            }\n            s = ns;\n            for (int i = half(v), j = (((v / p) - 1) | 1) ; j &gt;= p ; j -= 2) {\n                int c = smalls[j / 2] - pc;\n                for (int e = j * p / 2 ; i &gt;= e ; i--) {\n                    smalls[i] -= c;\n                }\n            }\n            pc++;\n        }\n    }\n    larges[0] += 1LL * (s + 2 * (pc - 1)) * (s - 1) &gt;&gt; 1;\n    for (int k = 1 ; k &lt; s ; k++) {\n        larges[0] -= larges[k];\n    }\n    for (int L = 1 ; L &lt; s ; L++) {\n        int q = roughs[L];\n        long long m = n / q;\n        int e = smalls[half(m / q)] - pc;\n        if (e &lt; L + 1) {\n            break;\n        }\n        long long t = 0;\n        for (int k = L + 1 ; k &lt;= e ; k++) {\n            t += smalls[half(div(m, roughs[k]))];\n        }\n        larges[0] += t - 1LL * (e - L) * (pc + L - 1);\n    }\n    return larges[0] + 1;\n}\n#undef div\n#undef half\n</code></pre> \u4f8b\u9898 <p>P7884 \u3010\u6a21\u677f\u3011Meissel\u2013Lehmer \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>#6235. \u533a\u95f4\u7d20\u6570\u4e2a\u6570 - LibreOJ</p>"},{"location":"template/math/number-theory/mobius/","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570","text":""},{"location":"template/math/number-theory/mobius/#_2","title":"\u5b9a\u4e49","text":"\\[ \\begin{equation} \\mu(n)= \\begin{cases} 1&amp;&amp;n=1\\\\ {(-1)}^r&amp;&amp;n=p_1^1*p_2^1*\u2026*p_r^1\\\\ 0&amp;&amp;else \\end{cases} \\end{equation} \\]"},{"location":"template/math/number-theory/mobius/#_3","title":"\u5b9a\u7406","text":"\\[ \\begin{equation} \\sum_{d|n}\\mu(d)= \\begin{cases} 1&amp;&amp;n=1\\\\ 0&amp;&amp;n&gt;1 \\end{cases} \\end{equation} \\] \u7b5b\u6cd5\u6c42\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570 C++<pre><code>namespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    void init(const int N) {\n        prime.resize(0);\n        vis.resize(0);\n        vis.resize(N + 1);\n        mob.resize(0);\n        mob.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.push_back(i);\n                mob[i] = -1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt; N) break;\n                vis[i * x] = x;\n                if (i % x == 0) {\n                    mob[i * x] = 0;\n                    break;\n                }\n                mob[i * x] = -mob[i];\n            }\n        }\n    }\n} // MobiusSieve\n</code></pre>"},{"location":"template/math/number-theory/mobius/#_4","title":"\u83ab\u6bd4\u4e4c\u65af\u53d8\u6362","text":"<p>\u2460 \u5982\u679c \\(f(n)=\\sum_{d|n}g(d)\\)\uff0c\u90a3\u4e48 \\(g(n)=\\sum_{d|n}\\mu(d)*f(\\frac{n}{d})\\)</p> <p>\u2461 \u5982\u679c \\(f(n)=\\sum_{n|d}g(d)\\)\uff0c\u90a3\u4e48 \\(g(n)=\\sum_{n|d}\\mu(\\frac{d}{n})*f(d)\\)</p>"},{"location":"template/math/number-theory/mobius/#_5","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14","text":"\\[ [\\gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d) \\] \u9898\u5355 <p>\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14\uff08\u51fd\u6570\uff09\u7ec3\u4e60\u9898\u5355 - \u9898\u5355 - \u6d1b\u8c37</p> \u6d1b\u8c37P2257\u6d1b\u8c37P2522P3327 <p>P2257 YY\u7684GCD - \u6d1b\u8c37</p> \\[ \\begin{align} &amp;\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)\\in prime]\\\\ &amp;=\\sum_{k=1}^{\\min(n,m)}\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j)=k]&amp;(k\\in prime)\\\\ &amp;=\\sum_{k=1}^{\\min(n,m)}\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}[\\gcd(i,j)=1]&amp;(k\\in prime)\\\\ &amp;=\\sum_{k=1}^{\\min(n,m)}\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}\\sum_{d|\\gcd(i,j)}\\mu(d)&amp;(k\\in prime)\\\\ &amp;=\\sum_{k=1}^{\\min(n,m)}\\sum_{d=1}^{\\lfloor\\frac{\\min(n,m)}{k}\\rfloor}\\mu(d)*\\lfloor\\dfrac{n}{kd}\\rfloor*\\lfloor\\frac{m}{kd}\\rfloor&amp;(k\\in prime)\\\\ \\end{align} \\] <p>\u4ee4 \\(T=k*d\\)</p> \\[ \\begin{align} &amp;=\\sum_{k=1}^{\\min(n,m)}\\sum_{d=1}^{\\lfloor\\frac{\\min(n,m)}{k}\\rfloor}\\mu(\\frac{T}{k})*\\lfloor\\dfrac{n}{T}\\rfloor*\\lfloor\\frac{m}{T}\\rfloor&amp;(k\\in prime)\\\\ &amp;=\\sum_{T=1}^{\\min(n,m)}\\lfloor\\dfrac{n}{T}\\rfloor*\\lfloor\\frac{m}{T}\\rfloor*\\sum_{k|T,k\\in prime}\\mu(\\frac{T}{k}) \\end{align} \\] <p>\u4ee4 \\(f(x)=\\sum_{k|x,k\\in prime}\\mu(\\frac{x}{k})\\)</p> <p>\u53ef\u4ee5\u53d1\u73b0\u901a\u8fc7\u679a\u4e3e\u8d28\u6570 \\(k\\) \u7684\u500d\u6570\u6765\u505a\u524d\u7f00\u548c\u9884\u5904\u7406 \\(f(x)\\)</p> \\[ \\begin{align} &amp;=\\sum_{T=1}^{\\min(n,m)}\\lfloor\\dfrac{n}{T}\\rfloor*\\lfloor\\frac{m}{T}\\rfloor*f(T) \\end{align} \\] \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nnamespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    vector&lt;i64&gt; sum;\n    void init(const int N) {\n        prime.resize(0);\n        vis.resize(0);\n        vis.resize(N + 1);\n        mob.resize(0);\n        mob.resize(N + 1);\n        sum.resize(0);\n        sum.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.push_back(i);\n                mob[i] = -1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt; N) break;\n                vis[i * x] = x;\n                if (i % x == 0) {\n                    mob[i * x] = 0;\n                    break;\n                }\n                mob[i * x] = -mob[i];\n            }\n        }\n        for (auto &amp;x : prime) {\n            int i = 1;\n            while (1LL * i * x &lt;= N) {\n                sum[i * x] += mob[i];\n                i++;\n            }\n        }\n        for (int i = 1 ; i &lt;= N ; i++) {\n            sum[i] += sum[i - 1];\n        }\n    }\n} // MobiusSieve\nint main() {\n    MobiusSieve::init(10000000);\n    using MobiusSieve::sum;\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        int n, m;\n        cin &gt;&gt; n &gt;&gt; m;\n        if (n &gt; m) swap(n, m);\n        i64 ans = 0;\n        for (int L = 1, R ; L &lt;= n ; L = R + 1) {\n            R = min(n / (n / L), m / (m / L));\n            ans += (sum[R] - sum[L - 1]) * (n / L) * (m / L);\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P2522 [HAOI2011] Problem b - \u6d1b\u8c37</p> \\[ \\begin{align} F(x,y)&amp;=\\sum_{i=1}^x\\sum_{j=1}^y[\\gcd(i,j)=1]\\\\ &amp;=\\sum_{i=1}^x\\sum_{j=1}^y\\sum_{d|\\gcd(i,j)}\\mu(d)\\\\ &amp;=\\sum_{d=1}^{min(x,y)}\\mu(d)*\\lfloor\\frac{x}{d}\\rfloor*\\lfloor\\frac{y}{d}\\rfloor \\end{align} \\] \\[ \\sum_{i=x}^n\\sum_{j=y}^m[\\gcd(i,j)=k]=F(\\frac{n}{k},\\frac{m}{k})-F(\\frac{x-1}{k},\\frac{m}{k})-F(\\frac{n}{k},\\frac{y-1}{k})+F(\\frac{x-1}{k},\\frac{y-1}{k}) \\] \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nnamespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    void init(const int N) {\n        prime.resize(0);\n        vis.resize(0);\n        vis.resize(N + 1);\n        mob.resize(0);\n        mob.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.push_back(i);\n                mob[i] = -1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt; N) break;\n                vis[i * x] = x;\n                if (i % x == 0) {\n                    mob[i * x] = 0;\n                    break;\n                }\n                mob[i * x] = -mob[i];\n            }\n\n\n        }\n        for (int i = 1 ; i &lt;= N ; i++) {\n            mob[i] += mob[i - 1];\n        }\n    }\n} // MobiusSieve\nint main() {\n    MobiusSieve::init(50005);\n    using MobiusSieve::mob;\n    auto get = [&amp;](int x, int y) {\n        int res = 0, k = min(x, y);\n        for (int i = 1, R ; i &lt;= k ; i = R + 1) {\n            R = min(x / (x / i), y / (y / i));\n            res += (mob[R] - mob[i - 1]) * (x / i) * (y / i);\n        }\n        return res;\n    };\n    int n;\n    cin &gt;&gt; n;\n    while (n--) {\n        int a, b, c, d, k;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k;\n        int ans = get(b / k, d / k) - get((a - 1) / k, d / k) - get(b / k, (c - 1) / k) + get((a - 1) / k, (c - 1) / k);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P3327 [SDOI2015] \u7ea6\u6570\u4e2a\u6570\u548c - \u6d1b\u8c37</p> \\[ \\begin{align} d(i*j)=\\sum_{x|i}\\sum_{y|j}[\\gcd(i,j)=1] \\end{align} \\] \\[ \\begin{align} \\sum_{i=1}^n\\sum_{j=1}^md(i*j)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}[\\gcd(i,j)=1]\\\\ &amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor*\\lfloor\\frac{m}{j}\\rfloor*[\\gcd(i,j)=1] \\end{align} \\] <p>\u4ee4 \\(f(x)=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor*\\lfloor\\frac{m}{j}\\rfloor*[\\gcd(i,j)=x]\\)</p> \\[ \\begin{align} g(x)&amp;=\\sum_{x|d}f(d)\\\\ &amp;=\\sum_{x|d}\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor*\\lfloor\\frac{m}{j}\\rfloor*[\\gcd(i,j)=x]\\\\ &amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor*\\lfloor\\frac{m}{j}\\rfloor*[x|\\gcd(i,j)]\\\\ &amp;=\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{x}\\rfloor}\\lfloor\\frac{n}{i*x}\\rfloor*\\lfloor\\frac{m}{j*x}\\rfloor\\\\ &amp;=\\left(\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\lfloor\\frac{n}{i*x}\\rfloor\\right)*\\left(\\sum_{j=1}^{\\lfloor\\frac{m}{x}\\rfloor}\\lfloor\\frac{m}{j*x}\\rfloor\\right)\\\\ \\end{align} \\] \\[ \\begin{align} f(x)&amp;=\\sum_{x|d}\\mu(\\frac{d}{x})*g(d)\\\\ f(1)&amp;=\\sum_{1|d}\\mu(\\frac{d}{1})*g(d)\\\\ &amp;=\\sum_{d=0}^{\\min(n,m)}\\mu(d)*\\left(\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor\\frac{n}{i*d}\\rfloor\\right)*\\left(\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\lfloor\\frac{m}{j*d}\\rfloor\\right)\\\\\\\\ \\end{align} \\] \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nnamespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    void init(const int N) {\n        prime.resize(0);\n        vis.resize(0);\n        vis.resize(N + 1);\n        mob.resize(0);\n        mob.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.push_back(i);\n                mob[i] = -1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt; N) break;\n                vis[i * x] = x;\n                if (i % x == 0) {\n                    mob[i * x] = 0;\n                    break;\n                }\n                mob[i * x] = -mob[i];\n            }\n        }\n        for (int i = 1 ; i &lt;= N ; i++) {\n            mob[i] += mob[i - 1];\n        }\n    }\n} // MobiusSieve\ni64 g[50005];\nusing MobiusSieve::mob;\nvoid solve() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    if (n &gt; m) swap(n, m);\n    i64 ans = 0;\n    for (int L = 1, R ; L &lt;= n ; L = R + 1) {\n        R = min(n / (n / L), m / (m / L));\n        ans += 1LL * (mob[R] - mob[L - 1]) * g[n / L] * g[m / L];\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nint main() {\n    MobiusSieve::init(50000);\n    for (int x = 1 ; x &lt;= 50000 ; x++) {\n        for (int L = 1, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            g[x] += 1LL * (R - L + 1) * (x / L);\n        }\n    }\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/mobius/#_6","title":"\u6b27\u62c9\u53cd\u6f14","text":"\\[ n=id_1(n)=\\sum_{d\\mid n}\\varphi(d)*I(\\frac{n}{d})=\\sum_{d\\mid n}\\varphi(d) \\] \u4f8b\u9898 \u6d1b\u8c37P1447 <p>P1447 [NOI2010] \u80fd\u91cf\u91c7\u96c6 - \u6d1b\u8c37</p> <p>\u5df2\u77e5 \\(n,m\\), \u6c42 \\(\\sum_{i=1}^n\\sum_{j=1}^m(2*\\gcd(i,j)-1)\\)</p> <p>\\(ans=\\sum_{i=1}^n\\sum_{j=1}^m(2*\\gcd(i,j)-1)=2*\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)\\)</p> <p>\u6839\u636e\u6b27\u62c9\u53cd\u6f14\u53ef\u5f97 \\(\\gcd(i,j)=\\sum_{d\\mid \\gcd(i,j)}\\varphi(d)\\)</p> \\[ \\begin{align} f&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d\\mid \\gcd(i,j)}\\varphi(d)\\\\ &amp;=\\sum_{d=1}^n(\\varphi(d)*\\sum_{i=1}^n\\sum_{j=1}^m[d\\mid i\\wedge d\\mid j])\\\\ &amp;=\\sum_{d=1}^n(\\varphi(d)*\\sum_{i=1}^n[d|i]*\\sum_{j=1}^m[d\\mid j]))\\\\ &amp;=\\sum_{d=1}^n(\\varphi(d)*\\lfloor\\frac{n}{d}\\rfloor*\\lfloor\\frac{m}{d}\\rfloor) \\end{align} \\]"},{"location":"template/math/number-theory/mobius/#_7","title":"\u9664\u6570\u53cd\u6f14","text":"\\[ \\sigma_k=\\sum_{d\\mid n}d^k \\] \u4f8b\u9898 \u6d1b\u8c37P3935 <p>P3935 Calculating - \u6d1b\u8c37</p> <p>\u5df2\u77e5 \\(L,R\\), \u6c42 \\(\\sum_{i=L}^R\\sigma_0(i)\\)</p> <p>\u4ee4 \\(S(n)=\\sum_{i=1}^n\\sigma_0(i)\\), \u5219 \\(ans=S(R)-S(L-1)\\)</p> \\[ \\begin{align} S(n)&amp;=\\sum_{i=1}^n\\sigma(i)\\\\ &amp;=\\sum_{i=1}^n\\sum_{d\\mid n}d^0\\\\ &amp;=\\sum_{d=1}^n\\sum_{i=1}^n[d\\mid i]\\\\ &amp;=\\sum_{d=1}\\lfloor\\frac{n}{d}\\rfloor \\end{align} \\]"},{"location":"template/math/number-theory/primary-root/","title":"\u539f\u6839","text":"<p>\u5f53 \\(g\\) \u662f \\(a\\) \u7684\u539f\u6839\u65f6\uff0c\\(g^i\\mod a\\) \\(i\\in(0,a)\\) \u4e92\u4e0d\u76f8\u540c</p> \u6a21\u7248 \u6700\u5c0f\u539f\u6839\u6240\u6709\u539f\u6839 \u4ee3\u7801 C++<pre><code>i64 qpow(i64 a, i64 b, i64 P, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 eulerPhi(i64 n) {\n    i64 ans = n;\n    for (int i = 2 ; 1LL * i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n * (n - 1);\n    }\n    return ans;\n}\nvector&lt;i64&gt; getFactors(i64 x) {\n    vector&lt;i64&gt; res;\n    for (int i = 1 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            res.emplace_back(i);\n            if (x != 1LL * i * i) {\n                res.emplace_back(x / i);\n            }\n        }\n    }\n    if (x &gt; 1) {\n        res.push_back(x);\n    }\n    return res;\n}\ni64 getMinRoot(i64 x) {\n    i64 phi = eulerPhi(x);\n    auto factors = getFactors(phi);\n    for (int i = 1 ; ; i++) {\n        if (__gcd(1LL * i, x) != 1) {\n            continue;\n        }\n        bool flag = true;\n        for (auto &amp;e : factors) {\n            if (e != phi &amp;&amp; qpow(i, e, x) == 1) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return i;\n    }\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nnamespace EulerSieve {\n    vector&lt;int&gt; prime, phi;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        phi.resize(n);\n        phi[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\nconst int N = 1000005;\nusing EulerSieve::primeInit;\nusing EulerSieve::phi;\nusing EulerSieve::prime;\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nbool exist[N + 100];\nvoid existInit() {\n    exist[2] = exist[4] = true;\n    int len = prime.size();\n    for (int i = 1 ; i &lt; len ; i++) {\n        for (i64 j = prime[i] ; j &lt;= N ; j *= prime[i]) {\n            exist[j] = true;\n            if (j * 2 &lt;= N) {\n                exist[j * 2] = true;\n            }\n        }\n    }\n}\nvector&lt;int&gt; getFactors(int x) {\n    vector&lt;int&gt; res;\n    for (int i = 1 ; i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            res.emplace_back(i);\n            if (x != i * i) {\n                res.emplace_back(x / i);\n            }\n        }\n    }\n    return res;\n}\nvector&lt;int&gt; getPrimativeRoots(int m) {\n    if (!exist[m]) return {};\n    int phis = phi[m], fst;\n    auto factors = getFactors(phis);\n    for (int i = 1 ; ; i++) {\n        if (__gcd(i, m) != 1) {\n            continue;\n        }\n        bool flag = true;\n        for (auto &amp;e : factors) {\n            if (e != phis &amp;&amp; qpow(i, e, m) == 1) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            fst = i;\n            break;\n        }\n    }\n    int cur = fst;\n    vector&lt;int&gt; res;\n    for (int i = 1 ; i &lt;= phis ; i++) {\n        if (__gcd(phis, i) == 1) {\n            res.emplace_back(cur);\n        }\n        cur = cur * fst % m;\n    }\n    return res;\n}\nvoid solve() {\n    int n, d;\n    cin &gt;&gt; n &gt;&gt; d;\n    auto res = getPrimativeRoots(n);\n    sort(begin(res), end(res));\n    cout &lt;&lt; res.size() &lt;&lt; \"\\n\";\n    for (int i = d ; i &lt;= (int(res.size()) / d) * d ; i += d) {\n        if (i - 1 &gt;= 0 &amp;&amp; i - 1 &lt; res.size())\n        cout &lt;&lt; res[i - 1] &lt;&lt; \" \";\n        else\n        cout &lt;&lt; 0 &lt;&lt; \" \";\n    }\n    cout &lt;&lt; \"\\n\";\n}\nint main() {\n    primeInit(N);\n    existInit();\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P6091 <p>P6091 \u3010\u6a21\u677f\u3011\u539f\u6839 - \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/prime-factorization/","title":"\u8d28\u56e0\u6570\u5206\u89e3","text":"\u6a21\u7248 \u66b4\u529b \\(O(\\log n*\\sqrt n)\\)Pollard_rho \\(O(n^{\\frac{1}{4}}*\\log n)\\) \u4ee3\u7801 C++<pre><code>vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long x) {\n    vector&lt;pair&lt;long long, int&gt;&gt; res;\n    for (int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            int cnt = 0;\n            while (x % i == 0) {\n                x /= i;\n                cnt++;\n            }\n            res.emplace_back(i, cnt);\n        }\n    }\n    if (x &gt; 1) {\n        res.emplace_back(x, 1);\n    }\n    return res;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>namespace Miller_Rabin {\n    using i64 = long long;\n    i64 qpow(__int128 a, i64 b, i64 P) {\n        __int128 res = 1;\n        while (b) {\n            if (b &amp; 1) res = res * a % P;\n            a = a * a % P;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    bool Miller_Rabin(i64 n, const vector&lt;i64&gt; &amp;as) {\n        i64 d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        i64 e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            i64 t = d;\n            __int128 y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(i64 n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u662f\u5426\u662f\u8d28\u6570\nnamespace Pollard_rho {\n    template&lt;class T&gt;\n    struct Random {\n        mt19937 mt;\n        Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n        T operator()(T L, T R) {\n            uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n            return dist(mt);\n        }\n    };\n    Random&lt;i64&gt; rng;\n    i64 get(i64 n) {\n        if (n % 2 == 0) {\n            return 2;\n        }\n        if (is_prime(n)) {\n            return n;\n        }\n        i64 R;\n        auto f = [&amp;](__int128 x) {\n            return (x * x + R) % n;\n        };\n        while (true) {\n            i64 x, y, ys, q = 1;\n            R = rng(2, n - 1), y = rng(2, n - 1);\n            i64 g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r *= 2) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        y = f(y);\n                        q = (__int128) q * (((x - y) % n + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    ys = f(ys);\n                    g = __gcd(((x - ys) % n + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;i64&gt; factorize(i64 n) {\n        if (n &lt;= 1) {\n            return {};\n        }\n        i64 p = get(n);\n        if (p == n) {\n            return {n};\n        }\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;i64, int&gt;&gt; prime_factor(i64 n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;i64, int&gt;&gt; res;\n        for (auto &amp;e : ps) {\n            if (!res.empty() &amp;&amp; res.back().first == e) {\n                res.back().second++;\n            } else {\n                res.emplace_back(e, 1);\n            }\n        }\n        return res;\n    }\n    vector&lt;i64&gt; divisors(i64 n) {\n        auto ps = prime_factor(n);\n        int cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            cnt *= t + 1;\n        }\n        vector&lt;i64&gt; res(cnt, 1);\n        cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            i64 pw = 1;\n            for (int i = 1 ; i &lt;= t ; i++) {\n                pw *= p;\n                for (int j = 0 ; j &lt; cnt ; j++) {\n                    res[cnt * i + j] = res[j] * pw;\n                }\n            }\n            cnt *= t + 1;\n        }\n        return res;\n    }\n} // Pollard_rho\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u8d28\u6570\nusing Pollard_rho::prime_factor; // \u6240\u6709\u8d28\u56e0\u5b50 (\u8d28\u56e0\u5b50, \u4e2a\u6570)\nusing Pollard_rho::divisors; // \u6240\u6709\u56e0\u5b50\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3715\u6d1b\u8c37P4718 <p>B3715 \u5206\u89e3\u8d28\u56e0\u5b50 2 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{12}\\)</p> <p>P4718 \u3010\u6a21\u677f\u3011Pollard rho \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{18}\\)</p>"},{"location":"template/math/number-theory/prime/","title":"\u7d20\u6570","text":""},{"location":"template/math/number-theory/prime/#_2","title":"\u7d20\u6570\u5b9a\u7406","text":"<p>\\(\\pi(x)\\) \u4e3a \\([1,x]\\) \u4e2d\u7684\u7d20\u6570\u4e2a\u6570</p> <p>\u968f\u7740 \\(x\\) \u7684\u589e\u957f \\(\\dfrac{\\pi(x)}{\\frac{x}{\\ln(x)}}=1\\)</p>"},{"location":"template/math/number-theory/prime/#_3","title":"\u57fa\u672c\u5b9a\u7406","text":"<p>\\(n=p_1^{\\alpha_1}*p_2^{\\alpha_2}*...*p_k^{\\alpha_k}\\)</p> <p>\u7ea6\u6570\u4e2a\u6570 \\(d(n)=(\\alpha_1+1)*(\\alpha_2+1)*...*(\\alpha_k+1)\\)</p> <p>\u7ea6\u6570\u4e4b\u548c \\(\\phi(n)=\\dfrac{p_1^{\\alpha_1+1}-1}{p_1-1}*\\dfrac{p_k^{\\alpha_k+1}-1}{p_k-1}*...*\\dfrac{p_k^{\\alpha_k+1}-1}{p_k-1}\\)</p> <p>\\(n!\\) \u56e0\u5b50 \\(p\\) \u7684\u6570\u91cf\u4e3a \\(\\lfloor\\dfrac{n}{p^1}\\rfloor+\\lfloor\\dfrac{n}{p^2}\\rfloor+...+\\lfloor\\dfrac{n}{p^{+\\infty}}\\rfloor\\)</p>"},{"location":"template/math/number-theory/prime/#_4","title":"\u7d20\u6570\u5224\u65ad","text":"\u6a21\u7248 \u66b4\u529b \\(O(\\sqrt x)\\)Miller_Rabin \\(O(k\\log{n}^2)\\) <p>\u6839\u53f7\u679a\u4e3e\u6240\u6709\u5c0f\u56e0\u5b50</p> \u4ee3\u7801 C++<pre><code>bool is_prime(i64 x) {\n    if (x &lt; 2) return false;\n    for (int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>namespace Miller_Rabin {\n    using i64 = long long;\n    i64 qpow(__int128 a, i64 b, i64 P) {\n        __int128 res = 1;\n        while (b) {\n            if (b &amp; 1) res = res * a % P;\n            a = a * a % P;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    bool Miller_Rabin(i64 n, const vector&lt;i64&gt; &amp;as) {\n        i64 d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        i64 e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            i64 t = d;\n            __int128 y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(i64 n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u662f\u5426\u662f\u8d28\u6570\n</code></pre>"},{"location":"template/math/number-theory/prime/#_5","title":"\u6885\u68ee\u7d20\u6570","text":"<p>\u5982\u679c \\(m\\) \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u4e14 \\(2^m-1\\) \u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5219 \\(m\\) \u662f\u7d20\u6570\u3002\u53cd\u4e4b\uff0c\u5982\u679c \\(m\\) \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u7d20\u6570\u4e14 \\(M_m=2^m-1\\)\u79f0\u4f5c\u4e3a\u7b2c \\(m\\) \u4e2a\u6885\u68ee\u6570\uff1b\u5982\u679c \\(p\\) \u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5e76\u4e14 \\(M_p=2^p-1\\) \u4e5f\u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5219 \\(M_p\\) \u6210\u4e3a\u6885\u68ee\u7d20\u6570\u3002</p> \u6d1b\u8c37U313346 <p>U313346 \u3010\u6a21\u677f\u3011Lucas-Lehmer - \u6d1b\u8c37</p> C++<pre><code>long long datas[64];\nbool Lucas_Lehmer(int p) {\n    if (p == 2) {\n        return true;\n    }\n    datas[1] = 4;\n    long long mod = (1LL &lt;&lt; p) - 1;\n    for (int i = 2 ; i &lt;= p - 1 ; i++) {\n        datas[i] = (((__int128)datas[i - 1] * datas[i - 1] % mod) - 2) % mod;\n    }\n    return datas[p - 1] == 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/problem-set/","title":"\u4e60\u9898","text":"\u6d1b\u8c37P2388CF27E\u6d1b\u8c37P5493\u6d1b\u8c37P7325 <p>P2388 \u9636\u4e58\u4e4b\u4e58 - \u6d1b\u8c37</p> <p>\u6c42 \\(\\prod {n!}\\) \u4e2d\u56e0\u5b50 \\(k\\) \u7684\u4e2a\u6570 \\(O(n\\cdot\\log{n})\\)</p> \u4ee3\u7801 C++<pre><code>i64 get(i64 n, i64 k) {\n    i64 ans = 0;\n    i64 num = k;\n    while (num &lt;= n) {\n        i64 z = n / num;\n        ans += num * z * (z - 1) / 2;\n        ans += z * (1 + n % num);\n        num *= k;\n    }\n    return ans;\n}\n</code></pre> <p>Problem - E - Codeforces</p> <p>\u6c42\u7ea6\u6570\u4e2a\u6570\u4e3a \\(k\\) \u7684\u6700\u5c0f\u6570 \\(k\\leq1000\\)</p> \u4ee3\u7801 C++<pre><code>using i64 = long long;\nusing u64 = unsigned long long;\nvector&lt;int&gt; prime{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\nconst int N = prime.size();\nconst i64 INF = 0x7fffffffffffffff;\nint k;\ni64 dfs(int idx, u64 sum, int num) {\n    if (num &gt; k || idx == N) {\n        return INF;\n    }\n    if (num == k) {\n        return sum;\n    }\n    i64 res = INF;\n    for (int i = 1 ; i &lt; 64 ; i++) {\n        if (sum * prime[idx] &gt; res) break;\n        sum *= prime[idx];\n        res = min(res, dfs(idx + 1, sum, num * (i + 1)));\n    }\n    return res;\n}\nint main() {\n    cin &gt;&gt; k;\n    cout &lt;&lt; dfs(0, 1, 1);\n    return 0;\n}\n</code></pre> <p>P5493 \u8d28\u6570\u524d\u7f00\u7edf\u8ba1 - \u6d1b\u8c37</p> <p>\\(\\sum_{i=1}^{\\lfloor\\sqrt{N}\\rfloor}i^2\\cdot{S(\\lfloor\\frac{N}{i}\\rfloor)}\\)</p> <p>\\(S(n)\\) \u4e3a \\(n\\) \u4ee5\u5185\u8d28\u6570\u7684 \\(C\\) \u6b21\u65b9\u548c</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 P, mod;\ni64 qpow(i64 a, i64 b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % P;\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Larange {\n    const int N = 13;\n    i64 fact[N], invf[N], pre[N], suf[N], f[N];\n    int m;\n    void init(int C) {\n        m = C + 2;\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            fact[i] = fact[i - 1] * i % P;\n            f[i] = (f[i - 1] + qpow(i, C)) % P;\n        }\n        invf[m] = qpow(fact[m], P - 2);\n        for (int i = m - 1 ; i &gt;= 0 ; i--) {\n            invf[i] = invf[i + 1] * (i + 1) % P;\n        }\n    }\n    i64 get(i64 v) {\n        if (v &lt;= m) return f[v];\n        v %= P;\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            pre[i] = pre[i - 1] * (v - i) % P;\n        }\n        suf[m + 1] = 1;\n        for (int i = m ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * (v - i) % P;\n        }\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            i64 s1 = pre[i - 1] * suf[i + 1] % P;\n            i64 s2 = invf[i - 1] * invf[m - i] % P;\n            if ((m - i) &amp; 1) {\n                s2 = P - s2;\n            }\n            res = (res + s1 * s2 % P * f[i] % P + P) % P;\n        }\n        return res;\n    }\n} // Larange\ni64 g0[200005], g1[200005];\ni64 add(i64 x, i64 y) {\n    return x + y &gt;= P ? x + y - P : x + y;\n}\ni64 sub(i64 x, i64 y) {\n    return x - y &lt; 0 ? x - y + P : x - y;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    i64 n;\n    int C;\n    cin &gt;&gt; n &gt;&gt; C &gt;&gt; P;\n    i64 sqr = sqrtl(n);\n    Larange::init(C);\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        g0[i] = sub(Larange::get(i), 1);\n        g1[i] = sub(Larange::get(n / i), 1);\n    }\n    for (int i = 2 ; i &lt;= sqr ; i++) {\n        if (g0[i] == g0[i - 1]) continue;\n        i64 pc = qpow(i, C), pg = g0[i - 1];\n        i64 L1 = sqr / i, L2 = min(n / i / i, sqr);\n        L1 = min(L1, L2);\n        for (int j = 1 ; j &lt;= L1 ; j++) {\n            g1[j] = sub(g1[j], pc * sub(g1[j * i], pg) % P);\n        }\n        i64 temp = n / i;\n        for (int j = L1 + 1 ; j &lt;= L2 ; j++) {\n            g1[j] = sub(g1[j], pc * sub(g0[temp / j], pg) % P);\n        }\n        i64 st = 1LL * i * i;\n        for (int j = sqr ; j &gt;= st ; j--) {\n            g0[j] = sub(g0[j], pc * sub(g0[j / i], pg) % P);\n        }\n    }\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        ans = add(ans, g1[i] * i % P * i % P);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P7325 [WC2021] \u6590\u6ce2\u90a3\u5951 - \u6d1b\u8c37</p> <p>\u5b9a\u4e49 \\(F_0=a,F_1=b,F_i=(F_{i-1}+F_{i-2})\\mod m\\)</p> <p>\u7ed9\u5b9a \\(a\\) \u548c \\(b\\) \u548c \\(m\\), \u95ee \\(F_p\\mod m = 0\\) \u7684 \u6700\u5c0f\u7684\u6574\u6570 \\(p\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nvoid Exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\nint inv(int a, int P) {\n    i64 x, y;\n    Exgcd(a, P, x, y);\n    return (x % P + P) % P;\n}\nstruct Node {\n    int x, y, z;\n    bool operator&lt;(const Node &amp;node) const {\n        if (x == node.x) {\n            if (y == node.y) {\n                return z &lt; node.z;\n            }\n            return y &lt; node.y;\n        }\n        return x &lt; node.x;\n    }\n};\nmap&lt;Node, int&gt; ans[100005];\nint n, m;\nint solve(int a, int b) {\n    if (a == 0) return 0;\n    if (b == 0) return 1;\n    int d = __gcd(__gcd(a, b), m);\n    int m1 = m / d;\n    a /= d;\n    b /= d;\n    int p = __gcd(a, m1), q = __gcd(b, m1), m2 = m1 / p / q;\n    a /= p;\n    b /= q;\n    int k = 1LL * a * inv(b, m2) % m2;\n    if (ans[m1].count({k, q, p})) return ans[m1][{k, q, p}];\n    return -1;\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int m1 = 2 ; m1 &lt;= m ; m1++) {\n        if (m % m1 == 0) {\n            int a = 0, b = 1;\n            for (int j = 0 ; ; j++) {\n                if (a &amp;&amp; b) {\n                    int p = __gcd(a, m1), q = __gcd(b, m1), m2 = m1 / p / q;\n                    int ta = a / p, tb = b / q;\n                    int k = 1LL * ta * inv(tb, m2) % m2;\n                    if (!ans[m1].count({k, q, p})) {\n                        ans[m1][{k, q, p}] = j;\n                    }\n                }\n                int x1 = b;\n                b = a;\n                a = (x1 + a) % m1;\n                if (b == 1 &amp;&amp; a == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        a %= m;\n        b = (m - b % m) % m;\n        cout &lt;&lt; solve(a, b) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/residue/","title":"\u5269\u4f59","text":""},{"location":"template/math/number-theory/residue/#_2","title":"\u5b9a\u4e49","text":"<p>\u4ee4\u6574\u6570 \\(k\\ge2\\)\uff0c\u6574\u6570 \\(a,m\\) \u6ee1\u8db3 \\(\\gcd(a,m)=1\\)\uff0c\u82e5\u5b58\u5728\u6574\u6570 \\(x\\) \u4f7f\u5f97</p> \\[ x^k\\equiv a\\pmod m \\] <p>\u5219\u79f0 \\(a\\) \u4e3a\u6a21 \\(m\\) \u7684 \\(k\\) \u6b21\u5269\u4f59\u3002</p>"},{"location":"template/math/number-theory/residue/#_3","title":"\u4e8c\u6b21\u5269\u4f59","text":"\\[ x^2\\equiv a\\pmod p \\] Euler\u5224\u522b\u6cd5 <p>\u5bf9\u4e8e\u5947\u7d20\u6570 \\(p\\) \u548c\u6ee1\u8db3 \\(\\gcd(a,p)=1\\)\u7684 \\(a\\)</p> <p>\u5f53 \\(a^{\\frac{p-1}{2}}\\equiv1\\pmod p\\) \u65f6, \\(a\\) \u662f\u6a21 \\(p\\) \u7684\u4e8c\u6b21\u5269\u4f59</p> \u6d1b\u8c37P5491 <p>P5491 \u3010\u6a21\u677f\u3011\u4e8c\u6b21\u5269\u4f59 - \u6d1b\u8c37</p> <p>\\(p\\) \u662f\u5947\u7d20\u6570</p> <p>\u6c42 \\(x^2\\equiv a\\pmod p\\) \u7684\u6839</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 w = 0; // x^2 - n \narray&lt;i64, 2&gt; mul(array&lt;i64, 2&gt; a, array&lt;i64, 2&gt; b, i64 P) {\n    return {(a[0] * b[0] + a[1] * b[1] % P * w) % P, (a[0] * b[1] + a[1] * b[0]) % P};\n}\ni64 qpow(i64 a, i64 b, i64 P) {\n    i64 res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 qpow(array&lt;i64, 2&gt; a, i64 b, i64 P) {\n    array&lt;i64, 2&gt; res{1, 0};\n    while (b) {\n        if (b &amp; 1) {\n            res = mul(res, a, P);\n        }\n        a = mul(a, a, P);\n        b &gt;&gt;= 1;\n    }\n    return res[0];\n}\ni64 cipolla(i64 a, i64 p) {\n    // x^2\\equiv a\\pmod p\n    a %= p;\n    if (qpow(a, (p - 1) / 2, p) == p - 1) {\n        // \u65e0\u89e3\n        return -1;\n    }\n    i64 x = 0;\n    while (true) {\n        x = rand() % p;\n        w = ((x * x % p - a) % p + p) % p;\n        if (qpow(w, (p - 1) / 2, p) == p - 1) {\n            break;\n        }\n    }\n    return qpow({x, 1}, (p + 1) / 2, p);\n}\nvoid solve() {\n    int a, p;\n    cin &gt;&gt; a &gt;&gt; p;\n    if (a == 0) {\n        cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n        return;\n    }\n    i64 ans1 = cipolla(a, p), ans2 = -ans1 + p;\n    if (ans1 == -1) {\n        cout &lt;&lt; \"Hola!\\n\";\n    } else {\n        if (ans1 &gt; ans2) {\n            swap(ans1, ans2);\n        }\n        if (ans1 != ans2) {\n            cout &lt;&lt; ans1 &lt;&lt; \" \";\n        }\n        cout &lt;&lt; ans2 &lt;&lt; \"\\n\";\n    }\n}\nint main() {\n    srand(time(nullptr));\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/number-theory/residue/#_4","title":"\u4e8c\u6b21\u5269\u4f59\u7684\u6570\u91cf","text":"<p>\u5bf9\u4e8e\u5947\u7d20\u6570 \\(p\\) \u548c\u6ee1\u8db3 \\(\\gcd(a,p)=1\\)\u7684 \\(a\\)</p> <p>\u4e8c\u6b21\u5269\u4f59\u548c\u975e\u4e8c\u6b21\u5269\u4f59\u5747\u6709 \\(\\frac{p-1}{2}\\)</p>"},{"location":"template/math/number-theory/residue/#_5","title":"\u7279\u4f8b","text":"<p>\u5f53 \\(p\\mod4=3\\) \u65f6, \\(a^{\\frac{p+1}{4}}\\mod p\\) \u4e3a\u4e00\u4e2a\u89e3.</p> <p>\u5f53 \\(p\\mod8=5\\) \u65f6, \\(B\\equiv(2a)^{\\frac{p-5}{8}}\\pmod p\\), \\(i\\equiv2ab^2\\pmod p\\), \\(a*b*(i-1)\\mod p\\) \u4e3a\u4e00\u4e2a\u89e3.</p>"},{"location":"template/math/number-theory/sieve/","title":"\u7b5b\u6cd5","text":""},{"location":"template/math/number-theory/sieve/#_2","title":"\u6b27\u62c9\u7b5b","text":"\u6a21\u7248 usageboolint <p>bool: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f \u82e5 vis[x] \u4e3a true, \u5219 x \u4e0d\u662f\u8d28\u6570, \u5426\u5219 x \u662f\u8d28\u6570.</p> <p>int: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f vis[x] \u4e3a x \u7684\u4e00\u4e2a\u8d28\u56e0\u5b50, vis[x] \u4e0e x \u76f8\u7b49\u65f6, x \u662f\u8d28\u6570 (1\u9664\u5916).</p> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                vis[i] = i;\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = i;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3383 <p>P3383 \u3010\u6a21\u677f\u3011\u7ebf\u6027\u7b5b\u7d20\u6570 - \u6d1b\u8c37</p>"},{"location":"template/math/number-theory/sieve/#_3","title":"\u79ef\u6027\u51fd\u6570\u7684\u7b5b\u6cd5","text":"\\[ f(n*p)=\\begin{cases} f(n)*f(p)&amp;p\\nmid n\\\\ f(n)*g(p)&amp;p\\mid n \\end{cases} \\] <p>\\(f(p)\\) \u4e3a\u4e00\u4e2a\u5173\u4e8e \\(p\\) \u7684\u7b80\u5355\u6709\u7406\u51fd\u6570</p> <p>\\(g(p)=\\dfrac{f(p^{k+1})}{f(p^k)},k\\ge1\\) \u4e3a\u4e00\u4e2a\u5173\u4e8e \\(p\\) \u7684\u7b80\u5355\u51fd\u6570</p>"},{"location":"template/math/number-theory/sieve/#_4","title":"\u6b27\u62c9\u51fd\u6570","text":"<p>\\(f(p)=p-1,g(p)=p\\)</p>"},{"location":"template/math/number-theory/sieve/#_5","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570","text":"<p>\\(f(p)=-1,g(p)=0\\)</p>"},{"location":"template/math/number-theory/sieve/#_6","title":"\u7ea6\u6570","text":"<p>\\(f(p)=2,g(p)=\\dfrac{h(p)+2}{h(p)+1},h(p)=1,h(n)=h(p)+1\\)</p>"},{"location":"template/math/number-theory/sieve/#_7","title":"\u7ea6\u6570\u548c","text":"<p>\\(f(p)=1+p,g(p)=\\dfrac{h(p)*p+1}{h(p)},h(p)=1+p,h(n)=h(p)*p+1\\)</p>"},{"location":"template/math/number-theory/sieve/#_8","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570","text":"<p>\\(d(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570</p> <p>\\(num(i)\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u4e2a\u6570</p> <p>\u7531\u4e8e \\(n=\\prod_i p_i^{a_i}\\)\uff0c\u5219\u6709 \\(d(n)=\\prod_i(a_i+1)\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(d(i)=2\uff0cnum(i)=1\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(d(i*x)=d(i)*d(x)\uff0cnum(i*x)=1\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(num(i*x)=num(i)+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(d(i)=(a_1+1)\\prod_{i=2}(a_i+1)\\)\uff0c\\(d(i*x)=(a_1+1+1)\\prod_{i=2}(a_i+1)\\)    \u6240\u4ee5 \\(d(i*x)=\\dfrac{d(i)}{(a_1+1)}(a_1+1+1)=\\dfrac{d(i)}{num(i)+1}(num(i*x)+1)=\\dfrac{d(i)}{num(i*x)}(num(i*x)+1)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime, d, num;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        d.resize(n);\n        d[1] = 1;\n        num.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    num[i * x] = num[i] + 1;\n                    d[i * x] = d[i] / num[i * x] * (num[i * x] + 1);\n                    break;\n                }\n                num[i * x] = 1;\n                d[i * x] = d[i] * 2;\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"template/math/number-theory/sieve/#_9","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c","text":"<p>\\(sd(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c</p> <p>\\(sp(i)\\) \u8868\u793a\u9996\u9879\u4e3a \\(1\\)\uff0c\u516c\u6bd4\u4e3a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u7b49\u6bd4\u6570\u5217\u7684\u548c</p> <p>\\(n=\\prod_ip_i^{a_i}\\)</p> <p>\\(sd(n)=(1+p_1+p_1^2+...+p_1^{a_1})(1+p_2+p_2^2+...+p_2^{a_2})...(1+p_k+p_k^2+...+p_k^{a_k})\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(sd(i)=1+i\uff0csp(i)=1+i\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(sd(i*x)=sd(i)*sd(x)\uff0csp(i*x)=1+x\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(sp(i*x)=sp(i)*x+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(sd(i)=(1+p_1+p_1^2+...+p_1^{a_1})\\prod\\)\uff0c\\(sd(i*x)=(1+p_1+p_1^2+...+p_1^{a_1}+p_1^{a_1+1})\\prod\\)    \u6240\u4ee5 \\(sd(i*x)=\\dfrac{sd(i)}{sp(i)}sp(i*x)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;long long&gt; sd, sp;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        sd.resize(n);\n        sd[1] = 1;\n        sp.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                sd[i] = sp[i] = i + 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    sp[i * x] = sp[i] * x + 1;\n                    sd[i * x] = sd[i] / sp[i] * sp[i * x];\n                    break;\n                }\n                sp[i * x] = 1 + x;\n                sd[i * x] = sd[i] * sd[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"template/math/numerical-algorithm/gauss/","title":"\u9ad8\u65af\u6d88\u5143","text":"\u4f8b\u9898 \u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4\u89e3\u5f02\u6216\u65b9\u7a0b\u7ec4 <p>P3389 \u3010\u6a21\u677f\u3011\u9ad8\u65af\u6d88\u5143\u6cd5 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>const double eps = 1e-8;\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    vector a(n + 2, vector(n + 2, 0.0));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= n + 1 ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int mx = i;\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            if (fabs(a[j][i]) &gt; fabs(a[mx][i])) {\n                mx = j;\n            }\n        }\n        if (fabs(a[mx][i]) &lt; eps) {\n            cout &lt;&lt; \"No Solution\";\n            return 0;\n        }\n        swap(a[i], a[mx]);\n        double t = a[i][i];\n        for (int j = i ; j &lt;= n + 1 ; j++) {\n            a[i][j] /= t;\n        }\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            t = a[j][i];\n            for (int k = i ; k &lt;= n + 1 ; k++) {\n                a[j][k] -= a[i][k] * t;\n            }\n        }\n    }\n    vector&lt;double&gt; ans(n + 1);\n    ans[n] = a[n][n + 1];\n    for (int i = n - 1 ; i &gt;= 1 ; i--) {\n        ans[i] = a[i][n + 1];\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            ans[i] -= a[i][j] * ans[j];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P2447 [SDOI2010] \u5916\u661f\u5343\u8db3\u866b - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>bitset&lt;1005&gt; a[2005];\nint n, m;\nint gauss() {\n    int mx = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int cur = i;\n        for (int j = i ; j &lt; m ; j++) {\n            if (a[j][i] == 0) continue;\n            cur = j;\n            break;\n        }\n        if (a[cur][i] == 0) return 0;\n        swap(a[i], a[cur]);\n        mx = max(mx, cur);\n        for (int j = 0 ; j &lt; m ; j++) {\n            if (i == j) continue;\n            if (a[j][i]) {\n                a[j] ^= a[i];\n            }\n        }\n    }\n    return mx + 1;\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        string s;\n        cin &gt;&gt; s;\n        for (int j = 0 ; j &lt; n ; j++) {\n            a[i][j] = s[j] - '0';\n        }\n        int x;\n        cin &gt;&gt; x;\n        a[i][n] = x;\n    }\n    int ret = gauss();\n    if (ret) {\n        cout &lt;&lt; ret &lt;&lt; \"\\n\";\n        for (int i = 0 ; i &lt; n ; i++) {\n            cout &lt;&lt; (a[i][n] ? \"?y7M#\" : \"Earth\") &lt;&lt; \"\\n\";\n        }\n    } else {\n        cout &lt;&lt; \"Cannot Determine\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/numerical-algorithm/integration/","title":"\u6570\u503c\u79ef\u5206","text":"\u6a21\u7248 \u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u9f99\u8d1d\u683c\u79ef\u5206 C++<pre><code>template&lt;class T = double&gt;\nstruct Simpson {\n    function&lt;T(T)&gt; f;\n    Simpson(function&lt;T(T)&gt; f) : f(f) {}\n    T simpson(T L, T R) {\n        T mid = (L + R) / 2;\n        return (R - L) * (f(L) + 4 * f(mid) + f(R)) / 6;\n    }\n    T asr(T L, T R, T eps, T ans) {\n        T mid = (L + R) / 2;\n        T fL = simpson(L, mid), fR = simpson(mid, R);\n        if (fabs(fL + fR - ans) &lt;= 15 * eps) {\n            return fL + fR + (fL + fR - ans) / 15;\n        }\n        return asr(L, mid, eps / 2, fL) + asr(mid, R, eps / 2, fR);\n    }\n    T operator()(T L, T R) {\n        return (*this)(L, R, 1e-12);\n    }\n    T operator()(T L, T R, T eps) {\n        return asr(L, R, eps, simpson(L, R));\n    }\n}; // Simpson\n</code></pre> C++<pre><code>template&lt;class T = double&gt;\nstruct Romberg {\n    function&lt;T(T)&gt; f;\n    Romberg(function&lt;T(T)&gt; f) : f(f) {}\n    T ctqf(T L, T R, T h) {\n        static T ans;\n        ans = 0.0;\n        for (T i = L + h / 2 ; i &lt; R ; i += h) {\n            ans += f(i);\n        }\n        return ans;\n    }\n    T operator()(T L, T R, T eps) {\n        static T T1, T2, S1, S2, C1, C2, R1, R2, h, S;\n        static int cnt, k;\n        k = 1; cnt = 0; h = R - L;\n        T1 = (f(L) + f(R)) * h / 2;\n        while (true) {\n            S = ctqf(L, R, h); cnt++;\n            T2 = (T1 + h * S) / 2; S2 = (4 * T2 - T1) / 3; h /= 2;\n            T1 = T2; S1 = S2; C1 = C2; R1 = R2;\n            if (k == 1) {\n                k++;\n                continue;\n            }\n            C2 = (16 * S2 - S1) / 15;\n            if (k == 2) {\n                k++;\n                continue;\n            }\n            R2 = (64 * C2 - C1) / 63;\n            if (k == 3) {\n                k++;\n                continue;\n            }\n            if (fabs(R1 - R2) &lt; eps || cnt &gt; 100) {\n                break;\n            }\n        }\n        return R2;\n    }\n}; // Romberg\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P4525\u6d1b\u8c37P4526 <p>P4525 \u3010\u6a21\u677f\u3011\u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u6cd5 1 - \u6d1b\u8c37</p> <p>P4526 \u3010\u6a21\u677f\u3011\u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u6cd5 2 - \u6d1b\u8c37</p>"},{"location":"template/math/numerical-algorithm/lagrange/","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c","text":"<p>\\(f(x)=\\sum_{i=1}^ny_i*\\prod_{j\\neq i}\\dfrac{x-x_j}{x_i-x_j}\\)</p> <p>\\(k\\) \u9636\u591a\u9879\u5f0f\u9700\u8981 \\(k+1\\) \u4e2a\u70b9\u63d2</p> \u4f8b\u9898 <p>P4781 \u3010\u6a21\u677f\u3011\u62c9\u683c\u6717\u65e5\u63d2\u503c - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst i64 P = 998244353;\ni64 qpow(i64 a, i64 b, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 x[2005], y[2005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i] &gt;&gt; y[i];\n    }\n    auto larange = [&amp;](long long k) {\n        long long res = 0;\n        for (int i = 0 ; i &lt; n ; i++) {\n            i64 s1 = 1, s2 = 1;\n            for (int j = 0 ; j &lt; n ; j++) {\n                if (i == j) continue;\n                s1 = s1 * (k - x[j]) % P;\n                s2 = s2 * (x[i] - x[j]) % P;\n            }\n            res = (res + y[i] * s1 % P * qpow(s2, P - 2) % P + P) % P;\n        }\n        return res;\n    };\n    cout &lt;&lt; larange(k) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P4593CF622FHydroOJP3453 <p>P4593 [TJOI2018] \u6559\u79d1\u4e66\u822c\u7684\u4eb5\u6e0e - \u6d1b\u8c37</p> <p>\\(ans=\\sum_{i=0}^m\\left(\\sum_{j=1}^{n-a_i}j^{m+1}-\\sum_{j=i+1}^m({(a_j-a_i)}^{m+1})\\right)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst i64 P = 1000000007;\ni64 qpow(i64 a, i64 b, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 y[55];\ni64 a[55];\nvoid solve() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a, a + m + 1);\n    int k = m + 1;\n    y[1] = 1;\n    for (int i = 2 ; i &lt;= k + 2 ; i++) {\n        y[i] = (y[i - 1] + qpow(i, k)) % P;\n    }\n    auto larange = [&amp;](i64 x) {\n        if (x &lt;= k + 2) return y[x];\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            i64 s1 = 1, s2 = 1;\n            for (int j = 1 ; j &lt;= k + 2 ; j++) {\n                if (i == j) continue;\n                s1 = s1 * (x - j) % P;\n                s2 = s2 * (i - j) % P;\n            }\n            res = (res + y[i] * s1 % P * qpow(s2, P - 2) % P + P) % P;\n        }\n        return res;\n    };\n    i64 ans = 0;\n    for (int i = 0 ; i &lt;= m ; i++) {\n        ans = (ans + larange(n - a[i])) % P;\n        i64 res = 0;\n        for (int j = i + 1 ; j &lt;= m ; j++) {\n            res = res + qpow(a[j] - a[i], k);\n        }\n        ans = ((ans - res) % P + P) % P;\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u6c42 \\(\\sum_{i=1}^ni^k\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst i64 P = 1000000007;\ni64 pre[1000005], suf[1000005], y[1000005], fact[1000005], invf[1000005];\ni64 qpow(i64 a, i64 b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1 ; i &lt;= k + 2 ; i++) {\n        y[i] = (y[i - 1] + qpow(i, k)) % P;\n    }\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= k + 2 ; i++) {\n        fact[i] = fact[i - 1] * i % P;\n    }\n    invf[k + 2] = qpow(fact[k + 2], P - 2);\n    for (int i = k + 2 ; i &gt;= 1 ; i--) {\n        invf[i - 1] = invf[i] * i % P;\n    }\n    auto lagrange = [&amp;](int x) {\n        if (x &lt;= k + 2) {\n            return y[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            pre[i] = pre[i - 1] * (x - i) % P;\n        }\n        suf[k + 3] = 1;\n        for (int i = k + 2 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * (x - i) % P;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 2 - i] \u7b26\u53f7(-1)^{k + 2 - i}\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            i64 s1 = pre[i - 1] * suf[i + 1] % P;\n            i64 s2 = invf[i - 1] * invf[k + 2 - i] % P;\n            if ((k + 2 - i) &amp; 1) {\n                s2 = P - s2;\n            }\n            res = (res + s1 * s2 % P * y[i] % P) % P;\n        }\n        return res;\n    };\n    cout &lt;&lt; lagrange(n);\n    return 0;\n}\n</code></pre> <p>tyvj 1858 XLkxc - HydroOJ</p> <p>f\u51fd\u6570\u662fk+1\u9636\u591a\u9879\u5f0f, g\u51fd\u6570\u662fk+2\u9636\u591a\u9879\u5f0f</p> <p>\u8bbe\u7b54\u6848\u4e3ah\u51fd\u6570, \u5219 h\u51fd\u6570\u662fk+3\u9636\u591a\u9879\u5f0f</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst i64 P = 1234567891;\ni64 pre[200], suf[200], y[200], fact[200], invf[200];\ni64 qpow(i64 a, i64 b = P - 2) {\n    i64 res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % P;\n        }\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ni64 f[200], g[200], h[200];\nvoid solve() {\n    int k, a, n, d;\n    cin &gt;&gt; k &gt;&gt; a &gt;&gt; n &gt;&gt; d;\n    for (int i = 1 ; i &lt;= k + 3 ; i++) {\n        f[i] = (f[i - 1] + qpow(i, k)) % P;\n        g[i] = (g[i - 1] + f[i]) % P;\n    }\n    auto lagrange1 = [&amp;](i64 x) {\n        if (x &lt;= k + 3) {\n            return g[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 3 ; i++) {\n            pre[i] = pre[i - 1] * ((x - i) % P) % P;\n        }\n        suf[k + 4] = 1;\n        for (int i = k + 3 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * ((x - i) % P) % P;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 3 - i] \u7b26\u53f7(-1)^{k + 3 - i}\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= k + 3 ; i++) {\n            i64 s1 = pre[i - 1] * suf[i + 1] % P;\n            i64 s2 = invf[i - 1] * invf[k + 3 - i] % P;\n            if ((k + 3 - i) &amp; 1) {\n                s2 = P - s2;\n            }\n            res = (res + s1 * s2 % P * g[i] % P) % P;\n        }\n        return res;\n    };\n    auto lagrange2 = [&amp;](i64 x) {\n        if (x &lt;= k + 4) {\n            return h[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 4 ; i++) {\n            pre[i] = pre[i - 1] * ((x - i) % P) % P;\n        }\n        suf[k + 5] = 1;\n        for (int i = k + 4 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * ((x - i) % P) % P;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 4 - i] \u7b26\u53f7(-1)^{k + 4 - i}\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= k + 4 ; i++) {\n            i64 s1 = pre[i - 1] * suf[i + 1] % P;\n            i64 s2 = invf[i - 1] * invf[k + 4 - i] % P;\n            if ((k + 4 - i) &amp; 1) {\n                s2 = P - s2;\n            }\n            res = (res + s1 * s2 % P * h[i] % P) % P;\n        }\n        return res;\n    };\n    for (int i = 1 ; i &lt;= k + 4 ; i++) {\n        h[i] = (h[i - 1] + lagrange1(a + 1LL * (i - 1) * d)) % P;\n    }\n    cout &lt;&lt; lagrange2(n + 1) &lt;&lt; \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= 150 ; i++) {\n        fact[i] = fact[i - 1] * i % P;\n    }\n    invf[150] = qpow(fact[150], P - 2);\n    for (int i = 150 ; i &gt;= 1 ; i--) {\n        invf[i - 1] = invf[i] * i % P;\n    }\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/math/numerical-algorithm/newton/","title":"\u725b\u987f\u8fed\u4ee3\u6cd5","text":"<p>\u5728 \\([a,b]\\) \u4e0a\u8fde\u7eed\u4e14\u5355\u8c03\u7684\u51fd\u6570 \\(f(x)\\)\uff0c\u6c42\u65b9\u7a0b \\(f(x)=0\\) \u7684\u8fd1\u4f3c\u89e3\u3002</p> \\[ \\nonumber x_{i+1}=x_i-\\dfrac{f(x_i)}{f^\\prime(x_i)} \\] \u6c42\u89e3\u5e73\u65b9\u6839 C++<pre><code>const double eps = 1e-15;\ndouble Sqrt(double n) {\n    double x = 1;\n    while (true) {\n        double nx = (x + n / x) / 2;\n        if (fabs(x - nx) &lt; eps) {\n            break;\n        }\n        x = nx;\n    }\n    return x;\n}\n</code></pre>"},{"location":"template/math/poly/divide-conquer-ntt/","title":"\u5206\u6cbbNTT","text":"\u4e60\u9898 \u6d1b\u8c37P5644\u725b\u5ba226013C <p>P5644 [PKUWC2018] \u730e\u4eba\u6740 - \u6d1b\u8c37</p> <p>\u4ee4 \\(F(S)\\) \u4e3a\u96c6\u5408 \\(S\\) \u4e2d\u7684\u730e\u4eba\u5728 \\(1\\) \u53f7\u730e\u4eba\u540e\u9762\u6b7b\u7684\u6982\u7387\uff0c\\(G(S)\\) \u5728 \\(1\\) \u53f7\u730e\u4eba\u6b7b\u540e\uff0c\u730e\u4eba\u96c6\u5408\u6070\u597d\u4e3a \\(S\\) \u7684\u6982\u7387\u3002</p> <p>\u90a3\u4e48\u6709 \\(F(S)=\\sum_{S\\subseteq T}G(T)\\)</p> <p>\u7531\u5b50\u96c6\u53cd\u6f14\u5f97 \\(G(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}*F(T)\\)</p> <p>\u90a3\u4e48 \\(G(\\varnothing)=\\sum_S(-1)^{|S|}*F(S)\\)</p> <p>\\(F(S)=\\sum_{i=0}^{+\\infty}(\\dfrac{w(U)-w_1-w(S)}{w(U)})^i*\\dfrac{w_1}{w(U)}=\\dfrac{w_1}{w_1+w(S)}\\)</p> <p>\u5f97 \\(G(\\varnothing)=\\sum_S(-1)^{|S|}*\\dfrac{w_1}{w_1+w(S)}\\)</p> <p>\u7531\u4e8e \\(w(S)\\leq10^5\\), \u6240\u4ee5\u53ef\u4ee5\u679a\u4e3e \\(w(S)\\)</p> <p>\u5f97 \\(G(\\varnothing)=\\sum_{w(S)=i}(-1)^{|S|}*\\dfrac{w_1}{w_1+i}\\)</p> <p>\u7136\u540e\u8f6c\u6362\u6210\u4e00\u4e2a\u80cc\u5305\u7684\u65e0\u6807\u53f7\u8ba1\u6570\u95ee\u9898\uff0c\u5bf9\u751f\u6210\u51fd\u6570 \\(1-w_i\\) \u8fdb\u884c\u5206\u6cbbNTT\u6c42\u89e3\u3002</p> \u4ee3\u7801 C++<pre><code>{ \u591a\u9879\u5f0f\u6a21\u7248 }\nint w[100005];\nvector&lt;int&gt; solve(int L, int R) {\n    if (L == R) {\n        Poly a(w[L] + 1);\n        a[0] = 1;\n        a[w[L]] = P - 1;\n        return a;\n    }\n    int mid = L + R &gt;&gt; 1;\n    return solve(L, mid) * solve(mid + 1, R);   \n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; w[i];\n    }\n    Poly res = solve(2, n);\n    i64 ans = 0;\n    for (int i = 0 ; i &lt; (int) res.size() ; i++) {\n        mod_add(ans, mod_mul_t(mod_mul_t(w[1], res[i]), qpow(i + w[1])));\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>C-\u6311\u9009\u961f\u53cb</p> <p>\\(n\\) \u4e2a\u4eba\u5206\u6210 \\(m\\) \u4e2a\u7fa4, \u8981\u9009 \\(k\\) \u4e2a\u4eba, \u6bcf\u4e2a\u7fa4\u81f3\u5c11\u9009\u4e00\u4eba, \u95ee\u9009\u62e9\u65b9\u6848\u6570.</p> <p>\u5df2\u77e5\u7b2c \\(i\\) \u4e2a\u7fa4\u7684\u751f\u6210\u51fd\u6570\u4e3a \\(\\sum_{i=1}^{s_i}C_{s_i}^i*x^i\\)</p> <p>\u5206\u6cbbNTT \u6c42\u51fa \\(m\\) \u4e2a\u7fa4\u7684\u65b9\u6848 \\(F(x)\\), \\([x^k]F(x)\\) \u5373\u4e3a\u7b54\u6848\u3002</p> \u4ee3\u7801 C++<pre><code>{ \u591a\u9879\u5f0f\u6a21\u7248 }\n{ \u7ec4\u5408\u6570\u6a21\u7248 }\nint s[100005];\nPoly solve(int L, int R) {\n    if (L == R) {\n        Poly r(s[L] + 1);\n        for (int i = 1 ; i &lt;= s[L] ; i++) {\n            r[i] = C(s[L], i);\n        }\n        return r;\n    }\n    int mid = L + R &gt;&gt; 1;\n    return solve(L, mid) * solve(mid + 1, R);\n}\nint main() {\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; s[i];\n    }\n    cout &lt;&lt; solve(1, m)[k];\n    return 0;\n}\n</code></pre>"},{"location":"template/math/poly/polynomial/","title":"\u591a\u9879\u5f0f\u521d\u7b49\u51fd\u6570","text":"\\(r*2^k+1\\) \\(r\\) \\(k\\) \\(g\\) 3 1 1 2 5 1 2 2 17 1 4 3 97 3 5 5 193 3 6 5 257 1 8 3 7681 15 9 17 12289 3 12 11 40961 5 13 3 65537 1 16 3 786433 3 18 10 5767169 11 19 3 7340033 7 20 3 23068673 11 21 3 104857601 25 22 3 167772161 5 25 3 469762049 7 26 3 998244353 119 23 3 1004535809 479 21 3 2013265921 15 27 31 2281701377 17 27 3 3221225473 3 30 5 75161927681 35 31 3 77309411329 9 33 7 206158430209 3 36 22 2061584302081 15 37 7 2748779069441 5 39 3 6597069766657 3 41 5 39582418599937 9 42 5 79164837199873 9 43 5 263882790666241 15 44 7 1231453023109121 35 45 3 1337006139375617 19 46 3 3799912185593857 27 47 5 4222124650659841 15 48 19 7881299347898369 7 50 6 31525197391593473 7 52 3 180143985094819841 5 55 6 1945555039024054273 27 56 5 4179340454199820289 29 57 3 \u6a21\u7248 C++<pre><code>using i64 = long long;\nusing Poly = vector&lt;int&gt;;\nconst int P = 998244353;\n#define mod_mul(a, b) (a = i64(a) * (b) % P)\n#define mod_mul_t(a, b) (i64(a) * (b) % P)\n#define mod_add(a, b) (((a) += (b)) &gt;= P ? (a) -= P : 0)\n#define mod_add_t(a, b) ((a) &gt;= P - (b) ? (a) + (b) - P : (a) + (b))\n#define mod_sub(a, b) (((a) -= (b)) &lt; 0 ? (a) += P : 0)\n#define mod_sub_t(a, b) ((a) &lt; (b) ? (a) - (b) + P : (a) - (b))\ni64 qpow(i64 a, int b = P - 2, i64 res = 1) {\n    while (b) {\n        if (b &amp; 1) res = res * a % P;\n        a = a * a % P;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nPoly inv = [](int L) {\n    Poly inv(L);\n    inv[0] = inv[1] = 1;\n    for (int i = 2 ; i &lt; L ; i++) {\n        inv[i] = mod_mul_t((P - P / i), inv[P % i]);\n    }\n    return inv;\n}(1 &lt;&lt; 20);\nnamespace FFT {\n    struct Complex {\n        double x = 0.0, y = 0.0;\n        Complex() {}\n        Complex(int x, int y) : x(x), y(y) {}\n        Complex(double x, double y) : x(x), y(y) {}\n        Complex(long double x, long double y) : x(x), y(y) {}\n        Complex operator+(const Complex &amp;rhs) const {\n            return Complex(x + rhs.x, y + rhs.y);\n        }\n        Complex operator-(const Complex &amp;rhs) const {\n            return Complex(x - rhs.x, y - rhs.y);\n        }\n        Complex operator*(const Complex &amp;rhs) const {\n            return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);\n        }\n        Complex operator*(const double b) const {\n            return Complex(x * b, y * b);\n        }\n        Complex operator/(const double b) const {\n            return Complex(x / b, y / b);\n        }\n        Complex conj() const {\n            return Complex(x, -y);\n        }\n    } I(0, 1);\n    int binary_upper_bound_in_bits(int w) {\n        if (w &lt;= 0) {\n            return 1;\n        }\n        return 32 - __builtin_clz(w);\n    }\n    const long double PI = acos(-1.0);\n    const long double PI2 = PI / 2;\n    vector&lt;Complex&gt; r;\n    void fft(vector&lt;Complex&gt; &amp;a) {\n        if (r.empty()) {\n            r = [](int len) {\n                vector&lt;Complex&gt; r(1 &lt;&lt; len);\n                for (int i = 0 ; i &lt; len ; i++) {\n                    int L = 1 &lt;&lt; i;\n                    r[L] = Complex(cos(PI2 / L), sin(PI2 / L));\n                    for (int j = L + 1 ; j &lt; (L &lt;&lt; 1) ; j++) {\n                        r[j] = r[j - L] * r[L];\n                    }\n                }\n                return r;\n            }(20);\n        }\n        int len = a.size();\n        for (int i = len ; i &gt;= 2 ; i /= 2) {\n            int L = i / 2;\n            for (int j = 0 ; j &lt; L ; j++) {\n                Complex z = a[j + L];\n                a[j + L] = a[j] - z;\n                a[j] = a[j] + z;\n            }\n            for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n                for (int k = 0 ; k &lt; L ; k++) {\n                    Complex z = a[j + k + L] * r[res];\n                    a[j + k + L] = a[j + k] - z;\n                    a[j + k] = a[j + k] + z;\n                }\n            }\n        }\n    }\n    void ifft(vector&lt;Complex&gt; &amp;a) {\n        int len = a.size();\n        for (int i = 2 ; i &lt;= len ; i *= 2) {\n            int L = i / 2;\n            for (int j = 0 ; j &lt; L ; j++) {\n                Complex z = a[j + L];\n                a[j + L] = a[j] - z;\n                a[j] = a[j] + z;\n            }\n            for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n                for (int k = 0 ; k &lt; L ; k++) {\n                    Complex z = a[j + k + L];\n                    a[j + k + L] = (a[j + k] - z) * r[res];\n                    a[j + k] = a[j + k] + z;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = a[i] / len;\n        }\n        reverse(begin(a) + 1, end(a));\n    }\n}\nnamespace NTT {\n    const int g = 3; // P \u7684\u539f\u6839\n    const int I = 86583718; // g^((P-1)/4)\n    // NTT \u6a21\u6570 mod \u5fc5\u987b\u4e3a p*2^(q)+1 (p,q\u4e3a\u4efb\u610f\u6b63\u6574\u6570)\n    // 167772161 | 3\n    // 469762049 | 3\n    // 754974721 | 11\n    // 998244353 | 3\n    // 1004535809 | 3\n    Poly W;\n    template&lt;class T&gt;\n    void DIF(T *a, int n) {\n        if (W.empty()) {\n            W = [](int L) {\n                int wn = qpow(g, P / L);\n                Poly w(L);\n                w[L &gt;&gt; 1] = 1;\n                for (int i = L / 2 + 1 ; i &lt; L ; i++) {\n                    w[i] = mod_mul_t(w[i - 1], wn);\n                }\n                for (int i = L / 2 - 1 ; i &gt;= 1 ; i--) {\n                    w[i] = w[i &lt;&lt; 1];\n                }\n                return w;\n            }(1 &lt;&lt; 20);\n        }\n        for (int k = n &gt;&gt; 1 ; k ; k &gt;&gt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k &lt;&lt; 1) {\n                i64 x, y;\n                for (int j = 0 ; j &lt; k ; j++) {\n                    x = a[i + j]; y = a[i + j + k];\n                    a[i + j] = mod_add_t(a[i + j], y);\n                    a[i + j + k] = mod_mul_t(mod_sub_t(x, y), W[j + k]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void IDIT(T *a, int n) {\n        for (int k = 1 ; k &lt; n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k &lt;&lt; 1) {\n                i64 x, y;\n                for (int j = 0 ; j &lt; k ; j++) {\n                    x = a[i + j]; y = mod_mul_t(a[i + j + k], W[j + k]);\n                    a[i + j] = mod_add_t(x, y);\n                    a[i + j + k] = mod_sub_t(x, y);\n                }\n            }\n        }\n        int inv = P - (P - 1) / n;\n        for (int i = 0 ; i &lt; n ; i++) {\n            mod_mul(a[i], inv);\n        }\n        reverse(a + 1, a + n);\n    }\n}\nnamespace FWT {\n    template&lt;class T&gt;\n    void AND(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    mod_add(a[j], a[j + t]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void IAND(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    mod_sub(a[j], a[j + t]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void OR(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    mod_add(a[j + t], a[j]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void IOR(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    mod_sub(a[j + t], a[j]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void XOR(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    int temp = a[j];\n                    mod_add(a[j], a[j + t]);\n                    a[j + t] = mod_sub_t(temp, a[j + t]);\n                }\n            }\n        }\n    }\n    template&lt;class T&gt;\n    void IXOR(T *a, int n) {\n        for (int k = 2 ; k &lt;= n ; k &lt;&lt;= 1) {\n            for (int i = 0 ; i &lt; n ; i += k) {\n                int t = k &gt;&gt; 1;\n                for (int j = i ; j &lt; i + t ; j++) {\n                    int temp = a[j];\n                    mod_add(a[j], a[j + t]);\n                    a[j + t] = mod_sub_t(temp, a[j + t]);\n                    mod_mul(a[j], inv[2]);\n                    mod_mul(a[j + t], inv[2]);\n                }\n            }\n        }\n    }\n}\nnamespace Polynomial {\n    int norm(int x) {\n        return 1 &lt;&lt; (__lg(x - 1) + 1);\n    }\n    void norm(Poly &amp;a) {\n        if (!a.empty()) {\n            a.resize(norm(a.size()));\n        } else {\n            a = {0};\n        }\n    }\n    void DFT(Poly &amp;a) {\n        NTT::DIF(a.data(), a.size());\n    }\n    void IDFT(Poly &amp;a) {\n        NTT::IDIT(a.data(), a.size());\n    }\n    void AND(Poly &amp;a) {\n        FWT::AND(a.data(), a.size());\n    }\n    void IAND(Poly &amp;a) {\n        FWT::IAND(a.data(), a.size());\n    }\n    void OR(Poly &amp;a) {\n        FWT::OR(a.data(), a.size());\n    }\n    void IOR(Poly &amp;a) {\n        FWT::IOR(a.data(), a.size());\n    }\n    void XOR(Poly &amp;a) {\n        FWT::XOR(a.data(), a.size());\n    }\n    void IXOR(Poly &amp;a) {\n        FWT::IXOR(a.data(), a.size());\n    }\n    Poly&amp; dot(Poly &amp;a, Poly &amp;b) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            mod_mul(a[i], b[i]);\n        }\n        return a;\n    }\n    Poly operator+(Poly a, Poly b) {\n        a.resize(max(a.size(), b.size()));   \n        for (int i = 0 ; i &lt; (int) b.size() ; i++) {\n            mod_add(a[i], b[i]);\n        }\n        return a;\n    }\n    Poly operator+(Poly a, int b) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            mod_add(a[i], b);\n        }\n        return a;\n    }\n    Poly operator-(Poly a, Poly b) {\n        a.resize(max(a.size(), b.size()));\n        for (int i = 0 ; i &lt; (int) b.size() ; i++) {\n            mod_sub(a[i], b[i]);\n        }\n        return a;\n    }\n    Poly operator-(Poly a, int b) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            mod_sub(a[i], b);\n        }\n        return a;\n    }\n    Poly operator-(Poly a) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            a[i] = mod_sub_t(P, a[i]);\n        }\n        return a;\n    }\n    Poly operator/(Poly a, int b) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            mod_mul(a[i], qpow(b));\n        }\n        return a;\n    }\n    Poly operator*(Poly a, int b) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            mod_mul(a[i], b);\n        }\n        return a;\n    }\n    Poly operator*(Poly a, Poly b) {\n        int n = a.size() + b.size() - 1;\n        if (a.size() &lt;= 16 || b.size() &lt;= 16) {\n            Poly c(n);\n            for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n                for (int j =  0; j &lt; (int) b.size() ; j++) {\n                    mod_add(c[i + j], mod_mul_t(a[i], b[j]));\n                }\n            }\n            return c;\n        }\n        int L = norm(n);\n        a.resize(L); b.resize(L);\n        DFT(a); DFT(b); dot(a, b); IDFT(a);\n        return a.resize(n), a;\n    }\n    Poly operator~(Poly a) {\n        reverse(begin(a), end(a));\n        return a;\n    }\n    Poly&amp; operator+=(Poly &amp;a, Poly b) {\n        return a = a + b;\n    }\n    Poly&amp; operator+=(Poly &amp;a, int b) {\n        return a = a + b;\n    }\n    Poly&amp; operator-=(Poly &amp;a, Poly b) {\n        return a = a - b;\n    }\n    Poly&amp; operator-=(Poly &amp;a, int b) {\n        return a = a - b;\n    }\n    Poly operator/=(Poly &amp;a, int b) {\n        return a = a / b;\n    }\n    Poly&amp; operator*=(Poly &amp;a, int b) {\n        return a = a * b;\n    }\n    Poly&amp; operator*=(Poly &amp;a, Poly b) {\n        return a = a * b;\n    }\n    Poly mtt_f(const Poly &amp;f, const Poly &amp;g, int mod) {\n        int n = f.size() + g.size() - 1;\n        if (f.size() &lt;= 16 || g.size() &lt;= 16) {\n            Poly c(n);\n            for (int i = 0 ; i &lt; (int) f.size() ; i++) {\n                for (int j =  0; j &lt; (int) g.size() ; j++) {\n                    c[i + j] = (c[i + j] + (i64) f[i] * g[j] % mod) % mod;\n                }\n            }\n            return c;\n        }\n        int L = norm(n);\n        vector&lt;FFT::Complex&gt; a(L), b(L), c(L);\n        for (int i = 0 ; i &lt; (int) f.size() ; i++) {\n            a[i] = {f[i] &amp; 65535, f[i] &gt;&gt; 16};\n        }\n        for (int i = 0 ; i &lt; (int) g.size() ; i++) {\n            b[i] = {g[i] &amp; 65535, g[i] &gt;&gt; 16};\n        }\n        FFT::fft(a);\n        FFT::fft(b);\n        c = a;\n        a[0] = a[0] * (b[0].x * 2);\n        c[0] = c[0] * (b[0].y * 2);\n        int w = FFT::binary_upper_bound_in_bits(L - 1);\n        for (int k = 0 ; k &lt; w ; k++) {\n            int l = 1 &lt;&lt; k, mask = l - 1;\n            for (int i = l ; i &lt; (l &lt;&lt; 1) ; i++) {\n                FFT::Complex p = b[i], q = b[i ^ mask].conj(), x = (p + q), y = (q - p) * FFT::I;\n                a[i] = a[i] * x;\n                c[i] = c[i] * y;\n            }\n        }\n        FFT::ifft(a);\n        FFT::ifft(c);\n        Poly res(n);\n        auto get = [&amp;](double x) {\n            i64 v = x + .5;\n            return ((v &lt; 0) ? (mod + (v - 1) / 2 % mod) : (v + 1) / 2) % mod;\n        };\n        for (int i = 0 ; i &lt; n ; i++) {\n            res[i] = (\n                (get(c[i].y) &lt;&lt; (16 &lt;&lt; 1)) +\n                (get(c[i].x + a[i].y) &lt;&lt; 16) +\n                get(a[i].x)\n            ) % mod;\n        }\n        return res;\n    }\n    Poly inv2k(Poly a) {\n        int n = a.size(), m = n &gt;&gt; 1;;\n        if (n == 1) {\n            return Poly(1, qpow(a[0]));\n        }\n        Poly b = inv2k(Poly(begin(a), begin(a) + m));\n        Poly c = b;\n        b.resize(n); DFT(a); DFT(b); dot(a, b); IDFT(a);\n        for (int i = 0 ; i &lt; n ; i++) {\n            a[i] = (i &lt; m ? 0 : P - a[i]);\n        }\n        DFT(a); dot(a, b); IDFT(a);\n        return move(begin(c), end(c), begin(a)), a;\n    }\n    Poly Inv(Poly a) {\n        int n = a.size();\n        norm(a);\n        a = inv2k(a);\n        return a.resize(n), a;\n    }\n    Poly deriv(Poly a) {\n        for (int i = 1 ; i &lt; (int) a.size() ; i++) {\n            a[i - 1] = mod_mul_t(a[i], i);\n        }\n        return a.pop_back(), a;\n    }\n    Poly integ(Poly a) {\n        a.push_back(0);\n        for (int i = (int) a.size() - 1 ; i &gt; 0 ; i--) {\n            a[i] = mod_mul_t(a[i - 1], inv[i]);\n        }\n        return a[0] = 0, a;\n    }\n    Poly Ln(Poly a) {\n        assert(a[0] == 1);\n        int n = a.size();\n        a = deriv(a) * Inv(a);\n        return a.resize(n - 1), integ(a);\n    }\n    Poly Exp(Poly a) {\n        assert(a[0] == 0);\n        int n = a.size(), k = norm(n);\n        Poly b = {1}, c, d;\n        a.resize(k);\n        for (int L = 2 ; L &lt;= k ; L &lt;&lt;= 1) {\n            d = b; b.resize(L);\n            c = Ln(b); c.resize(L);\n            for (int i = 0 ; i &lt; L ; i++) {\n                c[i] = mod_sub_t(a[i], c[i]);\n            }\n            mod_add(c[0], 1); DFT(b); DFT(c); dot(b, c); IDFT(b);\n            move(begin(d), end(d), begin(b));\n        }\n        return b.resize(n), b;\n    }\n    void Pow(Poly &amp;a, int m0, int m1, int d) {\n        int n = a.size();\n        a.erase(begin(a), begin(a) + d);\n        int a0 = a[0]; assert(a0);\n        a *= qpow(a0);\n        a = Exp(Ln(a) * m0) * qpow(a0, m1);\n        a.resize(n); d *= m0;\n        for (int i = n - 1 ; i &gt;= 0 ; i--) {\n            a[i] = (i &gt;= d ? a[i - d] : 0);\n        }\n    }\n    Poly Pow(Poly a, int m) {\n        int n = a.size(), d = 0;\n        while (d &lt; n &amp;&amp; a[d] == 0) {\n            d++;\n        }\n        if (d == n) return a;\n        if ((i64) d * m &gt;= n) {\n            return Poly(n);\n        }\n        Pow(a, m, m, d);\n        return a;\n    }\n    Poly Pow(Poly a, string str) {\n        int n = a.size(), d = 0;\n        while (d &lt; n &amp;&amp; a[d] == 0) {\n            d++;\n        }\n        if (d == n) return a;\n        if (d) {\n            if (str.size() &gt; 8 || d * stoll(str) &gt;= n) {\n                return Poly(n);\n            }\n        }\n        i64 m0 = 0, m1 = 0;\n        const int phi = P - 1;\n        for (int i = 0 ; i &lt; (int) str.size() ; i++) {\n            m0 = (m0 * 10 + str[i] - '0') % P;\n            m1 = (m1 * 10 + str[i] - '0') % phi;\n        }\n        Pow(a, m0, m1, d);\n        return a;\n    }\n    pair&lt;Poly, Poly&gt; Div(Poly f, Poly g) {\n        int n = f.size() - 1, m = g.size() - 1;\n        if (n &lt; m) {\n            return {Poly(1), f};\n        }\n        Poly f_rev = ~f, g_rev = ~g;\n        g_rev.resize(n - m + 1);\n        Poly q = f_rev * Inv(g_rev);\n        q.resize(n - m + 1); q = ~q;\n        g *= q;\n        f.resize(m); g.resize(m);\n        Poly r = f - g;\n        return {q, r};\n    }\n    Poly operator/(const Poly &amp;a, const Poly &amp;b) {\n        return Div(a, b).first;\n    }\n    Poly operator%(const Poly &amp;a, const Poly &amp;b) {\n        return Div(a, b).second;\n    }\n    Poly operator/=(Poly &amp;a, const Poly &amp;b) {\n        return a = a / b;\n    }\n    Poly operator%=(Poly &amp;a, const Poly &amp;b) {\n        return a = a % b;\n    }\n    Poly Sqrt(Poly a) {\n        assert(a[0] == 1); // \u591a\u9879\u5f0f\u5e38\u6570\u9879\u5fc5\u987b\u4e3a1\n        int n = a.size();\n        Poly res{1};\n        for (int len = 1 ; len &lt; (n &lt;&lt; 1) ; len &lt;&lt;= 1) {\n            Poly b = a; b.resize(len);\n            res.resize(len);\n            Poly c = b * Inv(res); c.resize(len);\n            res += c;\n            res /= 2;\n        }\n        return res.resize(n), res;\n    }\n    Poly Sin(Poly &amp;a) {\n        return (Exp(a * NTT::I) - Exp(a * (P - NTT::I))) * qpow(mod_mul_t(NTT::I, 2));\n    }\n    Poly Cos(Poly &amp;a) {\n        return (Exp(a * NTT::I) + Exp(a * (P - NTT::I))) * qpow(2);\n    }\n    Poly Tan(Poly &amp;a) {\n        return Sin(a) * Inv(Cos(a));\n    }\n    Poly Asin(Poly &amp;a) {\n        int n = a.size();\n        Poly c = a * a; c.resize(n);\n        mod_sub(c[0], 1);\n        c *= P - 1;\n        c = deriv(a) * Inv(Sqrt(c)); c.resize(n - 1);\n        return integ(c);\n    }\n    Poly Acos(Poly &amp;a) {\n        int n = a.size();\n        Poly c = a * a; c.resize(n);\n        mod_sub(c[0], 1);\n        c *= P - 1;\n        c = deriv(a) * Inv(Sqrt(c)); c.resize(n - 1);\n        c *= P - 1;\n        return integ(c);\n    }\n    Poly Atan(Poly &amp;a) {\n        int n = a.size();\n        Poly c = a * a; c.resize(n);\n        mod_add(c[0], 1);\n        c = deriv(a) * Inv(c); c.resize(n - 1);\n        return integ(c);\n    }\n    Poly Stirling2ndRow(int n) {\n        vector&lt;int&gt; fact(n + 1), invfact(n + 1);\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            fact[i] = mod_mul_t(fact[i - 1], i);\n        }\n        invfact[n] = qpow(fact[n]);\n        for (int i = n ; i &gt;= 1 ; i--) {\n            invfact[i - 1] = mod_mul_t(invfact[i], i);\n        }\n        Poly a(n + 1), b(n + 1);\n        for (int i = 0 ; i &lt;= n ; i++) {\n            a[i] = mod_mul_t(invfact[i], qpow(i, n));\n            b[i] = mod_mul_t(invfact[i], (i &amp; 1 ? P - 1 : 1));\n        }\n        a *= b;\n        return a.resize(n + 1), a;\n    }\n    Poly Stirling2ndCol(int k, int n) {\n        int mx = max(k, n);\n        vector&lt;int&gt; fact(mx + 1), invfact(mx + 1);\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= mx ; i++) {\n            fact[i] = mod_mul_t(fact[i - 1], i);\n        }\n        invfact[mx] = qpow(fact[mx]);\n        for (int i = mx ; i &gt;= 1 ; i--) {\n            invfact[i - 1] = mod_mul_t(invfact[i], i);\n        }\n        Poly a(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            a[i] = invfact[i];\n        }\n        a = Pow(a, k);\n        for (int i = 0 ; i &lt;= n ; i++) {\n            mod_mul(a[i], mod_mul_t(fact[i], invfact[k]));\n        }\n        return a;\n    }\n    Poly Stirling1stRow(int n) {\n        vector&lt;int&gt; fact(n + 1), invfact(n + 1);\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            fact[i] = mod_mul_t(fact[i - 1], i);\n        }\n        invfact[n] = qpow(fact[n]);\n        for (int i = n ; i &gt;= 1 ; i--) {\n            invfact[i - 1] = mod_mul_t(invfact[i], i);\n        }\n        function&lt;Poly(int)&gt; dfs = [&amp;](int n) -&gt; Poly {\n            if (n == 1) {\n                return {0, 1};\n            }\n            if (n &amp; 1) {\n                Poly a = dfs(n - 1);\n                a.resize(n + 1);\n                for (int i = n ; i &gt; 0 ; i--) {\n                    mod_mul(a[i], n - 1);\n                    mod_add(a[i], a[i - 1]);\n                }\n                mod_mul(a[0], n - 1);\n                return a;\n            } else {\n                Poly a = dfs(n / 2);\n                int len = n / 2;\n                a.resize(len + 1);\n                Poly b(len + 1), c(len + 1);\n                for (int i = 0 ; i &lt;= len ; i++) {\n                    b[i] = mod_mul_t(a[len - i], fact[len - i]);\n                    c[i] = mod_mul_t(qpow(len, i), invfact[i]);\n                }\n                b *= c;\n                for (int i = 0 ; i &lt;= len ; i++) {\n                    c[i] = mod_mul_t(b[len - i], invfact[i]);\n                }\n                a *= c;\n                return a;\n            }\n        };\n        return dfs(n);\n    }\n    Poly Stirling1stCol(int k, int n) {\n        int mx = max(k, n);\n        vector&lt;int&gt; fact(mx + 1), invfact(mx + 1);\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= mx ; i++) {\n            fact[i] = mod_mul_t(fact[i - 1], i);\n        }\n        invfact[mx] = qpow(fact[mx]);\n        for (int i = mx ; i &gt;= 1 ; i--) {\n            invfact[i - 1] = mod_mul_t(invfact[i], i);\n        }\n        Poly a(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            a[i] = mod_mul_t(fact[i - 1], invfact[i]);\n        }\n        a = Pow(a, k);\n        for (int i = 0 ; i &lt;= n ; i++) {\n            mod_mul(a[i], mod_mul_t(fact[i], invfact[k]));\n        }\n        return a;\n    }\n    Poly Bell(int n) {\n        vector&lt;int&gt; fact(n + 1), invfact(n + 1);\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            fact[i] = mod_mul_t(fact[i - 1], i);\n        }\n        invfact[n] = qpow(fact[n]);\n        for (int i = n ; i &gt;= 1 ; i--) {\n            invfact[i - 1] = mod_mul_t(invfact[i], i);\n        }\n        Poly a(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            a[i] = invfact[i];\n        }\n        a = Exp(a);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            mod_mul(a[i], fact[i]);\n        }\n        return a;\n    }\n    Poly Partition(int n, int m) {\n        assert(n &gt;= m &amp;&amp; n &lt; (int) inv.size());\n        Poly a(n + 1);\n        for (int i = 1 ; i &lt;= m ; i++) {\n            for (int j = i ; j &lt;= n ; j += i) {\n                mod_add(a[j], P - inv[j / i]);\n            }\n        } \n        a = Inv(Exp(a));\n        return a;\n    }\n    Poly BerlekampMassey(const Poly &amp;a) {\n        int n = a.size();\n        Poly temp(n + 1), f(n + 1), g(n + 1);\n        int k = 0, last_k = 0, last_delta, last = -1;\n        for (int i = 0 ; i &lt; n ; i++) {\n            int delta = P - a[i];\n            for (int j = 1 ; j &lt;= k ; j++) {\n                mod_add(delta, mod_mul_t(f[j], a[i - j]));\n            }\n            if (delta == 0) continue;\n            if (last == -1) {\n                k = i + 1;\n            } else {\n                int t = mod_mul_t(delta, qpow(last_delta));\n                mod_add(temp[i - last], t);\n                for (int j = 1 ; j &lt;= last_k ; j++) {\n                    mod_sub(temp[i - last + j], mod_mul_t(t, g[j]));\n                }\n                int p = last_k;\n                last_k = k;\n                k = max(k, i - last + p);\n                for (int j = 1 ; j &lt;= last_k ; j++) {\n                    g[j] = f[j];\n                }\n                for (int j = 1 ; j &lt;= k ; j++) {\n                    f[j] = temp[j];\n                }\n            }\n            last_delta = delta;\n            last = i;\n        }\n        return f.resize(k + 1), f;\n    }\n    i64 LinearRec(const Poly &amp;a, const Poly &amp;r, i64 n) {\n        Poly F(begin(a), begin(a) + r.size() - 1), R = -r;\n        R[0] = 1;\n        F *= R;\n        F.resize(R.size() - 1);\n        for ( ; n ; n /= 2) {\n            Poly rR = R;\n            for (int i = 0 ; i &lt; (int) rR.size() ; i += 2) {\n                rR[i] = mod_sub_t(P, rR[i]);\n            }\n            Poly FR = F * rR, RR = R * rR;\n            F.resize(0); R.resize(0);\n            for (int i = (n &amp; 1) ; i &lt; (int) FR.size() ; i+= 2) {\n                F.push_back(FR[i]);\n            }\n            for (int i = 0 ; i &lt; (int) RR.size() ; i += 2) {\n                R.push_back(RR[i]);\n            }\n        }\n        return F.empty() ? 0 : mod_mul_t(F[0],qpow(R[0]));\n    }\n    Poly operator&amp;(Poly a, Poly b) {\n        int n = a.size();\n        int L = norm(n);\n        a.resize(L); b.resize(L);\n        AND(a); AND(b); dot(a, b); IAND(a);\n        return a.resize(n), a;\n    }\n    Poly&amp; operator&amp;=(Poly &amp;a, Poly b) {\n        return a = a &amp; b;\n    }\n    Poly operator|(Poly a, Poly b) {\n        int n = max(a.size(), b.size());\n        int L = norm(n);\n        a.resize(L); b.resize(L);\n        OR(a); OR(b); dot(a, b); IOR(a);\n        return a.resize(n), a;\n    }\n     Poly&amp; operator|=(Poly &amp;a, Poly b) {\n        return a = a | b;\n    }\n    Poly operator^(Poly a, Poly b) {\n        int n = max(a.size(), b.size());\n        int L = norm(n);\n        a.resize(L); b.resize(L);\n        XOR(a); XOR(b); dot(a, b); IXOR(a);\n        return a.resize(n), a;\n    }\n     Poly&amp; operator^=(Poly &amp;a, Poly b) {\n        return a = a ^ b;\n    }\n    istream&amp; operator&gt;&gt;(istream &amp;is, Poly &amp;a) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            is &gt;&gt; a[i];\n        }\n        return is;\n    }\n    ostream&amp; operator&lt;&lt;(ostream &amp;os, const Poly &amp;a) {\n        for (int i = 0 ; i &lt; (int) a.size() ; i++) {\n            os &lt;&lt; a[i] &lt;&lt; \" \";\n        }\n        return os;\n    }\n} // Polynomial\nusing namespace Polynomial;\n</code></pre> \u4f8b\u9898 \u591a\u9879\u5f0f\u4e58\u6cd5\\(O(n*\\log n)\\)\u591a\u9879\u5f0f\u4efb\u610f\u6a21\u6570\u4e58\u6cd5\\(O(n*\\log n)\\)\u591a\u9879\u5f0f\u6c42\u9006\\(O(n*\\log n)\\)\u591a\u9879\u5f0f\u5bf9\u6570\\((\\ln)\\)\u51fd\u6570\\(O(n*\\log n)\\)\\((a_0=1)\\)\u591a\u9879\u5f0f\u6307\u6570\\((\\exp)\\)\u51fd\u6570\\(O(n*\\log^2n)\\)\\((a_0=1)\\)\u591a\u9879\u5f0f\u5e42\u51fd\u6570\\(O(n*\\log^2n)\\)\u591a\u9879\u5f0f\u4e09\u89d2\u51fd\u6570\\(O(n*\\log^2n)\\)\\((a_0=0)\\)\u591a\u9879\u5f0f\u53cd\u4e09\u89d2\u51fd\u6570\\(O(n*\\log^2n)\\)\\((a_0=0)\\)\u591a\u9879\u5f0f\u4f4d\u8fd0\u7b97\u5377\u79ef\\(O(n*\\log n)\\)\u591a\u9879\u5f0f\u8fde\u7eed\u70b9\u503c\u5e73\u79fb\\(O(n*log n)\\) <p>#108. \u591a\u9879\u5f0f\u4e58\u6cd5 - LibreOJ</p> <p>P4245 \u3010\u6a21\u677f\u3011\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 - \u6d1b\u8c37</p> <p>P4238 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u4e58\u6cd5\u9006 - \u6d1b\u8c37</p> <p>P4725 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5bf9\u6570\u51fd\u6570\uff08\u591a\u9879\u5f0f ln\uff09- \u6d1b\u8c37</p> <p>P4726 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6307\u6570\u51fd\u6570\uff08\u591a\u9879\u5f0f exp\uff09- \u6d1b\u8c37</p> <p>\\([x^n]\\exp(f(x))=\\dfrac{\\sum_{i=0}^{n-1}\\left(([x^i]exp(f(x)))*((n-i)*[x^{n-i}]f(x))\\right)}{n}\\)</p> <p>P5273 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5e42\u51fd\u6570\uff08\u52a0\u5f3a\u7248\uff09- \u6d1b\u8c37</p> <p>P5264 \u591a\u9879\u5f0f\u4e09\u89d2\u51fd\u6570 - \u6d1b\u8c37</p> <p>P5265 \u591a\u9879\u5f0f\u53cd\u4e09\u89d2\u51fd\u6570 - \u6d1b\u8c37</p> <p>P4717 \u3010\u6a21\u677f\u3011\u5feb\u901f\u83ab\u6bd4\u4e4c\u65af/\u6c83\u5c14\u4ec0\u53d8\u6362 (FMT/FWT) - \u6d1b\u8c37</p> <p>P5667 \u62c9\u683c\u6717\u65e5\u63d2\u503c2 - \u6d1b\u8c37</p>"},{"location":"template/math/poly/problem-set/","title":"\u4e60\u9898","text":"\u4e60\u9898\u4e00 CF102823 <p>Problem - B - Codeforces</p> \\[ A[i]=(\\sum_{j=i}^{min(i+L-1,n)}A[j])\\mod{P} \\] <p>\u6bcf\u6b21\u5bf9 \\(i\\) \u4ece \\(1\\) \u5230 \\(n\\) \u505a\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u95ee\u505a \\(m\\) \u6b21\u64cd\u4f5c\u540e \\(A[i]\\) \u7684\u503c?</p> <p>\u5c06 \\(A\\) \u7ffb\u8f6c, \u5bf9\u4e8e\u6bcf\u6b21\u64cd\u4f5c, \u5b9e\u9645\u4e0a\u5c31\u662f\u4e0e\u4e00\u4e2a\u524d \\(L\\) \u9879\u90fd\u4e3a \\(1\\) \u7684\u591a\u9879\u5f0f \\(f\\) \u8fdb\u884c\u5377\u79ef</p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u9879\u5f0f\u5feb\u901f\u5e42, \u6c42\u7684 \\(f^m\\), \u6700\u540e\u8ba1\u7b97 \\(a * f^m\\), \u7ffb\u8f6c\u8f93\u51fa\u5373\u53ef</p> Code C++<pre><code>{ \u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248 }\nvoid solve() {\n    int n, L, m;\n    cin &gt;&gt; n &gt;&gt; L &gt;&gt; m;\n    Poly a(n);\n    cin &gt;&gt; a;\n    reverse(begin(a), end(a));\n    Poly b(n);\n    for (int i = 0 ; i &lt; L ; i++) {\n        b[i] = 1;\n    }\n    b = Pow(b, m);\n    a *= b;\n    a.resize(n);\n    reverse(begin(a), end(a));\n    cout &lt;&lt; a &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    for (int i = 1 ; i &lt;= T ; i++) {\n        cout &lt;&lt; \"Case \" &lt;&lt; i &lt;&lt; \": \";\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/beat-matching/","title":"\u5bf9\u62cd","text":"\u4ee3\u7801 WindowsLinux C++<pre><code>while (true) {\n    system(\"dataGeneration.exe &gt; in.txt\");\n    system(\"A.exe &lt; in.txt &gt; A.txt\");\n    system(\"B.exe &lt; in.txt &gt; B.txt\");\n    if (system(\"fc A.txt B.txt\")) break;\n}\n</code></pre> Bash<pre><code>#!/bin/bash\ng++ a.cpp -o a -Wall\ng++ data.cpp -o data -Wall\ng++ b.cpp -o b -Wall\nwhile true;do\n    ./data&gt;data.in\n    ./a&lt;data.in&gt;a.out\n    ./b&lt;data.in&gt;b.out\n    if diff -b -B -q a.out b.out;then\n        echo \"AC\"\n    else\n        echo \"WA\"\n        break\n    fi\ndone\n</code></pre>"},{"location":"template/other/bracket-sequence/","title":"\u62ec\u53f7\u5e8f\u5217","text":"\u4e60\u9898 \u725b\u5ba221303 <p>\u5220\u62ec\u53f7</p> <p>\u7ed9\u51fa\u4e24\u4e2a\u62ec\u53f7\u5e8f\u5217 \\(s,t\\),</p> <p>\u95ee\u53ef\u4ee5\u5bf9 \\(s\\) \u5220\u53bb\u4efb\u610f\u6b21 \"()\",</p> <p>\u95ee\u662f\u5426\u53ef\u4ee5\u628a \\(s\\) \u53d8\u4e3a \\(t\\).</p> <p>\\(dp_{i,j}\\) \u8868\u793a \\(s\\) \u7684\u524d \\(i\\) \u4e2a\u62ec\u53f7\u53ef\u4ee5\u5220\u4e3a \\(t\\) \u7684\u524d \\(j\\) \u4e2a\u5b57\u7b26.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nbool dp[105][105];\nint main() {\n    string s, t;\n    cin &gt;&gt; s &gt;&gt; t;\n    s = \" \" + s;\n    t = \" \" + t;\n    dp[0][0] = true;\n    int n = s.size(), m = t.size();\n    int cnt = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (s[i] == '(') {\n            cnt++;\n        } else {\n            cnt--;\n        }\n        if (cnt == 0) {\n            dp[i][0] = true;\n        }\n        if (cnt &lt; 0) {\n            break;\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= m ; j++) {\n            if (s[i] == t[j]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            int cnt = 0, k = i;\n            while (k &gt;= 1) {\n                if (s[k] == '(') {\n                    cnt--;\n                } else {\n                    cnt++;\n                }\n                k--;\n                if (cnt &lt;= 0) {\n                    break;\n                }\n            }\n            if (cnt == 0) {\n                if (dp[k][j]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n    }\n    cout &lt;&lt; (dp[n][m] ? \"Possible\" : \"Impossible\"); \n    return 0;\n}\n</code></pre>"},{"location":"template/other/complex/","title":"\u590d\u6570","text":"\u6a21\u7248 C++<pre><code>template&lt;class T = double&gt;\nstruct __Complex {\n    T x, y;\n    __Complex() = default;\n    __Complex(const T x, const T y) : x(x), y(y) {}\n    __Complex&amp; operator+=(const __Complex &amp;b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n    __Complex&amp; operator-=(const __Complex &amp;b) {\n        x -= b.x;\n        y -= b.y;\n        return *this;\n    }\n    __Complex&amp; operator*=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = x * b.x - y * b.y;\n        temp.y = x * b.y + y * b.x;\n        *this = temp;\n        return *this;\n    }\n    __Complex&amp; operator*=(const T &amp;b) {\n        x *= b;\n        y *= b;\n        return *this;\n    }\n    __Complex&amp; operator/=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = (x * b.x + y * b.y) / (b.x * b.x + b.y * b.y);\n        temp.y = (y * b.x - x * b.y) / (b.x * b.x + b.y * b.y);\n        *this = temp;\n        return *this;\n    }\n    __Complex&amp; operator/=(const T b) {\n        x /= b;\n        y /= b;\n        return *this;\n    }\n    __Complex operator+(const __Complex &amp;b) {\n        __Complex a = *this;\n        a += b;\n        return a;\n    }\n    __Complex operator-(const __Complex &amp;b) {\n        __Complex a = *this;\n        a -= b;\n        return a;\n    }\n    __Complex operator*(const __Complex &amp;b) {\n        __Complex a = *this;\n        a *= b;\n        return a;\n    }\n    __Complex operator/(const __Complex &amp;b) {\n        __Complex a = *this;\n        a /= b;\n        return a;\n    }\n    friend istream&amp; operator&gt;&gt;(istream &amp;is, __Complex &amp;a) {\n        is &gt;&gt; a.x &gt;&gt; \" \" &gt;&gt; a.y;\n        return is;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const __Complex &amp;a) {\n        os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; a.x &lt;&lt; \" \" &lt;&lt; a.y;\n        return os;\n    }\n}; // __Complex\nusing Complex = __Complex&lt;&gt;;\n// \u590d\u6570\u7c7b\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u4e4b\u95f4\u7684\u52a0\u51cf\u4e58\u9664\u8fd0\u7b97\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u7684\u8f93\u5165\u8f93\u51fa\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u4e0e\u6574\u5f62/\u6d6e\u70b9\u578b\u53d8\u91cf\u4e4b\u95f4\u7684\u4e58\u9664\u8fd0\u7b97\n// \u7c7b\u578b\u540d\u79f0 Complex\n</code></pre>"},{"location":"template/other/factorial/","title":"\u9636\u4e58","text":"\\(n!\\) <p>P5282 \u3010\u6a21\u677f\u3011\u5feb\u901f\u9636\u4e58\u7b97\u6cd5 - \u6d1b\u8c37</p> <p>\u6c42 \\(n!\\mod p\\), \u4fdd\u8bc1 \\(p\\) \u4e3a\u8d28\u6570, \\(n,p\\leq2^{31}-1\\)</p> <p>\u591a\u9879\u5f0f\u4efb\u610f\u6a21\u6570\u4e58\u6cd5+\u591a\u9879\u5f0f\u8fde\u7eed\u70b9\u503c\u5e73\u79fb</p> \u4ee3\u7801 C++<pre><code>{ \u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248 }\nint st[64], tot;\ni64 getFact(int n, int p) {\n    int s = sqrt(n);\n    int invs = qpow(s, p - 2, p);\n    tot = 0;\n    for (int i = s ; i &gt; 1 ; i &gt;&gt;= 1) {\n        st[tot++] = i;\n    }\n    Poly c = {1, (s + 1) % p};\n    for (int j = tot - 1 ; j &gt;= 0 ; j--) {\n        int L = st[j];\n        auto d = ValueTrans(c, L &gt;&gt; 1, (L &gt;&gt; 1) + 1, p);\n        c.resize(2 * (int) c.size());\n        for (int i = 0 ; i &lt; (int) d.size() ; i++) {\n            c[d.size() + i] = d[i];\n        }\n        d = ValueTrans(c, (int) c.size() - 1, 1LL * invs * (L &gt;&gt; 1) % p, p);\n        for (int i = 0 ; i &lt; (int) c.size() ; i++) {\n            c[i] = 1LL * c[i] * d[i] % p;\n        }\n        if (L &amp; 1) {\n            for (int i = 0 ; i &lt;= L ; i++) {\n                c[i] = (1LL * i * s % p + L) % p * c[i] % p;\n            }\n        } else {\n            c.resize(L + 1);\n        }\n    }\n    i64 ans = 1;\n    for (int i = 0 ; i &lt; s ; i++) {\n        ans = ans * c[i] % p;\n    }\n    for (int i = s * s + 1 ; i &lt;= n ; i++) {\n        ans = ans * i % p;\n    }\n    return ans;\n}\n</code></pre> \\(\\sum_{i=1}^ni!\\) <p>\u6c42 \\(\\sum_{i=1}^n{i!}\\mod p\\), \u4fdd\u8bc1 \\(p\\) \u4e3a\u8d28\u6570, \\(n,p\\leq2^{31}-1\\)</p> <p>\u591a\u9879\u5f0f\u4efb\u610f\u6a21\u6570\u4e58\u6cd5+\u591a\u9879\u5f0f\u8fde\u7eed\u70b9\u503c\u5e73\u79fb</p> \u4ee3\u7801 C++<pre><code>{ \u591a\u9879\u5f0f\u57fa\u7840\u6a21\u7248 }\nusing namespace Polynomial;\nint st[64], tot;\ni64 getFactSum(int n, int p) {\n    int s = sqrt(n);\n    int invs = qpow(s, p - 2, p);\n    tot = 0;\n    for (int i = s ; i &gt; 1 ; i &gt;&gt;= 1) {\n        st[tot++] = i;\n    }\n    Poly tc[2], td[2];\n    tc[0] = {2 % p, (s + 2) % p};\n    tc[1] = {1, 1};\n    for (int j = tot - 1 ; j &gt;= 0 ; j--) {\n        int L = st[j];\n        for (int t = 0 ; t &lt; 2 ; t++) {\n            Poly &amp;c = tc[t], &amp;d = td[t];\n            d = ValueTrans(c, L &gt;&gt; 1, (L &gt;&gt; 1) + 1, p);\n            c.resize(2 * (int) c.size());\n            for (int i = 0 ; i &lt; (int) d.size() ; i++) {\n                c[d.size() + i] = d[i];\n            }\n            d = ValueTrans(c, (int) c.size() - 1, 1LL * invs * (L &gt;&gt; 1) % p, p);\n        }\n        for (int i = 0 ; i &lt; (int) tc[0].size() ; i++) {\n            tc[1][i] = (1LL * tc[0][i] * td[1][i] + tc[1][i]) % p;\n            tc[0][i] = 1LL * tc[0][i] * td[0][i] % p;\n        }\n        if (L &amp; 1) {\n            for (int i = 0 ; i &lt;= L ; i++) {\n                tc[1][i] = (tc[0][i] + tc[1][i]) % p;\n                tc[0][i] = (1LL * i * s + L + 1) % p * tc[0][i] % p;\n            }\n        } else {\n            tc[0].resize(L + 1);\n            tc[1].resize(L + 1);\n        }\n    }\n    i64 ans0 = 1, ans1 = 0;\n    for (int i = 0 ; i &lt; s ; i++) {\n        ans1 = (ans0 * tc[1][i] + ans1) % p;\n        ans0 = ans0 * tc[0][i] % p;\n    }\n    for (int i = s * s + 1 ; i &lt;= n ; i++) {\n        ans1 = (ans1 + ans0) % p;\n        ans0 = ans0 * (i + 1) % p;\n    }\n    return ans1;\n}\n</code></pre>"},{"location":"template/other/frac/","title":"\u5206\u6570","text":"\u6a21\u7248 C++<pre><code>struct Frac {\n    long long n, d;\n    Frac(long long n = 0, long long d = 1) : n(n), d(d) {\n        assert(d != 0);\n    }\n    void reduct() {\n        long long k = __gcd(llabs(n), d);\n        n /= k;\n        d /= k;\n    }\n    friend Frac operator+(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d + y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator-(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d - y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator*(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.n, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    Frac operator/(const Frac &amp;_) {\n        return *this * _.rev();\n    }\n    Frac&amp; operator+=(const Frac &amp;_) {\n        *this = *this + _;\n        return *this;\n    }\n    Frac&amp; operator-=(const Frac &amp;_) {\n        *this = *this - _;\n        return *this;\n    }\n    Frac&amp; operator*=(const Frac &amp;_) {\n        *this = *this * _;\n        return *this;\n    }\n    Frac&amp; operator/=(const Frac &amp;_) {\n        *this = *this / _;\n        return *this;\n    }\n    Frac rev() const {\n        Frac res(d, llabs(n));\n        if (n &lt; 0) {\n            res.n = -res.n;\n        }\n        return res;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Frac &amp;x) {\n        os &lt;&lt; x.n\n        if (x.d !== 1) os &lt;&lt; \"/\" &lt;&lt; x.n;\n\n        return os;\n    }\n}; // Frac\n</code></pre>"},{"location":"template/other/inversion-pair/","title":"\u9006\u5e8f\u5bf9","text":"\u4f8b\u9898 <p>P1908 \u9006\u5e8f\u5bf9 - \u6d1b\u8c37</p> \u5f52\u5e76\u6392\u5e8f \\(O(n*\\log n)\\)\u6811\u72b6\u6570\u7ec4 \\(O(n*\\log n)\\) \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ni64 ans = 0;\nint a[500005];\nvoid mergeSort(int L, int R) {\n    static int b[500005];\n    if (L == R) return;\n    int mid = L + R &gt;&gt; 1;\n    mergeSort(L, mid);\n    mergeSort(mid + 1, R);\n    int i = L, j = mid + 1, k = 0;\n    while (i &lt;= mid &amp;&amp; j &lt;= R) {\n        if (a[i] &lt;= a[j]) {\n            b[k++] = a[i++];\n        } else {\n            b[k++] = a[j++];\n            ans += mid - i + 1;\n        }\n    }\n    while (i &lt;= mid) {\n        b[k++] = a[i++];\n    }\n    while (j &lt;= R) {\n        b[k++] = a[j++];\n        ans += mid - i + 1;\n    }\n    for (int i = L ; i &lt;= R ; i++) {\n        a[i] = b[i - L];\n    }\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    mergeSort(1, n);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[500005];\nint tr[500005];\nint N;\nint lowbit(int x) {\n    return x &amp; -x;\n}\nvoid add(int x) {\n    while (x &lt;= N) {\n        tr[x]++;\n        x += lowbit(x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res += tr[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; idx(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    N = idx.size();\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        ans += query(N) - query(a[i]);\n        add(a[i]);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P3157QOJ1339 <p>P3157 [CQOI2011] \u52a8\u6001\u9006\u5e8f\u5bf9 - \u6d1b\u8c37</p> <p>\\(n\\) \u6392\u5217, \u6bcf\u6b21\u5220\u53bb\u4e00\u4e2a\u5143\u7d20, \u7136\u540e\u8f93\u51fa\u5220\u9664\u8fd9\u4e2a\u5143\u7d20\u4e4b\u524d\u7684\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570.</p> <p>\u6709\u4e24\u79cd\u505a\u6cd5, \u4f7f\u7528\u5206\u5757\u53ef\u4ee5\u5728\u7ebf, \u4f7f\u7528CDQ\u5206\u6cbb\u53ef\u4ee5\u79bb\u7ebf.</p> \u5206\u5757(\u5728\u7ebf)CDQ\u5206\u6cbb(\u79bb\u7ebf) \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint lowbit(int x) {\n    return x &amp; -x;\n}\nint n;\nint tr[320][100005];\nvoid add(int idx, int x, int k) {\n    while (x &lt;= n) {\n        tr[idx][x] += k;\n        x += lowbit(x);\n    }\n}\nint query(int idx, int x) {\n    int res = 0;\n    while (x) {\n        res += tr[idx][x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint a[100005], pos[100005];\nbool vis[100005];\nint belong[100005], st[320], ed[320], sz[320];\ni64 ans = 0;\nint B;\nvoid remove(int p) {\n    int now = pos[p];\n    int x = belong[now];\n    for (int i = st[x] ; i &lt; now ; i++) {\n        if (vis[i]) continue;\n        if (a[i] &gt; p) ans--;\n    }\n    for (int i = now + 1 ; i &lt;= ed[x] ; i++) {\n        if (vis[i]) continue;\n        if (a[i] &lt; p) ans--;\n    }\n    vis[now] = true;\n    for (int i = 1 ; i &lt; x ; i++) {\n        ans -= sz[i] - query(i, p);\n    }\n    for (int i = x + 1 ; i &lt;= B ; i++) {\n        ans -= query(i, p);\n    }\n    sz[x]--;\n    add(x, p, -1);\n}\nint main() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        pos[a[i]] = i;\n    }\n    { // \u521d\u59cb\u5316\n        B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n                add(i, a[j], 1);\n            }\n            sz[i] = ed[i] - st[i] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            ans += i - 1 - query(B + 1, a[i]);\n            add(B + 1, a[i], 1);\n        }\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        remove(x);\n    }\n    return 0;\n}\n</code></pre> <p>CDQ\u5206\u6cbb</p> <p>Couleur - QOJ</p> <p>\u7ed9\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3a \\(n\\) \u7684\u6570\u7ec4 \\(a\\), \u63a5\u4e0b\u6765 \\(n\\) \u884c, \u6bcf\u884c\u6709\u4e00\u4e2a\u6570 \\(x\\) \u4ee3\u8868\u6bcf\u6b21\u64cd\u4f5c\u5220\u53bb \\(a_x\\).</p> <p>\u6bcf\u6b21\u64cd\u4f5c\u524d, \u9700\u8981\u8f93\u51fa\u5f53\u524d\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u9006\u5e8f\u5bf9\u7684\u6700\u5927\u6570\u76ee, \u5f3a\u5236\u5728\u7ebf.</p> <p>\u5220\u9664 \\(a_x\\), \u672c\u8d28\u4e0a\u662f\u5c06\u4e00\u4e2a\u533a\u95f4\u5206\u6210\u4e24\u4e2a\u533a\u95f4, \u800c\u4e14\u6211\u4eec\u53ef\u4ee5\u542f\u53d1\u5f0f, \u66b4\u529b\u679a\u4e3e\u6c42\u5c0f\u533a\u95f4\u7684\u9006\u5e8f\u5bf9, \u5927\u533a\u95f4\u7684\u9006\u5e8f\u5bf9\u7531\u5408\u5e76\u540e\u533a\u95f4\u7684\u9006\u5e8f\u5bf9\u51cf\u53bb,\u5c0f\u533a\u95f4\u7684\u9006\u5e8f\u5bf9,\u518d\u51cf\u53bb\u5c0f\u533a\u95f4\u5bf9\u5927\u533a\u95f4\u7684\u5f71\u54cd,\u6700\u540e\u51cf\u53bb \\(a_x\\) \u7684\u5f71\u54cd\u5373\u53ef.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nstruct Node {\n    int Lrt, Rrt;\n    int sum;\n} tr[100005 &lt;&lt; 5];\nint tot;\nint a[100005];\nint update(int old, int L, int R, int pos) {\n    int now = ++tot;\n    tr[now] = tr[old];\n    tr[now].sum++;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        tr[now].Lrt = update(tr[now].Lrt, L, mid, pos);\n    } else {\n        tr[now].Rrt = update(tr[now].Rrt, mid + 1, R, pos);\n    }\n    return now;\n}\nint query(int QL, int QR, int L, int R, int VL, int VR) {\n    if (VL &gt; VR) {\n        return 0;\n    }\n    if (VL &lt;= L &amp;&amp; R &lt;= VR) {\n        return tr[QR].sum - tr[QL].sum;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int res = 0;\n    if (VL &lt;= mid) {\n        res += query(tr[QL].Lrt, tr[QR].Lrt, L, mid, VL, VR);\n    }\n    if (VR &gt;= mid + 1) {\n        res += query(tr[QL].Rrt, tr[QR].Rrt, mid + 1, R, VL, VR);\n    }\n    return res;\n}\nint rt[100005];\nstruct Result {\n    int L, R;\n    i64 res;\n    friend bool operator&lt;(const Result &amp;x, const Result &amp;y) {\n        return x.L &lt; y.L;\n    }\n};\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    tot = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        rt[i] = update(rt[i - 1], 1, n, a[i]);\n    }\n    multiset&lt;i64&gt; ans;\n    set&lt;Result&gt; st;\n    {\n        i64 res = 0;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            res += query(rt[0], rt[i], 1, n, a[i] + 1, n);\n        }\n        ans.insert(res);\n        st.insert({1, n, res});\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        i64 t = 0;\n        if (!ans.empty()) {\n            t = *rbegin(ans);\n        }\n        cout &lt;&lt; t &lt;&lt; \" \";\n        i64 tx;\n        cin &gt;&gt; tx;\n        tx ^= t;\n        int x = tx;\n        if (i == n) break;\n        auto it = st.upper_bound({x, x, -1});\n        if (it == begin(st)) {\n            continue;\n        }\n        it--;\n        auto [L, R, res] = *it;\n        st.erase(it);\n        ans.extract(res);\n        if (x - L &lt;= R - x) {\n            i64 resL = 0;\n            for (int j = L ; j &lt; x ; j++) { // \u66b4\u529b\u8ba1\u7b97\u5de6\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9, \u4e3b\u5e2d\u6811\u5feb\u901f\u8ba1\u7b97\u5de6\u534a\u5bf9\u53f3\u534a\u7684\u8d21\u732e\n                resL += query(rt[L - 1], rt[j], 1, n, a[j] + 1, n);\n                res -= query(rt[x], rt[R], 1, n, 1, a[j] - 1);\n            }\n            res -= resL; // \u51cf\u53bb\u5de6\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            res -= query(rt[L - 1], rt[x], 1, n, a[x] + 1, n); // \u51cf\u53bb x \u5bf9\u5de6\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            res -= query(rt[x], rt[R], 1, n, 1, a[x] - 1); // \u51cf\u53bb x \u5bf9\u53f3\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            // [L, x - 1]\n            if (L &lt;= x - 1) {\n                st.insert({L, x - 1, resL});\n                ans.insert(resL);\n            }\n            // [x + 1, R]\n            if (x + 1 &lt;= R) {\n                st.insert({x + 1, R, res});\n                ans.insert(res);\n            }\n        } else {\n            i64 resR = 0;\n            for (int j = x + 1 ; j &lt;= R ; j++) { // \u66b4\u529b\u8ba1\u7b97\u53f3\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9, \u4e3b\u5e2d\u6811\u5feb\u901f\u8ba1\u7b97\u53f3\u534a\u5bf9\u5de6\u534a\u7684\u8d21\u732e\n                resR += query(rt[j], rt[R], 1, n, 1, a[j] - 1);\n                res -= query(rt[L - 1], rt[x - 1], 1, n, a[j] + 1, n);\n            }\n            res -= resR; // \u51cf\u53bb\u53f3\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            res -= query(rt[L - 1], rt[x], 1, n, a[x] + 1, n); // \u51cf\u53bb x \u5bf9\u5de6\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            res -= query(rt[x], rt[R], 1, n, 1, a[x] - 1); // \u51cf\u53bb x \u5bf9\u53f3\u534a\u90e8\u5206\u7684\u9006\u5e8f\u5bf9\n            // [L, x - 1]\n            if (L &lt;= x - 1) {\n                st.insert({L, x - 1, res});\n                ans.insert(res);\n            }\n            // [x + 1, R]\n            if (x + 1 &lt;= R) {\n                st.insert({x + 1, R, resR});\n                ans.insert(resR);\n            }\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n}\nint main() {\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/inversion-pair/#_2","title":"\u533a\u95f4\u9006\u5e8f\u5bf9","text":"<p>\u533a\u95f4\u9006\u5e8f\u5bf9</p>"},{"location":"template/other/manhattan-distance/","title":"\u66fc\u54c8\u987f\u8ddd\u79bb\u6700\u503c","text":"<p>\u4e24\u4e2a \\(d\\) \u7ef4\u7684\u70b9 \\((x_1,x_2,...,x_d)\\) \u548c \\((y_1,y2,...,y_d)\\) \u7684\u54c8\u66fc\u987f\u8ddd\u79bb\u5b9a\u4e49\u4e3a \\(|x_1-y_1|+|x_2-y_2|+...+|x_d-y_d|\\)</p> <p>\\(|x_1-x_2|+|y_1-y_2|=\\max(|x_1^{'}-x_2^{'}|,|y_1^{'}-y_2^{'}|)\\)</p> <p>\\(x_1^{'}=x_1+y_1,y_1^{'}=y_1-x_1\\)</p> <p>\u6c42\u4e8c\u7ef4\u5e73\u9762\u4e0a\u4e24\u70b9\u95f4\u6700\u5927\u7684\u66fc\u54c8\u77ed\u8ddd\u79bb \\(\\max(max(x^{'})-\\min(x^{'}),max(y^{'})-\\min(y^{'}))\\)</p> \u4f8b\u9898 \u6d1b\u8c37P1648(d\u7ef4\u4e24\u70b9\u6700\u5927)CF1093G(d\u7ef4\u4e24\u70b9\u6700\u5927/\u5e26\u4fee/\u591a\u6b21\u533a\u95f4\u67e5\u8be2) <p>P1648 \u770b\u5b88 - \u6d1b\u8c37</p> <p>\u4e8c\u8fdb\u5236\u679a\u4e3e\u6bcf\u4e00\u7ef4\u6700\u7ec8\u7684\u6b63\u8d1f\u53f7, \u6c42\u7684\u6700\u7ec8\u6bcf\u4e00\u7ef4\u7684\u548c\u7684\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c</p> <p>\u7b54\u6848\u5373\u4e3a\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u4e4b\u5dee</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; a[1000005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, d;\n    cin &gt;&gt; n &gt;&gt; d;\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i].resize(d);\n        for (int j = 0 ; j &lt; d ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; 1 &lt;&lt; d ; i++) {\n        int mx = 0x7fffffff + 1, mi = 0x7fffffff;\n        for (int j = 0 ; j &lt; n ; j++) {\n            int sum = 0;\n            for (int k = 0 ; k &lt; d ; k++) {\n                if (i &amp; 1 &lt;&lt; k) {\n                    sum += a[j][k];\n                } else {\n                    sum -= a[j][k];\n                }\n            }\n            mx = max(mx, sum);\n            mi = min(mi, sum);\n        }\n        ans = max(ans, mx - mi);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>Problem - G - Codeforces</p> <p>\u4e8c\u8fdb\u5236\u679a\u4e3e\u7edd\u5bf9\u503c\u7b26\u53f7, \u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4max</p> <p>\u7b54\u6848\u4e3a max(f[i]+f[(~i) &amp; ((1 &lt;&lt; k) - 1)])</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nint k;\nstruct Info {\n    int L, R;\n    array&lt;int, 32&gt; f;\n    Info() {\n        f = array&lt;int, 32&gt;{};\n    }\n    void init(int tL, int tR, array&lt;int, 32&gt; v) { // build \u5185\u521d\u59cb\u5316\n        L = tL;\n        R = tR;\n        for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n            f[i] = 0;\n            for (int j = 0 ; j &lt; k ; j++) {\n                if (i &amp; 1 &lt;&lt; j) {\n                    f[i] += v[j];\n                } else {\n                    f[i] -= v[j];\n                }\n            }\n        }\n    }\n    friend Info operator+(const Info &amp;lhs, const Info &amp;rhs) { // pushup\n        Info res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n            res.f[i] = max(lhs.f[i], rhs.f[i]);\n        }\n        return res;\n    }\n};\narray&lt;int, 32&gt; a[200005];\nstruct SegmentTree {\n    int N = 0;\n    vector&lt;Info&gt; tr;\n    SegmentTree(int n) {\n        init(n);\n    }\n    void clear() {\n        N = 0;\n        tr.resize(0);\n    }\n    void init(int n) {\n        N = n;\n        n &lt;&lt;= 2;\n        tr.resize(n);\n    }\n    void build() {\n        build(1, N);\n    }\n    void build(int L, int R, int p = 1) {\n        if (L == R) {\n            tr[p].init(L, R, a[L]);\n            return;\n        }\n        int mid = L + R &gt;&gt; 1;\n        build(L, mid, p &lt;&lt; 1);\n        build(mid + 1, R, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    void modify(int QL, int QR, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            tr[p].init(QL, QR, a[QL]);\n            return;\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        if (QL &lt;= mid) modify(QL, QR, p &lt;&lt; 1);\n        if (QR &gt;= mid + 1) modify(QL, QR, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    Info query(int QL, int QR, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            return tr[p];\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        if (QR &lt;= mid) return query(QL, QR, p &lt;&lt; 1);\n        else if (QL &gt;= mid + 1) return query(QL, QR, p &lt;&lt; 1 | 1);\n        return query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1);\n    }\n}; // SegmentTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; k ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    SegmentTree st(n);\n    st.build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int pos;\n            cin &gt;&gt; pos;\n            for (int i = 0 ; i &lt; k ; i++) {\n                cin &gt;&gt; a[pos][i];\n            }\n            st.modify(pos, pos);\n        } else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            auto res = st.query(L, R);\n            int ans = 0;\n            for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n                ans = max(ans, res.f[i] + res.f[(~i) &amp; ((1 &lt;&lt; k) - 1)]);\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/interval/gcd/","title":"\u533a\u95f4gcd","text":""},{"location":"template/other/interval/gcd/#_1","title":"\u591a\u6b21\u67e5\u8be2\u533a\u95f4\u67e5\u8be2","text":"<p>\\(\\gcd(a_L,a_{L+1},...,a_R)\\)</p> <p>\u4f7f\u7528 ST\u8868 \u53ef\u4ee5 \\(O(n*\\log n)\\) \u9884\u5904\u7406\u51fa\u533a\u95f4\u7684gcd\uff0c\u7136\u540e \\(O(1)\\) \u67e5\u8be2\u3002</p>"},{"location":"template/other/interval/gcd/#_2","title":"\u6027\u8d28","text":"<p>\u4ee4 \\(f(L,R)=\\gcd(a_L,a_{L+1},...,a_R)\\)</p> <p>\u4ece \\(f(L,L),f(L,L+1),f(L,L+2),...,f(L,R)\\)\uff0c\u4e00\u5b9a\u662f\u5355\u8c03\u4e0d\u5347\u7684\u4e00\u4e2a\u5e8f\u5217\u3002</p> <p>\u4ece\u4e0a\u53ef\u5f97\uff0c\u6700\u591a\u6709 \\(logx\\) \u79cd \\(\\gcd\\) \u7684\u53d6\u503c\u3002</p> <p>\u6545\u53ef\u4ee5\u901a\u8fc7 \\(O(n*\\log n)\\) \u7684\u590d\u6742\u5ea6\u9884\u5904\u7406\u51fa\u6240\u6709\u7684\u533a\u95f4 \\(\\gcd\\)\u3002</p> \u4f8b\u9898 \u725b\u5ba269791F(\u56fa\u5b9a\u53f3\u7aef\u70b9)\u725b\u5ba276681K(\u56fa\u5b9a\u5de6\u7aef\u70b9) <p>F-\u5c0f\u8fb0\u521a\u5b66 gcd_\u725b\u5ba2\u5c0f\u767d\u6708\u8d5b81</p> <p>\u591a\u6b21\u67e5\u8be2\u96c6\u5408 \\(S=U_{i=L}^R \\{\\gcd_{j=i}^Ra_j\\}\\) \u7684\u5927\u5c0f</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nlong long a[600005];\nvector&lt;pair&lt;long long, int&gt;&gt; f[600005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        long long g = a[i];\n        f[i].emplace_back(g, i);\n        for (auto &amp;[preg, idx] : f[i - 1]) {\n            long long tg = __gcd(g, preg);\n            if (tg != g) {\n                f[i].emplace_back(tg, idx);\n                g = tg;\n            }\n            if (g == 1) break;\n        }\n    }\n    while (m--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        int ans = 0;\n        for (int i = 0 ; i &lt; int(f[R].size()) ; i++) {\n            // \u6b64\u65f6\u533a\u95f4 [L, R] \u7684 gcd \u5747\u4e3a f[R][i].first\n            // L \u5c5e\u4e8e\u533a\u95f4 [f[R][i + 1].second + 1, f[R][i].second]\n            // \u5f53 i = f[R].size() - 1 \u65f6, L = 1\n            if (L &lt;= f[R][i].second) {\n                ans++;\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>K-\u540c\u5b66\u805a\u4f1a_\u7b2c\u5341\u4e00\u5c4a\"\u56fe\u7075\u676f\"NEUQ-ACM\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b</p> <p>\u6c42 \\(\\dfrac{\\sum_{L=1}^{n}\\sum_{R=L}^n(R-L+1)*\\gcd_{i=L}^Ra_i}{\\dfrac{n*(n+1)}{2}}\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nint a[200005];\nvector&lt;pair&lt;int, int&gt;&gt; f[200005];\nconst long long mod = 998244353;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = n ; i &gt;= 1 ; i--) {\n        int g = a[i];\n        f[i].emplace_back(g, i);\n        for (auto &amp;[preg, idx] : f[i + 1]) {\n            int tg = __gcd(g, preg);\n            if (tg != g) {\n                f[i].emplace_back(tg, idx);\n                g = tg;\n            }\n            if (g == 1) break;\n        }\n    }\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; int(f[i].size()) ; j++) {\n            // \u6b64\u65f6\u533a\u95f4 [i, R] \u7684 gcd \u5747\u4e3a f[i][j].first\n            // R \u5c5e\u4e8e\u533a\u95f4 [f[i][j].second, f[i][j + 1].second - 1]\n            // \u5f53 j = f[i].size() - 1 \u65f6, R = n;\n            int L = f[i][j].second, R, g = f[i][j].first;\n            if (j &lt; int(f[i].size()) - 1) {\n                R = f[i][j + 1].second - 1;\n            } else {\n                R = n;\n            }\n            long long res = (1LL * (L + R) * (R - L + 1) / 2 - 1LL * (i - 1) * (R - L + 1) % mod + mod) % mod * g % mod;\n            ans = (ans + res) % mod;\n        }\n    }\n    cout &lt;&lt; ans * qpow(1LL * n * (n + 1) / 2 % mod, mod - 2) % mod &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/other/interval/inversion-pair/","title":"\u533a\u95f4\u9006\u5e8f\u5bf9","text":"\u4f8b\u9898 \u6d1b\u8c37P5047(\u79bb\u7ebf)\u6d1b\u8c37P5046(\u5728\u7ebf) <p>P5047 [Ynoi2019 \u6a21\u62df\u8d5b] Yuno loves sqrt technology II - \u6d1b\u8c37</p> <p>\u6839\u636e\u533a\u95f4\u9006\u5e8f\u5bf9\u7684\u6027\u8d28, \u5c06\u83ab\u961f\u518d\u6b21\u79bb\u7ebf\u5373\u4e8c\u6b21\u79bb\u7ebf\u83ab\u961f.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint a[100005];\nint tr[100005];\ni64 pre[100005], suf[100005];\nint lowbit(int x) {\n    return x &amp; -x;\n}\nint len;\nvoid add(int x) {\n    while (x &lt;= len) {\n        tr[x]++;\n        x += lowbit(x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res += tr[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint belong[100005], st[100005], ed[100005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        return x.R &lt; y.R;\n    }\n};\nint B;\ni64 cnt[100005], info[320];\nvoid addL(int k) {\n    int x = belong[k];\n    for (int i = st[x] ; i &lt; k ; i++) {\n        cnt[i]++;\n    }\n    for (int i = 1 ; i &lt;= x - 1 ; i++) {\n        info[i]++;\n    }\n}\nvoid addR(int k) {\n    int x = belong[k];\n    for (int i = k + 1 ; i &lt;= ed[x] ; i++) {\n        cnt[i]++;\n    }\n    for (int i = x + 1 ; i &lt;= B ; i++) {\n        info[i]++;\n    }\n}\nvector&lt;array&lt;int, 4&gt;&gt; quL[100005], quR[100005];\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx(1, -1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    len = idx.size() - 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        pre[i] = pre[i - 1] + query(len) - query(a[i]);\n        add(a[i]);\n    }\n    fill(tr, tr + len + 1, 0);\n    for (int i = n ; i &gt;= 1 ; i--) {\n        suf[i] = suf[i + 1] + query(a[i] - 1);\n        add(a[i]);\n    }\n    {\n        B = sqrt(len);\n        int cnt = len / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = len;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    vector&lt;MO&gt; mo;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;i64&gt; ans(m + 1);\n    int L = 1, R = 0;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        if (L &gt; QL) {\n            quR[QR + 1].push_back({QL, L - 1, idx, -1});\n            ans[idx] += suf[QL] - suf[L];\n        }\n        if (R &lt; QR) {\n            quL[L - 1].push_back({R + 1, QR, idx, -1});\n            ans[idx] += pre[QR] - pre[R];\n        }\n        if (L &lt; QL) {\n            quR[QR + 1].push_back({L, QL - 1, idx, 1});\n            ans[idx] -= suf[L] - suf[QL];\n        }\n        if (R &gt; QR) {\n            quL[L - 1].push_back({QR + 1, R, idx, 1});\n            ans[idx] -= pre[R] - pre[QR];\n        }\n        L = QL;\n        R = QR;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        addL(a[i]);\n        for (auto &amp;[L, R, idx, r] : quL[i]) {\n            i64 res = 0;\n            for (int j = L ; j &lt;= R ; j++) {\n                res += cnt[a[j]] + info[belong[a[j]]];\n            }\n            ans[idx] += r * res;\n        }\n    }\n    fill(cnt, cnt + len + 1, 0);\n    fill(info, info + B + 1, 0);\n    for (int i = n ; i &gt;= 1 ; i--) {\n        addR(a[i]);\n        for (auto &amp;[L, R, idx, r] : quR[i]) {\n            i64 res = 0;\n            for (int j = L ; j &lt;= R ; j++) {\n                res += cnt[a[j]] + info[belong[a[j]]];\n            }\n            ans[idx] += r * res;\n        }\n    }\n    for (int i = 1 ; i &lt; m ; i++) {\n        ans[mo[i].idx] += ans[mo[i - 1].idx];\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P5046 [Ynoi2019 \u6a21\u62df\u8d5b] Yuno loves sqrt technology I - \u6d1b\u8c37</p> <p>\u5206\u5757</p> <p>\u5982\u679c \\(L\\) \u548c \\(R\\) \u5728\u540c\u4e00\u4e2a\u5757\u5185, \u53ef\u4ee5\u5bf9\u6bcf\u4e00\u5757\u5355\u72ec\u6392\u5e8f, \u6309\u503c\u4ece\u5927\u5230\u5c0f\u904d\u5386, \u5c06\u4e0b\u6807\u5728\u533a\u95f4 \\(L,R\\) \u548c \\(&lt;L\\) \u62ff\u51fa\u6765\u5206\u522b\u8ba8\u8bba\u5373\u53ef\u8ba1\u7b97\u51fa\u533a\u95f4 \\([L,R]\\) \u7684\u9006\u5e8f\u5bf9\u6570\u91cf.</p> <p>\u5982\u679c \\(L\\) \u548c \\(R\\) \u4e0d\u5728\u540c\u4e00\u4e2a\u5757\u5185, \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u62c6\u6210\u6574\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u5de6\u6563\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u53f3\u6563\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u5de6\u6563\u5757\u4e0e\u53f3\u6563\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9.</p> <p>\u5bf9\u4e8e\u6574\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u6211\u4eec\u53ef\u4ee5\u5148\u9884\u5904\u7406\u51fa\u7b2c \\(1\\) \u5757\u5230\u7b2c \\(i\\) \u5757 \\(&lt;j\\) \u7684\u6570\u7684\u6570\u91cf, \u5373 \\(f_{i,j}\\). </p> <p>\u4ee4 \\(s_{i,j}\\) \u4e3a\u7b2c \\(i\\) \u5757\u5230\u7b2c \\(j\\) \u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9\u6570\u91cf, \u5219 \\(s_{i,j}=s_{i,j-1}+\\sum_{k=st_j}^{ed_j}((f_{j-1,n}-f_{i-1,n})-(f_{j-1,a_k}-f_{i-1,a_k}))\\)</p> <p>\u5bf9\u4e8e \\(f_{i,j}\\), \u6211\u4eec\u521a\u5f00\u59cb\u5148\u679a\u4e3e \\(a_k\\), \u4f7f \\(f_{belong_k,a_k}\\) \u81ea\u589e \\(1\\).</p> <p>\u7136\u540e\u6211\u4eec\u524d\u7f00 \\(i\\), \u5373\u5bf9\u4efb\u610f\u7684 \\(j\\) \u90fd \\(f_{i,j}+=f_{i-1,j}\\)</p> <p>\u7136\u540e\u6211\u4eec\u518d\u524d\u7f00 \\(j\\), \u5373\u5bf9\u4efb\u610f\u7684 \\(i\\) \u90fd \\(f_{i,j}+=f_{i,j-1}\\)</p> <p>\u5bf9\u4e8e\u5de6\u6563\u5757\u4e0e\u53f3\u6563\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u6211\u4eec\u53ef\u4ee5\u628a\u5de6\u4fa7\u548c\u53f3\u4fa7\u7684\u6570\u5206\u522b\u5347\u5e8f\u5b58\u5165\u4e24\u4e2a\u961f\u5217, \u7136\u540e\u4f7f\u7528\u5f52\u5e76\u7684\u601d\u60f3\u7ebf\u6027\u6c42\u9006\u5e8f\u5bf9.</p> <p>\u5bf9\u4e8e\u5de6\u6563\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u5de6\u6563\u5757\u7684 \\(a_k\\), \u901a\u8fc7 \\(\\sum(f_{belong_k,a_k-1}-f_{i,a_k-1})\\) \u6c42\u51fa.</p> <p>\u5bf9\u4e8e\u53f3\u6563\u5757\u4e0e\u6574\u5757\u4e4b\u95f4\u7684\u9006\u5e8f\u5bf9, \u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u53f3\u6563\u5757\u7684 \\(a_k\\), \u901a\u8fc7 \\(\\sum((f_{belong_k,n}-f_{i,n})-(f_{belong_k,a_k}-f_{i,a_k}))\\) \u6c42\u51fa.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[100005], st[320], ed[320];\nint B, len;\nint a[100005];\narray&lt;int, 2&gt; b[100005];\nint tr[100005];\nint lowbit(int x) {\n    return x &amp; -x;\n}\nvoid add(int x, int k) {\n    while (x &lt;= len) {\n        tr[x] += k;\n        x += lowbit(x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res += tr[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nint pre[100005], suf[100005];\nint f[320][100005]; // f[i][j] \u8868\u793a\u7b2c i \u5757\u4e2d\u5c0f\u4e8e j \u7684\u6570\u91cf\ni64 s[320][320]; // s[i][j] \u8868\u793a\u7b2c i \u5757\u5230\u7b2c j \u5757\u7684\u9006\u5e8f\u5bf9\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx(1, -1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    len = idx.size();\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n        b[i] = {a[i], i};\n    }\n    {\n        B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            sort(b + st[i], b + ed[i] + 1);\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n            int x = 0;\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                x += query(len) - query(a[j]);\n                pre[j] = x;\n                add(a[j], 1);\n            }\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                suf[j] = x;\n                add(a[j], -1);\n                x -= query(a[j] - 1);\n\n            }\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                f[i][a[j]]++;\n            }\n        }\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = 1 ; j &lt;= len ; j++) {\n                f[i][j] += f[i - 1][j];\n            }\n        }\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = 1 ; j &lt;= len ; j++) {\n                f[i][j] += f[i][j - 1];\n            }\n        }\n        for (int i = 1 ; i &lt;= B ; i++) {\n            s[i][i] = pre[ed[i]];\n            for (int j = i + 1 ; j &lt;= B ; j++) {\n                i64 res = s[i][j - 1] + pre[ed[j]];\n                for (int k = st[j] ; k &lt;= ed[j] ; k++) {\n                    res += (f[j - 1][len] - f[i - 1][len]) - (f[j - 1][a[k]] - f[i - 1][a[k]]);\n                }\n                s[i][j] = res;\n            }\n        }\n    }\n    i64 ans = 0;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        i64 tL, tR;\n        cin &gt;&gt; tL &gt;&gt; tR;\n        tL ^= ans;\n        tR ^= ans;\n        int L = tL, R = tR;\n        int x = belong[L], y = belong[R];\n        if (x == y) {\n            ans = pre[R] - (L == st[x] ? 0 : pre[L - 1]);\n            int c = 0;\n            for (int i = ed[x] ; i &gt;= st[x] ; i--) {\n                auto [v, idx] = b[i];\n                if (L &lt;= idx &amp;&amp; idx &lt;= R) {\n                    ans -= c;\n                } else if (idx &lt; L) {\n                    c++;\n                }\n            }\n        } else {\n            ans = s[x + 1][y - 1] + suf[L] + pre[R];\n            for (int i = L ; i &lt;= ed[x] ; i++) { // \u5de6\u6563\u5757\u5bf9\u4e2d\u95f4\u6574\u5757\u7684\u9006\u5e8f\u5bf9\n                ans += f[y - 1][a[i] - 1] - f[x][a[i] - 1];\n            }\n            for (int i = st[y] ; i &lt;= R ; i++) { // \u53f3\u6563\u5757\u5bf9\u4e2d\u95f4\u6574\u5757\u7684\u9006\u5e8f\u5bf9\n                ans += (f[y - 1][len] - f[y - 1][a[i]]) - (f[x][len] - f[x][a[i]]);\n            }\n            queue&lt;int&gt; ax, ay;\n            for (int i = st[x] ; i &lt;= ed[x] ; i++) {\n                auto [v, idx] = b[i];\n                if (idx &gt;= L) {\n                    ax.push(v);\n                }\n            }\n            for (int i = st[y] ; i &lt;= ed[y] ; i++) {\n                auto [v, idx] = b[i];\n                if (idx &lt;= R) {\n                    ay.push(v);\n                }\n            }\n            while (!ax.empty() &amp;&amp; !ay.empty()) {\n                if (ax.front() &lt;= ay.front()) {\n                    ax.pop();\n                } else {\n                    ans += ax.size();\n                    ay.pop();\n                }\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/interval/mode/","title":"\u533a\u95f4\u4f17\u6570","text":"\u4f8b\u9898 \u6d1b\u8c37P1997\u6d1b\u8c37P4168 <p>P1997 faebdc \u7684\u70e6\u607c - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2\u533a\u95f4\u4f17\u6570\u7684\u51fa\u73b0\u6b21\u6570</p> <p>\u4f7f\u7528\u56de\u6eda\u83ab\u961f/\u4e0d\u5220\u9664\u83ab\u961f\u5373\u53ef\u7ef4\u62a4</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[100005], st[100005], ed[100005];\nstruct MO {\n    int L, R, idx;\n    friend bool operator&lt;(const MO &amp;x, const MO &amp;y) {\n        if (belong[x.L] != belong[y.L]) {\n            return x.L &lt; y.L;\n        }\n        return x.R &lt; y.R;\n    }\n};\nint a[100005];\nint tcnt[100005], cnt[100005];\nint sum = 0;\nvoid add(int idx) {\n    cnt[a[idx]]++;\n    sum = max(sum, cnt[a[idx]]);\n}\nvoid del(int idx) {\n    cnt[a[idx]]--;\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    {\n        int B = sqrt(n);\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    vector&lt;int&gt; idx(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    vector&lt;MO&gt; mo;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mo.push_back({L, R, i});\n    }\n    sort(begin(mo), end(mo));\n    vector&lt;int&gt; ans(mo.size());\n    int lst = belong[mo[0].L], R = ed[lst], L = R + 1;\n    for (auto &amp;[QL, QR, idx] : mo) {\n        if (belong[QL] == belong[QR]) { // \u5728\u4e00\u4e2a\u5757\u5185, \u66b4\u529b\u67e5\u8be2\n            int temp = 0;\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]++;\n                temp = max(temp, tcnt[a[j]]);\n            }\n            for (int j = QL ; j &lt;= QR ; j++) {\n                tcnt[a[j]]--;\n            }\n            ans[idx] = temp;\n            continue;\n        }\n        if (lst != belong[QL]) {\n            // \u5982\u679c\u5f53\u524d\u4e0d\u5728\u67e5\u8be2\u5757\u5185, \u5219\u5c06 L \u548c R \u79fb\u81f3\u5757\u5185\n            while (R &gt; ed[belong[QL]]) {\n                del(R--);\n            }\n            while (L &lt; ed[belong[QL]] + 1) {\n                del(L++);\n            }\n            sum = 0;\n            lst = belong[QL];\n        }\n        while (R &lt; QR) { // \u5411\u53f3\u6269, \u76f4\u81f3 R = QR\n            add(++R);\n        }\n        int temp = sum, L1 = L;\n        while (L1 &gt; QL) { // \u65b0\u5f00\u5411\u5de6\u6269, \u76f4\u81f3 L1 = QL\n            add(--L1);\n        }\n        ans[idx] = sum;\n        while (L1 &lt; L) { // \u56de\u6eda\u5de6\u7aef\u70b9\n            del(L1++);\n        }\n        sum = temp;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P4168 [Violet] \u84b2\u516c\u82f1 - \u6d1b\u8c37</p> <p>\u591a\u6b21\u67e5\u8be2\u533a\u95f4\u4f17\u6570(\u591a\u4e2a\u5219\u9009\u5c0f\u503c), \u5f3a\u5236\u5728\u7ebf</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint belong[40005], st[40005], ed[40005];\nint a[40005];\nint cnt[40][40][40005], mode[40][40], tcnt[40005];\nvector&lt;int&gt; ind(1);\nvoid add(int L, int R, int idx) {\n    cnt[L][R][a[idx]]++;\n    if (cnt[L][R][a[idx]] &gt; cnt[L][R][0] || (cnt[L][R][a[idx]] == cnt[L][R][0] &amp;&amp; ind[a[idx]] &lt; mode[L][R])) {\n        mode[L][R] = ind[a[idx]];\n        cnt[L][R][0] = cnt[L][R][a[idx]];\n    }\n}\nvoid del(int L, int R, int idx) {\n    cnt[L][R][a[idx]]--;\n}\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int B = pow(n, 0.3333333333);\n    {\n        int cnt = n / B;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            st[i] = cnt * (i - 1) + 1;\n            ed[i] = cnt * i;\n        }\n        ed[B] = n;\n        for (int i = 1 ; i &lt;= B ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        ind.push_back(a[i]);\n    }\n    sort(begin(ind), end(ind));\n    ind.resize(unique(begin(ind), end(ind)) - begin(ind));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(ind), end(ind), a[i]) - begin(ind);\n    }\n    for (int i = 1 ; i &lt;= B ; i++) {\n        for (int j = i ; j &lt;= B ; j++) {\n            for (int k = st[i] ; k &lt;= ed[j] ; k++) {\n                add(i, j, k);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        L = (L + ans - 1) % n + 1;\n        R = (R + ans - 1) % n + 1;\n        if (L &gt; R) {\n            swap(L, R);\n        }\n        int x = belong[L], y = belong[R];\n        if (abs(x - y) &lt;= 2) { // \u5982\u679c\u67e5\u8be2\u5728\u4e00\u4e2a\u5757\u5185, \u66b4\u529b\u67e5\u8be2\n            ans = 0;\n            for (int j = L ; j &lt;= R ; j++) {\n                tcnt[a[j]]++;\n                if (tcnt[a[j]] &gt; tcnt[0] || (tcnt[a[j]] == tcnt[0] &amp;&amp; ind[a[j]] &lt; ans)) {\n                    ans = ind[a[j]];\n                    tcnt[0] = tcnt[a[j]];\n                }\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n            for (int j = L ; j &lt;= R ; j++) {\n                tcnt[a[j]]--;\n            }\n            tcnt[0] = 0;\n            continue;\n        }\n        int tx = x + 1, ty = y - 1;\n        int tmode = mode[tx][ty];\n        int tcnt = cnt[tx][ty][0];\n        for (int j = L ; j &lt;= ed[x] ; j++) { // \u628a\u5de6\u8fb9\u591a\u4f59\u90e8\u5206\u52a0\u8fdb\u6765\n            add(tx, ty, j);\n        }\n        for (int j = st[y] ; j &lt;= R ; j++) { // \u628a\u53f3\u8fb9\u591a\u4f59\u90e8\u5206\u52a0\u8fdb\u6765\n            add(tx, ty, j);\n        }\n        ans = mode[tx][ty];\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        for (int j = L ; j &lt;= ed[x] ; j++) { // \u5220\u53bb\u5de6\u8fb9\u591a\u4f59\u90e8\u5206\n            del(tx, ty, j);\n        }\n        for (int j = st[y] ; j &lt;= R ; j++) { // \u5220\u53bb\u53f3\u8fb9\u591a\u4f59\u90e8\u5206\n            del(tx, ty, j);\n        }\n        mode[tx][ty] = tmode; // \u590d\u539f\u4f17\u6570\n        cnt[tx][ty][0] = tcnt; // \u590d\u539f\u6570\u91cf\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/interval/perm/","title":"\u533a\u95f4\u6392\u5217","text":""},{"location":"template/other/interval/perm/#_2","title":"\u5b9a\u4e49","text":"<p>\u533a\u95f4 \\([L,R]\\) \\(\\max-min+1=R-L+1\\)</p> <p>\u6790\u5408\u6811</p>"},{"location":"template/other/interval/subarray-sum/","title":"\u533a\u95f4\u5b50\u6bb5\u548c","text":"<p>\u8fd9\u91cc\u53ea\u8003\u8651\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c</p> \u4f8b\u9898 \u6d1b\u8c37SP1043(\u4e0d\u5e26\u4fee)\u6d1b\u8c37SP1716(\u5e26\u4fee) <p>GSS1 - Can you answer these queries I - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u6570, \\(m\\) \u6b21\u64cd\u4f5c</p> <p>\u6bcf\u6b21\u64cd\u4f5c, \u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u8003\u8651\u5230\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u5b50\u6bb5\u548c.</p> <p>\u5bf9\u4e8e\u4e24\u4e2a\u533a\u95f4\u5408\u5e76, \u4e00\u5171\u6709\u4e09\u79cd\u60c5\u51b5.</p> <p>\u2460 \u6700\u5927\u5b50\u6bb5\u548c\u5b8c\u5168\u5728\u5de6\u4fa7\u533a\u95f4, \u8fd9\u4e2a\u65f6\u5019\u5c31\u662f\u5de6\u4fa7\u533a\u95f4\u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u2461 \u6700\u5927\u5b50\u6bb5\u548c\u5b8c\u5168\u5728\u53f3\u4fa7\u533a\u95f4, \u8fd9\u4e2a\u65f6\u5019\u5c31\u662f\u53f3\u4fa7\u533a\u95f4\u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u2462 \u6700\u5927\u5b50\u6bb5\u548c\u8de8\u8d8a\u4e24\u4e2a\u533a\u95f4, \u8fd9\u4e2a\u65f6\u5019\u9700\u8981\u5de6\u4fa7\u533a\u95f4\u53f3\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c \u548c \u53f3\u4fa7\u533a\u95f4\u5de6\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u8003\u8651\u7ef4\u62a4\u8fd9\u4e24\u4e2a\u53d8\u91cf, \u5f53\u533a\u95f4\u5408\u5e76\u65f6.</p> <p>\u5de6\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c\u53ef\u4ee5\u662f\u5de6\u4fa7\u533a\u95f4\u5de6\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c, \u4e5f\u53ef\u4ee5\u662f\u5de6\u4fa7\u533a\u95f4\u52a0\u4e0a\u53f3\u4fa7\u533a\u95f4\u5de6\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u53f3\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c\u53ef\u4ee5\u662f\u53f3\u4fa7\u533a\u95f4\u53f3\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u4e5f\u53ef\u4ee5\u662f\u53f3\u4fa7\u533a\u95f4\u52a0\u4e0a\u5de6\u4fa7\u533a\u95f4\u53f3\u4fa7\u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u9700\u8981\u591a\u7ef4\u62a4\u4e00\u4e2a\u53d8\u91cf, \u5373\u533a\u95f4\u548c.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 50005;\nstruct Node {\n    i64 Lmx, Rmx, mx, sum;\n} tr[N &lt;&lt; 2];\nNode merge(Node x, Node y) {\n    return {max&lt;i64&gt;(x.Lmx, x.sum + y.Lmx), \n            max&lt;i64&gt;(y.Rmx, y.sum + x.Rmx), \n            max&lt;i64&gt;({x.mx, y.mx, x.Rmx + y.Lmx}),\n            x.sum + y.sum};\n}\nvoid pushup(int p) {\n    tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nint a[N];\nvoid build(int p, int L, int R) {\n    if (L == R) {\n        tr[p] = {a[L], a[L], a[L], a[L]};\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    pushup(p);\n}\nNode rangeQuery(int p, int L, int R, int QL, int QR) {\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tr[p];\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (QR &lt;= mid) return rangeQuery(p &lt;&lt; 1, L, mid, QL, QR);\n    if (QL &gt;= mid + 1) return rangeQuery(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR);\n    return merge(rangeQuery(p &lt;&lt; 1, L, mid, QL, QR), rangeQuery(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR));\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    build(1, 1, n);\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        cout &lt;&lt; rangeQuery(1, 1, n, L, R).mx &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>GSS3 - Can you answer these queries III - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u6570, \\(m\\) \u6b21\u64cd\u4f5c</p> <p>\u6bcf\u6b21\u64cd\u4f5c,</p> <p>\u64cd\u4f5c\u4e8c, \u4fee\u6539 \\(a_x\\) \u4e3a \\(y\\).</p> <p>\u64cd\u4f5c\u4e00, \u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u7684\u6700\u5927\u5b50\u6bb5\u548c.</p> <p>\u5728\u4e0d\u5e26\u4fee\u7684\u7248\u672c\u52a0\u4e00\u4e2a\u5355\u70b9\u4fee\u6539\u5373\u53ef.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 50005;\nstruct Node {\n    i64 Lmx, Rmx, mx, sum;\n} tr[N &lt;&lt; 2];\nNode merge(Node x, Node y) {\n    return {max&lt;i64&gt;(x.Lmx, x.sum + y.Lmx), \n            max&lt;i64&gt;(y.Rmx, y.sum + x.Rmx), \n            max&lt;i64&gt;({x.mx, y.mx, x.Rmx + y.Lmx}),\n            x.sum + y.sum};\n}\nvoid pushup(int p) {\n    tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nint a[N];\nvoid build(int p, int L, int R) {\n    if (L == R) {\n        tr[p] = {a[L], a[L], a[L], a[L]};\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    pushup(p);\n}\nvoid modify(int p, int L, int R, int pos, int k) {\n    if (L == R) {\n        a[pos] = k;\n        tr[p] = {k, k, k, k};\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) modify(p &lt;&lt; 1, L, mid, pos, k);\n    else modify(p &lt;&lt; 1 | 1, mid + 1, R, pos, k);\n    pushup(p);\n}\nNode rangeQuery(int p, int L, int R, int QL, int QR) {\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tr[p];\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (QR &lt;= mid) return rangeQuery(p &lt;&lt; 1, L, mid, QL, QR);\n    if (QL &gt;= mid + 1) return rangeQuery(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR);\n    return merge(rangeQuery(p &lt;&lt; 1, L, mid, QL, QR), rangeQuery(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR));\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    build(1, 1, n);\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int op, L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 1) {\n            cout &lt;&lt; rangeQuery(1, 1, n, L, R).mx &lt;&lt; \"\\n\";\n        } else {\n            modify(1, 1, n, L, R);\n        }\n    }\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37SP1557\u6d1b\u8c37SP2916\u6d1b\u8c37SP4487\u6d1b\u8c37SP6779CF280D <p>GSS2 - Can you answer these queries II - \u6d1b\u8c37</p> <p>\\(n\\) \u4e2a\u6570, \\(m\\) \u6b21\u64cd\u4f5c</p> <p>\u6bcf\u6b21\u64cd\u4f5c, \u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u7684\u6700\u5927\u5b50\u6bb5\u548c(\u76f8\u540c\u7684\u6743\u503c\u53ea\u80fd\u7b97\u4e00\u6b21, \u4e14\u53ef\u9009\u62e9\u7a7a\u6bb5).</p> <p>\u79bb\u7ebf\u67e5\u8be2, \u6309 \\(R\\) \u6392\u5e8f, \u6211\u4eec\u6bcf\u6b21\u63d2\u5165 \\(a_i\\), \u7136\u540e\u67e5\u8be2\u4ee5 \\(i\\) \u4e3a\u53f3\u7aef\u70b9\u7684\u7b54\u6848.</p> <p>\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5de6\u7aef\u70b9\u56fa\u5b9a\u7684\u524d\u7f00\u6700\u5927\u5b50\u6bb5\u548c\u548c\u5386\u53f2\u6700\u5927\u5b50\u6bb5\u548c.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nconst int N = 100005;\nstruct Node {\n    i64 mx, hmx;\n} tr[N &lt;&lt; 2];\ni64 tagmx[N &lt;&lt; 2], taghmx[N &lt;&lt; 2];\nint a[N];\nNode merge(Node x, Node y) {\n    return {\n        max(x.mx, y.mx),\n        max(x.hmx, y.hmx)\n    };\n}\nvoid pushup(int p) {\n    tr[p] = merge(tr[p &lt;&lt; 1], tr[p &lt;&lt; 1 | 1]);\n}\nvoid pushtag(int p, i64 lazymx, i64 lazyhmx) {\n    tr[p].hmx = max(tr[p].hmx, tr[p].mx + lazyhmx);\n    taghmx[p] = max(taghmx[p], tagmx[p] + lazyhmx);\n    tr[p].mx += lazymx;\n    tagmx[p] += lazymx;\n\n}\nvoid pushdown(int p) {\n    pushtag(p &lt;&lt; 1, tagmx[p], taghmx[p]);\n    pushtag(p &lt;&lt; 1 | 1, tagmx[p], taghmx[p]);\n    tagmx[p] = taghmx[p] = 0;\n}\nvoid modify(int p, int L, int R, int QL, int QR, i64 k) {\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        pushtag(p, k, k);\n        return;\n    }\n    pushdown(p);\n    int mid = L + R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n    if (QR &gt; mid) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n    pushup(p);\n}\nNode query(int p, int L, int R, int QL, int QR) {\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tr[p];\n    }\n    pushdown(p);\n    int mid = L + R &gt;&gt; 1;\n    if (QR &lt;= mid) return query(p &lt;&lt; 1, L, mid, QL, QR);\n    if (QL &gt; mid) return query(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR);\n    return merge(query(p &lt;&lt; 1, L, mid, QL, QR), query(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR));\n}\nvector&lt;array&lt;int, 2&gt;&gt; vec[N];\nint ans[N];\nint last[N];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; idx(1, -1000000000);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.push_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    int m;\n    cin &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        vec[R].push_back({L, i});\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        modify(1, 1, n, last[a[i]] + 1, i, idx[a[i]]);\n        for (auto &amp;[L, idx] : vec[i]) {\n            ans[idx] = query(1, 1, n, L, i).hmx;\n        }\n        last[a[i]] = i;\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>GSS5 - Can you answer these queries V - \u6d1b\u8c37</p> <p>GSS6 - Can you answer these queries VI - \u6d1b\u8c37</p> <p>GSS7 - Can you answer these queries VII - \u6d1b\u8c37</p> <p>Problem - D - Codeforces</p>"},{"location":"template/other/randomization/hill-climbing/","title":"\u722c\u5c71\u7b97\u6cd5","text":"\u4f8b\u9898 <p>P4035 [JSOI2008] \u7403\u5f62\u7a7a\u95f4\u4ea7\u751f\u5668 - \u6d1b\u8c37</p> <p>\u7ed9\u51fa \\(n+1\\) \u4e2a \\(n\\) \u7ef4\u7684\u70b9, \u6c42\u4ed6\u4eec\u6240\u5728\u7403\u7684\u7403\u5fc3</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\ndouble a[15][15], ans[15], dist[15], cans[15];\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n + 1 ; i++) {\n        for (int j = 1 ; j &lt;= n ; j++) {\n            cin &gt;&gt; a[i][j];\n            ans[j] += a[i][j];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        ans[i] /= n + 1;\n    }\n    auto get = [&amp;]() {\n        double res = 0;\n        for (int i = 1 ; i &lt;= n + 1 ; i++) {\n            dist[i] = cans[i] = 0;\n            for (int j = 1 ; j &lt;= n ; j++) {\n                dist[i] += (a[i][j] - ans[j]) * (a[i][j] - ans[j]);\n            }\n            dist[i] = sqrt(dist[i]);\n            res += dist[i];\n        }\n        res /= n + 1;\n        for (int i = 1 ; i &lt;= n + 1 ; i++) {\n            for (int j = 1 ; j &lt;= n ; j++) {\n                cans[j] += (dist[i] - res) * (a[i][j] - ans[j]) / res;\n            }\n        }\n    };\n    auto sa = [&amp;]() {\n        for (double t = 50000 ; t &gt;= 1e-4 ; t *= 0.99995) {\n            get();\n            for (int i = 1 ; i &lt;= n ; i++) {\n                ans[i] += cans[i] * t;\n            }\n        }\n    };\n    sa();\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/other/randomization/radom/","title":"\u968f\u673a\u6570","text":"\u6a21\u7248 usage\u4ee3\u7801 <p>\u5747\u7b49\u5206\u5e03</p> <p>\u4ec5\u652f\u6301\u6574\u6570\u7c7b\u578b int / long long / unsigned long long</p> <p>\u548c\u6d6e\u70b9\u6570\u7c7b\u578b double / long double</p> C++<pre><code>template&lt;class T&gt;\nstruct Random {\n    mt19937 mt;\n    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    T operator()(const T&amp; L, const T&amp; R);\n};\ntemplate&lt;&gt;\nint Random&lt;int&gt;::operator()(const int &amp;L, const int &amp;R) {\n    uniform_int_distribution&lt;int&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong long Random&lt;long long&gt;::operator()(const long long &amp;L, const long long &amp;R) {\n    uniform_int_distribution&lt;long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nunsigned long long Random&lt;unsigned long long&gt;::operator()(const unsigned long long &amp;L, const unsigned long long &amp;R) {\n    uniform_int_distribution&lt;unsigned long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\ndouble Random&lt;double&gt;::operator()(const double &amp;L, const double &amp;R) {\n    uniform_real_distribution&lt;double&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong double Random&lt;long double&gt;::operator()(const long double &amp;L, const long double &amp;R) {\n    uniform_real_distribution&lt;long double&gt; dist(L, R);\n    return dist(mt);\n}\nRandom&lt;int&gt; rng;\n</code></pre>"},{"location":"template/other/randomization/simulated-annealing/","title":"\u6a21\u62df\u9000\u706b","text":"\u4f8b\u9898 LOJ#2076\u6d1b\u8c37P2503 <p>#2076. \u300cJSOI2016\u300d\u70b8\u5f39\u653b\u51fb - LibreOJ</p> <p>\u8d77\u70b9\u4e3a\u968f\u673a\u654c\u4eba, \u5f00\u59cb\u6a21\u62df\u9000\u706b.</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint ans = 0;\ni64 x[11], y[11], r[11], p[1005], q[1005];\nint main() {\n    srand(time(0));\n    int n, m, R;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; R;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i];\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; p[i] &gt;&gt; q[i];\n    }\n    auto dist = [&amp;](double x1, double y1, double x2, double y2) {\n        return (double) sqrtl((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    };\n    auto get = [&amp;](double sx, double sy) {\n        double miR = R;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            miR = min(miR, dist(sx, sy, x[i], y[i]) - r[i]);\n        }\n        int cnt = 0;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            if (dist(sx, sy, p[i], q[i]) &lt;= miR) {\n                cnt++;\n            }\n        }\n        ans = max(ans, cnt);\n        return cnt;\n    };\n    auto rnd = [&amp;](int L, int R) {\n        return rand() % (R - L + 1) + L;\n    };\n    auto sa = [&amp;]() {\n        int pos = rnd(1, m);\n        double nx = p[pos], ny = q[pos];\n        int now = get(nx, ny);\n        for (double t = 3000 ; t &gt;= 1e-8 ; t *= 0.99) {\n            double mx = nx + t * rnd(-1000, 1000), my = ny + t * rnd(-1000, 1000);\n            int tnow = get(mx, my);\n            if (tnow &gt; now || exp(10000 * (tnow - now) / t) &gt; 1.0 * rand() / RAND_MAX) {\n                nx = mx;\n                ny = my;\n                now = tnow;\n            }\n        }\n    };\n    while(1.0 * clock() / CLOCKS_PER_SEC &lt; 0.9) {\n        sa();\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P2503 [HAOI2006] \u5747\u5206\u6570\u636e - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing i64 = long long;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint n, m;\nint a[25], sum[25];\ndouble dp[25][8], avg;\ndouble ans = 1e9;\ndouble get() {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        sum[i] = sum[i - 1] + a[i];\n    }\n    for (int i = 0 ; i &lt;= n ; i++ ){\n        for (int j = 0 ; j &lt;= m ; j++) {\n            dp[i][j] = 1000000;\n        }\n    }\n    dp[0][0] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= min(i, m) ; j++) {\n            for (int k = 1 ; k &lt;= i ; k++) {\n                double res = sum[i] - sum[k - 1] - avg;\n                res *= res;\n                dp[i][j] = min(dp[i][j], dp[k - 1][j - 1] + res);\n            }\n        }\n    }\n    ans = min(ans, dp[n][m]);\n    return dp[n][m];\n}\nint main() {\n    srand(time(0));\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        avg += a[i];\n    }\n    avg /= m;\n    auto rnd = [&amp;](int L, int R) {\n        return rand() % (R - L + 1) + L;\n    };\n    auto sa = [&amp;]() {\n        double now = ans;\n        for (double t = 5000 ; t &gt;= 1e-8 ; t *= 0.99) {\n            int x, y;\n            do {\n                x = rnd(1, n);\n                y = rnd(1, n);\n            } while (x == y);\n            swap(a[x], a[y]);\n            double tnow = get();\n            if (tnow &lt; now || exp((now - tnow) / t) &gt; 1.0 * rand() / RAND_MAX) {\n                now = tnow;\n            } else {\n                swap(a[x], a[y]);\n            }\n        }\n    };\n    while(1.0 * clock() / CLOCKS_PER_SEC &lt; 0.9) {\n        sa();\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sqrt(ans / m) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"template/string/ac-automaton/","title":"AC\u81ea\u52a8\u673a","text":"\u4f8b\u9898 \u7edf\u8ba1\u6a21\u5f0f\u4e32\u51fa\u73b0\u7684\u6b21\u6570\u6c42\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u6a21\u5f0f\u4e32 \u4ee3\u7801 C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string &amp;str) {\n        int len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string &amp;str) {\n        int len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    AC_Automaton *ac = new AC_Automaton();\n    string str;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; str;\n        ac -&gt; insert(str);\n    }\n    ac -&gt; build();\n    cin &gt;&gt; str;\n    cout &lt;&lt; (ac -&gt; query(str));\n    return 0;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>const int N = 151;\nconst int M = N * 70;\nstruct AC_Automaton {\n    int tree_size, fail[M], nxt[M][26], val[M], idx[M];\n    int cnt[N];\n    void insert(const string &amp;str, int pos) {\n        int len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        idx[index] = pos;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string &amp;str) {\n        int len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 ; j = fail[j]) {\n                val[j]++;\n            }\n        }\n        for (int i = 1 ; i &lt;= tree_size ; i++) {\n            if (idx[i] == 0) continue;\n            res = max(res, val[i]);\n            cnt[idx[i]] = val[i];\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    AC_Automaton *ac = new AC_Automaton();\n    while (cin &gt;&gt; n) {\n        if (n == 0) break;\n        vector&lt;string&gt; s(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            cin &gt;&gt; s[i];\n            ac -&gt; insert(s[i], i);\n        }\n        ac -&gt; build();\n        string str;\n        cin &gt;&gt; str;\n        int ans = ac -&gt; query(str);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= n ; i++) {\n            if (ac -&gt; cnt[i] == ans) {\n                cout &lt;&lt; s[i] &lt;&lt; \"\\n\";\n            }\n        }\n        for (int i = 0 ; i &lt;= (ac -&gt; tree_size) ; i++) {\n            ac -&gt; fail[i] = 0;\n            ac -&gt; val[i] = 0;\n            ac -&gt; idx[i] = 0;\n            for (int j = 0 ; j &lt; 26 ; j++) {\n                ac -&gt; nxt[i][j] = 0;\n            }\n        }\n        ac -&gt; tree_size = 0;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            ac -&gt; cnt[i] = 0;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"template/string/kmp/","title":"KMP","text":"\u6a21\u7248 base0base1 \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; prefix(const string &amp;str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 1 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j]) {\n            j = nxt[j - 1];\n        }\n        if (str[i] == str[j]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\nvector&lt;int&gt; findOccurrences(const string &amp;str, const string &amp;x) {\n    string cur = x + \"#\" + str;\n    int len1 = str.size(), len2 = x.size();\n    vector&lt;int&gt; nxt = prefix(cur);\n    vector&lt;int&gt; pos;\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 ; i++) {\n        if (nxt[i] == len2) {\n            pos.push_back(i - 2 * len2);\n        }\n    }\n    return pos;\n}\nint match(const string &amp;str, const string &amp;x) {\n    int cnt = 0;\n    int len1 = str.size(), len2 = x.size();\n    auto nxt = prefix(x);\n    int j = 0;\n    for (int i = 0 ; i &lt; len1 ; i++) {\n        while (j &amp;&amp; str[i] != x[j]) {\n            j = nxt[j - 1];\n        }\n        if (str[i] == x[j]) {\n            j++;\n        }\n        if (j == len2) {\n            return i - len2 + 1;\n            j = nxt[j - 1];\n        }\n    }\n    return -1;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; prefix(const string &amp;str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\n</code></pre> \u4f8b\u9898 <p>P3375 \u3010\u6a21\u677f\u3011KMP - \u6d1b\u8c37</p>"},{"location":"template/string/kmp/#_1","title":"\u5e94\u7528","text":""},{"location":"template/string/kmp/#_2","title":"\u5b57\u7b26\u4e32\u7684\u5468\u671f","text":"<p>\u5b57\u7b26\u4e32\u7684\u6700\u5c0f\u5468\u671f\u5c31\u662f \\(len-nxt.back()\\)</p>"},{"location":"template/string/kmp/#_3","title":"\u7edf\u8ba1\u6bcf\u4e2a\u524d\u7f00\u51fa\u73b0\u7684\u6b21\u6570","text":"\u4ee3\u7801 C++<pre><code>string a;\ncin &gt;&gt; a;\nauto nxt = prefix(a);\nint len = a.size();\nvector&lt;long long&gt; ans(len + 1);\nfor (int i = 0 ; i &lt; len ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = len ; i &gt;= 1 ; i--) {\n    ans[nxt[i - 1]] += ans[i];\n}\nfor (int i = 1 ; i &lt;= len ; i++) {\n    ans[i]++;\n}\nlong long res = 0;\nfor (int i = 1 ; i &lt;= len ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre> \u4f8b\u9898 QOJ464LOJ103 <p>\u524d\u7f00\u51fd\u6570 / KMP - QOJ.ac</p> <p>#103. \u5b50\u4e32\u67e5\u627e - LibreOJ</p>"},{"location":"template/string/manacher/","title":"\u9a6c\u62c9\u8f66","text":"\u6a21\u7248 C++<pre><code>string str;\ncin &gt;&gt; str;\nint maxLen = 0;\nint idx = 0;\nint r = 0;\nint c = 0;\nint len = int(str.size()) * 2 + 1;\nvector&lt;char&gt; a(len);\nvector&lt;int&gt; b(len);\nfor (int i = 0 ; i &lt; len ; i++) {\n    a[i] = i &amp; 1 ? str[idx++] : '#';\n}\nfor (int i = 0 ; i &lt; len ; i++) {\n    b[i] = r &gt; i ? min(r - i, b[c * 2 - i]) : 1;\n    while (i - b[i] &gt; -1 &amp;&amp; i + b[i] &lt; len &amp;&amp; a[i - b[i]] == a[i + b[i]]) {\n        b[i]++;\n    }\n    if (i + b[i] &gt; r) {\n        r = i + b[i];\n        c = i;\n    }\n    if (b[i] - 1 &gt; maxLen) {\n        maxLen = b[i] - 1;\n        idx = i;\n    }\n}\ncout &lt;&lt; maxLen &lt;&lt; \" \" &lt;&lt; str.substr((idx - maxLen + 1) / 2, maxLen);\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3805 <p>P3805 \u3010\u6a21\u677f\u3011manacher \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"template/string/problem-set/","title":"\u4e60\u9898","text":"\u4e60\u9898\u4e00 CF808G <p>Problem - G - Codeforces</p> <p>\u4e32T\u5728\u4e32S(\u542b\u95ee\u53f7)\u4e2d\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) j++;\n        nxt[i] = j;\n    }\n    return nxt;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int n = a.size(), m = b.size();\n    a = \" \" + a;\n    b = \" \" + b;\n    auto kmp = prefix(b);\n    vector nxt(m + 1, vector(26, 0));\n    for (int i = 1 ; i &lt;= m + 1 ; i++) {\n        for (int j = 0 ; j &lt; 26 ; j++) {\n            if (i &lt;= m &amp;&amp; b[i] == 'a' + j) {\n                nxt[i - 1][j] = i;\n            } else {\n                nxt[i - 1][j] = nxt[kmp[i - 1]][j];\n            }\n        }\n    }\n    vector dp(n + 1, vector(m + 1, -100000000));\n    dp[0][0] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt;= m ; j++) {\n            if (a[i] == '?') {\n                for (int k = 0 ; k &lt; 26 ; k++) {\n                    dp[i][nxt[j][k]] = max(dp[i][nxt[j][k]], dp[i - 1][j]);\n                }\n            } else {\n                dp[i][nxt[j][a[i] - 'a']] = max(dp[i][nxt[j][a[i] - 'a']], dp[i - 1][j]);\n            }\n        }\n        dp[i][m]++;\n    }\n    int mx = 0;\n    for (int i = 0 ; i &lt;= m ; i++) mx = max(mx, dp[n][i]);\n    cout &lt;&lt; mx;\n    return 0;\n}\n</code></pre>"},{"location":"template/string/string-hash/","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"\u6a21\u7248 C++<pre><code>template&lt;int N&gt;\nstruct _StringHash {\n    static int mod;\n    static array&lt;int, N&gt; base;\n    static vector&lt;array&lt;int, N&gt;&gt; bases;\n    static bool noInit;\n    vector&lt;array&lt;int, N&gt;&gt; hash;\n    _StringHash(const string &amp;str) {\n        if (noInit) {\n            for (int i = 0 ; i &lt; N ; i++) {\n                base[i] = getRandom();\n            }\n            noInit = false;\n        }\n        int len = str.size() + 1;\n        hash.resize(len);\n        if (len &gt; int(bases.size())) {\n            int k = max(1, (int) bases.size());\n            bases.resize(len);\n            bases[0] = {1, 1};\n            for (int i = k ; i &lt; len ; i++) {\n                for (int j = 0 ; j &lt; N ; j++) {\n                    bases[i][j] = 1LL * bases[i - 1][j] * base[j] % mod;\n                }\n            }\n        }\n        for (int i = 1 ; i &lt; len ; i++) {\n            for (int j = 0 ; j &lt; N ; j++) {\n                hash[i][j] = (1LL * hash[i - 1][j] * base[j] + str[i - 1]) % mod;\n            }\n        }\n    }\n    static mt19937 rnd;\n    static int getRandom() {\n        return rnd() % 1000000 + 1000000;\n    }\n    array&lt;int, N&gt; get(int L, int R) {\n        array&lt;int, N&gt; res{};\n        for (int i = 0 ; i &lt; N ; i++) {\n            res[i] = (hash[R][i] - 1LL * hash[L - 1][i] * bases[R - L + 1][i] % mod + mod) % mod;\n        }\n        return res;\n    }\n}; // _StringHash\ntemplate&lt;int N&gt;\nmt19937 _StringHash&lt;N&gt;::rnd(time(nullptr));\ntemplate&lt;int N&gt;\nvector&lt;array&lt;int, N&gt;&gt; _StringHash&lt;N&gt;::bases;\ntemplate&lt;int N&gt;\narray&lt;int, N&gt; _StringHash&lt;N&gt;::base{};\ntemplate&lt;int N&gt;\nbool _StringHash&lt;N&gt;::noInit = true;\ntemplate&lt;int N&gt; // \u6b64\u5904\u4fee\u6539\u6a21\u6570, \u4ec5\u652f\u6301\u5355\u6a21\u6570\nint _StringHash&lt;N&gt;::mod = 1000000007;\nusing StringHash = _StringHash&lt;2&gt;; // \u786e\u5b9a\u5e95\u6570\u4e2a\u6570\n// \u5b9a\u4e49 StringHash sh(str)\n// \u4f20\u5165\u5b57\u7b26\u4e32\u5fc5\u987b\u4e0b\u6807\u4ece0\u5f00\u59cb\n// \u83b7\u53d6\u54c8\u5e0c\u503c sh.get(L, R) \u533a\u95f4\u4e0b\u6807\u4ee51\u4e3a\u57fa\u7840\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3370 <p>P3370 \u3010\u6a21\u677f\u3011\u5b57\u7b26\u4e32\u54c8\u5e0c - \u6d1b\u8c37</p>"},{"location":"template/string/trie/","title":"\u5b57\u5178\u6811","text":"\u6a21\u7248 \u7ed3\u6784\u4f53 C++<pre><code>struct Trie {\n    const static int N = 100000;\n    const static int M = 26;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int find(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) return 0;\n            index = nxt[index][c];\n        }\n        return exist[index];\n    }\n}; // Trie\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P8306AcWing143(\u6700\u5927\u5f02\u6216\u5bf9) <p>P8306 \u3010\u6a21\u677f\u3011\u5b57\u5178\u6811 - \u6d1b\u8c37</p> <p>143. \u6700\u5927\u5f02\u6216\u5bf9 - AcWing\u9898\u5e93</p> <p>\\(n\\) \u4e2a\u6574\u6570 \\(a\\), \u4efb\u9009\u4e24\u4e2a\u6570\u8fdb\u884c\u5f02\u6216\uff0c\u6c42\u6700\u5927\u503c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nstruct Trie {\n    const static int N = 100000 * 30;\n    const static int M = 2;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(int x) {\n        int index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int query(int x) {\n        int res = 0, index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c ^ 1]) {\n                res |= 1 &lt;&lt; i;\n                index = nxt[index][c ^ 1];\n            } else if (nxt[index][c]) {\n                index = nxt[index][c];\n            } else {\n                return res;\n            }\n        }\n        return res;\n    }\n}; // Trie\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    Trie trie;\n    int ans = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        int res = trie.query(x);\n        ans = max(ans, res);\n        trie.insert(x);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"}]}