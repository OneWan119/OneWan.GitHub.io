{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Home","text":"<p>   \u672c\u6587\u603b\u9605\u8bfb\u91cf  \u6b21 </p> <p>     \u672c\u7ad9\u603b\u8bbf\u95ee\u91cf\u6b21 </p> <p>   \u672c\u7ad9\u8bbf\u5ba2\u6570\u4eba\u6b21 </p>"},{"location":"Template/DataStructure/FenwickTree/","title":"\u6811\u72b6\u6570\u7ec4","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4\u6743\u503c\u6811\u72b6\u6570\u7ec4-\u5168\u5c40\u7b2c k \u5c0f \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 500005;\nint n = N - 1, sum[N];\nusing B = int;\nB query(int x) {\n    B res = 0;\n    while (x) {\n        res += sum[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    while (x &lt;= n) {\n        sum[x] += k;\n        x += lowbit(x);\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum, sumX;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n        sumX.resize(0);\n        sumX.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            res += (x + 1) * sum[i] - sumX[i];\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        T kx = k * x;\n        while (x &lt;= size) {\n            sum[x] += k;\n            sumX[x] += kx;\n            x += lowbit(x);\n        }\n    }\n    void add(int L, int R, T k) {\n        add(L, k);\n        add(R + 1, -k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 1000005;\nlong long sum[N], sumX[N];\nint n = N - 1;\nusing B = long long;\nB query(int x) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        res += (x + 1) * sum[i] - sumX[i];\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    B kx = k * x;\n    while (x &lt;= n) {\n        sum[x] += k;\n        sumX[x] += kx;\n        x += lowbit(x);\n    }\n}\nvoid add(int L, int R, B k) {\n    add(L, k);\n    add(R + 1, -k);\n}\n</code></pre> \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(sizeX + 1);\n        for (int i = 1 ; i &lt;= sizeX ; i++) {\n            sum[i].resize(sizeY + 1);\n        }\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n            }\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nint n = N - 1, m = M - 1;\nusing B = long long;\nB sum[N][M];\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n        }\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum, sumX, sumY, sumXY;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        sumY.resize(n + 1);\n        sumXY.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n            sumX[i].resize(m + 1);\n            sumY[i].resize(m + 1);\n            sumXY[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        resize(0, 0);\n        resize(sizeX, sizeY);\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        T kx = k * x;\n        T ky = k * y;\n        T kxy = kx * y;\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n                sumX[i][j] += kx;\n                sumY[i][j] += ky;\n                sumXY[i][j] += kxy;\n            }\n        }\n    }\n    void add(int x1, int y1, int x2, int y2, T k) {\n        add(x1, y1, k);\n        add(x1, y2 + 1, -k);\n        add(x2 + 1, y1, -k);\n        add(x2 + 1, y2 + 1, k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nusing B = long long;\nB sum[N][M], sumX[N][M], sumY[N][M], sumXY[N][M];\nint n = N - 1, m = M - 1;\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    B kx = k * x;\n    B ky = k * y;\n    B kxy = kx * y;\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n            sumX[i][j] += kx;\n            sumY[i][j] += ky;\n            sumXY[i][j] += kxy;\n        }\n    }\n}\nvoid add(int x1, int y1, int x2, int y2, B k) {\n    add(x1, y1, k);\n    add(x1, y2 + 1, -k);\n    add(x2 + 1, y1, -k);\n    add(x2 + 1, y2 + 1, k);\n}\n</code></pre> C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n    T kth(int rk) {\n        int res = 0, now = 0;\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            int k = 1 &lt;&lt; i;\n            if (now + k &lt;= size &amp;&amp; res + sum[now + k] &lt; rk) {\n                now += k;\n                res += sum[now];\n            }\n        }\n        return now + 1;\n    }\n}; // FenwickTree\n</code></pre> \u4f8b\u9898 \u4e00\u7ef4\u4e8c\u7ef4 \u6d1b\u8c37P3374(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ132(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>P3374 \u3010\u6a21\u677f\u3011\u6811\u72b6\u6570\u7ec4 1 - \u6d1b\u8c37</p> <p>#132. \u6811\u72b6\u6570\u7ec4 3 \uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> LOJ133(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ135(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>#133. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 1\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> <p>#135. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 3\uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p>"},{"location":"Template/DataStructure/MonotonicQueue/","title":"\u5355\u8c03\u961f\u5217","text":"\u6a21\u7248 C++<pre><code>// \u6c42 [i-m+1, i] \u7684\u6700\u503c\ndeque&lt;int&gt; que;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &gt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mi.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mi[i] &lt;&lt; \" \\n\"[i == n - m];\ndeque&lt;int&gt;().swap(que);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &lt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mx.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mx[i] &lt;&lt; \" \\n\"[i == n - m];\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1886 <p>P1886 \u3010\u6a21\u677f\u3011\u5355\u8c03\u961f\u5217 - \u6d1b\u8c37</p>"},{"location":"Template/DataStructure/MonotonicStack/","title":"\u5355\u8c03\u6808","text":"\u6a21\u7248 C++<pre><code>// \u6c42 i \u540e\u9762\u4e00\u4e2a\u6bd4 a[i] \u5927\u7684\u6570\u7684\u4e0b\u6807\nstack&lt;int&gt; st;\nvector&lt;int&gt; ans(n + 1);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!st.empty() &amp;&amp; a[st.top()] &lt; a[i]) {\n        ans[st.top()] = i;\n        st.pop();\n    }\n    st.emplace(i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5788 <p>P5788 \u3010\u6a21\u677f\u3011\u5355\u8c03\u6808 - \u6d1b\u8c37</p>"},{"location":"Template/DataStructure/SparseTable/","title":"ST\u8868","text":"<p>\\(O(n\\log n)\\)</p> <p>\u89e3\u51b3 RMQ \u95ee\u9898\uff0c\u5982\u9759\u6001\u533a\u95f4\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u548c \\(\\gcd\\)</p> \u6a21\u7248 C++<pre><code>template&lt;class T&gt;\nstruct SparseTable {\n    vector&lt;vector&lt;T&gt;&gt; st;\n    vector&lt;int&gt; lg;\n    // \u4f20\u5165\u7684 vector \u7684\u4e0b\u6807\u5fc5\u987b\u4ee5 1 \u4e3a\u57fa\u7840\n    SparseTable(const vector&lt;T&gt; &amp;s) {\n        const int n = s.size() - 1;\n        st.assign(n + 1, vector&lt;T&gt;(22, 0));\n        lg.resize(n);\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            st[i][0] = s[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n    }\n    T query(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(st[L][k], st[R - (1 &lt;&lt; k) + 1][k]);\n    }\n}; // SparseTable\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3865 <p>P3865 \u3010\u6a21\u677f\u3011ST \u8868 - \u6d1b\u8c37</p>"},{"location":"Template/Default/FastIO/","title":"\u5feb\u8bfb","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; inline void read(T &amp;k) {\n    T x = 0, f = 1; \n    char ch = getchar(); \n    while (ch &lt; '0' || ch &gt; '9') {\n        if (ch == '-') {\n            f = -1;\n        }\n        ch = getchar();\n    }\n    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\n        ch = getchar();\n    }\n    k = x * f;\n}\ntemplate&lt;class T&gt; inline void write(T x) {\n    if (x &lt; 0) {\n        putchar('-'), x = -x;\n    }\n    if (x &gt; 9) {\n        write(x / 10);\n    }\n    putchar(x % 10 + '0');\n}\n</code></pre>"},{"location":"Template/Default/HashCode/","title":"\u54c8\u5e0c\u8868\u91cd\u5199\u54c8\u5e0c\u51fd\u6570","text":"\u6a21\u7248 \u6574\u6570pair C++<pre><code>struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ x &gt;&gt; 30) * 0xbf58476d1ce4e5b9;\n        x = (x ^ x &gt;&gt; 27) * 0x94d049bb133111eb;\n        return x ^ x &gt;&gt; 31;\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nunordered_map&lt;int, int, custom_hash&gt; safe_map;\n</code></pre> C++<pre><code>struct pair_hash {\n    template&lt;class T1, class T2&gt;\n    size_t operator() (const pair&lt;T1, T2&gt;&amp; pair) const {\n        return hash&lt;T1&gt;()(pair.first) ^ hash&lt;T2&gt;()(pair.second);\n    }\n};\nunordered_map&lt;pair&lt;int, int&gt;, int, pair_hash&gt; safe_map;\n</code></pre>"},{"location":"Template/Default/HighAccuracy/","title":"\u9ad8\u7cbe\u5ea6","text":"\u6a21\u7248 C++<pre><code>struct BigInt {\n    static const int BASE = 100000000;\n    static const int WIDTH = 8;\n    bool sign = true;\n    vector&lt;int&gt; num;\n    BigInt() : num(1) {}\n    BigInt(int x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(long long x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(const string x) {\n        if (x.front() == '-') {\n            sign = false;\n        }\n        int len = (int(x.size()) - 1 - (!sign)) / WIDTH + 1;\n        num.resize(len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            int end = int(x.size()) - i * WIDTH;\n            int start = max(int(!sign), end - WIDTH);\n            long long k = 0;\n            for (int j = start ; j &lt; end ; j++) {\n                k = k * 10 + (x[j] ^ 48);\n            }\n            num[i] = k;\n        }\n    }\n    int abs_equal(const BigInt &amp;L, const BigInt &amp;R) {\n        int lenL = L.num.size(), lenR = R.num.size();\n        if (lenL == lenR) {\n            for (int i = lenL - 1 ; i &gt;= 0 ; i--) {\n                if (L.num[i] == R.num[i]) {\n                    continue;\n                }\n                return L.num[i] &lt; R.num[i] ? -1 : 1;\n            }\n            return 0;\n        }\n        return lenL &lt; lenR ? -1 : 1;\n    }\n    BigInt operator+(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !x.sign;\n            return *this - _x;\n        }\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        int len = max(lenA, lenB);\n        res.resize(len);\n        int k = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            if (i &lt; lenA) {\n                k += num[i];\n            }\n            if (i &lt; lenB) {\n                k += x.num[i];\n            }\n            res[i] = k % BASE;\n            k /= BASE;\n        }\n        if (k &gt; 0) res.push_back(k);\n        res.sign = sign;\n        return res;\n    }\n    BigInt operator-(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !_x.sign;\n            return *this + _x;\n        }\n        BigInt res(*this), _x(x);\n        if (abs_equal(res, _x) &lt; 0) {\n            swap(res, _x);\n            res.sign = !res.sign;\n        }\n        int lenA = res.size(), lenB = _x.size();\n        int k = 0;\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            res[i] -= k;\n            if (i &lt; lenB) {\n                res[i] -= _x[i];\n            } else if (k == 0) {\n                continue;\n            }\n            k = 0;\n            if (res[i] &lt; 0) {\n                res[i] += BASE;\n                k += 1;\n            }\n        }\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator*(const BigInt &amp;x) {\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        res.resize(lenA + lenB);\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            for (int j = 0 ; j &lt; lenB ; j++) {\n                long long k = 1LL * num[i] * x.num[j] + res[i + j];\n                res[i + j] = k % BASE;\n                res[i + j + 1] += k / BASE;\n            }\n        }\n        res.sign = !(sign ^ x.sign);\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator /(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return res;\n        } else if (k == -1) {\n            return BigInt(0);\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return res;\n    }\n    BigInt operator %(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            return BigInt(0);\n        } else if (k == -1) {\n            return *this;\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return Remain;\n    }\n    BigInt&amp; operator+=(const BigInt &amp;x) {\n        *this = *this + x;\n        return *this;\n    }\n    BigInt&amp; operator-=(const BigInt &amp;x) {\n        *this = *this - x;\n        return *this;\n    }\n    BigInt&amp; operator*=(const BigInt &amp;x) {\n        *this = *this * x;\n        return *this;\n    }\n    BigInt&amp; operator/=(const BigInt &amp;x) {\n        *this = *this / x;\n        return *this;\n    }\n    BigInt operator-() {\n        BigInt a(*this);\n        a.sign = !a.sign;\n        return a;\n    }\n    pair&lt;BigInt, BigInt&gt; divide(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return {res, BigInt(0)};\n        } else if (k == -1) {\n            return {BigInt(0), BigInt(0)};\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return {res, Remain};\n    }\n    static BigInt Copy(const BigInt &amp;x, const int pos) {\n        BigInt res;\n        int len = x.num.size();\n        res.resize(len + pos);\n        for (int i = 0 ; i &lt; len ; i++) {\n            res[i + pos] = x.num[i];\n        }\n        return res;\n    }\n    int &amp;operator[](const int pos) {\n        return num[pos];\n    }\n    int &amp;back() {\n        return num.back();\n    }\n    int size() {\n        return num.size();\n    }\n    void resize(const int size) {\n        num.resize(size);\n    }\n    void emplace_back(const int x) {\n        num.emplace_back(x);\n    }\n    void pop_back() {\n        num.pop_back();\n    }\n    void print() const {\n        if (num.size() == 1 &amp;&amp; num[0] == 0) {\n            cout &lt;&lt; num[0];\n            return;\n        }\n        if (!sign) cout &lt;&lt; \"-\";\n        cout &lt;&lt; num.back();\n        int len = num.size();\n        for (int i = len - 2 ; i &gt;= 0 ; i--) {\n            cout &lt;&lt; setfill('0') &lt;&lt; setw(WIDTH) &lt;&lt; num[i];\n        }\n    }\n    friend istream &amp;operator&gt;&gt;(istream &amp;is, BigInt &amp;x) {\n        string str;\n        is &gt;&gt; str;\n        BigInt a(str);\n        x = a;\n        return is;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const BigInt &amp;x) {\n        return x.print(), os;\n    }\n}; // BigInt;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1932 <p>P1932 A+B A-B A*B A/B A%B Problem - \u6d1b\u8c37</p>"},{"location":"Template/Default/ModInt/","title":"ModInt","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; constexpr T qpow(T a, long long b) {\n    T res = 1;\n    while (b) {\n        if (b &amp; 1) res *= a;\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate &lt;class T&gt; struct _MInt {\n    T value;\n    constexpr _MInt() : value() {}\n    constexpr _MInt(T value) : value(normal(value % getMod())) {}\n    static int _mod;\n    constexpr static int getMod() {\n        return _mod;\n    }\n    constexpr T normal(T x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr _MInt inv() const {\n        return qpow(*this, getMod() - 2);\n    }\n    constexpr _MInt operator-() const {\n        _MInt res;\n        res.value = normal(getMod() - value);\n        return res;\n    }\n    constexpr _MInt &amp;operator*=(_MInt rhs) &amp; {\n        if (is_same&lt;T, long long&gt;::value) {\n            value = (__int128) value * rhs.x % getMod();\n        } else {\n            value = (long long) value * rhs.x % getMod();\n        }\n        return *this;\n    }\n    constexpr _MInt &amp;operator+=(_MInt rhs) &amp; {\n        value = normal(value + rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator-=(_MInt rhs) &amp; {\n        value = normal(value - rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator/=(_MInt rhs) &amp; {\n        return *this *= rhs.inv(); \n    }\n    friend constexpr _MInt operator*(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator+(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr _MInt operator-(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator/(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr istream &amp;operator&gt;&gt;(istream &amp;is, _MInt &amp;a) {\n        long long v;\n        is &gt;&gt; v;\n        a = _MInt(v);\n        return is;\n    }\n    friend constexpr ostream &amp;operator&lt;&lt;(ostream &amp;os, const _MInt &amp;a) {\n        return os &lt;&lt; a.value;\n    }\n    friend constexpr bool operator==(_MInt lhs, _MInt rhs) {\n        return lhs.value == rhs.value;\n    }\n    friend constexpr bool operator!=(_MInt lhs, _MInt rhs) {\n        return lhs.value != rhs.value;\n    }\n};\ntemplate &lt;&gt; int _MInt&lt;int&gt;::_mod = 998244353;\nusing MInt = _MInt&lt;int&gt;;\n</code></pre>"},{"location":"Template/Default/Sort/","title":"\u6392\u5e8f","text":"\u6a21\u7248 \u5feb\u901f\u6392\u5e8f\\(O(n\\log n)\\)\u5f52\u5e76\u6392\u5e8f \\(O(n\\log n)\\)\u63d2\u5165\u6392\u5e8f \\(O(n^2)\\)\u5192\u6ce1\u6392\u5e8f \\(O(n^2)\\)\u9009\u62e9\u6392\u5e8f \\(O(n^2)\\)\u5e0c\u5c14\u6392\u5e8f \\(O(n\\log n)\\) C++<pre><code>void quickSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    int i = L - 1, j = R + 1;\n    int k = a[L + R &gt;&gt; 1];\n    while (i &lt; j) {\n        do i++; while (a[i] &lt; k);\n        do j--; while (a[j] &gt; k);\n        if (i &lt; j) swap(a[i], a[j]);\n    }\n    quickSort(a, L, j);\n    quickSort(a, j + 1, R);\n}\n</code></pre> C++<pre><code>int cnt = 0;\nvoid mergeSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    vector&lt;int&gt; b(R - L + 1);\n    int mid = L + R &gt;&gt; 1;\n    mergeSort(a, L, mid);\n    mergeSort(a, mid + 1, R);\n    int i = L, j = mid + 1, k = 0;\n    while (i &lt;= mid &amp;&amp; j &lt;= R) {\n        if (a[i] &lt;= a[j]) {\n            b[k++] = a[i++];\n        } else {\n            b[k++] = a[j++];\n            cnt += mid - i + 1;\n        }\n    }\n    while (i &lt;= mid) b[k++] = a[i++];\n    while (j &lt;= R) {\n        b[k++] = a[j++];\n        cnt += mid - i + 1;\n    }\n    for (int i = L ; i &lt;= R ; i++) a[i] = b[i - L];\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L + 1 ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - 1;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + 1] = a[j];\n            --j;\n        }\n        a[j + 1] = v;\n    }\n}\n</code></pre> C++<pre><code>void bubbleSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt;= R ; i++) {\n        for (int j = R ; j &gt; i ; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                swap(a[j - 1], a[j]);\n            }\n        }\n    }\n}\n</code></pre> C++<pre><code>void selectSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt; R ; i++) {\n        int t = i;\n        for (int j = i ; j &lt;= R ; j++) {\n            if (a[j] &lt; a[t]) {\n                t = j;\n            }\n        }\n        swap(a[t], a[i]);\n    }\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R, int g) {\n    for (int i = L + g ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - g;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + g] = a[j];\n            j -= g;\n        }\n        a[j + g] = v;\n    }\n}\nvoid shellSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    vector&lt;int&gt; g;\n    for (int h = 1 ; h &lt;= R ; h = 3 * h + 1 ) g.emplace_back(h);\n    reverse(begin(g), end(g));\n    for (auto &amp;i : g) insertSort(a, L, R, i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1177\u6d1b\u8c37U232725 <p>P1177 \u3010\u6a21\u677f\u3011\u6392\u5e8f - \u6d1b\u8c37</p> <p>U232725 \u3010\u6a21\u677f\u3011\u5f52\u5e76\u6392\u5e8f - \u6d1b\u8c37</p>"},{"location":"Template/Default/__builtin/","title":"__builtin","text":"\u51fd\u6570 \u63cf\u8ff0 __builtin_ctz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero __builtin_ctzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero long long __builtin_clz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero __builtin_clzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero long long __builtin_popcount(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count __builtin_popcountll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count long long __builtin_parity(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u7684\u5947\u5076\u6027(1, 0) parity __builtin_parityll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u5947\u5076\u6027(1, 0) parity long long __builtin_ffs(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat __builtin_ffsll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat long long __builtin_sqrt(double x) \u8fd4\u56de  \\(\\sqrt {double\\ x}\\)  \u7684\u503c sqrt __builtin_sqrtf(float x) \u8fd4\u56de  \\(\\sqrt {float\\ x}\\)  \u7684\u503c sqrt float"},{"location":"Template/DynamicProgramming/Knapsack/","title":"\u80cc\u5305","text":""},{"location":"Template/DynamicProgramming/Knapsack/#0-1","title":"0-1\u80cc\u5305","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - w[i]] + d[i]);\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + d[i - 1]);\n        }\n    }\n    cout &lt;&lt; dp[N][M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P2871AcWing278(\u6c42\u4f53\u79ef\u6070\u597d\u4e3aM\u7684\u65b9\u6848\u6570)AcWing11(\u6c42\u6700\u4f18\u65b9\u6848\u6570)AcWing12 <p>P2871 [USACO07DEC] Charm Bracelet S - \u6d1b\u8c37</p> <p>278. \u6570\u5b57\u7ec4\u5408 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; v[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    dp[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= v[i] ; j--) {\n            dp[j] = dp[j] + dp[j - v[i]];\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>11. \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst long long mod = 1000000007;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;long long&gt; dp(M + 1), g(M + 1);\n    g[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            long long k;\n            long long temp = dp[j - w[i]] + v[i];\n            if (dp[j] &lt; temp) {\n                g[j] = g[j - w[i]];\n                dp[j] = temp;\n            } else if (dp[j] == temp) {\n                g[j] = (g[j] + g[j - w[i]]) % mod;\n            }\n        }\n    }\n    long long res = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        res = max(res, dp[i]);\n    }\n    long long ans = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        if (dp[i] == res) {\n            ans = (ans + g[i]) % mod;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>12. \u80cc\u5305\u95ee\u9898\u6c42\u5177\u4f53\u65b9\u6848 - AcWing</p> \u7f16\u53f7\u6b63\u5e8f\u7f16\u53f7\u9006\u5e8f C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = N - 1 ; i &gt;= 0 ; i--) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i + 1][j];\n        }\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + v[i]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = 0, j = M ; i &lt; N ; i++) {\n        if (j &gt;= w[i] &amp;&amp; dp[i][j] == dp[i + 1][j - w[i]] + v[i]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = N - 1, j = M ; i &gt;= 0 ; i--) {\n        if (j &gt;= w[i] &amp;&amp; dp[i + 1][j] - v[i] == dp[i][j - w[i]]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85/","title":"\u4e8c\u7ef4\u8d39\u7528\u80cc\u5305","text":"<p>P1855 \u69a8\u53d6kkksc03 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M, T;\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; T;\n    vector&lt;int&gt; m(N), t(N);\n    vector&lt;vector&lt;int&gt;&gt; dp(M + 1, vector&lt;int&gt;(T + 1));\n    for (int i = 0 ; i &lt; N ; i++) cin &gt;&gt; m[i] &gt;&gt; t[i];\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= m[i] ; j--) {\n            for (int k = T ; k &gt;= t[i] ; k--) {\n                dp[j][k] = max(dp[j][k], dp[j - m[i]][k - t[i]] + 1);\n            }\n        }\n    }\n    cout &lt;&lt; dp[M][T];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","title":"\u5206\u7ec4\u80cc\u5305","text":"<p>P1757 \u901a\u5929\u4e4b\u5206\u7ec4\u80cc\u5305 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; M &gt;&gt; N;\n    map&lt;int, vector&lt;int&gt;&gt; v, w;\n    for (int i = 0 ; i &lt; N ; i++) {\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        w[z].emplace_back(x);\n        v[z].emplace_back(y);\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (auto&amp; [g, ww] : w) {\n        auto&amp; vv = v[g];\n        for (int i = M ; i &gt;= 0 ; i--) {\n            int len = ww.size();\n            for (int j = 0 ; j &lt; len ; j++) {\n                if (i &gt;= ww[j]) {\n                    dp[i] = max(dp[i], dp[i - ww[j]] + vv[j]);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[M];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/","title":"\u591a\u4eba\u80cc\u5305","text":"<p>P1858 \u591a\u4eba\u80cc\u5305 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int K, V, N;\n    cin &gt;&gt; K &gt;&gt; V &gt;&gt; N;\n    vector&lt;int&gt; w(N), v(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(K, vector&lt;int&gt;(V + 1, 0x7fffffff + 1));\n    vector&lt;int&gt; re(K);\n    dp[0][0] = 0;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = V ; j &gt;= w[i] ; j--) {\n            int a = 0, b = 0, t = 0;\n            while (t &lt; K) {\n                if (dp[a][j] &gt;= dp[b][j - w[i]] + v[i]) {\n                    re[t++] = dp[a++][j];\n                } else {\n                    re[t++] = dp[b++][j - w[i]] + v[i];\n                }\n            }\n            for (int k = 0 ; k &lt; K ; k++) {\n                dp[k][j] = re[k];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; K ; i++) ans += dp[i][V];\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","title":"\u591a\u91cd\u80cc\u5305","text":"<p>5. \u591a\u91cd\u80cc\u5305\u95ee\u9898 II - AcWing</p> <p>6. \u591a\u91cd\u80cc\u5305\u95ee\u9898 III - AcWing</p>"},{"location":"Template/DynamicProgramming/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#_2","title":"\u4e8c\u8fdb\u5236\u4f18\u5316","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N), s(N);\n    for (int i = 0 ; i &lt; N ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    vector&lt;long long&gt; vv, ww;\n    for (int i = 0 ; i &lt; N ; i++) {\n        int temp = 1;\n        int k = s[i];\n        while (k &gt; temp) {\n            k -= temp;\n            vv.emplace_back(1LL * v[i] * temp);\n            ww.emplace_back(1LL * w[i] * temp);\n            temp &lt;&lt;= 1;\n        }\n        if (k) {\n            vv.emplace_back(1LL * v[i] * k);\n            ww.emplace_back(1LL * w[i] * k);\n        }\n    }\n    vector&lt;long long&gt; dp(M + 1);\n    int len = vv.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        for (int j = M ; j &gt;= ww[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - ww[i]] + vv[i]);\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#_3","title":"\u961f\u5217\u4f18\u5316","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\nint q[1000000];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N), s(N);\n    for (int i = 0 ; i &lt; N ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    vector&lt;vector&lt;long long&gt;&gt; dp(2, vector&lt;long long&gt;(M + 1));\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = 0 ; j &lt; w[i] ; j++) {\n            int L = 0, R = -1;\n            for (int k = j ; k &lt;= M ; k += w[i]) {\n                while (L &lt;= R &amp;&amp; k - 1LL * s[i] * w[i] &gt; q[L]) L++;\n                while (L &lt;= R &amp;&amp; dp[i &amp; 1][q[R]] + (k - q[R]) / w[i] * v[i] &lt;= dp[i &amp; 1][k]) R--;\n                q[++R] = k;\n                dp[i &amp; 1 ^ 1][k] = dp[i &amp; 1][q[L]] + (k - q[L]) / w[i] * v[i];\n            }\n        }\n    }\n    cout &lt;&lt; dp[N &amp; 1][M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","title":"\u5b8c\u5168\u80cc\u5305","text":"<p>3. \u5b8c\u5168\u80cc\u5305\u95ee\u9898 - AcWing</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; w(n), v(n), dp(m + 1);\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = w[i] ; j &lt;= m ; j++) {\n            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n        }\n    }\n    cout &lt;&lt; dp[m];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/#v","title":"\u6c42\u4f53\u79ef\u6070\u597d\u7b49\u4e8eV\u7684\u65b9\u6848\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n), dp(m + 1);\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; v[i];\n    dp[0] = 1;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = v[i] ; j &lt;= m ; j++) {\n            dp[j] = dp[j] + dp[j - v[i]];\n        }\n    }\n    cout &lt;&lt; dp[m];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/#_2","title":"\u6c42\u6700\u4f18\u9009\u6cd5\u7684\u65b9\u6848\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int mod = 1000000007;\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; w(n), v(n);\n    vector&lt;long long&gt; dp(m + 1), g(m + 1);\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\n    g[0] = 1;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = w[i] ; j &lt;= m ; j++) {\n            long long k;\n            long long temp = dp[j - w[i]] + v[i];\n            if (dp[j] &lt; temp) {\n                k = g[j - w[i]];\n            } else if (dp[j] == temp) {\n                k = g[j - w[i]] + g[i];\n            } else {\n                k = g[j];\n            }\n            dp[j] = max(dp[j], temp);\n            g[j] = k % mod;\n        }\n    }\n    long long res = 0;\n    for (int i = 0 ; i &lt;= m ; i++) res = max(res, dp[i]);\n    long long ans = 0;\n    for (int i = 0 ; i &lt; m ; i++) {\n        if (dp[i] == res) ans = (ans + g[i]) % mod;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/MinimumSpanningTree/","title":"\u6700\u5c0f\u751f\u6210\u6811","text":""},{"location":"Template/Graph/MinimumSpanningTree/#prim","title":"Prim","text":"<p>\\(O(n\\log n)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int to, val;\n    Node() = default;\n    Node(const int to, const int val) : to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;vector&lt;Node&gt;&gt; adj;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    adj.assign(n + 1, vector&lt;Node&gt;());\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n        adj[v].emplace_back(u, val);\n    }\n    vector&lt;int&gt; dist(n + 1, 0x7fffffff), vis(n + 1);\n    priority_queue&lt;Node&gt; que;\n    que.emplace(1, 0);\n    int res = 0;\n    int cnt = 0;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [to, val] = que.top();\n        que.pop();\n        if (vis[to] == true) continue;\n        vis[to] = true;\n        cnt++;\n        res += val;\n        for (auto &amp;[to, val] : adj[to]) {\n            if (val &lt; dist[to]) {\n                dist[to] = val;\n                que.emplace(to, val);\n            }\n        }\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/MinimumSpanningTree/#kruskal","title":"Kruskal","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int from, to, val;\n    Node() = default;\n    Node(const int from, const int to, const int val) : from(from), to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint f[5005];\nint find(const int x) {\n    return f[x] == x ? x : f[x] = find(f[x]);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;Node&gt; edge(m);\n    iota(f, f + n + 1, 0);\n    priority_queue&lt;Node&gt; que;\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].val;\n        que.emplace(edge[i]);\n    }\n    vector&lt;int&gt; vis(n + 1);\n    int res = 0;\n    int cnt = 1;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [from, to, val] = que.top();\n        que.pop();\n        from = find(from);\n        to = find(to);\n        if (from == to) continue;\n        f[from] = to;\n        cnt++;\n        res += val;\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/MinimumSpanningTree/#_2","title":"\u6700\u5c0f\u5f02\u6216\u751f\u6210\u6811","text":"\u4f8b\u9898 CF888G <p>Problem - G - Codeforces</p> <p>\\(n\\) \u4e2a\u70b9\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a \\(a_i\\), \u70b9 \\(i\\) \u548c \\(j\\) \u7684\u8fb9\u7684\u6743\u503c\u7b49\u4e8e \\(a_i\\oplus\u2009a_j\\)\uff0c\u95ee\u6700\u5c0f\u751f\u6210\u6811\u7684\u6743\u503c(\u6240\u6709\u8fb9\u6743\u4e4b\u548c)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint tot = 0;\nconst int N = 200000 * 31;\nvector&lt;int&gt; e[N];\nint nxt[N][2];\nvoid insert(int x) {\n    int index = 0;\n    for (int i = 30 ; i &gt;= 0 ; i--) {\n        int k = x &gt;&gt; i &amp; 1;\n        if (nxt[index][k] == 0) {\n            nxt[index][k] = ++tot;\n        }\n        index = nxt[index][k];\n        e[index].emplace_back(x);\n    }\n}\nint query(int index, int d, int x) {\n    if (d &lt; 0) {\n        return 0;\n    }\n    int k = x &gt;&gt; d &amp; 1;\n    if (nxt[index][k]) {\n        return query(nxt[index][k], d - 1, x);\n    }\n    return query(nxt[index][k ^ 1], d - 1, x) + (1 &lt;&lt; d);\n}\nlong long ans = 0;\nvoid solve(int index, int d) {\n    int L = nxt[index][0], R = nxt[index][1];\n    if (L &amp;&amp; R) {\n        if (e[L].size() &gt; e[R].size()) swap(L, R);\n        int mi = 1 &lt;&lt; 30;\n        for (auto &amp;x : e[L]) {\n            mi = min(mi, query(R, d - 1, x));\n        }\n        ans += mi + (1 &lt;&lt; d);\n    }\n    if (L) {\n        solve(L, d - 1);\n    }\n    if (R) {\n        solve(R, d - 1);\n    }\n\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        insert(a[i]);\n    }\n    solve(0, 30);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/ShortestPath/","title":"\u6700\u77ed\u8def","text":""},{"location":"Template/Graph/ShortestPath/#floyed","title":"Floyed \u7b97\u6cd5","text":"<p>\\(O(n^3)\\)</p> \u6a21\u7248 C++<pre><code>for (int k = 1 ; k &lt;= n ; k++) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= n ; j++) {\n            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n        }\n    }\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3647 <p>B3647 \u3010\u6a21\u677f\u3011Floyd \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#bellman-ford","title":"Bellman-Ford \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nint n;\nvoid bellman_ford(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n    }\n    dist[s] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        bool flag = false;\n        for (int p = 1 ; p &lt;= n ; p++) {\n            if (dist[p] == 0x7fffffff) {\n                continue;\n            }\n            for (auto &amp;[to, val] : adj[p]) {\n                if (dist[p] + val &lt; dist[to]) {\n                    dist[to] = dist[p] + val;\n                    flag = true;\n                }\n            }\n        }\n        if (flag == false) {\n            break;\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    bellman_ford(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#spfa","title":"Spfa \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nint dist[10005];\nbool vis[10005];\nvector&lt;Node&gt; adj[10005];\nint n;\nvoid spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    spfa(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \\n\"[i == n];\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371\u6d1b\u8c37P3385 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p> <p>P3385 \u3010\u6a21\u677f\u3011\u8d1f\u73af - \u6d1b\u8c37</p> <p>\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af(\u8def\u5f84\u548c\u4e3a\u8d1f\u6570\u7684\u73af)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nlong long dist[2005];\nbool vis[2005];\nint cnt[2005];\nvector&lt;Node&gt; adj[2005];\nint n;\nbool spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffffffffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nbool solve() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        adj[i].clear();\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        if (val &gt;= 0) {\n            adj[v].emplace_back(u, val);\n        }\n        adj[u].emplace_back(v, val);\n    }\n    return spfa(1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        cout &lt;&lt; (solve() ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/ShortestPath/#dijkstra","title":"Dijkstra \u7b97\u6cd5","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nbool vis[200005];\nint n;\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    dijkstra(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P4779 <p>P4779 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#johnson","title":"Johnson \u5168\u6e90\u6700\u77ed\u8def\u5f84\u7b97\u6cd5","text":"<p>\\(O(nm\\log m)\\)</p> <p>\u8dd1\u4e00\u904d spfa \u5224\u8d1f\u73af\uff0c\u540e\u8dd1 n \u904d dijkstra</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint h[3005];\nint dist[3005];\nint cnt[3005];\nbool vis[3005];\nvector&lt;Node&gt; adj[3005];\nint n;\nbool spfa() {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        h[i] = 0x7fffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n        adj[0].emplace_back(i, 0);\n    }\n    queue&lt;int&gt; que;\n    que.emplace(0);\n    h[0] = 0;\n    vis[0] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (h[p] + val &lt; h[to]) {\n                h[to] = h[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    if (spfa()) {\n        cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (auto &amp;[to, val] : adj[i]) {\n            val += h[i] - h[to];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dijkstra(i);\n        long long ans = 0;\n        for (int j = 1 ; j &lt;= n ; j++) {\n            if (dist[j] == 0x7fffffff) {\n                ans += j * 1000000000L;\n            } else {\n                ans += 1LL * j * (dist[j] + h[j] - h[i]);\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5905 <p>P5905 \u3010\u6a21\u677f\u3011Johnson \u5168\u6e90\u6700\u77ed\u8def - \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/PrimeFactorization/","title":"\u8d28\u56e0\u6570\u5206\u89e3","text":"\u6a21\u7248 \u66b4\u529b \\(O(n\\sqrt n)\\)Pollard_rho \\(O(n^{\\frac{1}{4}}\\log{n})\\) C++<pre><code>vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long x) {\n    vector&lt;pair&lt;long long, int&gt;&gt; res;\n    for (int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            int cnt = 0;\n            while (x % i == 0) {\n                x /= i;\n                cnt++;\n            }\n            res.emplace_back(i, cnt);\n        }\n    }\n    if (x &gt; 1) {\n        res.emplace_back(x, 1);\n    }\n    return res;\n}\n</code></pre> C++<pre><code>namespace Miller_Rabin {\n    long long qpow(long long a, long long b, long long mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = (__int128) res * a % mod;\n            b &gt;&gt;= 1;\n            a = (__int128) a * a % mod;\n        }\n        return res;\n    }\n    bool Miller_Rabin(long long n, const vector&lt;long long&gt; &amp;as) {\n        long long d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        long long e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            long long t = d;\n            long long y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = (__int128) y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(long long n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nnamespace Pollard_rho {\n    template&lt;class T&gt; struct Random {\n        mt19937 mt;\n        Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n        T operator()(T L, T R) {\n            uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n            return dist(mt);\n        }\n    };\n    Random&lt;long long&gt; rng;\n    long long get(long long n) {\n        if (n % 2 == 0) {\n            return 2;\n        }\n        if (Miller_Rabin::is_prime(n)) {\n            return n;\n        }\n        long long R;\n        auto f = [&amp;](long long x) {\n            return ((__int128) x * x + R) % n;\n        };\n        while (true) {\n            long long x, y, ys, q = 1;\n            R = rng(2, n - 1), y = rng(2, n - 1);\n            long long g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r *= 2) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        q = (__int128) q * ((x - (y = f(y)) + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    g = __gcd((x - (ys = f(ys)) + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;long long&gt; factorize(long long n) {\n        if (n &lt;= 1) {\n            return {};\n        }\n        long long p = get(n);\n        if (p == n) {\n            return {n};\n        }\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;long long, int&gt;&gt; res;\n        for (auto &amp;e : ps) {\n            if (!res.empty() &amp;&amp; res.back().first == e) {\n                res.back().second++;\n            } else {\n                res.emplace_back(e, 1);\n            }\n        }\n        return res;\n    }\n    vector&lt;long long&gt; divisors(long long n) {\n        auto ps = prime_factor(n);\n        int cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            cnt *= t + 1;\n        }\n        vector&lt;long long&gt; res(cnt, 1);\n        cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            long long pw = 1;\n            for (int i = 1 ; i &lt;= t ; i++) {\n                pw *= p;\n                for (int j = 0 ; j &lt; cnt ; j++) {\n                    res[cnt * i + j] = res[j] * pw;\n                }\n            }\n            cnt *= t + 1;\n        }\n        return res;\n    }\n} // Pollard_rho\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u8d28\u6570\nusing Pollard_rho::prime_factor; // \u6240\u6709\u8d28\u56e0\u5b50 (\u8d28\u56e0\u5b50, \u4e2a\u6570)\nusing Pollard_rho::divisors; // \u6240\u6709\u56e0\u5b50\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3715\u6d1b\u8c37P4718 <p>B3715 \u5206\u89e3\u8d28\u56e0\u5b50 2 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{12}\\)</p> <p>P4718 \u3010\u6a21\u677f\u3011Pollard rho \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{18}\\)</p>"},{"location":"Template/Math/NumberTheory/Sieve/","title":"\u7b5b\u6cd5","text":""},{"location":"Template/Math/NumberTheory/Sieve/#_2","title":"\u6b27\u62c9\u7b5b","text":"\u6a21\u7248 usageboolint <p>bool: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f \u82e5 vis[x] \u4e3a true, \u5219 x \u4e0d\u662f\u8d28\u6570, \u5426\u5219 x \u662f\u8d28\u6570.</p> <p>int: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f vis[x] \u4e3a x \u7684\u4e00\u4e2a\u8d28\u56e0\u5b50, vis[x] \u4e0e x \u76f8\u7b49\u65f6, x \u662f\u8d28\u6570 (1\u9664\u5916).</p> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                vis[i] = i;\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = i;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3383 <p>P3383 \u3010\u6a21\u677f\u3011\u7ebf\u6027\u7b5b\u7d20\u6570 - \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/Sieve/#_3","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570","text":"<p>\\(d(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570</p> <p>\\(num(i)\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u4e2a\u6570</p> <p>\u7531\u4e8e \\(n=\\prod_i p_i^{a_i}\\)\uff0c\u5219\u6709 \\(d(n)=\\prod_i(a_i+1)\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(d(i)=2\uff0cnum(i)=1\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(d(i*x)=d(i)*d(x)\uff0cnum(i*x)=1\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(num(i*x)=num(i)+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(d(i)=(a_1+1)\\prod_{i=2}(a_i+1)\\)\uff0c\\(d(i*x)=(a_1+1+1)\\prod_{i=2}(a_i+1)\\)    \u6240\u4ee5 \\(d(i*x)=\\dfrac{d(i)}{(a_1+1)}(a_1+1+1)=\\dfrac{d(i)}{num(i)+1}(num(i*x)+1)=\\dfrac{d(i)}{num(i*x)}(num(i*x)+1)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime, d, num;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        d.resize(n);\n        d[1] = 1;\n        num.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    num[i * x] = num[i] + 1;\n                    d[i * x] = d[i] / num[i * x] * (num[i * x] + 1);\n                    break;\n                }\n                num[i * x] = 1;\n                d[i * x] = d[i] * 2;\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"Template/Math/NumberTheory/Sieve/#_4","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c","text":"<p>\\(sd(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c</p> <p>\\(sp(i)\\) \u8868\u793a\u9996\u9879\u4e3a \\(1\\)\uff0c\u516c\u6bd4\u4e3a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u7b49\u6bd4\u6570\u5217\u7684\u548c</p> <p>\\(n=\\prod_ip_i^{a_i}\\)</p> <p>\\(sd(n)=(1+p_1+p_1^2+...+p_1^{a_1})(1+p_2+p_2^2+...+p_2^{a_2})...(1+p_k+p_k^2+...+p_k^{a_k})\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(sd(i)=1+i\uff0csp(i)=1+i\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(sd(i*x)=sd(i)*sd(x)\uff0csp(i*x)=1+x\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(sp(i*x)=sp(i)*x+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(sd(i)=(1+p_1+p_1^2+...+p_1^{a_1})\\prod\\)\uff0c\\(sd(i*x)=(1+p_1+p_1^2+...+p_1^{a_1}+p_1^{a_1+1})\\prod\\)    \u6240\u4ee5 \\(sd(i*x)=\\dfrac{sd(i)}{sp(i)}sp(i*x)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;long long&gt; sd, sp;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        sd.resize(n);\n        sd[1] = 1;\n        sp.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                sd[i] = sp[i] = i + 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    sp[i * x] = sp[i] * x + 1;\n                    sd[i * x] = sd[i] / sp[i] * sp[i * x];\n                    break;\n                }\n                sp[i * x] = 1 + x;\n                sd[i * x] = sd[i] * sd[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"Template/Other/Randomization/Radom/","title":"\u968f\u673a\u6570","text":"\u6a21\u7248 usage\u4ee3\u7801 <p>\u5747\u7b49\u5206\u5e03</p> <p>\u4ec5\u652f\u6301\u6574\u6570\u7c7b\u578b int / long long / unsigned long long</p> <p>\u548c\u6d6e\u70b9\u6570\u7c7b\u578b double / long double</p> C++<pre><code>template&lt;class T&gt;\nstruct Random {\n    mt19937 mt;\n    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    T operator()(const T&amp; L, const T&amp; R);\n};\ntemplate&lt;&gt;\nint Random&lt;int&gt;::operator()(const int &amp;L, const int &amp;R) {\n    uniform_int_distribution&lt;int&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong long Random&lt;long long&gt;::operator()(const long long &amp;L, const long long &amp;R) {\n    uniform_int_distribution&lt;long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nunsigned long long Random&lt;unsigned long long&gt;::operator()(const unsigned long long &amp;L, const unsigned long long &amp;R) {\n    uniform_int_distribution&lt;unsigned long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\ndouble Random&lt;double&gt;::operator()(const double &amp;L, const double &amp;R) {\n    uniform_real_distribution&lt;double&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong double Random&lt;long double&gt;::operator()(const long double &amp;L, const long double &amp;R) {\n    uniform_real_distribution&lt;long double&gt; dist(L, R);\n    return dist(mt);\n}\nRandom&lt;int&gt; rng;\n</code></pre>"},{"location":"Template/Other/Randomization/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","title":"\u6a21\u62df\u9000\u706b","text":"<p>#2076. \u300cJSOI2016\u300d\u70b8\u5f39\u653b\u51fb - LibreOJ</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble x[10], y[10], r[10], p[1005], q[1005];\nint main() {\n    srand(time(nullptr));\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M, R;\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; R;\n    int ans = 0;\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i];\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cin &gt;&gt; p[i] &gt;&gt; q[i];\n    }\n    auto dist = [&amp;](double x1, double y1, double x2, double y2) {\n        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    };\n    auto check = [&amp;](double x1, double y1) {\n        double mi = R;\n        for (int i = 0 ; i &lt; N ; i++) {\n            mi = min(mi, dist(x1, y1, x[i], y[i]) - r[i]);\n        }\n        int res = 0;\n        for (int i = 0 ; i &lt; M ; i++) {\n            if (dist(x1, y1, p[i], q[i]) &lt;= mi) {\n                res++;\n            }\n        }\n        return res;\n    };\n    auto rng = [&amp;](int L, int R) {\n        return rand() % (R - L + 1) + L;\n    };\n    auto Sa = [&amp;]() {\n        int pos = rng(0, M);\n        double nx = p[pos], ny = q[pos];\n        int k = check(nx, ny);\n        ans = max(ans, k);\n        for (double t = 3000 ; t &gt;= 1e-8 ; t *= 0.99) {\n            double mx = nx + t * rng(-100, 100), my = ny + t * rng(-100, 100);\n            int _k = check(mx, my);\n            ans = max(ans, _k);\n            int delta = _k - k;\n            if (delta &gt; 0) {\n                nx = mx;\n                ny = my;\n                k = check(nx, ny);\n                ans = max(ans, k);\n            }\n        }\n    };\n    for (int i = 0 ; i &lt; 10 ; i ++) {\n        Sa();\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P2503 [HAOI2006] \u5747\u5206\u6570\u636e - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint a[25], s[25];\nint main() {\n    srand(time(0));\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int sum = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        sum += a[i];\n    }\n    double ans = 0x7fffffff;\n    double _x = (double) sum / m;\n    auto check = [&amp;]() {\n        int que[8] = {0};\n        for (int i = 1 ; i &lt;= n ; i++) {\n            int mi = 0;\n            for (int j = 0 ; j &lt; m ; j++) {\n                if (que[j] &lt; que[mi]) {\n                    mi = j;\n                }\n            }\n            que[mi] += a[i];\n        }\n        double res = 0;\n        for (int i = 0 ; i &lt; m ; i++) {\n            res += (_x - que[i]) * (_x - que[i]);\n        }\n        return res;\n    };\n    ans = min(ans, check());\n    for (int i = 0 ; i &lt; 1000000 ; i++) {\n        random_shuffle(a + 1, a + 1 + n);\n        ans = min(ans, check());\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sqrt(ans / m) &lt;&lt; \"\\n\"; \n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/Randomization/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95/","title":"\u722c\u5c71\u7b97\u6cd5","text":"<p>P4035 [JSOI2008] \u7403\u5f62\u7a7a\u95f4\u4ea7\u751f\u5668 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble a[11][10], sum[11], dist[11], cans[11];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n + 1 ; i++) {\n        for (int j = 0 ; j &lt; n ; j++) {\n            cin &gt;&gt; a[i][j];\n            sum[j] += a[i][j];\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum[i] /= n + 1;\n    }\n    auto check = [&amp;]() {\n        double res = 0;\n        for (int i = 0 ; i &lt; n + 1 ; i++) {\n            dist[i] = cans[i] = 0;\n            for (int j = 0 ; j &lt; n ; j++) {\n                dist[i] += (a[i][j] - sum[j]) * (a[i][j] - sum[j]);\n            }\n            dist[i] = sqrt(dist[i]);\n            res += dist[i];\n        }\n        res /= n + 1;\n        for (int i = 0 ; i &lt; n + 1 ; i++) {\n            for (int j = 0 ; j &lt; n ; j++) {\n                cans[j] += (dist[i] - res) * (a[i][j] - sum[j]) / res;\n            }\n        }\n    };\n    for (double t = 10000 ; t &gt;= 1e-4 ; t *= 0.99995) {\n        check();\n        for (int i = 0 ; i &lt; n ; i++) {\n            sum[i] += cans[i] * t;\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; sum[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/","title":"AC\u81ea\u52a8\u673a(AC_Automaton)","text":"<p>P3808 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u7b80\u5355\u7248\uff09 - \u6d1b\u8c37</p> <p>P3796 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 - \u6d1b\u8c37</p> Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_1","title":"\u6c42\u6709\u591a\u5c11\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u51fa\u73b0\u8fc7\u7684\u4e2a\u6570","text":"Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    AC_Automaton *ac = new AC_Automaton();\n    string str;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; str;\n        ac -&gt; insert(str);\n    }\n    ac -&gt; build();\n    cin &gt;&gt; str;\n    cout &lt;&lt; (ac -&gt; query(str));\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_2","title":"\u6c42\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u6a21\u5f0f\u4e32","text":"Code C++<pre><code>const int N = 151;\nconst int M = N * 70;\nstruct AC_Automaton {\n    int tree_size, fail[M], nxt[M][26], val[M], idx[M];\n    int cnt[N], id_num;\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        idx[index] = ++id_num;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 ; j = fail[j]) {\n                val[j]++;\n            }\n        }\n        for (int i = 1 ; i &lt;= tree_size ; i++) {\n            if (idx[i] == 0) continue;\n            res = max(res, val[i]);\n            cnt[idx[i]] = val[i];\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    AC_Automaton *ac = new AC_Automaton();\n    while (cin &gt;&gt; n) {\n        if (n == 0) break;\n        for (int i = 0 ; i &lt; M ; i++) {\n            ac -&gt; fail[i] = 0;\n            ac -&gt; val[i] = 0;\n            ac -&gt; idx[i] = 0;\n            for (int j = 0 ; j &lt; 26 ; j++) {\n                ac -&gt; nxt[i][j] = 0;\n            }\n        }\n        for (int i = 0 ; i &lt; N ; i++) {\n            ac -&gt; cnt[i] = 0;\n        }\n        ac -&gt; id_num = 0;\n        ac -&gt; tree_size = 0;\n        vector&lt;string&gt; s(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            cin &gt;&gt; s[i];\n            ac -&gt; insert(s[i]);\n        }\n        ac -&gt; build();\n        string str;\n        cin &gt;&gt; str;\n        int ans = ac -&gt; query(str);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= n ; i++) {\n            if (ac -&gt; cnt[i] == ans) {\n                cout &lt;&lt; s[i] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/StringHash/","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"\u6a21\u7248 usageHashOneTwo <p>T \u4e00\u5b9a\u8981CV\u5230Hash\u7684\u4e0b\u65b9</p> <p>\u521d\u59cb\u5316\u54c8\u5e0c\uff0c\u6b64\u5904 T \u53ef\u4ee5\u4e3a One/Two/unsigned long long \u5206\u522b\u4ee3\u8868 \u5355\u54c8\u5e0c/\u53cc\u54c8\u5e0c/\u81ea\u7136\u6ea2\u51fa</p> Text Only<pre><code>Hash&lt;T&gt; h(str); \n</code></pre> <p>\u83b7\u53d6\u67d0\u4e00\u6bb5\u7684\u54c8\u5e0c\u503c\uff0c\u8c28\u9632\u8d8a\u754c</p> Text Only<pre><code>h.get(L, R);\n</code></pre> C++<pre><code>template&lt;class T&gt; struct Hash {\n    static vector&lt;T&gt; base;\n    vector&lt;T&gt; hashVal;\n    Hash(const string &amp;val) {\n        if (base.empty()) {\n            base = vector&lt;T&gt;();\n            base.emplace_back(T(1));\n            base.emplace_back(T(true));\n        }\n        int len = val.size() + 1;\n        int lenBase = base.size();\n        if (len &gt; lenBase) {\n            base.resize(len);\n            for (int i = lenBase ; i &lt; len ; i++) {\n                base[i] = base[i - 1] * base[1];\n            }\n        }\n        hashVal.resize(len);\n        for (int i = 1 ; i &lt; len ; i++) {\n            hashVal[i] = hashVal[i - 1] * base[1] + T(val[i - 1]);\n        }\n    }\n    T get(int L, int R) {\n        return hashVal[R] - hashVal[L - 1] * base[R - L + 1];\n    }\n}; // Hash\n</code></pre> C++<pre><code>#define base1 rand() + 1\nconst long long mod = 1000000007;\nstruct One {\n    int x;\n    One() = default;\n    One(const bool flag) : x(base1) {}\n    One(const int x) : x(x) {}\n    friend One operator+(const One &amp;lhs, const One &amp;rhs) {\n        int xVal = lhs.x &gt;= mod - rhs.x ? lhs.x + rhs.x - mod : lhs.x + rhs.x;\n        return One(xVal);\n    }\n    friend One operator-(const One &amp;lhs, const One &amp;rhs) {\n        int xVal = lhs.x &lt; rhs.x ? lhs.x - rhs.x + mod : lhs.x - rhs.x;\n        return One(xVal);\n    }\n    friend One operator*(const One &amp;lhs, const One &amp;rhs) {\n        return One(int(1LL * lhs.x * rhs.x % mod));\n    }\n    friend bool operator==(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x == rhs.x;\n    }\n    friend bool operator!=(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x != rhs.x;\n    }\n    friend bool operator&lt;(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x &lt; rhs.x;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const One &amp;one) {\n        return os &lt;&lt; one.x;\n    }\n}; // One\ntemplate&lt;&gt;\nvector&lt;One&gt; Hash&lt;One&gt;::base(0);\n</code></pre> C++<pre><code>#define base1 rand() + 1\n#define base2 23333\nconst long long mod = 1000000007;\nstruct Two {\n    int x, y;\n    Two() = default;\n    Two(const bool flag) : x(base1), y(base2) {}\n    Two(const int val) : x(val), y(val) {}\n    Two(const int x, const int y) : x(x), y(y) {}\n    friend Two operator+(const Two &amp;lhs, const Two &amp;rhs) {\n        int xVal = lhs.x &gt;= mod - rhs.x ? lhs.x + rhs.x - mod : lhs.x + rhs.x;\n        int yVal = lhs.y &gt;= mod - rhs.y ? lhs.y + rhs.y - mod : lhs.y + rhs.y;\n        return Two(xVal, yVal);\n    }\n    friend Two operator-(const Two &amp;lhs, const Two &amp;rhs) {\n        int xVal = lhs.x &lt; rhs.x ? lhs.x - rhs.x + mod : lhs.x - rhs.x;\n        int yVal = lhs.y &lt; rhs.y ? lhs.y - rhs.y + mod : lhs.y - rhs.y; \n        return Two(xVal, yVal);\n    }\n    friend Two operator*(const Two &amp;lhs, const Two &amp;rhs) {\n        return Two(int(1LL * lhs.x * rhs.x % mod), int(1LL * lhs.y * rhs.y % mod));\n    }\n    friend bool operator==(const Two &amp;lhs, const Two &amp;rhs) {\n        return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;\n    }\n    friend bool operator!=(const Two &amp;lhs, const Two &amp;rhs) {\n        return lhs.x != rhs.x &amp;&amp; lhs.y != rhs.y;\n    }\n    friend bool operator&lt;(const Two &amp;lhs, const Two &amp;rhs) {\n        if (lhs.x == rhs.x) return lhs.y &lt; rhs.y;\n        return lhs.x &lt; rhs.x;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Two &amp;two) {\n        return os &lt;&lt; two.x &lt;&lt; \" \" &lt;&lt; two.y;\n    }\n}; // Two\ntemplate&lt;&gt;\nvector&lt;Two&gt; Hash&lt;Two&gt;::base(0);\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3370 <p>P3370 \u3010\u6a21\u677f\u3011\u5b57\u7b26\u4e32\u54c8\u5e0c - \u6d1b\u8c37</p>"},{"location":"Template/String/Trie/","title":"\u5b57\u5178\u6811","text":"\u6a21\u7248 \u7ed3\u6784\u4f53 C++<pre><code>struct Trie {\n    const static int N = 100000;\n    const static int M = 26;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int find(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) return 0;\n            index = nxt[index][c];\n        }\n        return exist[index];\n    }\n}; // Trie\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P8306AcWing143(\u6700\u5927\u5f02\u6216\u5bf9) <p>P8306 \u3010\u6a21\u677f\u3011\u5b57\u5178\u6811 - \u6d1b\u8c37</p> <p>143. \u6700\u5927\u5f02\u6216\u5bf9 - AcWing\u9898\u5e93</p> <p>\\(n\\) \u4e2a\u6574\u6570 \\(a\\), \u4efb\u9009\u4e24\u4e2a\u6570\u8fdb\u884c\u5f02\u6216\uff0c\u6c42\u6700\u5927\u503c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nstruct Trie {\n    const static int N = 100000 * 30;\n    const static int M = 2;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(int x) {\n        int index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int query(int x) {\n        int res = 0, index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c ^ 1]) {\n                res |= 1 &lt;&lt; i;\n                index = nxt[index][c ^ 1];\n            } else if (nxt[index][c]) {\n                index = nxt[index][c];\n            } else {\n                return res;\n            }\n        }\n        return res;\n    }\n}; // Trie\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    Trie trie;\n    int ans = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        int res = trie.query(x);\n        ans = max(ans, res);\n        trie.insert(x);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/","title":"\u524d\u7f00\u51fd\u6570\u4e0eKMP","text":"<p>P3375 \u3010\u6a21\u677f\u3011KMP \u5b57\u7b26\u4e32\u5339\u914d - \u6d1b\u8c37</p>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_1","title":"\u524d\u7f00\u51fd\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len + 1);\n    nxt[0] = -1;\n    int j = -1;\n    for (int i = 0 ; i &lt; len ; i++) {\n        while (j != -1 &amp;&amp; str[i] != str[j]) {\n            j = nxt[j];\n        }\n        nxt[i + 1] = ++j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2, j = 0 ; i &lt; len ; i++) {\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_1","title":"KMP","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_1","title":"Base0","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    int j = 0;\n    for (int i = 0 ; i &lt; len1 ; i++) {\n        while (j != -1 &amp;&amp; str[i] != x[j]) j = nxt[j];\n        j++;\n        if (j == len2) {\n            return i - len2 + 1;\n            j = nxt[j];\n        }\n    }\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_1","title":"Base1","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    for (int i = 1, j = 0 ; i &lt; len1 ; i++) {\n        while (j &amp;&amp; str[i] != x[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == x[j + 1]) {\n            j++;\n        }\n        if (j + 1 == len2) {\n            return i - len2 + 2;\n            j = nxt[j];\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_2","title":"KMP\u5e94\u7528","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_2","title":"\u67e5\u627e\u5b50\u4e32\u51fa\u73b0\u7684\u6240\u6709\u4f4d\u7f6e","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_2","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string str, const string x) {\n    string cur = x + '#' + str;\n    int len1 = str.size(), len2 = x.size();\n    vector&lt;int&gt; pos;\n    vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 + 1 ; i++) {\n        if (nxt[i] == len2) {\n            pos.push_back(i - 2 * len2);\n        }\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_2","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string&amp; str, const string&amp; x) {\n    string cur = x + str;\n    int len1 = str.size(), len2 = x.size();\n        vector&lt;int&gt; pos;\n        vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 ; i++) {\n        if (nxt[i] == len2 - 1)\n          pos.push_back(i - 2 * (len2 - 1));\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_3","title":"\u7edf\u8ba1\u6bcf\u4e2a\u524d\u7f00\u7684\u51fa\u73b0\u6b21\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_3","title":"Base0","text":"Code C++<pre><code>string str;\ncin &gt;&gt; str;\nint len = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(len + 1);\nfor (int i = 1 ; i &lt;= len ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = len - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_3","title":"Base1","text":"Code C++<pre><code>string str, x;\nstr = \" \" + str;\nint n = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(n);\nfor (int i = 1 ; i &lt; n ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = n - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","title":"\u540e\u7f00\u6570\u7ec4","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#-onlog2n","title":"\u500d\u589e - \\(O(n\\log^2{n})\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct SuffixArray {\n    string str;\n    vector&lt;int&gt; rank, sa, nxt;\n    SuffixArray() = default;\n    SuffixArray(string s) { init(s); }\n    void init(string s) {\n        static int cnt[2000005];\n        int m = 127;\n        fill(cnt, cnt + m + 1, 0);\n        int len = s.size();\n        rank.resize(len + 1);\n        sa.resize(len + 1);\n        nxt.resize(len + 1);\n        str = \" \" + s;\n        for (int i = 1 ; i &lt;= len ; i++) {\n            cnt[rank[i] = str[i]]++;\n        }\n        for (int i = 1 ; i &lt;= m ; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        for (int i = len ; i &gt;= 1 ; i--) {\n            sa[cnt[rank[i]]--] = i;\n        }\n        for (int k = 1 ; k &lt;= len ; k &lt;&lt;= 1) {\n            int r = 0;\n            for (int i = len - k + 1 ; i &lt;= len ; i++) {\n                nxt[++r] = i;\n            }\n            for (int i = 1 ; i &lt;= len ; i++) {\n                if (sa[i] &gt; k) {\n                    nxt[++r] = sa[i] - k;\n                }\n            }\n            fill(cnt, cnt + m + 1, 0);\n            for (int i = 1 ; i &lt;= len ; i++) {\n                cnt[rank[i]]++;\n            }\n            for (int i = 1 ; i &lt;= m ; i++) {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = len ; i &gt;= 1 ; i--) {\n                sa[cnt[rank[nxt[i]]]--] = nxt[i];\n            }\n            swap(nxt, rank);\n            rank[sa[1]] = 1;\n            r = 1;\n            for (int i = 2 ; i &lt;= len ; rank[sa[i]] = r, i++) {\n                if (nxt[sa[i - 1]] != nxt[sa[i]] || nxt[sa[i - 1] + k] != nxt[sa[i] + k]) {\n                    r++;\n                }\n            }\n            if (r &gt;= len) break;\n            m = r;\n        }\n    }\n    int operator[](int x) {\n        return sa[x];\n    }\n}; // SuffixArray\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string str;\n    cin &gt;&gt; str;\n    SuffixArray sa(str);\n    int len = str.size();\n    for (int i = 1 ; i &lt;= len ; i++) {\n        cout &lt;&lt; sa[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_2","title":"\u5e94\u7528","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_3","title":"\u67e5\u627e\u5b50\u4e32","text":"Code C++<pre><code>string str, x;\ncin &gt;&gt; str &gt;&gt; x;\nSuffixArray sa(str);\nint L = 1, R = str.size();\nstr = \" \" + str;\nwhile (L &lt; R) {\n    int mid = L + R &gt;&gt; 1;\n    cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n    int k = str.compare(sa[mid], x.size(), x);\n    if (k &gt; 0) R = mid - 1;\n    else if (k &lt; 0) L = mid + 1;\n    else R = mid;\n}\nint k = -1;\nif (str.compare(sa[L], x.size(), x) == 0) k = sa[L];\ncout &lt;&lt; k &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/#ts","title":"\u4e32T\u5728\u4e32S(\u542b\u95ee\u53f7)\u4e2d\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570","text":"<p>Problem - G - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) j++;\n        nxt[i] = j;\n    }\n    return nxt;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int n = a.size(), m = b.size();\n    a = \" \" + a;\n    b = \" \" + b;\n    auto kmp = prefix(b);\n    vector nxt(m + 1, vector(26, 0));\n    for (int i = 1 ; i &lt;= m + 1 ; i++) {\n        for (int j = 0 ; j &lt; 26 ; j++) {\n            if (i &lt;= m &amp;&amp; b[i] == 'a' + j) {\n                nxt[i - 1][j] = i;\n            } else {\n                nxt[i - 1][j] = nxt[kmp[i - 1]][j];\n            }\n        }\n    }\n    vector dp(n + 1, vector(m + 1, -100000000));\n    dp[0][0] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt;= m ; j++) {\n            if (a[i] == '?') {\n                for (int k = 0 ; k &lt; 26 ; k++) {\n                    dp[i][nxt[j][k]] = max(dp[i][nxt[j][k]], dp[i - 1][j]);\n                }\n            } else {\n                dp[i][nxt[j][a[i] - 'a']] = max(dp[i][nxt[j][a[i] - 'a']], dp[i - 1][j]);\n            }\n        }\n        dp[i][m]++;\n    }\n    int mx = 0;\n    for (int i = 0 ; i &lt;= m ; i++) mx = max(mx, dp[n][i]);\n    cout &lt;&lt; mx;\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E9%A9%AC%E6%8B%89%E8%BD%A6%28Manacher%29/","title":"\u9a6c\u62c9\u8f66(Manacher)","text":"<p>P3805 \u3010\u6a21\u677f\u3011manacher \u7b97\u6cd5 - \u6d1b\u8c37</p> Code C++<pre><code>int maxLen = 0, idx = 0, r = 0, c = 0, len = (int(str.size()) &lt;&lt; 1 | 1);\nvector&lt;char&gt; a(len);\nvector&lt;int&gt; b(len);\nfor (int i = 0 ; i &lt; len ; i++) {\n    a[i] = i &amp; 1 ? str[idx++] : '#';\n}\nfor (int i = 0 ; i &lt; len ; i++) {\n    b[i] = r &gt; i ? min(r - i, b[c * 2 - i]) : 1;\n    while (i - b[i] &gt; -1 &amp;&amp; i + b[i] &lt; len &amp;&amp; a[i - b[i]] == a[i + b[i]]) {\n        b[i]++;\n    }\n    if (i + b[i] &gt; r) {\n        r = i + b[i];\n        c = i;\n    }\n    if (b[i] - 1 &gt; maxLen) {\n        maxLen = b[i] - 1;\n        idx = i;\n    }\n}\ncout &lt;&lt; maxLen &lt;&lt; \" \" &lt;&lt; str.substr((idx - maxLen + 1) / 2, maxLen);\n</code></pre>"}]}