{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5bfc\u822a\u680f","text":"<p>     \u672c\u7ad9\u603b\u8bbf\u95ee\u91cf\u6b21 </p> <p>   \u672c\u7ad9\u8bbf\u5ba2\u6570\u4eba </p>"},{"location":"#_1","title":"\u5f85\u5b8c\u5584","text":"<ul> <li>[ ] \u6570\u5b66/\u6570\u8bba/\u6b27\u62c9\u51fd\u6570 [\u6269\u5c55\u6b27\u62c9\u5b9a\u7406/\u4e60\u9898]</li> <li>[ ] \u52a8\u6001\u89c4\u5212/\u6811\u5f62dp [\u5f88\u591a\u5f88\u591a]</li> <li>[ ] \u6570\u5b66/\u6570\u503c\u7b97\u6cd5/\u62c9\u683c\u6717\u65e5 [\u4e60\u9898]</li> <li>[ ] \u6570\u5b66/\u6570\u8bba/\u540c\u4f59 [\u4e60\u9898]</li> </ul>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#dfrac1n-m","title":"\u6c42 \\(\\dfrac{1}{n}\\) \u7684\u7b2c \\(m\\) \u4f4d\u5c0f\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    cout &lt;&lt; qpow(10, m, 10 * n) / n;\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#lr-k","title":"\u6c42 L~R \u7684\u6570\u5b57\u7684\u6570\u4f4d\u4e2d\u51fa\u73b0k\u7684\u6b21\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long f[18];\nstring str;\nlong long strll;\nlong long get(int index, long long mid) {\n    mid--;\n    if (index + str.size() &gt;= 18) {\n        return 0x7fffffffffffffff;\n    }\n    if (str[0] == '0') {\n        mid += f[index];\n    }\n    long long p = mid % f[index];\n    long long q = mid / f[index];\n    return q * f[index + str.size()] + strll * f[index] + p;\n}\nvoid solve() {\n    cin &gt;&gt; str;\n    strll = 0;\n    for (auto&amp; i : str) {\n        strll = strll * 10 + i - '0';\n    }\n    auto get_sum = [&amp;](long long x) {\n        long long ans = 0;\n        for (int i = 0 ; i &lt; 16 ; i++) {\n            long long L = 0, R = f[16 - str.size()];\n            while (L &lt; R) {\n                long long mid = L + R + 1 &gt;&gt; 1;\n                if (get(i, mid) &lt;= x) {\n                    L = mid;\n                } else {\n                    R = mid - 1;\n                }\n            }\n            ans += L;\n        }\n        return ans;\n    };\n    long long L, R;\n    cin &gt;&gt; L &gt;&gt; R;\n    cout &lt;&lt; get_sum(R) - get_sum(L - 1) &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    f[0] = 1;\n    for (int i = 1 ; i &lt; 18 ; i++) {\n        f[i] = f[i - 1] * 10;\n    }\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#_1","title":"\u6c42\u6240\u6709\u5b50\u533a\u95f4\u5f02\u6216\u7684\u548c \u548c \u6240\u6709\u5b50\u533a\u95f4\u548c\u7684\u5f02\u6216","text":"<p>\u9898\u76ee\u8be6\u60c5 - \u5c0fQ\u7684\u65e0\u654c\u5f02\u6216 - HydroOJ</p> Code C++<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint n;\nvector&lt;int&gt; tree;\nint lowbit(int x){\n    return (x)&amp;(-x);\n}\nvoid add(int x, int v){\n    while (x &lt;= n + 1) {\n        tree[x] += v;\n        x += lowbit(x);\n    }\n}\nint query(int x){\n    int res = 0;\n    while (x) {\n        res += tree[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nconst long long mod = 998244353;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    vector&lt;long long&gt; sum(n + 1);\n    vector&lt;int&gt; sumXor(n + 1);\n    tree.resize(n + 2);\n    for(int i = 1 ; i &lt;= n ; i++){\n        cin &gt;&gt; a[i];\n        sumXor[i] = sumXor[i - 1] ^ a[i];\n        sum[i] = sum[i - 1] + a[i];\n    }\n    long long ans1 = 0, ans2 = 0;\n    for (int i = 20 ; i &gt;= 0 ; i--) {\n        int cnt[2] = {0, 0};\n        for (int j = 0 ; j &lt;= n ; j++) {\n            int k = sumXor[j] &gt;&gt; i &amp; 1;\n            ans1 = (ans1 + cnt[k ^ 1] * (1LL &lt;&lt; i) % mod) % mod;\n            cnt[k]++;\n        }\n    }\n    vector&lt;long long&gt; p(n + 1);\n    auto get = [&amp;](long long x) -&gt; int {\n        return upper_bound(begin(p), end(p), x) - begin(p);\n    };\n    for (int i = 35 ; i &gt;= 0 ; i--){\n        long long res = 0;\n        for(int j = 0 ; j &lt;= n ; j++) {\n            p[j] = sum[j] &amp; ((1LL &lt;&lt; i + 1) - 1);\n        }\n        sort(begin(p), end(p));\n        fill(begin(tree), end(tree), 0);\n        for (int j = 0 ; j &lt;= n ; j++) {\n            long long k = sum[j] &amp; ((1LL &lt;&lt; i + 1) - 1);\n            add(get(k), 1);\n            int t1 = query(get(k - (1LL &lt;&lt; i)));\n            int t2 = query(get(k + (1LL &lt;&lt; i)));\n            int t3 = query(get(k));\n            res += t1 + t2 - t3;\n        }\n        if (res &amp; 1) {\n            ans2 |= 1LL &lt;&lt; i;\n        }\n    }\n    cout &lt;&lt; ans1 &lt;&lt; \" \" &lt;&lt; ans2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#_2","title":"\u6c42 \u4e0d\u76f8\u4ea4\u533a\u95f4\u5f02\u6216\u7684\u4e58\u79ef\u7684\u548c","text":"\\[ \\begin{align} f(L,R)&amp;=sumXor[R]\\oplus{}sumXor[L-1]\\\\ g&amp;=\\sum_{1\\le{L_1}\\le{R_1}&lt;{L_2}\\leq{R_2}&lt;{L_3}\\le{R_3}&lt;{n}}f(L_1,R_1)\\times{f(L_2,R_2)}\\times{f(L_2,R_2)} \\end{align} \\] Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst long long mod = 998244353;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1), sumXor(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        sumXor[i] = sumXor[i - 1] xor a[i];\n    }\n    vector&lt;long long&gt; s(n + 1, 1), f(n + 1);\n    for (auto&amp; _ : {1, 2, 3}) {\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            long long cnt[2] = {0, 0};\n            for (int j = 0 ; j &lt;= n ; j++) {\n                int k = sumXor[j] &gt;&gt; i &amp; 1;\n                f[j] = (f[j] + (cnt[k ^ 1] &lt;&lt; i)) % mod;\n                cnt[k] = (cnt[k] + s[j]) % mod;\n            }\n        }\n        s[0] = 0;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            s[i] = (s[i - 1] + f[i]) % mod;\n            f[i] = 0;\n        }\n    }\n    cout &lt;&lt; s[n];\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#fracpq","title":"\u6c42 \\(\\frac{p}{q}\\) \u7684 \u5faa\u73af\u8282\u957f\u5ea6","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nlong long euler_phi(long long n) {\n    long long ans = n;\n    for (long long i = 2 ; i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n * (n - 1);\n    }\n    return ans;\n}\n\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = (__int128) res * a % mod;\n        }\n        a = (__int128) a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    long long p, q;\n    cin &gt;&gt; p &gt;&gt; q;\n    long long k = __gcd(p, q);\n    p /= k;\n    q /= k;\n    int cnt2 = 0, cnt5 = 0;\n    while (q % 2 == 0) {\n        q /= 2;\n        cnt2++;\n    }\n    while (q % 5 == 0) {\n        q /= 5;\n        cnt5++;\n    }\n    if (q == 1) {\n        cout &lt;&lt; -1;\n    } else {\n        cout &lt;&lt; max(cnt2, cnt5) &lt;&lt; \" \";\n        long long ans = 0x7fffffffffffffff;\n        long long phi = euler_phi(q);\n        for (long long i = 1 ; i * i &lt;= phi ; i++) {\n            if (phi % i == 0) {\n                if (qpow(10, i, q) == 1) {\n                    ans = min(ans, i);\n                }\n                if (qpow(10, phi / i, q) == 1) {\n                    ans = min(ans, phi / i);\n                }\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#_3","title":"\u5e26\u5220\u9664\u9006\u5e8f\u5bf9","text":"<p>P3157 [CQOI2011] \u52a8\u6001\u9006\u5e8f\u5bf9 - \u6d1b\u8c37</p>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#-","title":"\u5728\u7ebf-\u5206\u5757","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 1000005;\nint a[N];\nstruct FenwickTree {\n    int mx;\n    vector&lt;long long&gt; sum;\n    FenwickTree(int N) {\n        mx = N;\n        sum.resize(N + 1);\n    }\n    static int lowbit(int x) {\n        return x &amp; -x;\n    }\n    void add(int x, int k) {\n        while (x &lt;= mx) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n    long long query(int x) {\n        long long res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n};\nstruct Block {\n    vector&lt;int&gt; st, ed, bel, sz, pos;\n    vector&lt;bool&gt; exist;\n    vector&lt;FenwickTree&gt; ft;\n    int size;\n    long long ans;\n    Block(int n) {\n        ans = 0;\n        int m = sqrt(n);\n        int k = n / m + 1;\n        ft.resize(k + 1, FenwickTree(n + 1));\n        st.resize(k + 1);\n        ed.resize(k + 1);\n        sz.resize(k + 1);\n        exist.resize(n + 1, false);\n        bel.resize(n + 1);\n        pos.resize(n + 1);\n        int cnt = 0;\n        size = 1;\n        st[1] = 1;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            pos[a[i]] = i;\n            if (cnt == m) {\n                cnt = 0;\n                size++;\n                st[size] = i;\n                ed[size - 1] = i - 1;\n            }\n            bel[i] = size;\n            cnt++;\n            sz[size]++;\n        }\n        ed[size] = n;\n        for (int i = 1 ; i &lt;= size ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                ft[i].add(a[j], 1);\n            }\n        }\n        FenwickTree fft(n + 1);\n        for (int i = n ; i &gt;= 1 ; i--) {\n            ans += fft.query(a[i]);\n            fft.add(a[i], 1);\n        }\n    }\n    void remove(int x) {\n        int now = pos[x], be = bel[now];\n        for (int i = st[be] ; i &lt; now ; i++) {\n            if (exist[i]) continue;\n            if (a[i] &gt; x) ans--;\n        }\n        for (int i = now + 1 ; i &lt;= ed[be] ; i++) {\n            if (exist[i]) continue;\n            if (a[i] &lt; x) ans--;\n        }\n        exist[now] = true;\n        for (int i = 1 ; i &lt; be ; i++) {\n            ans -= sz[i] - ft[i].query(x);\n        }\n\n        for (int i = be + 1 ; i &lt;= size ; i++) {\n            ans -= ft[i].query(x);\n        }\n        ft[be].add(x, -1);\n        sz[be]--;\n    }\n    long long query() {\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    Block block(n);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        cout &lt;&lt; block.query() &lt;&lt; \"\\n\";\n        block.remove(x);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#_4","title":"\u8be2\u95ee\u4e09\u4e2a\u533a\u95f4\uff0c\u628a\u4e09\u4e2a\u533a\u95f4\u4e2d\u540c\u65f6\u51fa\u73b0\u7684\u6570\u4e00\u4e2a\u4e00\u4e2a\u5220\u6389\uff0c\u95ee\u6700\u540e\u4e09\u4e2a\u533a\u95f4\u5269\u4e0b\u7684\u6570\u7684\u4e2a\u6570\u548c","text":"<p>P4688 [Ynoi2016] \u6389\u8fdb\u5154\u5b50\u6d1e - \u6d1b\u8c37 | \u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u65b0\u751f\u6001 (luogu.com.cn)</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nint belong[100005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        if (belong[L] &amp; 1) return R &lt; x.R;\n        return R &gt; x.R;\n    }\n};\nvector&lt;int&gt; c(1);\nbitset&lt;100001&gt; bs[100000 / 3 + 1], res;\nint cnt[100005];\nint a[100005];\nbool vis[100005];\nint n;\nvoid add(int x) {\n    res[cnt[x] + x] = 1;\n    cnt[x]++;\n}\nvoid del(int x) {\n    cnt[x]--;\n    res[cnt[x] + x] = 0;\n}\nvoid solve(int q) {\n    vector&lt;MQuery&gt; mq;\n    vector&lt;int&gt; ans(q);\n    for (int i = 0 ; i &lt; q ; i++) {\n        for (int j = 0 ; j &lt; 3 ; j++) {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            mq.emplace_back(L, R, i);\n            ans[i] += R - L + 1;\n        }\n    }\n    sort(begin(mq), end(mq));\n    fill(vis, vis + n + 1, false);\n    fill(cnt, cnt + n + 1, 0);\n    res.reset();\n    for (int i = 0, L = 1, R = 0 ; i &lt; 3 * q ; i++) {\n        while (L &gt; mq[i].L) add(a[--L]);\n        while (R &lt; mq[i].R) add(a[++R]);\n        while (L &lt; mq[i].L) del(a[L++]);\n        while (R &gt; mq[i].R) del(a[R--]);\n        if (vis[mq[i].idx]) bs[mq[i].idx] &amp;= res;\n        else {\n            vis[mq[i].idx] = true;\n            bs[mq[i].idx] = res;\n        }\n    }\n    for (int i = 0 ; i &lt; q ; i++) {\n        ans[i] -= bs[i].count() * 3;\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int q;\n    cin &gt;&gt; n &gt;&gt; q;\n    int mx = sqrt(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        belong[i] = i / mx;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        c.emplace_back(a[i]);\n    }\n    sort(begin(c), end(c));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(c), end(c), a[i]) - begin(c);\n    }\n    int B = q / 3;\n    solve(B);\n    solve(B);\n    solve(q - 2 * B);\n    return 0;\n}\n</code></pre>"},{"location":"Template/%E6%9D%82%E9%A2%98%281%29/#nlr","title":"n\u6392\u5217\uff0c\u6c42\u6709\u591a\u5c11\u5b50\u533a\u95f4[L,R]\u6ee1\u8db3\u533a\u95f4\u6700\u5927\u503c\u51fa\u73b0\u5728\u533a\u95f4\u6700\u5c0f\u503c\u7684\u53f3\u4fa7","text":"<p>Problem - E - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; p(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; p[i];\n    }\n    vector&lt;int&gt; min_L(n + 2, 0), min_R(n + 2, n + 1), max_L(n + 2, 0), max_R(n + 2, n + 1);\n    stack&lt;int&gt; smin, smax;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        while (!smin.empty() &amp;&amp; p[i] &lt; p[smin.top()]) {\n            min_R[smin.top()] = i;\n            smin.pop();\n        }\n        if (!smin.empty()) {\n            min_L[i] = smin.top();\n        }\n        smin.emplace(i);\n        while (!smax.empty() &amp;&amp; p[i] &gt; p[smax.top()]) {\n            max_R[smax.top()] = i;\n            smax.pop();\n        }\n        if (!smax.empty()) {\n            max_L[i] = smax.top();\n        }\n        smax.emplace(i);\n    }\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int L = max_L[i], R = max_R[i];\n        if (R - i &lt; i - L) {\n            int now = n;\n            for (int j = i ; j &lt; R ; j++) {\n                now = min(now, min_L[j]);\n                ans += max(0, now - L);\n            }\n        } else {\n            int now = i;\n            for (int j = i ; j &gt; L ; j--) {\n                if (p[j] &lt; p[now]) {\n                    now = j;\n                }\n                if (now != i) {\n                    ans += max(0, min(min_R[now], R) - i);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/Pick%E5%AE%9A%E7%90%86/","title":"Pick \u5b9a\u7406","text":"<p>\u7ed9\u5b9a\u9876\u70b9\u5747\u4e3a\u6574\u70b9\u7684\u7b80\u5355\u591a\u8fb9\u5f62\uff0c\u76ae\u514b\u5b9a\u7406\u8bf4\u660e\u4e86\u5176\u9762\u79ef \\(A\\) \u548c\u5185\u90e8\u683c\u70b9\u6570\u76ee \\(a\\) \u3001\u8fb9\u4e0a\u683c\u70b9\u6570\u76ee \\(b\\) \u7684\u5173\u7cfb\uff1a\\(A=a+\\dfrac{b}{2}-1\\)</p>"},{"location":"Template/ComputationalGeometry/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/","title":"\u4e09\u89d2\u5256\u5206","text":""},{"location":"Template/ComputationalGeometry/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/#_2","title":"\u6a21\u677f","text":"Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nstruct Edge {\n    int idx;\n    list&lt;Edge&gt;::iterator nxt;\n    Edge(int idx = 0) : idx(idx) {}\n};\nlist&lt;Edge&gt; head[100005];\nint idx[100005], n;\nvector&lt;pair&lt;Point, int&gt;&gt; points;\nvoid addEdge(int u, int v) {\n    head[u].emplace_front(v);\n    head[v].emplace_front(u);\n    begin(head[u]) -&gt; nxt = begin(head[v]);\n    begin(head[v]) -&gt; nxt = begin(head[u]);\n}\nvoid Delaunay(int L, int R) {\n    if (R - L &lt; 3) {\n        for (int i = L ; i &lt;= R ; i++) {\n            for (int j = i + 1 ; j &lt;= R ; j++) {\n                addEdge(i, j);\n            }\n        }\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Delaunay(L, mid);\n    Delaunay(mid + 1, R);\n    int _L = L, _R = R;\n    for (bool up = true ; up ; ) {\n        up = false;\n        Point pL = points[_L].first, pR = points[_R].first;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pR, pL, t));\n            if (res &gt; 0 || (res == 0 &amp;&amp; sgn(distance(pR, t) - distance(pR, pL)) &lt; 0)) {\n                _L = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n        if (up) continue;\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pL, pR, t));\n            if (res &lt; 0 || (res == 0 &amp;&amp; sgn(distance(pL, t) - distance(pL, pR)) &lt; 0)) {\n                _R = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n    }\n    addEdge(_L, _R);\n    while (true) {\n        Point pL = points[_L].first, pR = points[_R].first;\n        int ch = -1, side = 0;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            if (sgn(cross(pL, pR, points[it -&gt; idx].first)) &gt; 0 &amp;&amp; (ch == -1 || pointCircleRelation(points[it -&gt; idx].first, Circle(pL, pR, points[ch].first)) == 0)) {\n                ch = it -&gt; idx;\n                side = -1;\n            }\n        }\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            if (sgn(cross(pR, points[it -&gt; idx].first, pL)) &gt; 0 &amp;&amp; (ch == -1 || pointCircleRelation(points[it -&gt; idx].first, Circle(pL, pR, points[ch].first)) == 0)) {\n                ch = it -&gt; idx;\n                side = 1;\n            }\n        }\n        if (ch == -1) break;\n        if (side == -1) {\n            for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n                if (lineCrossRelation(Line(pL, points[it -&gt; idx].first), Line(pR, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_L].erase(it);\n                }\n            }\n            _L = ch;\n            addEdge(_L, _R);\n        } else {\n            for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n                if (lineCrossRelation(Line(pR, points[it -&gt; idx].first), Line(pL, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_R].erase(it);\n                }\n            }\n            _R = ch;\n            addEdge(_L, _R);\n        }\n    }\n}\nvector&lt;pair&lt;int, int&gt;&gt; getEdge() {\n    vector&lt;pair&lt;int, int&gt;&gt; res;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (auto it = begin(head[i]) ; it != end(head[i]) ; it++) {\n            if (it -&gt; idx &lt; i) continue;\n            res.emplace_back(points[i].second, points[it -&gt; idx].second);\n        }\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        points.emplace_back(Point(x, y), i);\n    }\n    sort(begin(points), end(points));\n    for (int i = 0 ; i &lt; n ; i++) {\n        idx[points[i].second] = i;\n    }\n    Delaunay(0, n - 1);\n    auto res = getEdge();\n    for (auto &amp;[x, y] : res) {\n        cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/#lca","title":"\u4e09\u89d2\u5256\u5206+\u500d\u589eLCA","text":"<p>Problem - 99999383 - Codeforces</p> Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nstruct Edge {\n    int idx;\n    list&lt;Edge&gt;::iterator nxt;\n    Edge(int idx = 0) : idx(idx) {}\n};\nlist&lt;Edge&gt; head[100005];\nint n;\nvector&lt;pair&lt;Point, int&gt;&gt; points;\nvoid addEdge(int u, int v) {\n    head[u].emplace_front(v);\n    head[v].emplace_front(u);\n    begin(head[u]) -&gt; nxt = begin(head[v]);\n    begin(head[v]) -&gt; nxt = begin(head[u]);\n}\nvoid Delaunay(int L, int R) {\n    if (R - L &lt; 3) {\n        for (int i = L ; i &lt;= R ; i++) {\n            for (int j = i + 1 ; j &lt;= R ; j++) {\n                addEdge(i, j);\n            }\n        }\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Delaunay(L, mid);\n    Delaunay(mid + 1, R);\n    int _L = L, _R = R;\n    for (bool up = true ; up ; ) {\n        up = false;\n        Point pL = points[_L].first, pR = points[_R].first;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pR, pL, t));\n            if (res &gt; 0 || (res == 0 &amp;&amp; sgn(distance(pR, t) - distance(pR, pL)) &lt; 0)) {\n                _L = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n        if (up) continue;\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            Point t = points[it -&gt; idx].first;\n            int res = sgn(cross(pL, pR, t));\n            if (res &lt; 0 || (res == 0 &amp;&amp; sgn(distance(pL, t) - distance(pL, pR)) &lt; 0)) {\n                _R = it -&gt; idx;\n                up = true;\n                break;\n            }\n        }\n    }\n    addEdge(_L, _R);\n    while (true) {\n        Point pL = points[_L].first, pR = points[_R].first;\n        int ch = -1, side = 0;\n        for (auto it = begin(head[_L]) ; it != end(head[_L]) ; it++) {\n            if (sgn(cross(pL, pR, points[it -&gt; idx].first)) &gt; 0 &amp;&amp; (ch == -1 || inCircle(points[it -&gt; idx].first, pL, pR, points[ch].first) &lt; 0)) {\n                ch = it -&gt; idx;\n                side = -1;\n            }\n        }\n        for (auto it = begin(head[_R]) ; it != end(head[_R]) ; it++) {\n            if (sgn(cross(pR, points[it -&gt; idx].first, pL)) &gt; 0 &amp;&amp; (ch == -1 || inCircle(points[it -&gt; idx].first, pL, pR, points[ch].first) &lt; 0)) {\n                ch = it -&gt; idx;\n                side = 1;\n            }\n        }\n        if (ch == -1) break;\n        if (side == -1) {\n            for (auto it = begin(head[_L]) ; it != end(head[_L]) ; ) {\n                if (segmentCrossRelation(Line(pL, points[it -&gt; idx].first), Line(pR, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_L].erase(it++);\n                } else {\n                    it++;\n                }\n            }\n            _L = ch;\n            addEdge(_L, _R);\n        } else {\n            for (auto it = begin(head[_R]) ; it != end(head[_R]) ; ) {\n                if (segmentCrossRelation(Line(pR, points[it -&gt; idx].first), Line(pL, points[ch].first)) == 2) {\n                    head[it -&gt; idx].erase(it -&gt; nxt);\n                    head[_R].erase(it++);\n                } else {\n                    it++;\n                }\n            }\n            _R = ch;\n            addEdge(_L, _R);\n        }\n    }\n}\nstruct Node {\n    int u, v;\n    Tdouble d;\n    Node() = default;\n    Node(int u, int v, Tdouble d) : u(u), v(v), d(d) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return sgn(d - x.d) &lt; 0;\n    }\n};\nvector&lt;Node&gt; getEdge() {\n    vector&lt;Node&gt; res;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (auto it = begin(head[i]) ; it != end(head[i]) ; it++) {\n            if (it -&gt; idx &lt; i) continue;\n            res.emplace_back(points[i].second, points[it -&gt; idx].second, distance(points[i].first, points[it -&gt; idx].first));\n        }\n    }\n    return res;\n}\nint f[100005];\nint find(int x) {\n    return f[x] == x ? x : f[x] = find(f[x]);\n}\nvector&lt;pair&lt;int, double&gt;&gt; adj[100005];\nint fa[100005][21], deep[100005];\nTdouble val[100005][21];\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; (1 &lt;&lt; i) &lt;= deep[u] ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        val[u][i] = max(val[u][i - 1], val[fa[u][i - 1]][i - 1]);\n    }\n    for (auto &amp;[v, d] : adj[u]) {\n        if (v == p) continue;\n        val[v][0] = d;\n        dfs(v, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &gt; deep[y]) swap(x, y);\n    for (int i = 20 ; i &gt;= 0 ; i--) {\n        if (deep[x] &gt; deep[fa[y][i]]) continue;\n        y = fa[y][i];\n    }\n    if (x == y) return x;\n    for (int i = 20 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nTdouble calc(int x, int y) {\n    Tdouble res = 0;\n    while (x != y) {\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == 0 || deep[fa[x][i]] &lt; deep[y]) continue;\n            res = max(res, val[x][i]);\n            x = fa[x][i];\n        }\n    }\n    return res;\n}\nTdouble solve(int u, int v) {\n    int k = LCA(u, v);\n    return max(calc(u, k), calc(v, k));\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        points.emplace_back(Point(x, y), i);\n    }\n    sort(begin(points), end(points));\n    Delaunay(0, n - 1);\n    auto res = getEdge();\n    sort(begin(res), end(res));\n    int len = res.size();\n    iota(f, f + n + 1, 0);\n    for (int i = 0 ; i &lt; len ; i++) {\n        auto [u, v, d] = res[i];\n        u++;\n        v++;\n        int x = find(u), y = find(v);\n        if (x == y) continue;\n        f[x] = y;\n        adj[u].emplace_back(v, d);\n        adj[v].emplace_back(u, d);\n    }\n    dfs(1, 0);\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; solve(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/","title":"\u51f8\u5305","text":""},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#_2","title":"\u4e8c\u7ef4\u51f8\u5305","text":"<p>P2742 [USACO5.1] \u5708\u5976\u725bFencing the Cows /\u3010\u6a21\u677f\u3011\u4e8c\u7ef4\u51f8\u5305 - \u6d1b\u8c37</p>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#andrew-oncdotlogn","title":"Andrew - \\(O(n\\cdot\\log{n})\\)","text":"Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nint st[100005];\nbool used[100005];\nvector&lt;Point&gt; ConvexHull2D(vector&lt;Point&gt; &amp;p) {\n    sort(begin(p), end(p));\n    int len = p.size(), top = 0;\n    for (int i = 0 ; i &lt; len ; i++) {\n        used[i] = false;\n    }\n    st[++top] = 0;\n    for (int i = 1 ; i &lt; len ; i++) {\n        while (top &gt; 1 &amp;&amp; sgn(cross(p[st[top]] - p[st[top - 1]], p[i] - p[st[top]])) &lt;= 0) {\n            used[st[top--]] = false;\n        }\n        used[i] = true;\n        st[++top] = i;\n    }\n    int temp = top;\n    for (int i = len - 2 ; i &gt;= 0 ; i--) {\n        if (used[i]) continue;\n        while (top &gt; temp &amp;&amp; sgn(cross(p[st[top]] - p[st[top - 1]], p[i] - p[st[top]])) &lt;= 0) {\n            used[st[top--]] = false;\n        }\n        used[i] = true;\n        st[++top] = i;\n    }\n    vector&lt;Point&gt; res;\n    for (int i = 1 ; i &lt;= top ; i++) {\n        res.emplace_back(p[st[i]]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto b = ConvexHull2D(a);\n    Tdouble ans = 0;\n    int len = b.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(b[i], b[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#graham-oncdotlogn","title":"Graham - \\(O(n\\cdot\\log{n})\\)","text":"Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nint st[100005];\nvector&lt;Point&gt; ConvexHull2D(vector&lt;Point&gt; &amp;p) {\n    sort(begin(p) + 1, end(p), [&amp;](const Point &amp;x, const Point &amp;y) {\n        Tdouble temp = cross(x - p[0], y - p[0]);\n        if (sgn(temp) == 1) return true;\n        return sgn(temp) == 0 &amp;&amp; distance(x, p[0]) &lt; distance(y, p[0]);\n    });\n    int len = p.size(), top = 0;\n    st[++top] = 0;\n    for (int i = 1 ; i &lt; len ; i++) {\n        while (top &gt; 1 &amp;&amp; sgn(cross(p[st[top - 1]] - p[st[top]], p[st[top]] - p[i])) &lt;= 0) {\n            top--;\n        }\n        st[++top] = i;\n    }\n    st[++top] = 0;\n    vector&lt;Point&gt; res;\n    for (int i = 1 ; i &lt;= top ; i++) {\n        res.emplace_back(p[st[i]]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n        if (a[i].y &lt; a[0].y || (a[i].y == a[0].y &amp;&amp; a[i].x &lt; a[0].x)) {\n            swap(a[i], a[0]);\n        }\n    }\n    auto b = ConvexHull2D(a);\n    Tdouble ans = 0;\n    int len = b.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(b[i], b[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#_3","title":"\u4f8b\u9898","text":"<p>P3829 [SHOI2012] \u4fe1\u7528\u5361\u51f8\u5305 - \u6d1b\u8c37</p> Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    Tdouble a, b, r;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; r;\n    a -= 2 * r;\n    b -= 2 * r;\n    Tdouble L = sqrt(a * a + b * b) / 2;\n    Tdouble phi = atan(a / b);\n    vector&lt;Point&gt; c;\n    for (int i = 0 ; i &lt; n ; i++) {\n        Tdouble x, y, theta;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; theta;\n        {\n            Tdouble dx = cos(theta + phi) * L;\n            Tdouble dy = sin(theta + phi) * L;\n            c.emplace_back(x + dx, y + dy);\n            c.emplace_back(x - dx, y - dy);\n        }\n        {\n            Tdouble dx = cos(theta - phi) * L;\n            Tdouble dy = sin(theta - phi) * L;\n            c.emplace_back(x + dx, y + dy);\n            c.emplace_back(x - dx, y - dy);\n        }\n    }\n    auto res = ConvexHull2D(c);\n    Tdouble ans = 0;\n    int len = res.size();\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        ans += distance(res[i], res[i + 1]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans + 2 * PI * r &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#_4","title":"\u4e09\u7ef4\u51f8\u5305","text":"<p>P4724 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u51f8\u5305 - \u6d1b\u8c37</p>"},{"location":"Template/ComputationalGeometry/%E5%87%B8%E5%8C%85/#_5","title":"\u6a21\u677f","text":"Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nFace st[2005];\nFace temp[2005];\nbool vis[2005][2005];\nvector&lt;Face&gt; ConvexHull3D(const vector&lt;Point3D&gt; &amp;p) {\n    int cnt = 2;\n    temp[1] = {{p[0], 0}, {p[1], 1}, {p[2], 2}};\n    temp[2] = {{p[2], 2}, {p[1], 1}, {p[0], 0}};\n    int len = p.size();\n    for (int i = 3, top = 0 ; i &lt; len ; i++) {\n        for (int j = 1, v ; j &lt;= cnt ; j++) {\n            if (!(v = temp[j].see(p[i]))) {\n                st[++top] = temp[j];\n            }\n            for (int k = 0 ; k &lt; 3 ; k++) {\n                vis[temp[j][k]][temp[j][(k + 1) % 3]] = v;\n            }\n        }\n        for (int j = 1 ; j &lt;= cnt ; j++) {\n            for (int k = 0 ; k &lt; 3 ; k++) {\n                int x = temp[j][k], y = temp[j][(k + 1) % 3];\n                if (vis[x][y] &amp;&amp; !vis[y][x]) {\n                    st[++top] = {{p[x], x}, {p[y], y}, {p[i], i}};\n                }\n            }\n        }\n        for (int j = 1 ; j &lt;= top ; j++) {\n            temp[j] = st[j];\n        }\n        cnt = top;\n        top = 0;\n    }\n    vector&lt;Face&gt; res;\n    for (int i = 1 ; i &lt;= cnt ; i++) {\n        res.emplace_back(temp[i]);\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point3D&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n        a[i].shake();\n    }\n    auto res = ConvexHull3D(a);\n    Tdouble ans = 0;\n    int len = res.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        ans += res[i].area();\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/","title":"\u534a\u5e73\u9762\u4ea4","text":""},{"location":"Template/ComputationalGeometry/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/#_2","title":"\u6a21\u677f","text":"<p>P4196 [CQOI2006] \u51f8\u591a\u8fb9\u5f62 /\u3010\u6a21\u677f\u3011\u534a\u5e73\u9762\u4ea4 - \u6d1b\u8c37</p> Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\nvector&lt;Point&gt; points[10];\nvector&lt;Line&gt; lines;\nint deq[505];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int m;\n        cin &gt;&gt; m;\n        points[i].resize(m);\n        for (int j = 0 ; j &lt; m ; j++) {\n            cin &gt;&gt; points[i][j];\n        }\n        for (int j = 0 ; j &lt; m ; j++) {\n            lines.emplace_back(points[i][j], points[i][(j + 1) % m]);\n        }\n    }\n    sort(begin(lines), end(lines));\n    lines.resize(unique(begin(lines), end(lines)) - begin(lines));\n    auto check = [&amp;](int i, int j, int k) {\n        Point x = getLineIntersection(lines[j], lines[k]);\n        return sgn(cross(x, lines[i].p1, lines[i].p2)) &lt; 0;\n    };\n    int L = 1, R = 0;\n    deq[++R] = 0;\n    deq[++R] = 1;\n    int len = lines.size();\n    for (int i = 2 ; i &lt; len ; i++) {\n        while (L &lt; R &amp;&amp; check(i, deq[R], deq[R - 1])) {\n            R--;\n        }\n        while (L &lt; R &amp;&amp; check(i, deq[L], deq[L + 1])) {\n            L++;\n        }\n        deq[++R] = i;\n    }\n    while (L &lt; R &amp;&amp; check(deq[L], deq[R - 1], deq[R])) {\n        R--;\n    }\n    while (L &lt; R &amp;&amp; check(deq[R], deq[L], deq[L + 1])) {\n        L++;\n    }\n    vector&lt;Point&gt; res;\n    for (int i = L ; i &lt; R ; i++) {\n        res.emplace_back(getLineIntersection(lines[deq[i]], lines[deq[i + 1]]));\n    }\n    if (R - L &gt; 1) {\n        res.emplace_back(getLineIntersection(lines[deq[R]], lines[deq[L]]));\n    }\n    len = res.size();\n    Tdouble ans = 0;\n    for (int i = 0 ; i &lt; len ; i++) {\n        ans += cross(res[i], res[(i + 1) % len]);\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; fabs(ans) / 2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E5%9F%BA%E7%A1%80/","title":"\u57fa\u7840","text":""},{"location":"Template/ComputationalGeometry/%E5%9F%BA%E7%A1%80/#_2","title":"\u51e0\u4f55\u516c\u5f0f","text":""},{"location":"Template/ComputationalGeometry/%E5%9F%BA%E7%A1%80/#_3","title":"\u4e09\u89d2\u5f62","text":"<p>\u5468\u957f \\(P=\\dfrac{a+b+c}{2}\\)</p> <p>\u9762\u79ef \\(S=\\dfrac{\u4f4e*\u9ad8}{2}=\\dfrac{ab\\cdot\\sin{C}}{2}=\\sqrt{P\\cdot(P-a)\\cdot(P-b)\\cdot(P-c)}\\)</p> <p>\u4e2d\u7ebf \\(Ma=\\dfrac{\\sqrt{2b^2+2c^2-a^2}}{2}=\\dfrac{\\sqrt{b^2+c^2+2\\cdot{b}\\cdot{c}\\cdot\\cos(A)}}{2}\\)</p> <p>\u89d2\u5e73\u5206\u7ebf \\(Ta=\\dfrac{\\sqrt{b\\cdot{c}\\cdot((b+c)^2-a^2)}}{b+c}=\\dfrac{2\\cdot{b}\\cdot{c}\\cdot\\cos(\\frac{A}{2})}{b+c}\\)</p> <p>\u9ad8 \\(Ha=b\\cdot\\sin(C)=c\\cdot\\sin(B)=\\sqrt{b^2-{(\\frac{a^2+b^2-c^2}{2a})}^2}\\)</p> <p>\u5916\u5207\u5706\u534a\u5f84 \\(R=\\dfrac{a\\cdot{b}\\cdot{c}}{4S}=\\dfrac{a}{2\\sin(A)}=\\dfrac{b}{2\\sin(B)}=\\dfrac{c}{2\\sin(C)}\\)</p> <p>\u5185\u5207\u5706\u534a\u5f84 \\(r=\\dfrac{S}{P}=\\dfrac{arcsin(\\frac{B}{2})\\cdot\\sin(\\frac{C}{2})}{\\sin(\\frac{B+C}{2})}=4R\\cdot\\sin(\\frac{A}{2})\\cdot\\sin(\\frac{B}{2})\\cdot\\sin(\\frac{C}{2})=P\\cdot\\tan(\\frac{A}{2})\\cdot\\tan(\\frac{B}{2})\\cdot\\tan(\\frac{C}{2})\\)</p>"},{"location":"Template/ComputationalGeometry/%E5%9F%BA%E7%A1%80/#_4","title":"\u56db\u8fb9\u5f62","text":"<p>\\(D_1\\)\u3001\\(D_2\\) \u4e3a\u5bf9\u89d2\u7ebf\uff0cM\u662f\u5bf9\u89d2\u7ebf\u4e2d\u70b9\u7684\u8fde\u7ebf\uff0cA\u4e3a\u5bf9\u89d2\u7ebf\u5939\u89d2</p> <p>\\(a^2+b^2+c^2+d^2=D_1^2+D_2^2+4M^2\\)</p> <p>\\(S=\\dfrac{D_1\\cdot{D_2}\\cdot\\sin(A)}{2}\\)</p> <p>// \u5706\u7684\u5185\u63a5\u56db\u8fb9\u5f62</p> <p>\\(a\\cdot{c}+b\\cdot{d}=D_1\\cdot{D_2}\\)</p> <p>\\(S=\\sqrt{(P-a)\\cdot(P-b)\\cdot(P-c)\\cdot(P-d)}\\)</p>"},{"location":"Template/ComputationalGeometry/%E5%9F%BA%E7%A1%80/#n","title":"\u6b63n\u8fb9\u5f62","text":"<p>R\u4e3a\u5916\u63a5\u5706\u534a\u5f84\uff0cr\u4e3a\u5185\u5207\u5706\u534a\u5f84</p> <p>\u4e2d\u5fc3\u89d2 \\(A=\\dfrac{2\\pi}{n}\\)</p> <p>\u5185\u89d2 \\(C=\\dfrac{(n-2)\\cdot\\pi}{n}\\)</p> <p>\u8fb9\u957f \\(a=2\\sqrt{R * R - r * r}\\)</p> Code C++<pre><code>// \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 OneWan\n    using Tdouble = double;\n    const Tdouble eps = 1e-9;\n    const Tdouble PI = acos(-1.0);\n    Tdouble Rand() {\n        return rand() / (Tdouble) RAND_MAX;\n    }\n    Tdouble reps() {\n        return (Rand() - 0.5) * eps;\n    }\n    int sgn(Tdouble x) { // \u5224\u65ad x \u7684\u7b26\u53f7\n        if (fabs(x) &lt; eps) return 0;\n        if (x &lt; 0) return -1;\n        return 1;\n    }\n    struct Point {\n        Tdouble x, y;\n        Point() = default;\n        Point(Tdouble x, Tdouble y) : x(x), y(y) {}\n        Point rotate(Point base, Tdouble rad) { // \u7ed5\u70b9base \u9006\u65f6\u9488\u65cb\u8f6c rad \u5f27\u5ea6\n            Point v(x - base.x, y - base.y);\n            Tdouble si = sin(rad), co = cos(rad);\n            return Point(base.x + v.x * co - v.y * si, base.y + v.x * si +  v.y * co);\n        }\n    }; // \u70b9\n    Point operator*(Point lhs, Tdouble rhs) {\n        return Point(lhs.x * rhs, lhs.y * rhs);\n    }\n    Point operator/(Point lhs, Tdouble rhs) {\n        return Point(lhs.x / rhs, lhs.y / rhs);\n    }\n    bool operator&lt;(const Point &amp;lhs, const Point &amp;rhs) {\n        return sgn(lhs.x - rhs.x) &lt; 0 || (sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) &lt; 0);\n    }\n    bool operator==(const Point &amp;lhs, const Point &amp;rhs) {\n        return !sgn(lhs.x - rhs.x) &amp;&amp; !sgn(lhs.y - rhs.y);\n    }\n    istream &amp;operator&gt;&gt;(istream &amp;is, Point &amp;point) {\n        return is &gt;&gt; point.x &gt;&gt; point.y;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point point) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; point.x &lt;&lt; \" \" &lt;&lt; point.y;\n    }\n    Tdouble distance(Point a, Point b) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    Tdouble distance2(Point a, Point b) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u5e73\u65b9\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n    struct Vector {\n        Tdouble x, y;\n        Vector() = default;\n        Vector(Tdouble x, Tdouble y) : x(x), y(y) {}\n        Tdouble length() { // \u5411\u91cf\u7684\u6a21\u957f\n            return sqrt(x * x + y * y);\n        }\n        Tdouble length2() { // \u5411\u91cf\u7684\u6a21\u957f\u7684\u5e73\u65b9\n            return x * x + y * y;\n        }\n        Tdouble getAngle() const { // \u5411\u91cf\u4e0ex\u8f74\u6b63\u65b9\u5411\u7684\u6781\u89d2\n            return atan2(y, x);\n        }\n        Vector normal() { // \u5355\u4f4d\u6cd5\u5411\u91cf(\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0)\n            assert(!sgn(x) &amp;&amp; !sgn(y));\n            Tdouble len = length();\n            return Vector(-y / len, x / len);\n        }\n        Vector format() { // \u5355\u4f4d\u5411\u91cf\n            Tdouble len = length();\n            return Vector(x / len, y / len);\n        }\n        Vector rotate(Tdouble rad) { // \u9006\u65f6\u9488\u65cb\u8f6c rad \u5f27\u5ea6\n            Tdouble si = sin(rad), co = cos(rad);\n            return Vector(x * co - y * si, x * si + y * co);\n        }\n        Vector rotateLeft() { // \u5de6\u65cb 90\u00b0\n            return Vector(-y, x);\n        }\n        Vector rotateRight() { // \u53f3\u65cb 90\u00b0\n            return Vector(y, -x);\n        }\n    }; // \u5411\u91cf\n    istream &amp;operator&gt;&gt;(istream &amp;is, Vector &amp;vec) {\n        return is &gt;&gt; vec.x &gt;&gt; vec.y;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vector vec) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; vec.x &lt;&lt; \" \" &lt;&lt; vec.y;\n    }\n    Vector operator+(const Vector lhs, const Vector rhs) { // \u5411\u91cf+\u5411\u91cf=\u5411\u91cf\n        return Vector(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Vector operator-(const Point lhs, const Point rhs) { // \u70b9-\u70b9=\u5411\u91cf\n        return Vector(lhs.x - rhs.x, lhs.y - rhs.y);\n    }\n    Point operator+(const Point lhs, const Point rhs) { // \u70b9+\u70b9=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator+(const Point lhs, const Vector rhs) { // \u70b9+\u5411\u91cf=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator+(const Vector lhs, const Point rhs) { // \u5411\u91cf+\u70b9=\u70b9\n        return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    Point operator-(const Point lhs, const Vector rhs) { // \u70b9-\u5411\u91cf=\u70b9\n        return Point(lhs.x - rhs.x, lhs.y - rhs.y);\n    }\n    Vector operator*(Vector lhs, Tdouble rhs) {\n        return Vector(lhs.x * rhs, lhs.y * rhs);\n    }\n    Vector operator/(Vector lhs, Tdouble rhs) {\n        return Vector(lhs.x / rhs, lhs.y / rhs);\n    }\n    Tdouble dot(Vector A, Vector B) { // \u5411\u91cf\u70b9\u79ef\n        return A.x * B.x + A.y * B.y;\n    }\n    Tdouble cross(Point A, Point B) { // \u5411\u91cf\u53c9\u79ef\n        return A.x * B.y - B.x * A.y;\n    }\n    Tdouble cross(Vector A, Vector B) { // \u5411\u91cf\u53c9\u79ef\n        return A.x * B.y - B.x * A.y;\n    }\n    Tdouble cross(Point A, Point B, Point C) { // \u5411\u91cf\u53c9\u79ef\n        return cross(B - A, C - A);\n    }\n    Tdouble angle(Vector A, Vector B) { // \u8ba1\u7b97\u5939\u89d2(\u5f27\u5ea6\u5236)\n        return acos(dot(A, B) / A.length() / B.length());\n    }\n    Tdouble area2(Point a, Point b, Point c) { // \u8ba1\u7b97\u4e24\u5411\u91cf\u6784\u6210\u7684\u5e73\u884c\u56db\u8fb9\u5f62\u6709\u5411\u9762\u79ef\n        return cross(b - a, c - a);\n    }\n    struct Line {\n        Vector v;\n        Point p1, p2;\n        Line() = default;\n        Line(Point a, Vector v) : v(v), p1(a), p2(a + v) {}\n        Line(Point a, Point b) : v(b - a), p1(a), p2(b) {}\n        Point getPoint(Tdouble t) { // \u83b7\u53d6\u76f4\u7ebf\u4e0a\u4e00\u70b9\n            return v * t + p1;\n        }\n        bool isVertical(Line x) { // \u4e24\u7ebf\u662f\u5426\u5782\u76f4\n            return sgn(dot(v, x.v)) == 0;\n        }\n        bool isParallel(Line x) { // \u4e24\u7ebf\u662f\u5426\u5e73\u884c\n            return sgn(cross(v, x.v)) == 0;\n        }\n    };\n    bool operator&lt;(const Line &amp;lhs, const Line &amp;rhs) {\n        Tdouble delta = lhs.v.getAngle() - rhs.v.getAngle();\n        if (sgn(delta) == 0) {\n            Vector a = rhs.p1 - lhs.p1, b = rhs.p2 - lhs.p1;\n            return cross(a, b) &gt; 0;\n        }\n        return delta &lt; 0;\n    }\n    bool operator==(const Line &amp;lhs, const Line &amp;rhs) {\n        return sgn(lhs.v.getAngle() - rhs.v.getAngle()) == 0;\n    }\n    int pointLineRelation(Point A, Point B, Point C) { // \u5224\u65ad\u70b9\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n        return sgn(cross(C - B, A - B));\n    }\n    int pointLineRelation(Point A, Line L) { // \u5224\u65ad\u70b9\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n        return sgn(cross(L.p2 - L.p1, A - L.p1));\n    }\n    int lineCrossRelation(Line A, Line B) { // \u5224\u65ad\u76f4\u7ebf\u4e0e\u76f4\u7ebf\u95f4\u7684\u5173\u7cfb\n        // 0 \u5e73\u884c; 1 \u91cd\u5408; 2 \u76f8\u4ea4;\n        if (A.isParallel(B)) return (pointLineRelation(B.p1, A) == 0);\n        return 2;\n    }\n    bool segmentIntersection(Point A1, Point A2, Point B1, Point B2, bool contain = true) { // \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4(\u9ed8\u8ba4\u542b\u7aef\u70b9)\n        double c1 = cross(A2 - A1, B1 - A1), c2 = cross(A2 - A1, B2 - A1);\n        double c3 = cross(B2 - B1, A1 - B1), c4 = cross(B2 - B1, A2 - B1);\n        if (contain) return sgn(c1) * sgn(c2) &lt;= 0 &amp;&amp; sgn(c3) * sgn(c4) &lt;= 0;\n        return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(c3) * sgn(c4) &lt; 0;\n    }\n    bool onSegment(Point P, Point A, Point B) { // \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\n        return sgn(cross(A - P, B - P)) == 0 &amp;&amp; sgn(dot(A - P, B - P)) &lt;= 0;\n    }\n    bool onSegment(Point P, Line L) { // \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a\n        Point s = L.p1, e = L.p2; \n        return onSegment(P, s, e);\n    }\n    int segmentLineRelation(Line seg, Line line) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u76f4\u7ebf\u7684\u5173\u7cfb\n        // 0 \u4e0d\u76f8\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n        int r1 = sgn(cross(line.v, seg.p1 - line.p1));\n        int r2 = sgn(cross(line.v, seg.p2 - line.p1));\n        if (r1 * r2 &lt; 0) return 2;\n        return (r1 == 0 || r2 == 0);\n    }\n    int segmentCrossRelation(Line a, Line b) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u7ebf\u6bb5\u7684\u5173\u7cfb\n        // 0 \u4e0d\u60f3\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n        int r1 = segmentLineRelation(a, b);\n        int r2 = segmentLineRelation(b, a);\n        if (r1 == 2 &amp;&amp; r2 == 2) return 2;\n        if (r1 == 1 || r2 == 1) {\n            return onSegment(b.p1, a) || onSegment(b.p2, a) || onSegment(a.p1, b) || onSegment(a.p2, b);\n        }\n        return 0;\n    }\n    Point getLineIntersection(Line A, Line B) { // \u4e24\u76f4\u7ebf\u4ea4\u70b9\n        assert(cross(A.v, B.v) != 0);\n        Vector u = A.p1 - B.p1;\n        Tdouble t = cross(B.v, u) / cross(A.v, B.v);\n        return A.p1 + A.v * t;\n    }\n    Tdouble distanceLine(Point P, Point A, Point B) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector v1 = B - A, v2 = P - A;\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceLine(Point P, Line x) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector v1 = x.v, v2 = P - x.p1;\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceSegment(Point P, Point A, Point B) { // \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\n        if (A == B) return (P - A).length();\n        Vector v1 = B - A, v2 = P - A, v3 = P - B;\n        if (sgn(dot(v1, v2)) &lt; 0) return v2.length();\n        if (sgn(dot(v1, v3)) &gt; 0) return v3.length();\n        return fabs(cross(v1, v2) / v1.length());\n    }\n    Tdouble distanceSegment(Point P, Line S) { // \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb\n        return distanceSegment(P, S.p1, S.p2);\n    }\n    Point lineProjection(Point P, Line x) { // \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9\n        return getLineIntersection(Line(P, x.v.rotateLeft()), x);\n    }\n    Point lineProjection(Point P, Point A, Point B) { // \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9\n        return lineProjection(P, Line(A, B));\n    }\n    Point footPoint(Point P, Point A, Point B) { // \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3\n        Vector x = P - A, y = P - B, z = B - A;\n        double len1 = dot(x, z) / z.length(), len2 = -1.0 * dot(y, z) / z.length();\n        return A + z * (len1 / (len1 + len2));\n    }\n    Point footPoint(Point P, Line X) { // \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3\n        Vector x = P - X.p1, y = P - X.p2, z = X.v;\n        double len1 = dot(x, z) / z.length(), len2 = -1.0 * dot(y, z) / z.length();\n        return X.p1 + z * (len1 / (len1 + len2));\n    }\n    Point symmetry(Point P, Line x) { // \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9\n        Point t = lineProjection(P, x);\n        return Point(2 * t.x - P.x, 2 * t.y - P.y);\n    }\n    Point symmetry(Point P, Point A, Point B) { // \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9\n        return symmetry(P, Line(A, B));\n    }\n    int pointTriangleRelation(Point P, Point A, Point B, Point C) { // \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb\n        // 1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n        if (P == A || P == B || P == C) return 4;\n        Vector v[3];\n        v[0] = A - P;\n        v[1] = B - P;\n        v[2] = C - P;\n        Tdouble z[3];\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            z[i] = fabs(cross(v[i], v[(i + 1) % 3]));\n        }\n        Tdouble S = fabs(cross(A - C, B - C));\n        if ((S - z[0] - z[1] - z[2]) &lt; 0) return 2;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            if (sgn(z[i]) == 0) return 3;\n        }\n        return 1;\n    }\n    Tdouble polygonArea(const vector&lt;Point&gt; &amp;points) { // \u6c42\u591a\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef\n        Tdouble area = 0.0;\n        int len = points.size();\n        for (int i = 1 ; i &lt; len - 1 ; i++) {\n            area += cross(points[i] - points[0], points[i + 1] - points[0]);\n        }\n        return area / 2.0;\n    }\n    Point polygonCenter(const vector&lt;Point&gt; &amp;points) { // \u6c42\u591a\u8fb9\u5f62\u91cd\u5fc3\n        Point res(0, 0);\n        Tdouble area = polygonArea(points);\n        if (sgn(area) == 0) return res;\n        int len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            res = res + (points[i] + points[(i + 1) % len]) * cross(points[i], points[(i + 1) % len]);\n        }\n        return res / area / 6.0;\n    }\n    int pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points) { // \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb\n        // 0 \u5728\u5916; 1 \u5728\u5185; 2 \u5728\u8fb9\u4e0a; 3 \u5728\u9876\u70b9\u4e0a;\n        int cnt = 0, len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            if (P == points[i]) return 3;\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            int j = (i + 1) % len;\n            if (onSegment(P, Line(points[i], points[j]))) return 2;\n            int c = sgn(cross(P - points[j], points[i] - points[j]));\n            int u = sgn(points[i].y - P.y);\n            int v = sgn(points[j].y - P.y);\n            if (c &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0) cnt++;\n            if (c &lt; 0 &amp;&amp; u &gt;= 0 &amp;&amp; v &lt; 0) cnt--;\n        }\n        return cnt != 0;\n    }\n    int segmentPolygonRelation(Line S, const vector&lt;Point&gt; &amp;points) { // \u7ebf\u7aef\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb\n        // 0 \u89c4\u8303\u76f8\u4ea4(\u4e0d\u542b\u7aef\u70b9); 1 \u5185\u76f8\u4ea4; 2 \u5185\u4e0d\u76f8\u4ea4; 3 \u4e0d\u76f8\u4ea4;\n        if (pointPolygonRelation(S.p1, points) == 1 &amp;&amp; pointPolygonRelation(S.p2, points) == 1) {\n            return 2;\n        }\n        vector&lt;Point&gt; temp;\n        int len = points.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            Line a(points[i], points[(i + 1) % len]);\n            if (segmentCrossRelation(S, a) == 2) return 0;\n            else if (onSegment(S.p1, a)) temp.emplace_back(S.p1);\n            else if (onSegment(S.p2, a)) temp.emplace_back(S.p2);\n            if (onSegment(points[i], S)) temp.emplace_back(points[i]);\n        }\n        sort(begin(temp), end(temp));\n        len = temp.size();\n        for (int i = 1 ; i &lt; len ; i++) {\n            if (pointPolygonRelation((temp[i] + temp[i - 1]) / 2, points) == 1) return 1;\n        }\n        return 3;\n    }\n    int gridOnEdge(const vector&lt;Point&gt; &amp;points) { // \u591a\u8fb9\u5f62\u4e0a\u7f51\u683c\u70b9\u4e2a\u6570\n        int len = points.size();\n        int res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            res += __gcd(llabs(points[i].x - points[(i + 1) % len].x), llabs(points[i].y - points[(i + 1) % len].y));\n        }\n        return res;\n    }\n    int gridInSide(const vector&lt;Point&gt; &amp;points) { // \u591a\u8fb9\u5f62\u5185\u7f51\u683c\u70b9\u4e2a\u6570\n        int len = points.size();\n        int res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            res += points[(i + 1) % len].y * (points[i].x - points[(i + 2) % len].x);\n        }\n        return (llabs(res) - gridOnEdge(points)) / 2 + 1;\n    }\n    struct Circle {\n        Point c;\n        Tdouble r;\n        Circle() = default;\n        Circle(Point c, Tdouble r) : c(c), r(r) {}\n        Circle(Point A, Point B, Point C) {\n            Tdouble x11 = A.x * A.x + A.y * A.y;\n            Tdouble x22 = B.x * B.x + B.y * B.y;\n            Tdouble D = (x22 - (C.x * C.x + C.y * C.y)) * (A.y - B.y) - (x11 - x22) * (B.y - C.y);\n            D /=  (A.x - B.x) * (B.y - C.y) - (B.x - C.x) * (A.y - B.y);\n            Tdouble E = x11 - x22 + D * (A.x - B.x);\n            E /= B.y - A.y;\n            Tdouble F = -(x11 + D * A.x + E * A.y);\n            c = Point(-D / 2.0, -E / 2.0);\n            r = (D * D + E * E - 4 * F) / 4.0;\n        }\n        Point getPoint(Tdouble a) { // a \u4e3a\u5706\u5fc3\u89d2\n            return Point(c.x + cos(a) * r, c.y + sin(a) * r);\n        }\n    };\n    int pointCircleRelation(Point P, Circle C) { // \u5224\u65ad\u70b9\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = (P.x - C.c.x) * (P.x - C.c.x) + (P.y - C.c.y) * (P.y - C.c.y);\n        return 1 - sgn(dis - C.r * C.r);\n    }\n    int segmentCircleRelation(Line S, Circle C) { // \u5224\u65ad\u7ebf\u6bb5\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = distanceSegment(C.c, S);\n        int flag = sgn(dis - C.r);\n        if (flag &lt; 0) return 2;\n        else if (flag == 0) return 1;\n        return 0;\n    }\n    int lineCircleRelation(Line L, Circle C) { // \u5224\u65ad\u76f4\u7ebf\u548c\u5706\u7684\u5173\u7cfb\n        // 0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n        Tdouble dis = distanceLine(C.c, L);\n        int flag = sgn(dis - C.r);\n        if (flag &lt; 0) return 2;\n        else if (flag == 0) return 1;\n        return 0;\n    }\n    int circleCrossRelation(Circle C1, Circle C2) { //\u5224\u65ad\u4e24\u5706\u4e4b\u95f4\u7684\u5173\u7cfb\n        // 5 \u76f8\u79bb; 4 \u5916\u5207; 3 \u76f8\u4ea4; 2 \u5185\u5207; 1 \u5185\u542b;\n        Tdouble d = (C1.c - C2.c).length();\n        int k = sgn(d - (C1.r + C2.r));\n        if (k &gt; 0) return 5;\n        if (k == 0) return 4;\n        Tdouble dif = fabs(C1.r - C2.r);\n        int k2 = sgn(d - dif);\n        if (k &lt; 0 &amp;&amp; k2 &gt; 0) return 3;\n        if (k2 == 0) return 2;\n        return 1;\n    }\n    vector&lt;Point&gt; getLineCircleIntersection(Line L, Circle C) { // \u5706\u4e0e\u76f4\u7ebf\u4ea4\u70b9\n        Tdouble a = L.v.x, b = L.p1.x - C.c.x, c = L.v.y, d = L.p1.y - C.c.y;\n        Tdouble e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;\n        Tdouble delta = f * f - 4 * e * g;\n        if (sgn(delta) &lt; 0) {\n            return {};\n        }\n        if (sgn(delta) == 0) {\n            return {L.getPoint(-f / (2.0 * e))};\n        }\n        Tdouble sqr = sqrt(delta);\n        return {L.getPoint((-f - sqr) / (2.0 * e)), L.getPoint((-f + sqr) / (2.0 * e))};\n    }\n    vector&lt;Point&gt; getSegmentCircleIntersection(Line S, Circle C) { // \u7ebf\u6bb5\u548c\u5706\u7684\u4ea4\u70b9\n        Point proj = lineProjection(C.c, S);\n        Tdouble d1 = distance(C.c, proj);\n        if (!onSegment(proj, S)) {\n            d1 = min(distance(C.c, S.p1), distance(C.c, S.p2));\n        }\n        if (sgn(d1 - C.r) &gt; 0) return {};\n        Tdouble d2 = sqrt(C.r * C.r - distance(C.c, proj) * distance(C.c, proj));\n        if (sgn(d2) == 0) {\n            return {proj};\n        }\n        Vector v = S.v.format() * d2;\n        return {proj - v, proj + v};\n    }\n    vector&lt;Point&gt; getCircleIntersection(Circle C1, Circle C2) { // \u4e24\u5706\u4ea4\u70b9\n        int r = circleCrossRelation(C1, C2);\n        if (r == 1 || r == 5) return {};\n        Tdouble d1 = distance(C1.c, C2.c);\n        Tdouble len = (d1 * d1 + C1.r * C1.r - C2.r * C2.r) / (2 * d1);\n        Tdouble h = sqrt(C1.r * C1.r - len * len);\n        Vector u = C2.c - C1.c, v = u.rotateLeft();\n        Point proj = C1.c + u.format() * len;\n        Vector temp = v.format() * h;\n        if (r == 2 || r == 4) return {proj + temp};\n        return {proj + temp, proj - temp};\n    }\n    vector&lt;Line&gt; getCircleTangents(Point P, Circle C) { // \u70b9\u5230\u5706\u7684\u5207\u7ebf\n        int flag = pointCircleRelation(P, C);\n        if (flag == 2) return {};\n        if (flag == 1) {\n            return {Line(P, P + (P - C.c).rotateLeft())};\n        }\n        Tdouble d = distance(P, C.c);\n        Tdouble len = C.r * C.r / d;\n        Tdouble h = sqrt(C.r * C.r - len * len);\n        Point proj = C.c + (P - C.c).format() * len;\n        Vector temp = (P - C.c).format().rotateLeft() * h;\n        return {Line(P, proj + temp), Line(P, proj - temp)};\n    }\n    Tdouble circleOverlap2(Circle C1, Circle C2) { // \u4e24\u5706\u9762\u79ef\u4ea4\n        double d = (C1.c - C2.c).length();\n        if (sgn(C1.r + C2.r - d) == -1) {\n            return 0.0;\n        }\n        if (sgn(fabs(C1.r - C2.r) - d) == 1) {\n            Tdouble r = min(C1.r, C2.r);\n            return PI * r * r;\n        }\n        Tdouble x = (d * d + C1.r * C1.r - C2.r * C2.r) / (2.0 * d);\n        Tdouble p = (C1.r + C2.r + d) / 2.0;\n        Tdouble t1 = acos(x / C1.r);\n        Tdouble t2 = acos((d - x) / C2.r);\n        Tdouble s1 = C1.r * C1.r * t1;\n        Tdouble s2 = C2.r * C2.r * t2;\n        Tdouble s3 = 2 * sqrt(p * (p - C1.r) * (p - C2.r) * (p - d));\n        return s1 + s2 - s3;\n    }\n    Point nearPointToCircle(Point P, Circle C) { // \u5706\u4e0a\u8ddd\u79bbP\u6700\u8fd1\u7684\u70b9\n        Vector z = P - C.c;\n        Tdouble len = z.length();\n        if (sgn(len) == 0) return P;\n        Tdouble sign = (C.c.x - P.x) * (C.c.y - P.y) &lt; 0 ? -1 : 1;\n        Tdouble a1 = C.r * fabs(C.c.x - P.x) / len;\n        Tdouble a2 = C.r * fabs(C.c.y - P.y) / len * sign;\n        Point u(C.c.x + a1, C.c.y + a2), v(C.c.x - a1, C.c.y - a2);\n        return (u - P).length() &lt; (v - P).length() ? u : v;\n    }\n    Circle getCircumCircle(Point A, Point B, Point C) { // \u5916\u63a5\u5706\n        Tdouble Bx = B.x - A.x, By = B.y - A.y;\n        Tdouble Cx = C.x - A.x, Cy = C.y - A.y;\n        Tdouble D = 2.0 * (Bx * Cy - By * Cx);\n        Tdouble ansX = A.x + (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D;\n        Tdouble ansY = A.y + (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D;\n        Point c(ansX, ansY);\n        return Circle(c, (A - c).length());\n    }\n    Circle getInscribedCircle(Point A, Point B, Point C) { // \u5185\u63a5\u5706\n        Tdouble a = (B - C).length();\n        Tdouble b = (C - A).length();\n        Tdouble c = (A - B).length();\n        Point p = (A * a + B * b + C * c) / (a + b + c);\n        return Circle(p, distanceLine(p, A, B));\n    }\n    struct Point3D {\n        Tdouble x, y, z;\n        Point3D() = default;\n        Point3D(Tdouble x, Tdouble y, Tdouble z) : x(x), y(y), z(z) {}\n        Point3D(Point P) : x(P.x), y(P.y), z(P.x * P.x + P.y * P.y) {}\n        void shake() {\n            x += reps();\n            y += reps();\n            z += reps();\n        }\n    };\n    bool operator==(const Point3D &amp;lhs, const Point3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) == 0 &amp;&amp; sgn(lhs.z - rhs.z) == 0;\n    }\n    istream &amp;operator&gt;&gt;(istream &amp;is, Point3D &amp;point) {\n        return is &gt;&gt; point.x &gt;&gt; point.y &gt;&gt; point.z;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point3D point) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; point.x &lt;&lt; \" \" &lt;&lt; point.y &lt;&lt; \" \" &lt;&lt; point.z;\n    }\n    struct Vector3D {\n        Tdouble x, y, z;\n        Vector3D() = default;\n        Vector3D(Point3D P) : x(P.x), y(P.y), z(P.z) {}\n        Vector3D(Tdouble x, Tdouble y, Tdouble z) : x(x), y(y), z(z) {}\n        Tdouble length() const {\n            return sqrtl(x * x + y * y + z * z);\n        }\n        Vector3D format() { // \u5355\u4f4d\u5411\u91cf\n            Tdouble len = length();\n            return Vector3D(x / len, y / len, z / len);\n        }\n    };\n    istream &amp;operator&gt;&gt;(istream &amp;is, Vector3D &amp;vec) {\n        return is &gt;&gt; vec.x &gt;&gt; vec.y &gt;&gt; vec.z;\n    }\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vector3D vec) {\n        return os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; vec.x &lt;&lt; \" \" &lt;&lt; vec.y &lt;&lt; \" \" &lt;&lt; vec.z;\n    }\n    bool operator==(const Vector3D &amp;lhs, const Vector3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) == 0 &amp;&amp; sgn(lhs.y - rhs.y) == 0 &amp;&amp; sgn(lhs.z - rhs.z) == 0;\n    }\n    bool operator!=(const Vector3D &amp;lhs, const Vector3D &amp;rhs) {\n        return sgn(lhs.x - rhs.x) != 0 || sgn(lhs.y - rhs.y) != 0 || sgn(lhs.z - rhs.z) != 0;\n    }\n    Vector3D operator+(const Vector3D lhs, const Vector3D rhs) { // \u5411\u91cf+\u5411\u91cf=\u5411\u91cf\n        return Vector3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Vector3D operator-(const Point3D lhs, const Point3D rhs) { // \u70b9-\u70b9=\u5411\u91cf\n        return Vector3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n    }\n    Point3D operator+(const Point3D lhs, const Point3D rhs) { // \u70b9+\u70b9=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator+(const Point3D lhs, const Vector3D rhs) { // \u70b9+\u5411\u91cf=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator+(const Vector3D lhs, const Point3D rhs) { // \u5411\u91cf+\u70b9=\u70b9\n        return Point3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n    }\n    Point3D operator-(const Point3D lhs, const Vector3D rhs) { // \u70b9-\u5411\u91cf=\u70b9\n        return Point3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n    }\n    Vector3D operator*(const Vector3D lhs, const Tdouble rhs) {\n        return Vector3D(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);\n    }\n    Tdouble distance(Point3D A, Point3D B) { // \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n        return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) + (A.z - B.z) * (A.z - B.z));\n    }\n    Vector3D cross(Vector3D A, Vector3D B) { // \u4e09\u7ef4\u53c9\u79ef\n        return Vector3D(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);\n    }\n    Vector3D cross(Point3D A, Point3D B, Point3D C) { // \u4e09\u7ef4\u53c9\u79ef\n        return cross(B - A, C - A);\n    }\n    Tdouble dot(Vector3D A, Vector3D B) { // \u4e09\u7ef4\u70b9\u79ef\n        return A.x * B.x + A.y * B.y + A.z * B.z;\n    }\n    int inCircle(Point P, Point A, Point B, Point C) { // \u70b9\u4e0e\u5706\u7684\u5173\u7cfb\n        // -1 \u5185; 0 \u4e0a; 1 \u5916; \n        if (cross(A, B, C) &lt; 0) swap(B, C);\n        Point3D p(P), a(A), b(B), c(C);\n        Vector3D p1(p - a), a1(a), b1(b - a), c1(c - a);\n        return sgn(dot(p1, cross(b1, c1)));\n    }\n    struct Line3D {\n        Vector3D v;\n        Point3D p1, p2;\n        Line3D() = default;\n        Line3D(Point3D a, Vector3D v) : v(v), p1(a), p2(a + v) {}\n        Line3D(Point3D a, Point3D b) : v(b - a), p1(a), p2(b) {}\n        Point3D getPoint3D(Tdouble t) { // \u5f97\u5230\u7ebf\u4e0a\u4e00\u70b9\n            return v * t + p1;\n        }\n        bool isVertical(Line3D x) { // \u5224\u65ad\u5782\u76f4\n            return sgn(dot(v, x.v)) == 0;\n        }\n        bool isParallel(Line3D x) { // \u5224\u65ad\u5e73\u884c\n            return sgn(cross(v, x.v).length()) == 0;\n        }\n    };\n    Tdouble distanceLine(Point3D P, Line3D x) { // \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb\n        Vector3D v1 = x.v, v2 = P - x.p1;\n        return fabs(cross(v1, v2).length() / v1.length());\n    }\n    Point3D getLineIntersection(Line3D A, Line3D B) { // \u4e24\u76f4\u7ebf\u4ea4\u70b9\n        Vector3D u = cross(B.v, A.p1 - B.p1);\n        Vector3D v = cross(A.v, B.v);\n        Tdouble flag = dot(u, v);\n        if (sgn(flag) &gt; 0) return A.p1 + A.v * (u.length() / v.length());\n        return A.p1 + A.v * (-u.length() / v.length());\n    }\n    Line3D getPlaneIntersection(Line3D A, Line3D B) { // \u4e24\u9762\u4ea4\u7ebf\n        // A, B\u4e3a\u6cd5\u5411\u91cf \u8d77\u70b9\u5728\u5e73\u9762\u4e0a\n        Vector3D v = cross(A.v, B.v);\n        Tdouble d1 = -dot(Vector3D(A.p1), A.v);\n        Tdouble d2 = -dot(Vector3D(B.p1), B.v);\n        Tdouble x = 0, y = 0, z = 0;\n        if (sgn(v.x)) {\n            y = (A.v.z * d2 - B.v.z * d1) / (A.v.y * B.v.z - B.v.y * A.v.z);\n            z = (B.v.y * d1 - A.v.y * d2) / (A.v.y * B.v.z - B.v.y * A.v.z);\n        } else if (sgn(v.y)) {\n            x = (A.v.z * d2 - B.v.z * d1) / (A.v.x * B.v.z - B.v.x * A.v.z);\n            z = (B.v.x * d1 - A.v.x * d2) / (A.v.x * B.v.z - B.v.x * A.v.z);\n        } else {\n            x = (A.v.y * d2 - B.v.y * d1) / (A.v.x * B.v.y - B.v.x * A.v.y);\n            y = (B.v.x * d1 - A.v.x * d2) / (A.v.x * B.v.y - B.v.x * A.v.y);\n        }\n        return Line3D(Point3D(x, y, z), v);\n    }\n    int point3DTriangleRelation(Point3D P, Point3D A, Point3D B, Point3D C) { // \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb\n        // 1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n        if (P == A || P == B || P == C) return 4;\n        Vector3D v[3];\n        v[0] = A - P;\n        v[1] = B - P;\n        v[2] = C - P;\n        Tdouble z[3];\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            z[i] = fabs(cross(v[i], v[(i + 1) % 3]).length());\n        }\n        Tdouble S = fabs(cross(A - C, B - C).length());\n        if (sgn(S - z[0] - z[1] - z[2]) &lt; 0) return 2;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            if (sgn(z[i]) == 0) return 3;\n        }\n        return 1;\n    }\n    struct Face {\n        pair&lt;Point3D, int&gt; x, y, z;\n        Face() = default;\n        Face(pair&lt;Point3D, int&gt; x, pair&lt;Point3D, int&gt; y, pair&lt;Point3D, int&gt; z) : x(x), y(y), z(z) {}\n        Vector3D normal() const { // \u6cd5\u5411\u91cf\n            return cross(x.first, y.first, z.first);\n        }\n        Tdouble area() { // \u9762\u79ef\n            return normal().length() / 2.0;\n        }\n        bool see(Point3D P) { // \u662f\u5426\u5728\u5e73\u9762\u4e0a\n            return sgn(dot(normal(), P - x.first)) &gt; 0;\n        }\n        int operator[](int pos) {\n            if (pos == 0) return x.second;\n            if (pos == 1) return y.second;\n            if (pos == 2) return z.second;\n            return -1;\n        }\n    };\n    Point3D lineFaceIntersection(Line3D L, Point3D A, Point3D B, Point3D C) { // \u7ebf\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9\n        Vector3D v = cross(A, B, C);\n        Tdouble vt = dot(L.v, v);\n        assert(sgn(vt) != 0);\n        return L.getPoint3D(dot(A, v) / vt);\n    }\n/*\n    \u70b9\u7ed5\u70b9\u9006\u65f6\u9488\u65cb\u8f6c    Point::rotate(Point base, Tdouble rad)\n    \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb     distance(Point a, Point b) \n                   distance(Point3D A, Point3D B)\n    \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u7684\u5e73\u65b9 distance2(Point a, Point b)\n    \u6a21\u957f         Vector::length()\n    \u6a21\u957f\u7684\u5e73\u65b9         Vector::length2()\n    \u4e0ex\u8f74\u6b63\u65b9\u5411\u5939\u89d2 Vector::getAngle()\n    \u5355\u4f4d\u6cd5\u5411\u91cf(\u9006\u65f6\u948890\u00b0) Vector::normal()\n    \u5355\u4f4d\u5411\u91cf       Vector::format()\n    \u5411\u91cf\u9006\u65f6\u9488\u65cb\u8f6c  Vector::rotate(Tdouble rad)\n    \u5411\u91cf\u5de6\u65cb90\u00b0  Vector::rotateLeft()\n    \u5411\u91cf\u53f3\u65cb90\u00b0  Vector::rotateRight()\n    \u5411\u91cf\u70b9\u79ef  dot(Vector A, Vector B)\n            dot(Vector3D A, Vector3D B)\n    \u5411\u91cf\u53c9\u79ef  cross(Vector A, Vector B)\n            cross(Point A, Point B)\n            cross(Point A, Point B, Point C)\n            cross(Vector3D A, Vector3D B)\n            cross(Point3D A, Point3D B, Point3D C)\n    \u5411\u91cf\u5939\u89d2 angle(Vector A, Vector B)\n    \u5411\u91cf\u6784\u6210\u5e73\u884c\u56db\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef area2(Point a, Point b, Point c)\n    \u76f4\u7ebf\u4e0a\u4e00\u70b9 Line::getPoint(Tdouble t)\n            Line3D::getPoint3D(Tdouble t)\n    \u5224\u65ad\u76f4\u7ebf\u5782\u76f4 Line::isVertical(Line x)\n                Line3D:;isVertical(Line3D x)\n    \u5224\u65ad\u76f4\u7ebf\u5e73\u884c Line::isParallel(Line x)\n            Line3D::isParallel(Line3D x)\n    \u70b9\u548c\u76f4\u7ebf\u5173\u7cfb pointLineRelation(Point A, Line L)\n              pointLineRelation(Point A, Point B, Point C)\n              1 \u5de6\u4fa7; -1 \u53f3\u4fa7; 0 \u5728\u76f4\u7ebf\u4e0a;\n    \u76f4\u7ebf\u4e0e\u76f4\u7ebf\u95f4\u7684\u5173\u7cfb lineCrossRelation(Line A, Line B)\n            0 \u5e73\u884c; 1 \u91cd\u5408; 2 \u76f8\u4ea4;\n    \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a onSegment(Point P, Line L)\n            onSegment(Point P, Point A, Point B)\n    \u7ebf\u6bb5\u548c\u76f4\u7ebf\u7684\u5173\u7cfb segmentLineRelation(Line seg, Line line)\n            0 \u4e0d\u76f8\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n    \u7ebf\u6bb5\u548c\u7ebf\u6bb5\u7684\u5173\u7cfb segmentCrossRelation(Line a, Line b)\n            0 \u4e0d\u60f3\u4ea4; 1 \u975e\u89c4\u8303\u76f8\u4ea4(\u90e8\u5206\u91cd\u5408/\u7aef\u70b9\u76f8\u4ea4); 2 \u89c4\u8303\u76f8\u4ea4;\n    \u4e24\u76f4\u7ebf\u4ea4\u70b9 getLineIntersection(Line A, Line B)\n    \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb distanceLine(Point P, Line x)\n               distanceLine(Point P, Point A, Point B)\n               distanceLine(Point3D P, Line3D x)\n    \u70b9\u5230\u7ebf\u6bb5\u7684\u8ddd\u79bb  distanceSegment(Point P, Line S)\n            distanceSegment(Point P, Point A, Point B)\n    \u70b9\u5728\u76f4\u7ebf\u4e0a\u7684\u6295\u5f71\u70b9 lineProjection(Point P, Line x)\n                lineProjection(Point P, Point A, Point B)\n    \u70b9\u5230\u76f4\u7ebf\u7684\u5782\u8db3 footPoint(Point P, Line X)\n            footPoint(Point P, Point A, Point B)\n    \u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9  symmetry(Point P, Line x)\n                symmetry(Point P, Point A, Point B)\n    \u70b9\u4e0e\u4e09\u89d2\u5f62\u7684\u4f4d\u7f6e\u5173\u7cfb pointTriangleRelation(Point P, Point A, Point B, Point C)\n                   point3DTriangleRelation(Point3D P, Point3D A, Point3D B, Point3D C)\n                1 \u5185; 2 \u5916; 3 \u4e0a; 4 \u9876\u70b9;\n    \u591a\u8fb9\u5f62\u7684\u6709\u5411\u9762\u79ef polygonArea(const vector&lt;Point&gt; &amp;points)\n    \u591a\u8fb9\u5f62\u91cd\u5fc3 polygonCenter(const vector&lt;Point&gt; &amp;points)\n    \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points)\n            0 \u5728\u5916; 1 \u5728\u5185; 2 \u5728\u8fb9\u4e0a; 3 \u5728\u9876\u70b9\u4e0a;\n    \u7ebf\u7aef\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb segmentPolygonRelation(Line S, const vector&lt;Point&gt; &amp;points)\n            0 \u89c4\u8303\u76f8\u4ea4(\u4e0d\u542b\u7aef\u70b9); 1 \u5185\u76f8\u4ea4; 2 \u5185\u4e0d\u76f8\u4ea4; 3 \u4e0d\u76f8\u4ea4;\n    \u70b9\u4e0e\u591a\u8fb9\u5f62\u7684\u5173\u7cfb pointPolygonRelation(Point P, const vector&lt;Point&gt; &amp;points)\n                1 \u591a\u8fb9\u5f62\u5185; 0 \u591a\u8fb9\u5f62\u5916; -1 \u591a\u8fb9\u5f62\u4e0a;\n    \u591a\u8fb9\u5f62\u4e0a\u7f51\u683c\u70b9\u4e2a\u6570 gridOnEdge(const vector&lt;Point&gt; &amp;points)\n    \u591a\u8fb9\u5f62\u5185\u7f51\u683c\u70b9\u4e2a\u6570 gridInSide(const vector&lt;Point&gt; &amp;points)\n    \u5706\u4e0a\u4e00\u70b9 Circle::getPoint(Tdouble a)\n    \u70b9\u548c\u5706\u7684\u5173\u7cfb pointCircleRelation(Point P, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u7ebf\u6bb5\u548c\u5706\u7684\u5173\u7cfb segmentCircleRelation(Line S, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u76f4\u7ebf\u548c\u5706\u7684\u5173\u7cfb lineCircleRelation(Line L, Circle C)\n            0 \u5706\u5916; 1 \u5706\u4e0a; 2 \u5706\u5185;\n    \u4e24\u5706\u4e4b\u95f4\u7684\u5173\u7cfb circleCrossRelation(Circle C1, Circle C2)\n            5 \u76f8\u79bb; 4 \u5916\u5207; 3 \u76f8\u4ea4; 2 \u5185\u5207; 1 \u5185\u542b;\n    \u76f4\u7ebf\u4e0e\u5706\u4ea4\u70b9 getLineCircleIntersection(Line L, Circle C)\n    \u7ebf\u6bb5\u4e0e\u5706\u7684\u4ea4\u70b9 getSegmentCircleIntersection(Line S, Circle C)\n    \u4e24\u5706\u4ea4\u70b9 getCircleIntersection(Circle C1, Circle C2)\n    \u70b9\u5230\u5706\u7684\u5207\u7ebf getCircleTangents(Point P, Circle C)\n    \u4e24\u5706\u9762\u79ef\u4ea4 circleOverlap2(Circle C1, Circle C2)\n    \u5706\u4e0a\u8ddd\u79bbP\u6700\u8fd1\u7684\u70b9 nearPointToCircle(Point P, Circle C)\n    \u5916\u63a5\u5706 getCircumCircle(Point A, Point B, Point C)\n    \u5185\u63a5\u5706 getInscribedCircle(Point A, Point B, Point C)\n    \u9762\u9762\u4ea4\u7ebf getPlaneIntersection(Line3D A, Line3D B)\n    \u5e73\u9762\u6cd5\u5411\u91cf Face::normal()\n    \u5e73\u9762\u9762\u79ef Face::area()\n    \u70b9\u662f\u5426\u5728\u5e73\u9762\u4e0a Face::see(Point3D P)\n    \u7ebf\u4e0e\u5e73\u9762\u7684\u4ea4\u70b9 lineFaceIntersection(Line3D L, Point3D A, Point3D B, Point3D C)\n*/\n//\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E6%89%AB%E6%8F%8F%E7%BA%BF/","title":"\u626b\u63cf\u7ebf","text":""},{"location":"Template/ComputationalGeometry/%E6%89%AB%E6%8F%8F%E7%BA%BF/#_2","title":"\u6c42\u77e9\u9635\u9762\u79ef\u5e76","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int L, R, H, mark;\n    Node() = default;\n    Node(const int L, const int R, const int H, const int mark) : L(L), R(R), H(H), mark(mark) {}\n    bool operator&lt;(const Node&amp; x) const {\n        if (H == x.H) {\n            return mark &gt; x.mark;\n        }\n        return H &lt; x.H;\n    }\n};\nvector&lt;int&gt; idx;\nvector&lt;Node&gt; lines;\nint sum[200010 &lt;&lt; 2];\nlong long len[200010 &lt;&lt; 3];\nvoid push(const int p, const int L, const int R) {\n    if (sum[p]) {\n        len[p] = idx[R + 1] - idx[L];\n    } else {\n        len[p] = len[p &lt;&lt; 1] + len[p &lt;&lt; 1 | 1];\n    }\n}\nvoid modify(const int p, const int QL, const int QR, const int L, const int R, const int mark) {\n    if (idx[R + 1] &lt;= QL || QR &lt;= idx[L]) {\n        return;\n    }\n    if (QL &lt;= idx[L] &amp;&amp; idx[R + 1] &lt;= QR) {\n        sum[p] += mark;\n        push(p, L, R);\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, QL, QR, L, mid, mark);\n    modify(p &lt;&lt; 1 | 1, QL, QR, mid + 1, R, mark);\n    push(p, L, R);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    idx.emplace_back(-1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        idx.emplace_back(x1);\n        idx.emplace_back(x2);\n        lines.emplace_back(x1, x2, y1, 1);\n        lines.emplace_back(x1, x2, y2, -1);\n    }\n    sort(begin(idx), end(idx));\n    sort(begin(lines), end(lines));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    long long ans = 0;\n    int lens = idx.size();\n    for (int i = 0 ; i &lt; n * 2 - 1 ; i++) {\n        modify(1, lines[i].L, lines[i].R, 1, lens - 2, lines[i].mark);\n        ans += len[1] * (lines[i + 1].H - lines[i].H);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E6%89%AB%E6%8F%8F%E7%BA%BF/#_3","title":"\u6c42\u77e9\u9635\u5468\u957f\u5e76","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int L, R, H, mark;\n    Node() = default;\n    Node(const int L, const int R, const int H, const int mark) : L(L), R(R), H(H), mark(mark) {}\n    bool operator&lt;(const Node&amp; x) const {\n        if (H == x.H) {\n            return mark &gt; x.mark;\n        }\n        return H &lt; x.H;\n    }\n};\nvector&lt;int&gt; idx;\nvector&lt;Node&gt; lines;\nint sum[100010 &lt;&lt; 4];\nint len[100010 &lt;&lt; 4];\nint mark[100010 &lt;&lt; 4];\nbool contain[100010 &lt;&lt; 4][2];\nvoid push(const int p, const int L, const int R) {\n    const int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n    if (sum[p]) {\n        len[p] = idx[R + 1] - idx[L];\n        contain[p][0] = contain[p][1] = true;\n        mark[p] = 1;\n    } else {\n        len[p] = len[x] + len[y];\n        contain[p][0] = contain[x][0];\n        contain[p][1] = contain[y][1];\n        mark[p] = mark[x] + mark[y];\n        if (contain[x][1] &amp;&amp; contain[y][0]) {\n            mark[p]--;\n        }\n    }\n}\nvoid modify(const int p, const int QL, const int QR, const int L, const int R, const int mark) {\n    if (idx[R + 1] &lt;= QL || QR &lt;= idx[L]) {\n        return;\n    }\n    if (QL &lt;= idx[L] &amp;&amp; idx[R + 1] &lt;= QR) {\n        sum[p] += mark;\n        push(p, L, R);\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, QL, QR, L, mid, mark);\n    modify(p &lt;&lt; 1 | 1, QL, QR, mid + 1, R, mark);\n    push(p, L, R);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    idx.emplace_back(-10000);\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        idx.emplace_back(x1);\n        idx.emplace_back(x2);\n        lines.emplace_back(x1, x2, y1, 1);\n        lines.emplace_back(x1, x2, y2, -1);\n    }\n    sort(begin(idx), end(idx));\n    sort(begin(lines), end(lines));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    long long ans = 0, pre = 0;\n    int lens = idx.size();\n    for (int i = 0 ; i &lt; n * 2 - 1 ; i++) {\n        modify(1, lines[i].L, lines[i].R, 1, lens - 2, lines[i].mark);\n        ans += llabs(pre - len[1]);\n        pre = len[1];\n        ans += 2LL * mark[1] * (lines[i + 1].H - lines[i].H);\n    }\n    ans += lines[2 * n - 1].R - lines[2 * n - 1].L;\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/","title":"\u65cb\u8f6c\u5361\u58f3","text":""},{"location":"Template/ComputationalGeometry/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/#_2","title":"\u6c42\u51f8\u5305\u76f4\u5f84","text":"<p>\u6c42\u51f8\u5305\uff0c\u679a\u4e3e\u8fb9\uff0c\u627e\u6700\u8fdc\u7684\u70b9</p> <p>P1452 [USACO03FALL] Beauty Contest G /\u3010\u6a21\u677f\u3011\u65cb\u8f6c\u5361\u58f3 - \u6d1b\u8c37</p> Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\nTdouble RoatingCalipers(const vector&lt;Point&gt; &amp;p) {\n    if (p.size() == 3) return (p[0] - p[1]).length();\n    int cur = 0, len = p.size();\n    Tdouble ans = 0;\n    for (int i = 0 ; i &lt; len - 1 ; i++) {\n        Line line(p[i], p[i + 1]);\n        while (sgn(distanceLine(p[cur], line) - distanceLine(p[(cur + 1) % len], line)) &lt;= 0) {\n            cur = (cur + 1) % len;\n        }\n        ans = max({ans, (p[i] - p[cur]).length(), (p[i + 1] - p[cur]).length()});\n    } \n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto c = ConvexHull2D(a);\n    auto d = RoatingCalipers(c);\n    cout &lt;&lt; int(d * d);\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/#_3","title":"\u6c42\u6700\u5c0f\u8986\u76d6\u77e9\u5f62\u7684\u9762\u79ef\u4ee5\u53ca\u56db\u4e2a\u9876\u70b9","text":"<p>P3187 [HNOI2007] \u6700\u5c0f\u77e9\u5f62\u8986\u76d6 - \u6d1b\u8c37</p> Code C++<pre><code>{ \u8ba1\u7b97\u51e0\u4f55\u57fa\u7840 }\n{ \u4e8c\u7ef4\u51f8\u5305 }\n#define func(a) (sgn(a) &lt; 0 ? a = -a : 0.0)\npair&lt;array&lt;Point, 4&gt;, Tdouble&gt; RoatingCalipers(const vector&lt;Point&gt; &amp;p) {\n    Tdouble res, ans = 1e100;\n    int a = 1, b = 1, c = 1, len = p.size();\n    array&lt;Point, 4&gt; point;\n    for (int i = 1 ; i &lt; len ; i++) {\n        Vector v1 = p[i - 1] - p[i], v2 = p[i] - p[i - 1];\n        while (sgn(cross(p[(a + 1) % len] - p[i], v1) - cross(p[a] - p[i], v1) &gt;= 0)) {\n            a = (a + 1) % len;\n        }\n        while (sgn(dot(p[(b + 1) % len] - p[i], v1) - dot(p[b] - p[i], v1)) &lt;= 0) {\n            b = (b + 1) % len;\n        }\n        if (i == 1) c = a;\n        while (sgn(dot(p[(c + 1) % len] - p[i - 1], p[i] - p[i - 1]) - dot(p[c] - p[i - 1], p[i] - p[i - 1])) &lt;= 0) {\n            c = (c + 1) % len;\n        }\n        Tdouble dis = v2.length();\n        Tdouble L = dot(p[c] - p[i], v1) / dis;\n        Tdouble R = dot(p[b] - p[i - 1], v2) / dis;\n        Tdouble H = fabs(area2(p[i], p[i - 1], p[a])) / dis;\n        func(L);func(R);func(H);\n        res = (L + R - dis) * H;\n        if (res &lt; ans) {\n            ans = res;\n            point[0] = p[i] - v2 * (L / dis);\n            point[1] = point[0] + v2 * ((L + R - dis) / dis);\n            point[2] = point[1] + (p[b] - point[1]) * (H / (p[b] - point[1]).length());\n            point[3] = point[2] + v1 * ((L + R - dis) / dis);\n        }\n    }\n    return {point, ans};\n}\n#undef func(a)\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Point&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    auto c = ConvexHull2D(a);\n    auto [point, ans] = RoatingCalipers(c);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; ans &lt;&lt; \"\\n\";\n    int pos = 0;\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        if (point[i].y &lt; point[pos].y || (point[i].y == point[pos].y &amp;&amp; point[i].x &lt; point[pos].x)) {\n            pos = i;\n        }\n    }\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        int k = (pos + i) % 4;\n        if (sgn(point[k].x) == 0) point[k].x = 0.0;\n        if (sgn(point[k].y) == 0) point[k].y = 0.0;\n        cout &lt;&lt; point[k] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/ComputationalGeometry/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/ComputationalGeometry/%E6%9D%82%E9%A2%98%281%29/#_1","title":"\u6c42\u4e09\u7ef4\u7a7a\u95f4\u4e0a\u4e24\u4e2a\u5706\u9762\u7684\u4ea4\u7ebf\u7684\u957f\u5ea6","text":"Code <p>\u8f93\u5165\u662f\u4e24\u4e2a\u5706\u9762\u7684\u534a\u5f84\uff0c\u5706\u5f62\u3001\u6cd5\u5411\u91cf</p> C++<pre><code>// Problem: H - Circle Intersection\n// Contest: Virtual Judge - \u6e56\u5357\u7701\u7b2c\u5341\u4e03\u5c4a\u5927\u5b66\u751f\u8ba1\u7b97\u673a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08HNCPC2021\uff09 [Cloned]\n// URL: https://vjudge.net/contest/577909#problem/H\n// Memory Limit: 128 MB\n// Time Limit: 1000 ms\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u57fa\u7840\u8ba1\u7b97\u51e0\u4f55 }\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    Point3D A, C;\n    Vector3D B, D;\n    Tdouble R1, R2;\n    while (cin &gt;&gt; R1 &gt;&gt; A &gt;&gt; B) {\n        cin &gt;&gt; R2 &gt;&gt; C &gt;&gt; D;\n        Vector3D G = cross(B, D);\n        Line3D v = getPlaneIntersection(Line3D(A, B), Line3D(C, D));\n        if (sgn(distanceLine(A, v) - R1) &gt; 0 || sgn(distanceLine(C, v) - R2) &gt; 0) {\n            cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n            continue;\n        }\n        Line3D C1(A, cross(v.v, B));\n        Point3D mid1 = getLineIntersection(C1, v);\n        Tdouble d1 = (A - mid1).length();\n        Vector3D t1 = v.v * (sqrt(R1 * R1 - d1 * d1) / v.v.length());\n        Point3D p1 = mid1 + t1;\n        Point3D p2 = mid1 - t1;\n        Line3D C2(C, cross(v.v, D));\n        Point3D mid2 = getLineIntersection(C2, v);\n        Tdouble d2 = (C - mid2).length();\n        Vector3D t2 = v.v * (sqrt(R2 * R2 - d2 * d2) / v.v.length());\n        Point3D p3 = mid2 + t2;\n        Point3D p4 = mid2 - t2;\n        Tdouble res = 0.0;\n        if (sgn(dot(p1 - p3, p1 - p4)) &lt;= 0) {\n            res = min(distance(p1, p2), distance(p1, p4));\n        } else if (sgn(dot(p2 - p3, p2 - p4)) &lt;= 0) {\n            res = min(distance(p2, p1), distance(p2, p3));\n        } else if (sgn(dot(p3 - p1, p3 - p2)) &lt;= 0) {\n            res = min(distance(p3, p4), distance(p3, p2));\n        } else if (sgn(dot(p4 - p1, p4 - p2)) &lt;= 0) {\n            res = min(distance(p4, p3), distance(p4, p1));\n        }\n        if (sgn(res) &lt;= 0) cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n        else cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/ChthollyTree/","title":"\u73c2\u6735\u8389\u6811","text":"\u6a21\u7248 C++<pre><code>template&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void update(K L, K R) { // \u533a\u95f4\u66f4\u65b0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            // Do what you want to do\n            it = next(it);\n        }\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\n// \u57fa\u4e8e map \u5b9e\u73b0\u7684\u73c2\u6735\u8389\u6811\n// K \u4ee3\u8868\u533a\u95f4\u7c7b\u578b, int \u6216 long long\n// V \u4ee3\u8868\u5b58\u7684\u503c\n</code></pre> \u4f8b\u9898 CF896CCF817F <p>Problem - C - Codeforces</p> <p>\u64cd\u4f5c\u4e00, \u533a\u95f4\u52a0</p> <p>\u64cd\u4f5c\u4e8c, \u533a\u95f4\u8d4b\u503c</p> <p>\u64cd\u4f5c\u4e09, \u8f93\u51fa\u533a\u95f4\u7b2ck\u5927</p> <p>\u64cd\u4f5c\u56db, \u8f93\u51fa\u533a\u95f4x\u6b21\u5e42\u7684\u548c\u6a21y</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void add(K L, K R, V val) { // \u533a\u95f4\u52a0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V &amp;v = it -&gt; second; // \u533a\u95f4\u503c\n            v += val;\n            it = next(it);\n        }\n    }\n    V kth(K L, K R, K rk) { // \u533a\u95f4\u7b2ck\u5927\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        vector&lt;pair&lt;V, K&gt;&gt; res;\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            res.push_back({v, r - l + 1});\n            it = next(it);\n        }\n        sort(begin(res), end(res));\n        for (auto &amp;[x, y] : res) {\n            rk -= y;\n            if (rk &lt;= 0) return x;\n        }\n        return -1;\n    }\n    V query(K L, K R, V x, V mod) { // \u533a\u95f4\u66f4\u65b0\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        V res = 0;\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V v = it -&gt; second; // \u533a\u95f4\u503c\n            res = (res + qpow(v % mod, x, mod) * (r - l + 1) % mod) % mod;\n            it = next(it);\n        }\n        return res;\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\nint seed;\nint rnd() {\n    int res = seed;\n    seed = (1LL * seed * 7 + 13) % 1000000007;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, vmax;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;\n    ODT&lt;int, long long&gt; odt(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int a = rnd() % vmax + 1;\n        odt[i] = a;\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int op, L, R, x, y;\n        op = rnd() % 4 + 1;\n        L = rnd() % n + 1;\n        R = rnd() % n + 1;\n        if (L &gt; R) swap(L, R);\n        if (op == 3) {\n            x = rnd() % (R - L + 1) + 1;\n        } else {\n            x = rnd() % vmax + 1;\n        }\n        if (op == 4) {\n            y = rnd() % vmax + 1;\n        }\n        if (op == 1) {\n            odt.add(L, R, x);\n        } else if (op == 2) {\n            odt.assign(L, R, x);\n        } else if (op == 3) {\n            cout &lt;&lt; odt.kth(L, R, x) &lt;&lt; \"\\n\";\n        } else if (op == 4) {\n            cout &lt;&lt; odt.query(L, R, x, y) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u64cd\u4f5c\u4e00, \u6dfb\u52a0\u533a\u95f4</p> <p>\u64cd\u4f5c\u4e8c, \u5220\u9664\u533a\u95f4</p> <p>\u64cd\u4f5c\u4e09, \u53cd\u8f6c\u533a\u95f4, \u5b58\u5728\u7684\u5220\u9664, \u4e0d\u5b58\u5728\u7684\u6dfb\u52a0</p> C++<pre><code>template&lt;class K, class V&gt;\nstruct ODT {\n    map&lt;K, V&gt; odt;\n    ODT(K mx) {\n        odt[mx + 1] = V();\n    } \n    void split(K x) {\n        auto it = prev(odt.upper_bound(x));\n        odt[x] = it -&gt; second;\n    }\n    void assign(K L, K R, V val) { // \u533a\u95f4\u8d4b\u503c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            it = odt.erase(it);\n        }\n        odt[L] = val;\n    }\n    void reverse(K L, K R) { // \u533a\u95f4\u53cd\u8f6c\n        R++;\n        split(L); split(R);\n        auto it = odt.find(L);\n        while (it -&gt; first != R) {\n            K l = it -&gt; first; // \u533a\u95f4\u5de6\u7aef\u70b9\n            K r = next(it) -&gt; first - 1; // \u533a\u95f4\u53f3\u7aef\u70b9\n            V &amp;v = it -&gt; second; // \u533a\u95f4\u503c\n            v ^= 1;\n            it = next(it);\n        }\n    }\n    K query() { // \u67e5\u8be2\n        for (auto &amp;[x, y] : odt) {\n            if (y == 0) {\n                return x;\n            }\n        }\n        return -1;\n    }\n    V&amp; operator[](K x) {\n        return odt[x];\n    }\n}; // ODT\n// \u57fa\u4e8e map \u5b9e\u73b0\u7684\u73c2\u6735\u8389\u6811\n// K \u4ee3\u8868\u533a\u95f4\u7c7b\u578b, int \u6216 long long\n// V \u4ee3\u8868\u5b58\u7684\u503c\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ODT&lt;long long, int&gt; odt(1000000000000000000LL);\n    odt.assign(1LL, 1000000000000000000LL, 0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op;\n        long long L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 1) {\n            odt.assign(L, R, 1);\n        } else if (op == 2) {\n            odt.assign(L, R, 0);\n        } else if (op == 3) {\n            odt.reverse(L, R);\n        }\n        cout &lt;&lt; odt.query() &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/DisjunctionTree/","title":"\u6790\u5408\u6811","text":"\u6a21\u7248 \u65e0\u5efa\u6811\u5efa\u6811 C++<pre><code>const int N = 300005;\nint n, a[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            int le = query(1, 1, n), now = ++cnt;\n            L[now] = R[now] = i;\n            siz[now] = 1;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    siz[k]++;\n                    now = st3[tp3];\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    siz[cnt] = 2;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    now = cnt;\n                } else {\n                    int tot = 0;\n                    do {\n                        tp3--;\n                        tot++;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[++cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    now = cnt;\n                    siz[cnt] = tot + 1;\n\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n    }\n}; // DisjunctionTree\n</code></pre> C++<pre><code>const int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n        dfs2(rt, 0);\n    }\n}; // DisjunctionTree\n</code></pre> \u4f8b\u9898 CF526FCF997E\u6d1b\u8c37P4747 <p>Problem - F - Codeforces</p> <p>\u6c42\u6392\u5217\u4e2d\u6709\u591a\u5c11\u6bb5\\(\\max-\\min=R-L+1\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 300005;\nint n, a[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            int le = query(1, 1, n), now = ++cnt;\n            L[now] = R[now] = i;\n            siz[now] = 1;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    siz[k]++;\n                    now = st3[tp3];\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    siz[cnt] = 2;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    now = cnt;\n                } else {\n                    int tot = 0;\n                    do {\n                        tp3--;\n                        tot++;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[++cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    now = cnt;\n                    siz[cnt] = tot + 1;\n\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y;\n    }\n    using DisjunctionTree::build;\n    using DisjunctionTree::cnt;\n    using DisjunctionTree::typ;\n    using DisjunctionTree::siz;\n    build();\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= cnt ; i++) {\n        if (typ[i]) {\n            ans += 1LL * siz[i] * (siz[i] - 1) / 2;\n        } else {\n            ans++;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>Problem - E - Codeforces</p> <p>\u6c42\u6392\u5217\u4e2d\u6709\u591a\u5c11\u6bb5\\(\\max-\\min=R-L+1\\)\uff0c\u533a\u95f4\u67e5\u8be2</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], pre[N &lt;&lt; 1], suf[N &lt;&lt; 1], siz[N &lt;&lt; 1], sum[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1], rk[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        long long temp = 0;\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n            pre[to] = temp + (typ[u] == 1 ? Cn2(i) : 0);\n            temp += siz[to];\n            sum[to] = temp;\n            rk[to] = i + 1;\n        }\n        temp = 0;\n        for (int i = (int)adj[u].size() - 1 ; i &gt;= 0 ; i--) {\n            int to = adj[u][i];\n            suf[to] = temp + (typ[u] == 1 ? Cn2((int)adj[u].size() - 1 - i) : 0);\n            temp += siz[to];\n        }\n    }\n    void dfs2(int u, int p) {\n        pre[u] += pre[p];\n        suf[u] += suf[p];\n        for (auto &amp;to : adj[u]) {\n            dfs2(to, u);\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    long long query(int L, int R) {\n        L--;\n        R++;\n        int z = LCA(idx[L], idx[R]);\n        int x = jump(idx[L], z), y = jump(idx[R], z);\n        long long res = (pre[idx[R]] - pre[y]) + (suf[idx[L]] - suf[x]) + sum[y] - sum[x] - siz[y] + (typ[z] == 1 ? Cn2(rk[y] - rk[x] - 1) : 0);\n        return res;\n    }\n    long long queryPre(int R) {\n        R++;\n        int x = jump(idx[R], rt);\n        long long res = (pre[idx[R]] - pre[x]) + (sum[x] - siz[x]) + (typ[rt] == 1 ? Cn2(rk[x] - 1) : 0);\n        return res;\n    }\n    long long querySuf(int L) {\n        L--;\n        int x = jump(idx[L], rt);\n        long long res = (suf[idx[L]] - suf[x]) + (sum[adj[rt].back()] - sum[x]) + (typ[rt] == 1 ? Cn2((int)adj[rt].size() - rk[x]) : 0);\n        return res;\n    }\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n        dfs2(rt, 0);\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    using DisjunctionTree::rt;\n    using DisjunctionTree::siz;\n    using DisjunctionTree::build;\n    using DisjunctionTree::querySuf;\n    using DisjunctionTree::queryPre;\n    using DisjunctionTree::query;\n    build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        if (L == 1 &amp;&amp; R == n) {\n            cout &lt;&lt; siz[rt] &lt;&lt; \"\\n\";\n        } else if (L == 1 &amp;&amp; R != n) {\n            cout &lt;&lt; queryPre(R) &lt;&lt; \"\\n\";\n        } else if (L != 1 &amp;&amp; R == n) {\n            cout &lt;&lt; querySuf(L) &lt;&lt; \"\\n\";\n        } else {\n            cout &lt;&lt; query(L, R) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>P4747 [CERC2017] Intrinsic Interval - \u6d1b\u8c37</p> <p>\u6c42\u5305\u542b\u8be5\u533a\u95f4\u7684\u6700\u5c0f\u8fde\u7eed\u533a\u95f4\\((\\max-\\min=R-L)\\)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 400005;\nint n, a[N];\nvector&lt;int&gt; adj[N];\nnamespace DisjunctionTree {\n    int lg[N], mx[N][22], mi[N][22];\n    int queryMx(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(mx[L][k], mx[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    int queryMi(int L, int R) {\n        int k = lg[R - L + 1];\n        return min(mi[L][k], mi[R - (1 &lt;&lt; k) + 1][k]);\n    }\n    bool judge(int L, int R) {\n        return queryMx(L, R) - queryMi(L, R) == R - L;\n    }\n    int lazy[N &lt;&lt; 2], mn[N &lt;&lt; 2];\n    void pushup(int p) {\n        mn[p] = min(mn[p &lt;&lt; 1], mn[p &lt;&lt; 1 | 1]);\n    }\n    void pushtag(int p, int tag) {\n        mn[p] += tag;\n        lazy[p] += tag;\n    }\n    void pushdown(int p) {\n        if (lazy[p]) {\n            pushtag(p &lt;&lt; 1, lazy[p]);\n            pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n            lazy[p] = 0;\n        }\n    }\n    void modify(int p, int L, int R, int QL, int QR, int k) {\n        if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n            pushtag(p, k);\n            return;\n        }\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (QR &lt;= mid) modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n        else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        else {\n            modify(p &lt;&lt; 1, L, mid, QL, QR, k);\n            modify(p &lt;&lt; 1 | 1, mid + 1, R, QL, QR, k);\n        }\n        pushup(p);\n    }\n    int query(int p, int L, int R) {\n        if (L == R) return L;\n        pushdown(p);\n        int mid = L + R &gt;&gt; 1;\n        if (mn[p &lt;&lt; 1] == 0) return query(p &lt;&lt; 1, L, mid);\n        return query(p &lt;&lt; 1 | 1, mid + 1, R);\n    }\n    int st1[N], tp1, st2[N], tp2, st3[N &lt;&lt; 1], tp3;\n    int cnt, L[N &lt;&lt; 1], R[N &lt;&lt; 1], M[N &lt;&lt; 1], typ[N &lt;&lt; 1];\n    // typ = 1 \u4ee3\u8868 \u5408\u70b9\n    // typ = 0 \u4ee3\u8868 \u6790\u70b9\n    long long w[N &lt;&lt; 1], siz[N &lt;&lt; 1];\n    int fa[N &lt;&lt; 1][22], deep[N &lt;&lt; 1], idx[N &lt;&lt; 1];\n    long long Cn2(long long n) {\n        return n * (n - 1) / 2;\n    }\n    void dfs1(int u, int p) {\n        fa[u][0] = p;\n        deep[u] = deep[p] + 1;\n        siz[u] = (typ[u] == 1 ? Cn2(adj[u].size()) : 1);\n        for (int i = 1 ; i &lt;= 21 ; i++) {\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        }\n        for (int i = 0 ; i &lt; (int)adj[u].size() ; i++) {\n            int to = adj[u][i];\n            dfs1(to, u);\n            siz[u] += siz[to];\n        }\n    }\n    int jump(int x, int y) {\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt;= deep[y]) continue;\n            x = fa[x][i];\n        }\n        return x;\n    }\n    int LCA(int x, int y) {\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (deep[fa[x][i]] &lt; deep[y]) continue;\n            x = fa[x][i];\n        }\n        if (x == y) return x;\n        for (int i = 21 ; i &gt;= 0 ; i--) {\n            if (fa[x][i] == fa[y][i]) continue;\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n        return fa[x][0];\n    }\n    int rt;\n    void build() {\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            mx[i][0] = mi[i][0] = a[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                mx[i][j] = max(mx[i][j - 1], mx[i + (1 &lt;&lt; j - 1)][j - 1]);\n                mi[i][j] = min(mi[i][j - 1], mi[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n        for (int i = 1 ; i &lt;= n ; i++) {\n            while (tp1 &amp;&amp; a[st1[tp1]] &lt; a[i]) {\n                modify(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], -a[st1[tp1]]);\n                tp1--;\n            }\n            while (tp2 &amp;&amp; a[st2[tp2]] &gt; a[i]) {\n                modify(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], a[st2[tp2]]);\n                tp2--;\n            }\n            modify(1, 1, n, st1[tp1] + 1, i, a[i]);\n            st1[++tp1] = i;\n            modify(1, 1, n, st2[tp2] + 1, i, -a[i]);\n            st2[++tp2] = i;\n            idx[i] = ++cnt;\n            int le = query(1, 1, n), now = cnt;\n            L[now] = R[now] = i;\n            while (tp3 &amp;&amp; L[st3[tp3]] &gt;= le) {\n                int k = st3[tp3];\n                if (typ[k] &amp;&amp; judge(M[k], i)) {\n                    R[k] = i;\n                    adj[k].push_back(now);\n                    now = k;\n                } else if (judge(L[k], i)) {\n                    typ[++cnt] = 1;\n                    L[cnt] = L[k];\n                    R[cnt] = i;\n                    M[cnt] = L[now];\n                    adj[cnt].push_back(k);\n                    adj[cnt].push_back(now);\n                    now = cnt;\n                } else {\n                    cnt++;\n                    adj[cnt].push_back(now);\n                    do {\n                        adj[cnt].push_back(st3[tp3]);\n                        tp3--;\n                    } while(tp3 &amp;&amp; !judge(L[st3[tp3]], i));\n                    L[cnt] = L[st3[tp3]];\n                    R[cnt] = i;\n                    adj[cnt].push_back(st3[tp3]);\n                    now = cnt;\n                }\n                tp3--;\n            }\n            st3[++tp3] = now;\n            modify(1, 1, n, 1, i, -1);\n        }\n        rt = st3[tp3];\n        for (int i = 1 ; i &lt;= cnt ; i++) {\n            sort(begin(adj[i]), end(adj[i]), [&amp;](const auto &amp;x, const auto &amp;y){\n                return L[x] &lt; L[y];\n            });\n        }\n        dfs1(rt, 0);\n    }\n    pair&lt;int, int&gt; query(int L, int R) {\n        int x = idx[L], y = idx[R];\n        int z = LCA(x, y);\n        if (typ[z] == 1) {\n            L = DisjunctionTree::L[jump(x, z)];\n            R = DisjunctionTree::R[jump(y, z)];\n        } else {\n            L = DisjunctionTree::L[z];\n            R = DisjunctionTree::R[z];\n        }\n        return {L, R};\n    }\n}; // DisjunctionTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    using DisjunctionTree::rt;\n    using DisjunctionTree::siz;\n    using DisjunctionTree::build;\n    using DisjunctionTree::query;\n    build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        tie(L, R) = query(L, R);\n        cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/FenwickTree/","title":"\u6811\u72b6\u6570\u7ec4","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4\u6743\u503c\u6811\u72b6\u6570\u7ec4-\u5168\u5c40\u7b2c k \u5c0f \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 500005;\nint n = N - 1, sum[N];\nusing B = int;\nB query(int x) {\n    B res = 0;\n    while (x) {\n        res += sum[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    while (x &lt;= n) {\n        sum[x] += k;\n        x += lowbit(x);\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum, sumX;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n        sumX.resize(0);\n        sumX.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            res += (x + 1) * sum[i] - sumX[i];\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        T kx = k * x;\n        while (x &lt;= size) {\n            sum[x] += k;\n            sumX[x] += kx;\n            x += lowbit(x);\n        }\n    }\n    void add(int L, int R, T k) {\n        add(L, k);\n        add(R + 1, -k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 1000005;\nlong long sum[N], sumX[N];\nint n = N - 1;\nusing B = long long;\nB query(int x) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        res += (x + 1) * sum[i] - sumX[i];\n    }\n    return res;\n}\nB query(int L, int R) {\n    return query(R) - query(L - 1);\n}\nvoid add(int x, B k) {\n    B kx = k * x;\n    while (x &lt;= n) {\n        sum[x] += k;\n        sumX[x] += kx;\n        x += lowbit(x);\n    }\n}\nvoid add(int L, int R, B k) {\n    add(L, k);\n    add(R + 1, -k);\n}\n</code></pre> \u5355\u70b9\u4fee\u6539-\u533a\u95f4\u67e5\u8be2\u533a\u95f4\u4fee\u6539-\u533a\u95f4\u67e5\u8be2 \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(sizeX + 1);\n        for (int i = 1 ; i &lt;= sizeX ; i++) {\n            sum[i].resize(sizeY + 1);\n        }\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n            }\n        }\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nint n = N - 1, m = M - 1;\nusing B = long long;\nB sum[N][M];\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n        }\n    }\n}\n</code></pre> \u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;vector&lt;T&gt;&gt; sum, sumX, sumY, sumXY;\n    int sizeX, sizeY;\n    FenwickTree() {}\n    FenwickTree(int n, int m) {\n        resize(n, m);\n    }\n    void resize(int n, int m) {\n        sum.resize(n + 1);\n        sumX.resize(n + 1);\n        sumY.resize(n + 1);\n        sumXY.resize(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            sum[i].resize(m + 1);\n            sumX[i].resize(m + 1);\n            sumY[i].resize(m + 1);\n            sumXY[i].resize(m + 1);\n        }\n        sizeX = n;\n        sizeY = m;\n    }\n    void clear() {\n        resize(0, 0);\n        resize(sizeX, sizeY);\n    }\n    T query(int x, int y) {\n        T res = 0;\n        for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n            for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n                res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n            }\n        }\n        return res;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n    void add(int x, int y, T k) {\n        T kx = k * x;\n        T ky = k * y;\n        T kxy = kx * y;\n        for (int i = x ; i &lt;= sizeX ; i += lowbit(i)) {\n            for (int j = y ; j &lt;= sizeY ; j += lowbit(j)) {\n                sum[i][j] += k;\n                sumX[i][j] += kx;\n                sumY[i][j] += ky;\n                sumXY[i][j] += kxy;\n            }\n        }\n    }\n    void add(int x1, int y1, int x2, int y2, T k) {\n        add(x1, y1, k);\n        add(x1, y2 + 1, -k);\n        add(x2 + 1, y1, -k);\n        add(x2 + 1, y2 + 1, k);\n    }\n}; // FenwickTree\n</code></pre> \u975e\u7ed3\u6784\u4f53 C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\nconst int N = 5005, M = 5005;\nusing B = long long;\nB sum[N][M], sumX[N][M], sumY[N][M], sumXY[N][M];\nint n = N - 1, m = M - 1;\nB query(int x, int y) {\n    B res = 0;\n    for (int i = x ; i &gt; 0 ; i -= lowbit(i)) {\n        for (int j = y ; j &gt; 0 ; j-= lowbit(j)) {\n            res += sum[i][j] * (x + 1) * (y + 1) - sumX[i][j] * (y + 1) - sumY[i][j] * (x + 1) + sumXY[i][j];\n        }\n    }\n    return res;\n}\nB query(int x1, int y1, int x2, int y2) {\n    return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n}\nvoid add(int x, int y, B k) {\n    B kx = k * x;\n    B ky = k * y;\n    B kxy = kx * y;\n    for (int i = x ; i &lt;= n ; i += lowbit(i)) {\n        for (int j = y ; j &lt;= m ; j += lowbit(j)) {\n            sum[i][j] += k;\n            sumX[i][j] += kx;\n            sumY[i][j] += ky;\n            sumXY[i][j] += kxy;\n        }\n    }\n}\nvoid add(int x1, int y1, int x2, int y2, B k) {\n    add(x1, y1, k);\n    add(x1, y2 + 1, -k);\n    add(x2 + 1, y1, -k);\n    add(x2 + 1, y2 + 1, k);\n}\n</code></pre> C++<pre><code>int lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt;\nstruct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(int n) {\n        resize(n);\n    }\n    void resize(int n) {\n        sum.resize(n + 1);\n        size = n;\n    }\n    void clear() {\n        sum.resize(0);\n        sum.resize(size + 1);\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(int L, int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n    T kth(int rk) {\n        int res = 0, now = 0;\n        for (int i = 20 ; i &gt;= 0 ; i--) {\n            int k = 1 &lt;&lt; i;\n            if (now + k &lt;= size &amp;&amp; res + sum[now + k] &lt; rk) {\n                now += k;\n                res += sum[now];\n            }\n        }\n        return now + 1;\n    }\n}; // FenwickTree\n</code></pre> \u4f8b\u9898 \u4e00\u7ef4\u4e8c\u7ef4 \u6d1b\u8c37P3374(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ132(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>P3374 \u3010\u6a21\u677f\u3011\u6811\u72b6\u6570\u7ec4 1 - \u6d1b\u8c37</p> <p>#132. \u6811\u72b6\u6570\u7ec4 3 \uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> LOJ133(\u5355\u70b9\u4fee\u6539 \u533a\u95f4\u67e5\u8be2)LOJ135(\u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2) <p>#133. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 1\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> <p>#135. \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4 3\uff1a\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2 - LibreOJ</p> \u5176\u4ed6\u9898 \u725b\u5ba276609F(\u6309\u7167\u6392\u5217\u5faa\u73af/\u5355\u70b9\u4fee\u6539/\u6c42\u4e0d\u540c\u4e2a\u6570) <p>F-\u5c0f\u7ea2\u7684\u597d\u5b50\u4e32\u8be2\u95ee_\u725b\u5ba2\u5468\u8d5b Round 36</p> <p>\u4e00\u4e2a\u4e32(\u53ea\u5305\u542br,e,d)</p> <p>\u597d\u4e32\u4e3a\u6309\u7167\u6392\u5217\u5faa\u73af\\(\\{red,rde,erd,edr,der,dre\\}\\)</p> <p>\u64cd\u4f5c\\(1\\),\u7b2c \\(x\\) \u4e2a\u5b57\u7b26\u4fee\u6539\u4e3a \\(ch\\)\u3002</p> <p>\u64cd\u4f5c\\(2\\),\u67e5\u8be2\u533a\u95f4 \\([L,R]\\) \u4fee\u6539\u591a\u5c11\u4e2a\u5b57\u7b26\u53ef\u4ee5\u53d8\u4e3a\u597d\u4e32\u3002</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 100005;\nint lowbit(int x) {\n    return x &amp; -x;\n}\nint sum[6][N];\nint n;\nvoid add(int idx, int x, int k) {\n    while (x &lt;= n) {\n        sum[idx][x] += k;\n        x += lowbit(x);\n    }\n}\nint query(int idx, int x) {\n    int res = 0;\n    while (x) {\n        res += sum[idx][x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nstring s[] = {\n    \"red\", \"rde\",\n    \"erd\", \"edr\",\n    \"der\", \"dre\"\n};\nstring str;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int q;\n    cin &gt;&gt; n &gt;&gt; q;\n    cin &gt;&gt; str;\n    str = \" \" + str;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; 6 ; j++) {\n            if (s[j][(i - 1) % 3] != str[i]) {\n                add(j, i, 1);\n            }\n        }\n    }\n    while (q--) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int x;\n            char ch;\n            cin &gt;&gt; x &gt;&gt; ch;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                if (s[j][(x - 1) % 3] != str[x]) {\n                    add(j, x, -1);\n                }\n            }\n            str[x] = ch;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                if (s[j][(x - 1) % 3] != str[x]) {\n                    add(j, x, 1);\n                }\n            }\n        } else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            int ans = 0x7fffffff;\n            for (int j = 0 ; j &lt; 6 ; j++) {\n                ans = min(ans, query(j, R) - query(j, L - 1));\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/MonotonicQueue/","title":"\u5355\u8c03\u961f\u5217","text":"\u6a21\u7248 C++<pre><code>// \u6c42 [i-m+1, i] \u7684\u6700\u503c\ndeque&lt;int&gt; que;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &gt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mi.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mi[i] &lt;&lt; \" \\n\"[i == n - m];\ndeque&lt;int&gt;().swap(que);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!que.empty() &amp;&amp; a[que.back()] &lt;= a[i]) que.pop_back();\n    que.emplace_back(i);\n    while (que.front() &lt;= i - m) que.pop_front();\n    if (i &gt;= m) mx.emplace_back(a[que.front()]);\n}\nfor (int i = 0 ; i &lt; n - m + 1 ; i++) cout &lt;&lt; mx[i] &lt;&lt; \" \\n\"[i == n - m];\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1886 <p>P1886 \u3010\u6a21\u677f\u3011\u5355\u8c03\u961f\u5217 - \u6d1b\u8c37</p>"},{"location":"Template/DataStructure/MonotonicStack/","title":"\u5355\u8c03\u6808","text":"\u6a21\u7248 C++<pre><code>// \u6c42 i \u540e\u9762\u4e00\u4e2a\u6bd4 a[i] \u5927\u7684\u6570\u7684\u4e0b\u6807\nstack&lt;int&gt; st;\nvector&lt;int&gt; ans(n + 1);\nfor (int i = 1 ; i &lt;= n ; i++) {\n    while (!st.empty() &amp;&amp; a[st.top()] &lt; a[i]) {\n        ans[st.top()] = i;\n        st.pop();\n    }\n    st.emplace(i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5788 <p>P5788 \u3010\u6a21\u677f\u3011\u5355\u8c03\u6808 - \u6d1b\u8c37</p>"},{"location":"Template/DataStructure/ProblemSet/","title":"\u4e60\u9898","text":"\u533a\u95f4\u6392\u5217(\u7ebf\u6bb5\u6811+\u5355\u8c03\u6808) CF526F <p>Problem - F - Codeforces</p> <p>n\u6392\u5217\u4e2d\uff0c\u6c42\u6240\u6709\u6ee1\u8db3 \\(\\max-\\min=R-L\\) \u7684\u533a\u95f4\uff0c(\u6b64\u4ee3\u7801\u53ef\u4ee5\u6c42\u91cd\u590d\u6392\u5217)</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 300005;\nint n, a[N];\nint st1[N], t1, st2[N], t2;\nmap &lt;int, int&gt; last;\nstruct Info {\n    int L, R, mi, cnt;\n    int lazy;\n} tr[N&lt;&lt;2];\nvoid build(int p, int L, int R) {\n    tr[p].L = L;\n    tr[p].R = R;\n    tr[p].cnt = R - L + 1;\n    if (L == R) {\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n}\nvoid pushup(int p) {\n    tr[p].mi = min(tr[p &lt;&lt; 1].mi, tr[p &lt;&lt; 1 | 1].mi);\n    tr[p].cnt = (tr[p].mi == tr[p &lt;&lt; 1].mi ? tr[p &lt;&lt; 1].cnt : 0) + (tr[p].mi == tr[p &lt;&lt; 1 | 1].mi ? tr[p &lt;&lt; 1 | 1].cnt : 0);\n}\nvoid pushtag(int p, int tag) {\n    tr[p].mi += tag;\n    tr[p].lazy += tag;\n}\nvoid pushdown(int p) {\n    if (tr[p].lazy) {\n        pushtag(p &lt;&lt; 1, tr[p].lazy);\n        pushtag(p &lt;&lt; 1 | 1, tr[p].lazy);\n        tr[p].lazy = 0;\n    }\n}\nvoid modify(int p, int QL, int QR, int k) {\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        pushtag(p, k);\n        return;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QR &lt;= mid) modify(p &lt;&lt; 1, QL, QR, k);\n    else if (QL &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    else {\n        modify(p &lt;&lt; 1, QL, QR, k);\n        modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    }\n    pushup(p);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1, x, y; i &lt;= n; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y;\n    }\n    build(1, 1, n);\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        while (t1 &amp;&amp; a[st1[t1]] &lt; a[i]) { // \u7ef4\u62a4 max\n            modify(1, st1[t1 - 1] + 1, st1[t1], -a[st1[t1]]); // \u64a4\u9500\n            t1--;\n        }\n        while (t2 &amp;&amp; a[st2[t2]] &gt; a[i]) { // \u7ef4\u62a4 min\n            modify(1, st2[t2 - 1] + 1, st2[t2], a[st2[t2]]); // \u64a4\u9500\n            t2--;\n        }\n        modify(1, last[a[i]] + 1, i, -1);\n        last[a[i]] = st1[++t1] = st2[++t2] = i;\n        modify(1, st1[t1 - 1] + 1, i, a[i]);\n        modify(1, st2[t2 - 1] + 1, i, -a[i]);\n        ans += tr[1].cnt;\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/SegmentTree/","title":"\u7ebf\u6bb5\u6811","text":"\u6a21\u7248 \u7ed3\u6784\u4f53(\u6570\u7ec4) C++<pre><code>long long mod;\nstruct Info {\n    int L, R;\n    long long sum;\n    void init(int tL, int tR, long long v) { // build \u5185\u521d\u59cb\u5316\n        L = tL;\n        R = tR;\n        sum = v;\n    }\n    friend Info operator+(const Info &amp;lhs, const Info &amp;rhs) { // pushup\n        Info res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        res.sum = (lhs.sum + rhs.sum) % mod;\n        return res;\n    }\n};\nstruct Lazy {\n    long long add, prod;\n    Lazy() { // \u61d2\u6807\u8bb0\u5f52\u96f6\n        add = 0;\n        prod = 1;\n    }\n    void work(Info &amp;info, Lazy &amp;lazy) { // pushdown\n        if (prod != 1) {\n            lazy.prod = lazy.prod * prod % mod;\n            lazy.add = lazy.add * prod % mod;\n            info.sum = info.sum * prod % mod;\n        }\n        if (add != 0) {\n            lazy.add = (lazy.add + add) % mod;\n            info.sum = (info.sum + (info.R - info.L + 1) * add % mod) % mod;\n        }\n    }\n};\nlong long a[100005];\nstruct SegmentTree {\n    int N = 0;\n    vector&lt;Info&gt; tr;\n    vector&lt;Lazy&gt; lazy;\n    SegmentTree(int n) {\n        init(n);\n    }\n    void clear() {\n        N = 0;\n        tr.resize(0);\n        lazy.resize(0);\n    }\n    void init(int n) {\n        N = n;\n        n &lt;&lt;= 2;\n        tr.resize(n);\n        lazy.resize(n);\n    }\n    void build() {\n        build(1, N);\n    }\n    void build(int L, int R, int p = 1) {\n        if (L == R) {\n            tr[p].init(L, R, a[L]);\n            return;\n        }\n        int mid = L + R &gt;&gt; 1;\n        build(L, mid, p &lt;&lt; 1);\n        build(mid + 1, R, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    void pushdown(int p) {\n        lazy[p].work(tr[p &lt;&lt; 1], lazy[p &lt;&lt; 1]);\n        lazy[p].work(tr[p &lt;&lt; 1 | 1], lazy[p &lt;&lt; 1 | 1]);\n        lazy[p] = Lazy();\n    }\n    void modify(int QL, int QR, Lazy la, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            la.work(tr[p], lazy[p]);\n            return;\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        pushdown(p);\n        if (QL &lt;= mid) modify(QL, QR, la, p &lt;&lt; 1);\n        if (QR &gt;= mid + 1) modify(QL, QR, la, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    Info query(int QL, int QR, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            return tr[p];\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        pushdown(p);\n        if (QR &lt;= mid) return query(QL, QR, p &lt;&lt; 1);\n        else if (QL &gt;= mid + 1) return query(QL, QR, p &lt;&lt; 1 | 1);\n        return  query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1);\n    }\n}; // SegmentTree\n</code></pre>"},{"location":"Template/DataStructure/SegmentTree/#_2","title":"\u7ebf\u6bb5\u6811\u5408\u5e76","text":"\u4f8b\u9898 \u6d1b\u8c37P4556 <p>\u6811\uff0c\u6bcf\u6b21\u64cd\u4f5c\u7ed9x\u5230y\u4e0a\u53d1\u4e00\u4e2a\u7c7b\u578b\u4e3az\u7684\u7269\u54c1</p> <p>\u95ee\u6700\u7ec8\u6bcf\u4e2a\u70b9\u5b58\u653e\u6570\u91cf\u6700\u591a\u7684\u7269\u54c1\u7684\u7c7b\u578b\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 100005;\nvector&lt;int&gt; adj[N];\nint fa[N][22], deep[N], tot;\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; i &lt;= 21 ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint Ls[N &lt;&lt; 8], Rs[N &lt;&lt; 8], sum[N &lt;&lt; 8], typ[N &lt;&lt; 8];\nvoid pushup(int p) {\n    if (sum[Ls[p]] &gt;= sum[Rs[p]]) {\n        sum[p] = sum[Ls[p]];\n        typ[p] = typ[Ls[p]];\n    } else {\n        sum[p] = sum[Rs[p]];\n        typ[p] = typ[Rs[p]];\n    }\n}\nint change(int &amp;p, int pos, int k, int L = 1, int R = N) {\n    if (p == 0) p = ++tot;\n    if (L == R) {\n        sum[p] += k;\n        typ[p] = pos;\n        return p;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) change(Ls[p], pos, k, L, mid);\n    else change(Rs[p], pos, k, mid + 1, R);\n    pushup(p);\n    return p;\n}\nint merge(int rtL, int rtR, int L = 1, int R = N) {\n    if (rtL == 0 || rtR == 0) return rtL + rtR;\n    if (L == R) {\n        sum[rtL] += sum[rtR];\n        typ[rtL] = L;\n        return rtL;\n    }\n    int mid = L + R &gt;&gt; 1;\n    Ls[rtL] = merge(Ls[rtL], Ls[rtR], L, mid);\n    Rs[rtL] = merge(Rs[rtL], Rs[rtR], mid + 1, R);\n    pushup(rtL);\n    return rtL;\n}\nint ans[N];\nint root[N];\nvoid solve(int u, int p) {\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        solve(to, u);\n        root[u] = merge(root[u], root[to]);\n    }\n    if (sum[root[u]]) {\n        ans[u] = typ[root[u]];\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        int k = LCA(x, y);\n        root[x] = change(root[x], z, 1);\n        root[y] = change(root[y], z, 1);\n        root[k] = change(root[k], z, -1);\n        if (fa[k][0]) {\n            root[fa[k][0]] = change(root[fa[k][0]], z, -1);\n        }\n    }\n    solve(1, 0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/SparseTable/","title":"ST\u8868","text":"<p>\\(O(n\\log n)\\)</p> <p>\u89e3\u51b3 RMQ \u95ee\u9898\uff0c\u5982\u9759\u6001\u533a\u95f4\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u548c \\(\\gcd\\)</p> \u6a21\u7248 C++<pre><code>template&lt;class T&gt;\nstruct SparseTable {\n    vector&lt;vector&lt;T&gt;&gt; st;\n    vector&lt;int&gt; lg;\n    // \u4f20\u5165\u7684 vector \u7684\u4e0b\u6807\u5fc5\u987b\u4ee5 1 \u4e3a\u57fa\u7840\n    SparseTable(const vector&lt;T&gt; &amp;s) {\n        const int n = s.size() - 1;\n        st.assign(n + 1, vector&lt;T&gt;(22, 0));\n        lg.resize(n + 1);\n        for (int i = 2 ; i &lt;= n ; i++) {\n            lg[i] = lg[i &gt;&gt; 1] + 1;\n        }\n        for (int i = 1 ; i &lt;= n ; ++i) {\n            st[i][0] = s[i];\n        }\n        for (int j = 1 ; j &lt;= lg[n] ; j++) {\n            for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= n ; i++) {\n                st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; j - 1)][j - 1]);\n            }\n        }\n    }\n    T query(int L, int R) {\n        int k = lg[R - L + 1];\n        return max(st[L][k], st[R - (1 &lt;&lt; k) + 1][k]);\n    }\n}; // SparseTable\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3865 <p>P3865 \u3010\u6a21\u677f\u3011ST \u8868 - \u6d1b\u8c37</p>"},{"location":"Template/DataStructure/Treap/","title":"Treap","text":"<p>#104. \u666e\u901a\u5e73\u8861\u6811 - LibreOJ</p> <p>#105. \u6587\u827a\u5e73\u8861\u6811 - LibreOJ</p>"},{"location":"Template/DataStructure/Treap/#treap_1","title":"\u65cb\u8f6c Treap","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T&gt; struct Info {\n    int L, R, rnd, cnt, size;\n    T val;\n    Info() = default;\n    Info(const int L, const int R, const int rnd, const int cnt, const int size, const T val) : L(L), R(R), rnd(rnd), cnt(cnt), size(size), val(val) {}\n};\ntemplate&lt;class T&gt; struct Treap {\n    vector&lt;Info&lt;T&gt;&gt; info;\n    int tot, root;\n    Treap(const int N) : tot(0), root(0), info(N + 1) {}\n    void push(const int p) {\n        info[p].size = info[info[p].L].size + info[info[p].R].size + info[p].cnt;\n    }\n    void LRotate(int &amp;p) {\n        int temp = info[p].R;\n        info[p].R = info[temp].L;\n        info[temp].L = p;\n        info[temp].size = info[p].size;\n        push(p);\n        p = temp;\n    }\n    void RRotate(int &amp;p) {\n        int temp = info[p].L;\n        info[p].L = info[temp].R;\n        info[temp].R = p;\n        info[temp].size = info[p].size;\n        push(p);\n        p = temp;\n    }\n    void build(int &amp;p, const T x) {\n        p = ++tot;\n        info[p] = Info(0, 0, rand(), 1, 1, x);\n    }\n    void insert(const T x) {\n        insert(root, x);\n    }\n    void insert(int &amp;p, const T x) {\n        if (p == 0) {\n            build(p, x);\n            return;\n        }\n        info[p].size++;\n        if (info[p].val == x) {\n            info[p].cnt++;\n        } else if (info[p].val &lt; x) {\n            insert(info[p].R, x);\n            if (info[info[p].R].rnd &lt; info[p].rnd) {\n                LRotate(p);\n            }\n        } else {\n            insert(info[p].L, x);\n            if (info[info[p].L].rnd &lt; info[p].rnd) {\n                RRotate(p);\n            }\n        }\n    }\n    bool erase(const T x) {\n        return erase(root, x);\n    }\n    bool erase(int &amp;p, const T x) {\n        if (p == 0) {\n            return false;\n        }\n        if (info[p].val == x) {\n            if (info[p].cnt &gt; 1) {\n                info[p].cnt--;\n                info[p].size--;\n                return true;\n            }\n            if (info[p].L == 0 || info[p].R == 0) {\n                p = info[p].L + info[p].R;\n                return true;\n            } else if (info[info[p].L].rnd &lt; info[info[p].R].rnd) {\n                RRotate(p);\n                return erase(p, x);\n            } else {\n                LRotate(p);\n                return erase(p, x);\n            }\n        } else if (info[p].val &lt; x) {\n            bool succ = erase(info[p].R, x);\n            if (succ) info[p].size--;\n            return succ;\n        } else {\n            bool succ = erase(info[p].L, x);\n            if (succ) info[p].size--;\n            return succ;\n        }\n    }\n    int queryRank(const T x) {\n        return queryRank(root, x);\n    }\n    int queryRank(const int p, const T x) {\n        if (p == 0) return 0;\n        if (info[p].val == x) {\n            return info[info[p].L].size + 1;\n        } else if (info[p].val &lt; x) {\n            return info[info[p].L].size + info[p].cnt + queryRank(info[p].R, x);\n        } else {\n            return queryRank(info[p].L, x);\n        }\n    }\n    T queryNum(const T x) {\n        return queryNum(root, x);\n    }\n    T queryNum(const int p, const T x) {\n        if (p == 0) return 0;\n        if (x &lt;= info[info[p].L].size) {\n            return queryNum(info[p].L, x);\n        } else if (x &gt; info[info[p].L].size + info[p].cnt) {\n            return queryNum(info[p].R, x - info[info[p].L].size - info[p].cnt);\n        } else {\n            return info[p].val;\n        }\n    }\n    int queryPre(const T x) {\n        return queryPre(root, x);\n    }\n    int queryPre(const int p, const T x) {\n        if (p == 0) return -1;\n        if (info[p].val &lt; x) {\n            int res = queryPre(info[p].R, x);\n            if (res != -1) return res;\n            return p;\n        }\n        return queryPre(info[p].L, x);\n    }\n    int querySub(const T x) {\n        return querySub(root, x);\n    }\n    int querySub(const int p, const T x) {\n        if (p == 0) return -1;\n        if (info[p].val &gt; x) {\n            int res = querySub(info[p].L, x);\n            if (res != -1) return res;\n            return p;\n        } else {\n            return querySub(info[p].R, x);\n        }\n    }\n    T &amp;operator[](const int p) {\n        return info[p].val;\n    }\n}; // Treap\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    Treap&lt;int&gt; treap(100000);\n    srand(123);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op, x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if (op == 1) {\n            treap.insert(x);\n        } else if (op == 2) {\n            treap.erase(x);\n        } else if (op == 3) {\n            cout &lt;&lt; treap.queryRank(x) &lt;&lt; \"\\n\";\n        } else if (op == 4) {\n            cout &lt;&lt; treap.queryNum(x) &lt;&lt; \"\\n\";\n        } else if (op == 5) {\n            cout &lt;&lt; treap[treap.queryPre(x)] &lt;&lt; \"\\n\";\n        } else {\n            cout &lt;&lt; treap[treap.querySub(x)] &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/Treap/#treap_2","title":"\u65e0\u65cb Treap","text":""},{"location":"Template/DataStructure/Treap/#_1","title":"\u4e0d\u5e26\u533a\u95f4\u64cd\u4f5c","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T&gt; struct Node {\n    Node *child[2];\n    T val;\n    int rnd, cnt, size;\n    Node(const T&amp; val) : val(val), cnt(1), size(1) {\n        rnd = rand();\n        child[0] = child[1] = nullptr;\n    }\n    void push() {\n        size = cnt;\n        if (child[0] != nullptr) {\n            size += child[0] -&gt; size;\n        }\n        if (child[1] != nullptr) {\n            size += child[1] -&gt; size;\n        }\n    }\n};\ntemplate&lt;class T&gt; struct Treap {\n    Node&lt;T&gt;* root = nullptr;\n    pair&lt;Node&lt;T&gt;*, Node&lt;T&gt;*&gt; split(Node&lt;T&gt;* cur, const T key) {\n        if (cur == nullptr) return {nullptr, nullptr};\n        if (cur -&gt; val &lt;= key) {\n            auto temp = split(cur -&gt; child[1], key);\n            cur -&gt; child[1] = temp.first;\n            cur -&gt; push();\n            return {cur, temp.second};\n        } else {\n            auto temp = split(cur -&gt; child[0], key);\n            cur -&gt; child[0] = temp.second;\n            cur -&gt; push();\n            return {temp.first, cur};\n        }\n    }\n    tuple&lt;Node&lt;T&gt;*, Node&lt;T&gt;*, Node&lt;T&gt;*&gt; splitByRank(Node&lt;T&gt;* cur, const int rank) {\n        if (cur == nullptr) return {nullptr, nullptr, nullptr};\n        int ls_size = cur -&gt; child[0] == nullptr ? 0 : cur -&gt; child[0] -&gt; size;\n        if (rank &lt;= ls_size) {\n            Node&lt;T&gt; *L, *mid, *R;\n            tie(L, mid, R) = splitByRank(cur -&gt; child[0], rank);\n            cur -&gt; child[0] = R;\n            cur -&gt; push();\n            return {L, mid, cur};\n        } else if (rank &lt;= ls_size + cur -&gt; cnt) {\n            Node&lt;T&gt; *lt = cur -&gt; child[0], *rt = cur -&gt; child[1];\n            cur -&gt; child[0] = cur -&gt; child[1] = nullptr;\n            return {lt, cur, rt};\n        } else {\n            Node&lt;T&gt; *L, *mid, *R;\n            tie(L, mid, R) = splitByRank(cur -&gt; child[1], rank - ls_size - cur -&gt; cnt);\n            cur -&gt; child[1] = L;\n            cur -&gt; push();\n            return {cur, mid, R};\n        }\n    }\n    Node&lt;T&gt;* merge(Node&lt;T&gt;* a, Node&lt;T&gt;* b) {\n        if (a == nullptr) return b;\n        if (b == nullptr) return a;\n        if (a -&gt; rnd &lt; b -&gt; rnd) {\n            a -&gt; child[1] = merge(a -&gt; child[1], b);\n            a -&gt; push();\n            return a;\n        } else {\n            b -&gt; child[0] = merge(a, b -&gt; child[0]);\n            b -&gt; push();\n            return b;\n        }\n    }\n    void insert(const T x) {\n        auto temp = split(root, x);\n        auto l_tr = split(temp.first, x - 1);\n        Node&lt;T&gt;* res;\n        if (l_tr.second == nullptr) {\n            res = new Node(x);\n        } else {\n            l_tr.second -&gt; cnt++;\n            l_tr.second -&gt; push();\n        }\n        Node&lt;T&gt;* l_tr_combined = merge(l_tr.first, l_tr.second == nullptr ? res : l_tr.second);\n        root = merge(l_tr_combined, temp.second);\n    }\n    void erase(const T x) {\n        auto temp = split(root, x);\n        auto l_tr = split(temp.first, x - 1);\n        if (l_tr.second -&gt; cnt &gt; 1) {\n            l_tr.second -&gt; cnt--;\n            l_tr.second -&gt; push();\n            l_tr.first = merge(l_tr.first, l_tr.second);\n        } else {\n            if (temp.first == l_tr.second) {\n                temp.first = nullptr;\n            }\n            delete l_tr.second;\n            l_tr.second = nullptr;\n        }\n        root = merge(l_tr.first, temp.second);\n    }\n    int queryRank(const T val) {\n        return queryRank(root, val);\n    }\n    int queryRank(Node&lt;T&gt;* &amp;cur, const T val) {\n        auto temp = split(cur, val - 1);\n        int res = (temp.first == nullptr ? 0 : temp.first -&gt; size) + 1;\n        root = merge(temp.first, temp.second);\n        return res;\n    }\n    int queryNum(const T val) {\n        return queryNum(root, val);\n    }\n    int queryNum(Node&lt;T&gt;* &amp;cur, const int rank) {\n        Node&lt;T&gt; *L, *mid, *R;\n        tie(L, mid, R) = splitByRank(cur, rank);\n        int res = mid -&gt; val;\n        root = merge(merge(L, mid), R);\n        return res;\n    }\n    int queryPre(const T val) {\n        auto temp = split(root, val - 1);\n        int res = queryNum(temp.first, temp.first -&gt; size);\n        root = merge(temp.first, temp.second);\n        return res;\n    }\n    int querySub(const T val) {\n        auto temp = split(root, val);\n        int res = queryNum(temp.second, 1);\n        root = merge(temp.first, temp.second);\n        return res;\n    }\n}; // Treap\nint main() {\n  ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    Treap&lt;int&gt; tr;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op, x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if (op == 1) {\n            tr.insert(x);\n        } else if (op == 2) {\n            tr.erase(x);\n        } else if (op == 3) {\n            cout &lt;&lt; (tr.queryRank(x)) &lt;&lt; \"\\n\";\n        } else if (op == 4) {\n            cout &lt;&lt; (tr.queryNum(x)) &lt;&lt; \"\\n\";\n        } else if (op == 5) {\n            cout &lt;&lt; (tr.queryPre(x)) &lt;&lt; \"\\n\";\n        } else {\n            cout &lt;&lt; (tr.querySub(x)) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/Treap/#_2","title":"\u5e26\u533a\u95f4\u64cd\u4f5c(\u533a\u95f4\u7ffb\u8f6c)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\ntemplate&lt;class T&gt; struct Node {\n    Node *child[2];\n    T val;\n    int rnd, cnt, size;\n    bool rev;\n    Node(const T&amp; val) : val(val), cnt(1), size(1), rev(false) {\n        rnd = rand();\n        child[0] = child[1] = nullptr;\n    }\n    void push() {\n        size = cnt;\n        if (child[0] != nullptr) {\n            size += child[0] -&gt; size;\n        }\n        if (child[1] != nullptr) {\n            size += child[1] -&gt; size;\n        }\n    }\n    void down() {\n        swap(child[0], child[1]);\n        if (child[0] != nullptr) {\n            child[0] -&gt; rev ^= 1;\n        }\n        if (child[1] != nullptr) {\n            child[1] -&gt; rev ^= 1;\n        }\n        rev = false;\n    }\n    void check() {\n        if (rev) {\n            down();\n        }\n    }\n};\ntemplate&lt;class T&gt; struct Treap {\n    Node&lt;T&gt;* root = nullptr;\n    pair&lt;Node&lt;T&gt;*, Node&lt;T&gt;*&gt; split(Node&lt;T&gt;* cur, const int&amp; size) {\n        if (cur == nullptr) return {nullptr, nullptr};\n        cur -&gt; check();\n        int sz = cur -&gt; child[0] == nullptr ? 0 : cur -&gt; child[0] -&gt; size;\n        if (sz &lt; size) {\n            auto temp = split(cur -&gt; child[1], size - sz - 1);\n            cur -&gt; child[1] = temp.first;\n            cur -&gt; push();\n            return {cur, temp.second};\n        } else {\n            auto temp = split(cur -&gt; child[0], size);\n            cur -&gt; child[0] = temp.second;\n            cur -&gt; push();\n            return {temp.first, cur};\n        }\n    }\n    Node&lt;T&gt;* merge(Node&lt;T&gt;* a, Node&lt;T&gt;* b) {\n        if (a == nullptr) return b;\n        if (b == nullptr) return a;\n        a -&gt; check();\n        b -&gt; check();\n        if (a -&gt; rnd &lt; b -&gt; rnd) {\n            a -&gt; child[1] = merge(a -&gt; child[1], b);\n            a -&gt; push();\n            return a;\n        } else {\n            b -&gt; child[0] = merge(a, b -&gt; child[0]);\n            b -&gt; push();\n            return b;\n        }\n    }\n    void insert(const T&amp; x) {\n        auto temp = split(root, x);\n        auto l_tr = split(temp.first, x - 1);\n        Node&lt;T&gt;* res;\n        if (l_tr.second == nullptr) {\n            res = new Node(x);\n        } else {\n            l_tr.second -&gt; cnt++;\n            l_tr.second -&gt; push();\n        }\n        Node&lt;T&gt;* l_tr_combined = merge(l_tr.first, l_tr.second == nullptr ? res : l_tr.second);\n        root = merge(l_tr_combined, temp.second);\n    }\n    void seg_rev(const int&amp; L, const int&amp; R) {\n        auto less = split(root, L - 1);\n        auto more = split(less.second, R - L + 1);\n        more.first -&gt; rev = true;\n        root = merge(less.first, merge(more.first, more.second));\n    }\n    void print() {\n        print(root);\n    }\n    void print(Node&lt;T&gt;* cur) {\n        if (cur == nullptr) {\n            return;\n        }\n        cur -&gt; check();\n        print(cur -&gt; child[0]);\n        cout &lt;&lt; cur -&gt; val &lt;&lt; \" \";\n        print(cur -&gt; child[1]);\n    }\n}; // Treap\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    Treap&lt;int&gt; tr;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        tr.insert(i);\n    }\n    while (m--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        tr.seg_rev(L, R);\n    }\n    tr.print();\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/heap/","title":"\u5806","text":""},{"location":"Template/DataStructure/heap/#_2","title":"\u5bf9\u9876\u5806","text":"\u4f8b\u9898 \u6d1b\u8c37SP16254 <p>RMID2 - Running Median Again - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nvoid solve() {\n    int x;\n    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;\n    auto check = [&amp;](){\n        int k = a.top();\n        a.pop();\n        return k;\n    };\n    auto adjust = [&amp;]() {\n        int A = a.size(), B = b.size();\n        int len = (A + B + 1) / 2;\n        if (A &gt; len) {\n            b.emplace(a.top()); a.pop();\n        } else if (A &lt; len) {\n            a.emplace(b.top()); b.pop();\n        }\n    };\n    auto push = [&amp;](int k) {\n        if (a.empty() || k &lt;= a.top()) {\n            a.emplace(k);\n        } else {\n            b.emplace(k);\n        }\n    };\n    while (cin &gt;&gt; x) {\n        if (x == 0) {\n            break;\n        }\n        if (x == -1) {\n            cout &lt;&lt; check() &lt;&lt; \"\\n\";\n        } else {\n            push(x);\n        }\n        adjust();\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/","title":"\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811","text":"<p>P3919 \u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 1\uff08\u53ef\u6301\u4e45\u5316\u6570\u7ec4\uff09 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 1000005;\nint a[N];\nint child[N &lt;&lt; 5][2], sum[N &lt;&lt; 5], tot;\nint build(int L, int R) {\n    int now = ++tot;\n    if (L == R) {\n        sum[now] = a[L];\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    child[now][0] = build(L, mid);\n    child[now][1] = build(mid + 1, R);\n    return now;\n}\nint update(int L, int R, int old, int pos, int k) {\n    int now = ++tot;\n    child[now][0] = child[old][0];\n    child[now][1] = child[old][1];\n    sum[now] = sum[old];\n    if (L == R) {\n        sum[now] = k;\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        child[now][0] = update(L, mid, child[now][0], pos, k);\n    } else {\n        child[now][1] = update(mid + 1, R, child[now][1], pos, k);\n    }\n    return now;\n}\nint query(int L, int R, int old, int pos) {\n    if (L == R) {\n        return sum[old];\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) return query(L, mid, child[old][0], pos);\n    return query(mid + 1, R, child[old][1], pos);\n}\nint root[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    root[0] = build(1, n);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int v, op, loc;\n        cin &gt;&gt; v &gt;&gt; op &gt;&gt; loc;\n        if (op == 1) {\n            int val;\n            cin &gt;&gt; val;\n            root[i] = update(1, n, root[v], loc, val);\n        } else {\n            root[i] = root[v];\n            cout &lt;&lt; query(1, n, root[i], loc) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/#_2","title":"\u4e3b\u5e2d\u6811","text":""},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/#k","title":"\u9759\u6001\u533a\u95f4\u7b2c k \u5c0f","text":"<p>P3834 \u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 2 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 200005;\nint a[N];\nint child[N &lt;&lt; 5][2], sum[N &lt;&lt; 5], tot;\nint build(int L, int R) {\n    int now = ++tot;\n    if (L == R) {\n        sum[now] = a[L];\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    child[now][0] = build(L, mid);\n    child[now][1] = build(mid + 1, R);\n    return now;\n}\nint update(int L, int R, int old, int pos) {\n    int now = ++tot;\n    child[now][0] = child[old][0];\n    child[now][1] = child[old][1];\n    sum[now] = sum[old] + 1;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        child[now][0] = update(L, mid, child[now][0], pos);\n    } else {\n        child[now][1] = update(mid + 1, R, child[now][1], pos);\n    }\n    return now;\n}\nint query(int QL, int QR, int L, int R, int pos) {\n    if (L == R) {\n        return L;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int x = sum[child[QR][0]] - sum[child[QL][0]];\n    if (pos &lt;= x) {\n        return query(child[QL][0], child[QR][0], L, mid, pos);\n    }\n    return query(child[QL][1], child[QR][1], mid + 1, R, pos - x);\n}\nint root[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx(1, -0x7fffffff);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.emplace_back(a[i]);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        root[i] = update(1, n, root[i - 1], a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, pos;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; pos;\n        cout &lt;&lt; idx[query(root[L - 1], root[R], 1, n, pos)] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/#_3","title":"\u9759\u6001\u533a\u95f4\u6570\u7684\u6392\u4f4d","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 200005;\nint a[N];\nint child[N &lt;&lt; 5][2], sum[N &lt;&lt; 5], tot;\nint build(int L, int R) {\n    int now = ++tot;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    child[now][0] = build(L, mid);\n    child[now][1] = build(mid + 1, R);\n    return now;\n}\nint update(int L, int R, int old, int pos) {\n    int now = ++tot;\n    child[now][0] = child[old][0];\n    child[now][1] = child[old][1];\n    sum[now] = sum[old] + 1;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        child[now][0] = update(L, mid, child[now][0], pos);\n    } else {\n        child[now][1] = update(mid + 1, R, child[now][1], pos);\n    }\n    return now;\n}\nint query(int QL, int QR, int L, int R, int pos) {\n    if (pos &lt; L) {\n        return 0;\n    }\n    if (R &lt; pos) {\n        return sum[QR] - sum[QL];\n    }\n    if (L == R) {\n        return 0;\n    }\n    int mid = L + R &gt;&gt; 1;\n    int res = 0;\n    if (pos &gt;= L) {\n        res += query(child[QL][0], child[QR][0], L, mid, pos);\n    }\n    if (pos &gt; mid) {\n        res += query(child[QL][1], child[QR][1], mid + 1, R, pos);\n    }\n    return res;\n}\nint root[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        root[i] = update(1, n, root[i - 1], a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, pos;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; pos;\n        cout &lt;&lt; query(root[L - 1], root[R], 1, n, pos) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/#uv","title":"\u9759\u6001\u533a\u95f4[u,v]\u7684\u4e2a\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 100005;\nint n, a[N];\nlong long child[N &lt;&lt; 5][2], sum[N &lt;&lt; 5];\nint tot;\nint update(int L, int R, int old, int pos) {\n    int now = ++tot;\n    sum[now] = sum[old] + 1;\n    child[now][0] = child[old][0];\n    child[now][1] = child[old][1];\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) child[now][0] = update(L, mid, child[now][0], pos);\n    else child[now][1] = update(mid + 1, R, child[now][1], pos);\n    return now;\n}\nint query(int L, int R, int old, int QL, int QR) {\n    if (QL &gt; QR) return 0;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return sum[old];\n    }\n    int mid = L + R &gt;&gt; 1;\n    int res = 0;\n    if (QL &lt;= mid) {\n        res += query(L, mid, child[old][0], QL, QR);\n    }\n    if (QR &gt; mid) {\n        res += query(mid + 1, R, child[old][1], QL, QR);\n    }\n    return res;\n}\nint root[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        root[i] = update(1, n, root[i - 1], a[i]);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, QL, QR;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; QL &gt;&gt; QR;\n        cout &lt;&lt; query(1, n, root[R], QL, QR) - query(1, n, root[L - 1], QL, QR) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/#_4","title":"\u9759\u6001\u533a\u95f4\u989c\u8272\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nconst int N = 1000000;\nint child[N &lt;&lt; 6][2], sum[N &lt;&lt; 6], rt[N &lt;&lt; 6], tot;\n\nint build(int L, int R) {\n    int now = ++tot;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    child[now][0] = build(L, mid);\n    child[now][1] = build(mid + 1, R);\n    return now;\n}\n\nint update(int L, int R, int old, int pos, int k) {\n    int now = ++tot;\n    child[now][0] = child[old][0];\n    child[now][1] = child[old][1];\n    sum[now] = sum[old] + k;\n    if (L == R) {\n        return now;\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        child[now][0] = update(L, mid, child[now][0], pos, k);\n    } else {\n        child[now][1] = update(mid + 1, R, child[now][1], pos, k);\n    }\n    return now;\n}\n\nint query(int L, int R, int pos, int rt) {\n    if (L == R) {\n        return sum[rt];\n    }\n    int mid = L + R &gt;&gt; 1;\n    if (pos &lt;= mid) {\n        return query(L, mid, pos, child[rt][0]) + sum[child[rt][1]];\n    }\n    return query(mid + 1, R, pos, child[rt][1]);\n}\n\nint a[N], last[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    rt[0] = build(1, n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (last[a[i]] == 0) {\n            rt[i] = update(1, n, rt[i - 1], i, 1);\n        } else {\n            int temp = update(1, n, rt[i - 1], last[a[i]], -1);\n            rt[i] = update(1, n, temp, i, 1);\n        }\n        last[a[i]] = i;\n    }\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        cout &lt;&lt; query(1, n, L, rt[R]) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%9D%97%E7%8A%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"\u5757\u72b6\u6570\u636e\u7ed3\u6784","text":"<p>P2801 \u6559\u4e3b\u7684\u9b54\u6cd5 - \u6d1b\u8c37</p> <p>#6280. \u6570\u5217\u5206\u5757\u5165\u95e8 4 - LibreOJ</p>"},{"location":"Template/DataStructure/%E5%9D%97%E7%8A%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_2","title":"\u5757\u72b6\u6570\u7ec4","text":"Code C++<pre><code>struct Block {\n    struct Info {\n        long long value, delta, sum;\n        Info() = default;\n    };\n    int num;\n    vector&lt;int&gt; belong, size;\n    vector&lt;int&gt; st, ed;\n    vector&lt;Info&gt; info;\n    Block() = default;\n    Block(const int N) : num(sqrt(N)), info(N + 1), st(num + 1), ed(num + 1), belong(N + 1), size(N + 1) {\n        const int k = N / num;\n        for (int i = 1 ; i &lt;= num ; i++) {\n            st[i] = k * (i - 1) + 1;\n            ed[i] = k * i;\n        }\n        ed[num] = N;\n        for (int i = 1 ; i &lt;= num ; i++) {\n            for (int j = st[i] ; j &lt;= ed[i] ; j++) {\n                belong[j] = i;\n            }\n            size[i] = ed[i] - st[i] + 1;\n        }\n    }\n    void init(const vector&lt;long long&gt; &amp;a) {\n        for (int i = 1 ; i &lt; int(a.size()) ; i++) {\n            info[i].value = a[i];\n            info[belong[i]].sum += a[i];\n        }\n    }\n    void modify(const int L, const int R, const int k) {\n        const int&amp; x = belong[L];\n        const int&amp; y = belong[R];\n        if (x == y) {\n            for (int i = L ; i &lt;= R ; i++) {\n                info[i].value += k;\n                info[x].sum += k;\n            }\n            return;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) {\n            info[i].value += k;\n            info[x].sum += k;\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) {\n            info[i].value += k;\n            info[y].sum += k;\n        }\n        for (int i = x + 1 ; i &lt; y ; i++) {\n            info[i].delta += k;\n            info[i].sum += 1LL * size[i] * k;\n        }\n    }\n    template&lt;class T&gt; T query(const int L, const int R, const int k) {\n        T res = 0;\n        const int&amp; x = belong[L];\n        const int&amp; y = belong[R];\n        if (x == y) {\n            for (int i = L ; i &lt;= R ; i++) {\n                res = (res + info[i].value + info[x].delta) % k;\n            }\n            return res;\n        }\n        for (int i = L ; i &lt;= ed[x] ; i++) {\n            res = (res + info[i].value + info[x].delta) % k;\n        }\n        for (int i = st[y] ; i &lt;= R ; i++) {\n            res = (res + info[i].value + info[y].delta) % k;\n        }\n        for (int i = x + 1 ; i &lt; y ; i++) {\n            res = (res + info[i].sum) % k;\n        }\n        return res;\n    }\n    void print(const int L, const int R) {\n        for (int i = L ; i &lt;= R ; i++) {\n            cout &lt;&lt; info[i].value + info[belong[i]].delta &lt;&lt; \" \\n\"[i == R];\n        }\n    }\n}; // Block\n</code></pre>"},{"location":"Template/DataStructure/%E5%9D%97%E7%8A%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_3","title":"\u6811\u5206\u5757","text":"<p>P6177 Count on a tree II/\u3010\u6a21\u677f\u3011\u6811\u5206\u5757 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 40001;\nconst int S = 200;\nbitset&lt;N&gt; bs[N / S + 1][N / S + 1], res;\nvector&lt;int&gt; adj[N];\nint a[N], up[N], deep[N], fa[N][17], id[N], rev[N / S + 1], tot;\nvoid dfs(int u, int p) {\n    static int mxd[N];\n    mxd[u] = deep[u] = deep[p] + 1;\n    fa[u][0] = p;\n    for (int i = 1 ; (1 &lt;&lt; i) &lt;= deep[u] ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        mxd[u] = max(mxd[u], mxd[v]);\n    }\n    if (mxd[u] - deep[u] &gt;= S &amp;&amp; u != 1) {\n        id[u] = ++tot;\n        rev[tot] = u;\n        mxd[u] = deep[u];\n    }\n}\nvoid build(int u, int p) {\n    static int y, tot = 0, h[N];\n    if (id[u] != 0) {\n        y = fa[u][0];\n        bs[h[tot]][id[u]].set(a[u]);\n        while (id[y] == 0 &amp;&amp; y != 0) {\n            bs[h[tot]][id[u]].set(a[y]);\n            y = fa[y][0];\n        }\n        if (y != 0) {\n            bs[h[tot]][id[u]].set(a[y]);\n        }\n        h[++tot] = id[u];\n        up[u] = rev[h[tot - 1]];\n        for (int i = tot - 2 ; i &gt;= 1 ; i--) {\n            bs[h[i]][id[u]] = bs[h[i]][h[tot - 1]] | bs[h[i + 1]][h[tot]];\n        }\n    }\n    for (auto &amp;v : adj[u]) {\n        if (v == p) continue;\n        build(v, u);\n    }\n    if (id[u]) tot--;\n}\nint LCA(int x, int y) {\n    if (deep[x] &gt; deep[y]) swap(x, y);\n    for (int i = 16 ; i &gt;= 0 ; i--) {\n        if (deep[x] &gt; deep[fa[y][i]]) continue;\n        y = fa[y][i];\n    }\n    if (x == y) return x;\n    for (int i = 16 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idx;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        idx.emplace_back(a[i]);\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    sort(begin(idx), end(idx));\n    idx.resize(unique(begin(idx), end(idx)) - begin(idx));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(idx), end(idx), a[i]) - begin(idx);\n    }\n    id[1] = ++tot;\n    rev[tot] = 1;\n    dfs(1, 0);\n    build(1, 0);\n    int ans = 0;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x ^= ans;\n        int z = LCA(x, y);\n        res.reset();\n        while (id[x] == 0 &amp;&amp; x != z) {\n            res.set(a[x]);\n            x = fa[x][0];\n        }\n        while (id[y] == 0 &amp;&amp; y != z) {\n            res.set(a[y]);\n            y = fa[y][0];\n        }\n        if (x != z) {\n            int k = x;\n            while (deep[up[x]] &gt;= deep[z]) {\n                x = up[x];\n            }\n            if (k != x) {\n                res |= bs[id[x]][id[k]];\n            }\n            while (x != z) {\n                res.set(a[x]);\n                x = fa[x][0];\n            }\n        }\n        if (y != z) {\n            int k = y;\n            while (deep[up[y]] &gt;= deep[z]) {\n                y = up[y];\n            }\n            if (k != y) {\n                res |= bs[id[y]][id[k]];\n            }\n            while (y != z) {\n                res.set(a[y]);\n                y = fa[y][0];\n            }\n        }\n        res.set(a[z]);\n        ans = res.count();\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"\u5e76\u67e5\u96c6","text":""},{"location":"Template/DataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/#_2","title":"\u8def\u5f84\u538b\u7f29+\u542f\u53d1\u5f0f\u5408\u5e76","text":"Code C++<pre><code>struct DSU {\n    vector&lt;int&gt; f;\n    dsu(const int N) : f(N) {\n        iota(f.begin(), f.end(), 0);\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        f[y] = x;\n    }\n    int find(const int x) {\n        if (f[x] == x) return x;\n        const int k = f[x];\n        f[x] = find(f[x]);\n        return f[x];\n    }\n}; // DSU\n</code></pre>"},{"location":"Template/DataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/#_3","title":"\u5e26\u4fee","text":"Code C++<pre><code>struct DSU {\n    vector&lt;int&gt; f, fs;\n    DSU(const int N) : f(N &lt;&lt; 1), fs(N &lt;&lt; 1, 1) {\n        iota(f.begin(), f.begin() + N, N);\n        iota(f.begin() + N, f.end(), N);\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (fs[x] &lt; fs[y]) swap(x, y);\n        f[y] = x;\n        fs[x] += fs[y];\n    }\n    void move(int x, int y) {\n        const int fx = find(x), fy = find(y);\n        if (fx == fy) return;\n        f[x] = fy;\n        --fs[fx];\n        ++fs[fy];\n    }\n    void erase(const int x) {\n        --fs[find(x)];\n        f[x] = x;\n    }\n    int find(const int x) {\n        if (f[x] == x) return x;\n        const int k = f[x];\n        f[x] = find(f[x]);\n        return f[x];\n    }\n}; // DSU\n</code></pre>"},{"location":"Template/DataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/#_4","title":"\u5e26\u6743","text":"Code C++<pre><code>struct Vector {\n    int val;\n    Vector() = default;\n    Vector(int val) : val(val) {}\n    Vector operator-() const {\n        return Vector(-val);\n    }\n    friend Vector operator+(const Vector &amp;lhs, const Vector &amp;rhs) {\n        int x = lhs.val + rhs.val;\n        return Vector(x);\n    }\n};\nint f[50005];\nVector val[50005];\nint find(int x) {\n    if (f[x] == x) return x;\n    find(f[x]);\n    val[x] = val[x] + val[f[x]];\n    return f[x] = f[f[x]];\n}\nvoid unite(int x, int y, Vector v) {\n    int tx = find(x), ty = find(y);\n    if (tx == ty) return;\n    val[tx] = val[y] + -val[x] + v;\n    f[tx] = ty;\n}\nVector query(int x, int y) {\n    int tx = find(x), ty = find(y);\n    assert(tx == ty);\n    return val[x] + -val[y];\n}\n</code></pre>"},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/","title":"\u6570\u636e\u7ed3\u6784\u6742\u9898(1)","text":""},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/#_1","title":"\u7ebf\u6bb5\u6811","text":""},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/#_2","title":"\u6c42\u533a\u95f4\u6700\u957f\u8fde\u7eed\u76f8\u540c\u5b57\u7b26","text":"<p>L-\u6700\u957f\u8fde\u7eed\u76f8\u540c\u5b57\u7b26_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u4e8c\uff09\u573a\uff1a\u6cb3\u5357\u5de5\u4e1a\u5927\u5b66</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int MAXN = 100000;\nstring str;\nint Lmx[MAXN &lt;&lt; 4], Rmx[MAXN &lt;&lt; 4], mx[MAXN &lt;&lt; 4], Lc[MAXN &lt;&lt; 4], Rc[MAXN &lt;&lt; 4];\nvoid push(const int p, const int L, const int R, const int mid) {\n    const int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n    Lmx[p] = Lmx[x];\n    Rmx[p] = Rmx[y];\n    if (Lmx[x] == mid - L + 1 &amp;&amp; str[mid] == str[mid + 1]) {\n        Lmx[p] += Lmx[y];\n    }\n    if (Rmx[y] == R - mid &amp;&amp; str[mid] == str[mid + 1]) {\n        Rmx[p] += Rmx[x];\n    }\n    if (mx[x] &gt;= mx[y]) {\n        mx[p] = mx[x];\n        Lc[p] = Lc[x];\n        Rc[p] = Rc[x];\n    } else {\n        mx[p] = mx[y];\n        Lc[p] = Lc[y];\n        Rc[p] = Rc[y];\n    }\n    if (str[mid] == str[mid + 1]) {\n        if (mx[p] &lt; Rmx[x] + Lmx[y]) {\n            mx[p] = Rmx[x] + Lmx[y];\n            Lc[p] = mid - Rmx[x] + 1;\n            Rc[p] = mid + Lmx[y];\n        } else if (mx[p] == Rmx[x] + Lmx[y]) {\n            if (Lc[p] &gt; mid - Rmx[x] + 1) {\n                Lc[p] = mid - Rmx[x] + 1;\n                Rc[p] = mid + Lmx[y];\n            }\n        }\n    }\n}\nvoid build(const int p, const int L, const int R) {\n    if (L == R) {\n        Lmx[p] = Rmx[p] = mx[p] = 1;\n        Lc[p] = Rc[p] = L;\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    push(p, L, R, mid);\n}\nvoid modify(const int p, const int pos, const char ch, const int L, const int R) {\n    if (R &lt; pos || L &gt; pos) {\n        return;\n    }\n    if (L == R) {\n        str[L] = ch;\n        return;\n    }\n    const int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, pos, ch, L, mid);\n    modify(p &lt;&lt; 1 | 1, pos, ch, mid + 1, R);\n    push(p, L, R, mid);\n}\npair&lt;int, int&gt; query(const int p, const int QL, const int QR, const int L, const int R) {\n    if (QR &lt; L || QL &gt; R) {\n        return {1, 0};\n    }\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return {Lc[p], Rc[p]};\n    }\n    const int mid = L + R &gt;&gt; 1;\n    auto resL = query(p &lt;&lt; 1, QL, QR, L, mid);\n    pair&lt;int, int&gt; resMid = {1, 0};\n    if (str[mid] == str[mid + 1] &amp;&amp; mid &gt;= QL &amp;&amp; mid + 1 &lt;= QR) {\n        resMid = {max(QL, mid - Rmx[p &lt;&lt; 1] + 1), min(QR, mid + Lmx[p &lt;&lt; 1 | 1])};\n    }\n    if (resL.second - resL.first + 1 &lt; resMid.second - resMid.first + 1) {\n        resL = resMid;\n    }\n    auto resR = query(p &lt;&lt; 1 | 1, QL, QR, mid + 1, R);\n    if (resL.second - resL.first + 1 &lt; resR.second - resR.first + 1) {\n        resL = resR;\n    }\n    return resL;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    cin &gt;&gt; str;\n    str = \" \" + str;\n    build(1, 1, n);\n    for (int i = 0 ; i &lt; m ; i++) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            if (L == 0) L = 1;\n            auto [x, y] = query(1, L, R, 1, n);\n            cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";\n        } else {\n            int x;\n            char ch;\n            cin &gt;&gt; x &gt;&gt; ch;\n            modify(1, x, ch, 1, n);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/#_3","title":"\u989c\u8272\u4e92\u6362\uff0c\u67d3\u8272\uff0c\u5206\u88c2","text":"<p>6.\u9b54\u672f\u5e08\u3010\u7b97\u6cd5\u8d5b\u3011 - \u84dd\u6865\u4e91\u8bfe (lanqiao.cn)</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2023 OneWan\n\nconst int N = 100000 + 5;\n// const int M = 1 &lt;&lt; __lg(N + 5) + 1;\nconst int M = N &lt;&lt; 4;\nconst long long mod = 998244353;\n\nstruct Node {\n    int L, R;\n    long long sum[3];\n    Node() {\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            sum[i] = 0;\n        }\n    }\n    friend Node operator+ (const Node &amp;lhs, const Node &amp;rhs) {\n        Node res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.sum[i] = (lhs.sum[i] + rhs.sum[i]) % mod;\n        }\n        return res;\n    }\n\n} tr[M];\nstruct Tag {\n    int to[3];\n    long long mul[3];\n    Tag() {\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            to[i] = i;\n            mul[i] = 1;\n        }\n    }\n} lazy[M];\n\nint a[N];\n\nvoid pushtag(int p, Tag tag) {\n    {\n        Node res;\n        res.L = tr[p].L;\n        res.R = tr[p].R;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.sum[tag.to[i]] = (res.sum[tag.to[i]] + tag.mul[i] * tr[p].sum[i] % mod) % mod;\n        }\n        tr[p] = res;\n    }\n    {\n        Tag res;\n        for (int i = 0 ; i &lt; 3 ; i++) {\n            res.to[i] = tag.to[lazy[p].to[i]];\n            res.mul[i] = lazy[p].mul[i] * tag.mul[lazy[p].to[i]] % mod;    \n        }\n        lazy[p] = res;\n    }\n}\n// \nvoid pushdown(int p) {\n    pushtag(p &lt;&lt; 1, lazy[p]);\n    pushtag(p &lt;&lt; 1 | 1, lazy[p]);\n    lazy[p] = Tag();\n}\nint n;\nvoid build(int p = 1, int L = 1, int R = n) {\n    tr[p].L = L;\n    tr[p].R = R;\n    if (L == R) {\n        tr[p].sum[a[L]] = 1;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\n\nvoid modify(int p, int QL, int QR, Tag tag) {\n    // cerr &lt;&lt; tr[p].L &lt;&lt; \" \" &lt;&lt; tr[p].R &lt;&lt; \"\\n\";\n    if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n        pushtag(p, tag);\n        // cout &lt;&lt; tr[p].sum[0] &lt;&lt; \" \" &lt;&lt; tr[p].sum[1] &lt;&lt; \" \" &lt;&lt; tr[p].sum[2] &lt;&lt; \"\\n\";\n        return;\n    }\n    pushdown(p);\n    int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n    if (QL &lt;= mid) modify(p &lt;&lt; 1, QL, QR, tag);\n    if (QR &gt;= mid + 1) modify(p &lt;&lt; 1 | 1, QL, QR, tag);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        a[i]--;\n    }\n    build();\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int L, R, op;\n        cin &gt;&gt; L &gt;&gt; R &gt;&gt; op;\n        Tag tag;\n        if (op == 1) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            x--;\n            y--;\n            tag.to[x] = y;\n            tag.to[y] = x;\n        }\n        if (op == 2) {\n            int x, y;\n            cin &gt;&gt; x &gt;&gt; y;\n            x--;\n            y--;\n            tag.to[x] = y;\n        }\n        if (op == 3) {\n            int x;\n            cin &gt;&gt; x;\n            x--;\n            tag.mul[x] = 2;\n        }\n        // cout &lt;&lt; tag.to[0] &lt;&lt; \" \" &lt;&lt; tag.to[1] &lt;&lt; \" \" &lt;&lt; tag.to[2] &lt;&lt; \"\\n\";\n        modify(1, L, R, tag);\n        cout &lt;&lt; tr[1].sum[0] &lt;&lt; \" \" &lt;&lt; tr[1].sum[1] &lt;&lt; \" \" &lt;&lt; tr[1].sum[2] &lt;&lt; \"\\n\";\n        // break;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/#_4","title":"\u6811\u72b6\u6570\u7ec4","text":""},{"location":"Template/DataStructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A2%98%281%29/#_5","title":"\u4e8c\u7ef4\u6570\u70b9","text":"<p>P2163 [SHOI2007] \u56ed\u4e01\u7684\u70e6\u607c - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt; struct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(const int n) {\n        init(n);\n    }\n    void init(const int n) {\n        size = n;\n        sum.assign(n + 1, 0);\n    }\n    void clear() {\n        sum.clear();\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(const int L, const int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, const T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; idxX, idxY;\n    vector&lt;int&gt; aX(n), aY(n), bX(m &lt;&lt; 1), bY(m &lt;&lt; 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; aX[i] &gt;&gt; aY[i];\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; bX[i] &gt;&gt; bY[i] &gt;&gt; bX[i + m] &gt;&gt; bY[i + m];\n        bX[i]--;\n        bY[i]--;\n    }\n    idxX.emplace_back(-100);\n    idxY.emplace_back(-100);\n    copy(make_move_iterator(begin(aX)), make_move_iterator(end(aX)), back_inserter(idxX));\n    copy(make_move_iterator(begin(bX)), make_move_iterator(end(bX)), back_inserter(idxX));\n    copy(make_move_iterator(begin(aY)), make_move_iterator(end(aY)), back_inserter(idxY));\n    copy(make_move_iterator(begin(bY)), make_move_iterator(end(bY)), back_inserter(idxY));\n    auto Unique = [&amp;](auto&amp; res) -&gt; void {\n        sort(begin(res), end(res));\n        res.resize(unique(begin(res), end(res)) - begin(res));\n    };\n    auto get = [&amp;](auto&amp; res, int val) {\n        return lower_bound(begin(res), end(res), val) - begin(res);\n    };\n    Unique(idxX);\n    Unique(idxY);\n    int lenX = idxX.size(), lenY = idxY.size();\n    vector&lt;int&gt; X1[lenX], X2[lenX], X3[lenX], ans(m);\n    for (int i = 0 ; i &lt; n ; i++) {\n        aX[i] = get(idxX, aX[i]);\n        aY[i] = get(idxY, aY[i]);\n        X1[aX[i]].emplace_back(i);\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        bX[i] = get(idxX, bX[i]);\n        bY[i] = get(idxY, bY[i]);\n        bX[i + m] = get(idxX, bX[i + m]);\n        bY[i + m] = get(idxY, bY[i + m]);\n        X2[bX[i]].emplace_back(i);\n        X3[bX[i + m]].emplace_back(i);\n    }\n    FenwickTree&lt;int&gt; ft(lenY);\n    for (int i = 1 ; i &lt; lenX ; i++) {\n        for (auto&amp; pos : X1[i]) {\n            ft.add(aY[pos], 1);\n        }\n        for (auto&amp; pos : X2[i]) {\n            ans[pos] += ft.query(bY[pos]) - ft.query(bY[pos + m]);\n        }\n        for (auto&amp; pos : X3[i]) {\n            ans[pos] += ft.query(bY[pos + m]) - ft.query(bY[pos]);\n        }\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/","title":"\u83ab\u961f","text":""},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/#_2","title":"\u666e\u901a\u83ab\u961f","text":"<p>P1494 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u5c0f Z \u7684\u889c\u5b50 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[1000005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        if (belong[L] &amp; 1) return R &lt; x.R;\n        return R &gt; x.R;\n    }\n};\nint C[50005], cnt[50005];\nlong long sum;\nvoid add(int x) {\n    sum += cnt[x];\n    cnt[x]++;\n}\nvoid del(int x) {\n    cnt[x]--;\n    sum -= cnt[x];\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = sqrt(N);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = i / mx;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; C[i];\n    }\n    vector&lt;MQuery&gt; mq(M);\n    for (int i = 0 ; i &lt; M ; i++) {\n        cin &gt;&gt; mq[i].L &gt;&gt; mq[i].R;\n        mq[i].idx = i;\n    }\n    sort(begin(mq), end(mq));\n    vector&lt;pair&lt;long long, long long&gt;&gt; ans(M);\n    for (int i = 0, L = 1, R = 0 ; i &lt; M ; i++) {\n        if (mq[i].L == mq[i].R) {\n            ans[mq[i].idx] = {0, 1};\n            continue;\n        }\n        while (L &gt; mq[i].L) add(C[--L]);\n        while (R &lt; mq[i].R) add(C[++R]);\n        while (L &lt; mq[i].L) del(C[L++]);\n        while (R &gt; mq[i].R) del(C[R--]);\n        ans[mq[i].idx] = {sum, 1LL * (R - L + 1) * (R - L) / 2};\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        auto [p, q] = ans[i];\n        long long d = __gcd(p, q);\n        p /= d;\n        q /= d;\n        cout &lt;&lt; p &lt;&lt; \"/\" &lt;&lt; q &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/#_3","title":"\u5e26\u4fee\u83ab\u961f","text":"<p>P1903 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u6570\u989c\u8272 / \u7ef4\u62a4\u961f\u5217 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[1000005];\nstruct MQuery {\n    int L, R, idx, time;        \n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        if (belong[R] == belong[x.R]) return time &lt; x.time;\n        if (belong[L] &amp; 1) return R &lt; x.R;\n        return R &gt; x.R;\n    }\n};\nint color[1000005], cnt[1000005];\nvector&lt;MQuery&gt; mq;\nvector&lt;pair&lt;int, int&gt;&gt; change(1);\nint res;\nvoid add(int x) {\n    if (cnt[x]++ == 0) res++;\n}\nvoid del(int x) {\n    if (cnt[x]-- == 1) res--;\n}\nvoid modify(int now, int i) {\n    if (change[now].first &gt;= mq[i].L &amp;&amp; change[now].first &lt;= mq[i].R) {\n        del(color[change[now].first]);\n        add(change[now].second);\n    }\n    swap(color[change[now].first], change[now].second);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = pow(N, 0.6666666666);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = i / mx;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; color[i];\n    }\n    int qcnt = 0, ccnt = 0;\n    for (int i = 0 ; i &lt; M ; i++) {\n        char ch;\n        int a, b;\n        cin &gt;&gt; ch &gt;&gt; a &gt;&gt; b;\n        if (ch == 'Q') {\n            mq.push_back({a, b, qcnt, ccnt});\n            qcnt++;\n        } else {\n            change.push_back({a, b});\n            ccnt++;\n        }\n    }\n    vector&lt;int&gt; ans(qcnt);\n    sort(begin(mq), end(mq));\n    for (int i = 0, L = 1, R = 0, now = 0 ; i &lt; qcnt ; i++) {\n        while (L &gt; mq[i].L) add(color[--L]);\n        while (R &lt; mq[i].R) add(color[++R]);\n        while (L &lt; mq[i].L) del(color[L++]);\n        while (R &gt; mq[i].R) del(color[R--]);\n        while (now &gt; mq[i].time) modify(now--, i);\n        while (now &lt; mq[i].time) modify(++now, i);\n        ans[mq[i].idx] = res;\n    }\n    for (int i = 0 ; i &lt; qcnt ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[100005], a[100005], cnt[200005], mex[100005];\nstruct MQuery {\n    int L, R, idx, time;        \n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        if (belong[R] == belong[x.R]) return time &lt; x.time;\n        if (belong[L] &amp; 1) return R &lt; x.R;\n        return R &gt; x.R;\n    }\n};\nvector&lt;MQuery&gt; mq;\nvector&lt;pair&lt;int, int&gt;&gt; change(1);\nvoid add(int x) {\n    mex[cnt[x]]--;\n    cnt[x]++;\n    mex[cnt[x]]++;\n}\nvoid del(int x) {\n    mex[cnt[x]]--;\n    cnt[x]--;\n    mex[cnt[x]]++;\n}\nvoid modify(int now, int i) {\n    if (change[now].first &gt;= mq[i].L &amp;&amp; change[now].first &lt;= mq[i].R) {\n        del(a[change[now].first]);\n        add(change[now].second);\n    }\n    swap(a[change[now].first], change[now].second);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    int mx = pow(n, 0.6666666666);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        belong[i] = i / mx;\n    }\n    vector&lt;int&gt; temp(1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        temp.emplace_back(a[i]);\n    }\n    int qcnt = 0, ccnt = 0;\n    for (int i = 0 ; i &lt; q ; i++) {\n        int op, L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 1) {\n            mq.push_back({L, R, qcnt, ccnt});\n            qcnt++;\n        } else {\n            change.emplace_back(L, R);\n            temp.emplace_back(R);\n            ccnt++;\n        }\n    }\n    sort(begin(mq), end(mq));\n    sort(begin(temp), end(temp));\n    temp.resize(unique(begin(temp), end(temp)) - begin(temp));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        a[i] = lower_bound(begin(temp), end(temp), a[i]) - begin(temp);\n    }\n    for (auto &amp;[x, y] : change) {\n        y = lower_bound(begin(temp), end(temp), y) - begin(temp);\n    }\n    vector&lt;int&gt; ans(qcnt);\n    for (int i = 0, L = 1, R = 0, now = 0 ; i &lt; qcnt ; i++) {\n        while (L &gt; mq[i].L) add(a[--L]);\n        while (R &lt; mq[i].R) add(a[++R]);\n        while (L &lt; mq[i].L) del(a[L++]);\n        while (R &gt; mq[i].R) del(a[R--]);\n        while (now &gt; mq[i].time) modify(now--, i);\n        while (now &lt; mq[i].time) modify(++now, i);\n        int res = 1;\n        while (mex[res]) res++;\n        ans[mq[i].idx] = res;\n    }\n    for (int i = 0 ; i &lt; qcnt ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/#_4","title":"\u56de\u6eda\u83ab\u961f","text":""},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/#_5","title":"\u4e0d\u5220\u9664\u83ab\u961f","text":"<p>P5906 \u3010\u6a21\u677f\u3011\u56de\u6eda\u83ab\u961f&amp;\u4e0d\u5220\u9664\u83ab\u961f - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[200005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        return R &lt; x.R;\n    }\n};\nint a[200005], b[200005];\npair&lt;int, int&gt; cnt[200005], cnt1[200005];\nint res;\nvoid addRight(int i) {\n    if (cnt[a[i]].first == 0) cnt[a[i]].first = i;\n    cnt[a[i]].second = i;\n    res = max(res, cnt[a[i]].second - cnt[a[i]].first);\n}\nvoid addLeft(int i) {\n    if (cnt1[a[i]].second == 0) cnt1[a[i]].second = i;\n    cnt1[a[i]].first = i;\n    res = max(res, max(cnt1[a[i]].second, cnt[a[i]].second) - cnt1[a[i]].first);\n}\nvoid del(int i) {\n    cnt[a[i]] = {0, 0};\n}\nvoid rollBack(int i) {\n    cnt1[a[i]] = {0, 0};\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N;\n    cin &gt;&gt; N;\n    int mx = sqrt(N);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = (i - 1)/ mx + 1;\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        b[i] = (i == belong[N]) ? N : mx * i;\n    }\n    vector&lt;int&gt; c(1);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; a[i];\n        c.emplace_back(a[i]);\n    }\n    sort(begin(c), end(c));\n    c.resize(unique(begin(c), end(c)) - begin(c));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        a[i] = lower_bound(begin(c), end(c), a[i]) - begin(c);\n    }\n    int M;\n    cin &gt;&gt; M;\n    vector&lt;MQuery&gt; mq;\n    for (int i = 0 ; i &lt; M ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mq.emplace_back(L, R, i);\n    }\n    sort(begin(mq), end(mq));\n    vector&lt;int&gt; ans(M);\n    int last = belong[mq[0].L], R = b[last], L = R + 1;\n    for (int i = 0 ; i &lt; M ; i++) {\n        if (belong[mq[i].L] == belong[mq[i].R]) {\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                if (cnt1[a[j]].first == 0) cnt1[a[j]].first = j;\n                cnt1[a[j]].second = j;\n            }\n            int temp = 0;\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                temp = max(temp, cnt1[a[j]].second - cnt1[a[j]].first);\n            }\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]] = {0, 0};\n            }\n            ans[mq[i].idx] = temp;\n            continue;\n        }\n        if (last != belong[mq[i].L]) {\n            while (R &gt; b[belong[mq[i].L]]) del(R--);\n            while (L &lt; b[belong[mq[i].L]] + 1) del(L++);\n            res = 0;\n            last = belong[mq[i].L];\n        }\n        while (R &lt; mq[i].R) addRight(++R);\n        int temp = res, L1 = L;\n        while (L1 &gt; mq[i].L) addLeft(--L1);\n        ans[mq[i].idx] = res;\n        while (L1 &lt; L) rollBack(L1++);\n        res = temp;\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>C - \u6b74\u53f2\u306e\u7814\u7a76 </p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[100005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        return R &lt; x.R;\n    }\n};\nint a[100005], b[100005];\nint cnt[100005], cnt1[100005];\nvector&lt;int&gt; c(1);\nlong long res;\nvoid add(int i) {\n    cnt[a[i]]++;\n    res = max(res, 1LL * cnt[a[i]] * c[a[i]]);\n}\nvoid del(int i) {\n    cnt[a[i]]--;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = sqrt(N);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = (i - 1)/ mx + 1;\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        b[i] = (i == belong[N]) ? N : mx * i;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; a[i];\n        c.emplace_back(a[i]);\n    }\n    sort(begin(c), end(c));\n    c.resize(unique(begin(c), end(c)) - begin(c));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        a[i] = lower_bound(begin(c), end(c), a[i]) - begin(c);\n    }\n    vector&lt;MQuery&gt; mq;\n    for (int i = 0 ; i &lt; M ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mq.push_back({L, R, i});\n    }\n    sort(begin(mq), end(mq));\n    vector&lt;long long&gt; ans(M);\n    int last = belong[mq[0].L], R = b[last], L = R + 1;\n    for (int i = 0 ; i &lt; M ; i++) {\n        if (belong[mq[i].L] == belong[mq[i].R]) {\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]++;\n            }\n            long long temp = 0;\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                temp = max(temp, 1LL * cnt1[a[j]] * c[a[j]]);\n            }\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]--;\n            }\n            ans[mq[i].idx] = temp;\n            continue;\n        }\n        if (last != belong[mq[i].L]) {\n            while (R &gt; b[belong[mq[i].L]]) del(R--);\n            while (L &lt; b[belong[mq[i].L]] + 1) del(L++);\n            res = 0;\n            last = belong[mq[i].L];\n        }\n        while (R &lt; mq[i].R) add(++R);\n        long long temp = res;\n        int L1 = L;\n        while (L1 &gt; mq[i].L) add(--L1);\n        ans[mq[i].idx] = res;\n        while (L1 &lt; L) del(L1++);\n        res = temp;\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DataStructure/%E8%8E%AB%E9%98%9F/#_6","title":"\u4e0d\u589e\u52a0\u83ab\u961f","text":"<p>P4137 Rmq Problem / mex - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[200005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        return R &gt; x.R;\n    }\n};\nint a[200005], b[200005];\nint cnt[200005], cnt1[200005];\nint res;\nvoid add(int i) {\n    cnt[a[i]]++;\n}\nvoid del(int i) {\n    if (cnt[a[i]]-- == 1) {\n        res = min(res, a[i]);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = sqrt(N);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = (i - 1)/ mx + 1;\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        b[i] = mx * (i - 1) + 1;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; a[i];\n        cnt[a[i]]++;\n    }\n    while (cnt[res]) res++;\n    vector&lt;MQuery&gt; mq;\n    for (int i = 0 ; i &lt; M ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mq.push_back({L, R, i});\n    }\n    sort(begin(mq), end(mq));\n    vector&lt;long long&gt; ans(M);\n    int L = 1, R = N, last = 0;\n    for (int i = 0 ; i &lt; M ; i++) {\n        if (belong[mq[i].L] == belong[mq[i].R]) {\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]++;\n            }\n            int temp = 0;\n            while (cnt1[temp]) temp++;\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]--;\n            }\n            ans[mq[i].idx] = temp;\n            continue;\n        }\n        if (belong[mq[i].L] != last) {\n            while (R &lt; N) add(++R);\n            while (L &lt; b[belong[mq[i].L]]) del(L++);\n            int temp = 0;\n            while (cnt[temp]) temp++;\n            res = temp;\n            last = belong[mq[i].L];\n        }\n        while (R &gt; mq[i].R) del(R--);\n        int temp = res, L1 = L;\n        while (L1 &lt; mq[i].L) del(L1++);\n        ans[mq[i].idx] = res;\n        while (L1 &gt; L) add(--L1);\n        res = temp;\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Default/FastIO/","title":"\u5feb\u8bfb","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; inline void read(T &amp;k) {\n    T x = 0, f = 1; \n    char ch = getchar(); \n    while (ch &lt; '0' || ch &gt; '9') {\n        if (ch == '-') {\n            f = -1;\n        }\n        ch = getchar();\n    }\n    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\n        ch = getchar();\n    }\n    k = x * f;\n}\ntemplate&lt;class T&gt; inline void write(T x) {\n    if (x &lt; 0) {\n        putchar('-'), x = -x;\n    }\n    if (x &gt; 9) {\n        write(x / 10);\n    }\n    putchar(x % 10 + '0');\n}\n</code></pre>"},{"location":"Template/Default/HashCode/","title":"\u54c8\u5e0c\u8868\u91cd\u5199\u54c8\u5e0c\u51fd\u6570","text":"\u6a21\u7248 \u6574\u6570pair C++<pre><code>struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ x &gt;&gt; 30) * 0xbf58476d1ce4e5b9;\n        x = (x ^ x &gt;&gt; 27) * 0x94d049bb133111eb;\n        return x ^ x &gt;&gt; 31;\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nunordered_map&lt;int, int, custom_hash&gt; safe_map;\n</code></pre> C++<pre><code>struct pair_hash {\n    template&lt;class T1, class T2&gt;\n    size_t operator() (const pair&lt;T1, T2&gt;&amp; pair) const {\n        return hash&lt;T1&gt;()(pair.first) ^ hash&lt;T2&gt;()(pair.second);\n    }\n};\nunordered_map&lt;pair&lt;int, int&gt;, int, pair_hash&gt; safe_map;\n</code></pre>"},{"location":"Template/Default/HighAccuracy/","title":"\u9ad8\u7cbe\u5ea6","text":"\u6a21\u7248 C++<pre><code>struct BigInt {\n    static const int BASE = 100000000;\n    static const int WIDTH = 8;\n    bool sign = true;\n    vector&lt;int&gt; num;\n    BigInt() : num(1) {}\n    BigInt(int x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(long long x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(const string x) {\n        if (x.front() == '-') {\n            sign = false;\n        }\n        int len = (int(x.size()) - 1 - (!sign)) / WIDTH + 1;\n        num.resize(len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            int end = int(x.size()) - i * WIDTH;\n            int start = max(int(!sign), end - WIDTH);\n            long long k = 0;\n            for (int j = start ; j &lt; end ; j++) {\n                k = k * 10 + (x[j] ^ 48);\n            }\n            num[i] = k;\n        }\n    }\n    static int abs_equal(const BigInt &amp;L, const BigInt &amp;R) {\n        int lenL = L.num.size(), lenR = R.num.size();\n        if (lenL == lenR) {\n            for (int i = lenL - 1 ; i &gt;= 0 ; i--) {\n                if (L.num[i] == R.num[i]) {\n                    continue;\n                }\n                return L.num[i] &lt; R.num[i] ? -1 : 1;\n            }\n            return 0;\n        }\n        return lenL &lt; lenR ? -1 : 1;\n    }\n    BigInt operator+(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !x.sign;\n            return *this - _x;\n        }\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        int len = max(lenA, lenB);\n        res.resize(len);\n        int k = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            if (i &lt; lenA) {\n                k += num[i];\n            }\n            if (i &lt; lenB) {\n                k += x.num[i];\n            }\n            res[i] = k % BASE;\n            k /= BASE;\n        }\n        if (k &gt; 0) res.push_back(k);\n        res.sign = sign;\n        return res;\n    }\n    BigInt operator-(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !_x.sign;\n            return *this + _x;\n        }\n        BigInt res(*this), _x(x);\n        if (abs_equal(res, _x) &lt; 0) {\n            swap(res, _x);\n            res.sign = !res.sign;\n        }\n        int lenA = res.size(), lenB = _x.size();\n        int k = 0;\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            res[i] -= k;\n            if (i &lt; lenB) {\n                res[i] -= _x[i];\n            } else if (k == 0) {\n                continue;\n            }\n            k = 0;\n            if (res[i] &lt; 0) {\n                res[i] += BASE;\n                k += 1;\n            }\n        }\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator*(const BigInt &amp;x) {\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        res.resize(lenA + lenB);\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            for (int j = 0 ; j &lt; lenB ; j++) {\n                long long k = 1LL * num[i] * x.num[j] + res[i + j];\n                res[i + j] = k % BASE;\n                res[i + j + 1] += k / BASE;\n            }\n        }\n        res.sign = !(sign ^ x.sign);\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator /(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return res;\n        } else if (k == -1) {\n            return BigInt(0);\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return res;\n    }\n    BigInt operator %(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            return BigInt(0);\n        } else if (k == -1) {\n            return *this;\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return Remain;\n    }\n    BigInt&amp; operator+=(const BigInt &amp;x) {\n        *this = *this + x;\n        return *this;\n    }\n    BigInt&amp; operator-=(const BigInt &amp;x) {\n        *this = *this - x;\n        return *this;\n    }\n    BigInt&amp; operator*=(const BigInt &amp;x) {\n        *this = *this * x;\n        return *this;\n    }\n    BigInt&amp; operator/=(const BigInt &amp;x) {\n        *this = *this / x;\n        return *this;\n    }\n    BigInt operator-() {\n        BigInt a(*this);\n        a.sign = !a.sign;\n        return a;\n    }\n    friend bool operator&lt;(const BigInt &amp;lhs, const BigInt &amp;rhs) {\n        if (lhs.sign) {\n            if (rhs.sign) {\n                return abs_equal(lhs, rhs) == -1;\n            } else {\n                return false;\n            }\n        } else {\n            if (rhs.sign) {\n                return true;\n            } else {\n                return abs_equal(lhs, rhs) == 1;\n            }\n        }\n    }\n    friend bool operator&lt;=(const BigInt &amp;lhs, const BigInt &amp;rhs) {\n        if (lhs == rhs) return true;\n        return lhs &lt; rhs;\n    }\n    friend bool operator&gt;(const BigInt &amp;lhs, const BigInt &amp;rhs) {\n        if (lhs.sign) {\n            if (rhs.sign) {\n                return abs_equal(lhs, rhs) == 1;\n            } else {\n                return true;\n            }\n        } else {\n            if (rhs.sign) {\n                return false;\n            } else {\n                return abs_equal(lhs, rhs) == -1;\n            }\n        }\n    }\n    friend bool operator&gt;=(const BigInt &amp;lhs, const BigInt &amp;rhs) {\n        if (lhs == rhs) return true;\n        return lhs &gt; rhs;\n    }\n    friend bool operator==(const BigInt &amp;lhs, const BigInt &amp;rhs) {\n        if (lhs.sign == rhs.sign &amp;&amp; abs_equal(lhs, rhs) == 0) return true;\n        return false;\n    }\n    pair&lt;BigInt, BigInt&gt; divide(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return {res, BigInt(0)};\n        } else if (k == -1) {\n            return {BigInt(0), BigInt(0)};\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return {res, Remain};\n    }\n    static BigInt Copy(const BigInt &amp;x, const int pos) {\n        BigInt res;\n        int len = x.num.size();\n        res.resize(len + pos);\n        for (int i = 0 ; i &lt; len ; i++) {\n            res[i + pos] = x.num[i];\n        }\n        return res;\n    }\n    int &amp;operator[](const int pos) {\n        return num[pos];\n    }\n    int &amp;back() {\n        return num.back();\n    }\n    int size() {\n        return num.size();\n    }\n    void resize(const int size) {\n        num.resize(size);\n    }\n    void emplace_back(const int x) {\n        num.emplace_back(x);\n    }\n    void pop_back() {\n        num.pop_back();\n    }\n    void push_back(const int x) {\n        num.push_back(x);\n    }\n    void print() const {\n        if (num.size() == 1 &amp;&amp; num[0] == 0) {\n            cout &lt;&lt; num[0];\n            return;\n        }\n        if (!sign) cout &lt;&lt; \"-\";\n        cout &lt;&lt; num.back();\n        int len = num.size();\n        for (int i = len - 2 ; i &gt;= 0 ; i--) {\n            cout &lt;&lt; setfill('0') &lt;&lt; setw(WIDTH) &lt;&lt; num[i];\n        }\n    }\n    friend istream &amp;operator&gt;&gt;(istream &amp;is, BigInt &amp;x) {\n        string str;\n        is &gt;&gt; str;\n        BigInt a(str);\n        x = a;\n        return is;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const BigInt &amp;x) {\n        return x.print(), os;\n    }\n}; // BigInt;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1932 <p>P1932 A+B A-B A*B A/B A%B Problem - \u6d1b\u8c37</p>"},{"location":"Template/Default/ModInt/","title":"ModInt","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; constexpr T qpow(T a, long long b) {\n    T res = 1;\n    while (b) {\n        if (b &amp; 1) res *= a;\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate &lt;class T&gt; struct _MInt {\n    T value;\n    constexpr _MInt() : value() {}\n    constexpr _MInt(T value) : value(normal(value % getMod())) {}\n    static int _mod;\n    constexpr static int getMod() {\n        return _mod;\n    }\n    constexpr T normal(T x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr _MInt inv() const {\n        return qpow(*this, getMod() - 2);\n    }\n    constexpr _MInt operator-() const {\n        _MInt res;\n        res.value = normal(getMod() - value);\n        return res;\n    }\n    constexpr _MInt &amp;operator*=(_MInt rhs) &amp; {\n        if (is_same&lt;T, long long&gt;::value) {\n            value = (__int128) value * rhs.x % getMod();\n        } else {\n            value = (long long) value * rhs.x % getMod();\n        }\n        return *this;\n    }\n    constexpr _MInt &amp;operator+=(_MInt rhs) &amp; {\n        value = normal(value + rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator-=(_MInt rhs) &amp; {\n        value = normal(value - rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator/=(_MInt rhs) &amp; {\n        return *this *= rhs.inv(); \n    }\n    friend constexpr _MInt operator*(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator+(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr _MInt operator-(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator/(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr istream &amp;operator&gt;&gt;(istream &amp;is, _MInt &amp;a) {\n        long long v;\n        is &gt;&gt; v;\n        a = _MInt(v);\n        return is;\n    }\n    friend constexpr ostream &amp;operator&lt;&lt;(ostream &amp;os, const _MInt &amp;a) {\n        return os &lt;&lt; a.value;\n    }\n    friend constexpr bool operator==(_MInt lhs, _MInt rhs) {\n        return lhs.value == rhs.value;\n    }\n    friend constexpr bool operator!=(_MInt lhs, _MInt rhs) {\n        return lhs.value != rhs.value;\n    }\n};\ntemplate &lt;&gt; int _MInt&lt;int&gt;::_mod = 998244353;\nusing MInt = _MInt&lt;int&gt;;\n</code></pre>"},{"location":"Template/Default/Sort/","title":"\u6392\u5e8f","text":"\u6a21\u7248 \u5feb\u901f\u6392\u5e8f\\(O(n\\log n)\\)\u5f52\u5e76\u6392\u5e8f \\(O(n\\log n)\\)\u63d2\u5165\u6392\u5e8f \\(O(n^2)\\)\u5192\u6ce1\u6392\u5e8f \\(O(n^2)\\)\u9009\u62e9\u6392\u5e8f \\(O(n^2)\\)\u5e0c\u5c14\u6392\u5e8f \\(O(n\\log n)\\) C++<pre><code>void quickSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    int i = L - 1, j = R + 1;\n    int k = a[L + R &gt;&gt; 1];\n    while (i &lt; j) {\n        do i++; while (a[i] &lt; k);\n        do j--; while (a[j] &gt; k);\n        if (i &lt; j) swap(a[i], a[j]);\n    }\n    quickSort(a, L, j);\n    quickSort(a, j + 1, R);\n}\n</code></pre> C++<pre><code>int cnt = 0;\nvoid mergeSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    vector&lt;int&gt; b(R - L + 1);\n    int mid = L + R &gt;&gt; 1;\n    mergeSort(a, L, mid);\n    mergeSort(a, mid + 1, R);\n    int i = L, j = mid + 1, k = 0;\n    while (i &lt;= mid &amp;&amp; j &lt;= R) {\n        if (a[i] &lt;= a[j]) {\n            b[k++] = a[i++];\n        } else {\n            b[k++] = a[j++];\n            cnt += mid - i + 1;\n        }\n    }\n    while (i &lt;= mid) b[k++] = a[i++];\n    while (j &lt;= R) {\n        b[k++] = a[j++];\n        cnt += mid - i + 1;\n    }\n    for (int i = L ; i &lt;= R ; i++) a[i] = b[i - L];\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L + 1 ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - 1;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + 1] = a[j];\n            --j;\n        }\n        a[j + 1] = v;\n    }\n}\n</code></pre> C++<pre><code>void bubbleSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt;= R ; i++) {\n        for (int j = R ; j &gt; i ; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                swap(a[j - 1], a[j]);\n            }\n        }\n    }\n}\n</code></pre> C++<pre><code>void selectSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt; R ; i++) {\n        int t = i;\n        for (int j = i ; j &lt;= R ; j++) {\n            if (a[j] &lt; a[t]) {\n                t = j;\n            }\n        }\n        swap(a[t], a[i]);\n    }\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R, int g) {\n    for (int i = L + g ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - g;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + g] = a[j];\n            j -= g;\n        }\n        a[j + g] = v;\n    }\n}\nvoid shellSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    vector&lt;int&gt; g;\n    for (int h = 1 ; h &lt;= R ; h = 3 * h + 1 ) g.emplace_back(h);\n    reverse(begin(g), end(g));\n    for (auto &amp;i : g) insertSort(a, L, R, i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1177\u6d1b\u8c37U232725 <p>P1177 \u3010\u6a21\u677f\u3011\u6392\u5e8f - \u6d1b\u8c37</p> <p>U232725 \u3010\u6a21\u677f\u3011\u5f52\u5e76\u6392\u5e8f - \u6d1b\u8c37</p>"},{"location":"Template/Default/__builtin/","title":"__builtin","text":"\u51fd\u6570 \u63cf\u8ff0 __builtin_ctz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero __builtin_ctzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero long long __builtin_clz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero __builtin_clzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero long long __builtin_popcount(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count __builtin_popcountll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count long long __builtin_parity(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u7684\u5947\u5076\u6027(1, 0) parity __builtin_parityll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u5947\u5076\u6027(1, 0) parity long long __builtin_ffs(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat __builtin_ffsll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat long long __builtin_sqrt(double x) \u8fd4\u56de  \\(\\sqrt {double\\ x}\\)  \u7684\u503c sqrt __builtin_sqrtf(float x) \u8fd4\u56de  \\(\\sqrt {float\\ x}\\)  \u7684\u503c sqrt float"},{"location":"Template/DynamicProgramming/Knapsack/","title":"\u80cc\u5305","text":""},{"location":"Template/DynamicProgramming/Knapsack/#0-1","title":"0-1\u80cc\u5305","text":"\u6a21\u7248 \u4e00\u7ef4\u4e8c\u7ef4 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - w[i]] + d[i]);\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; w(N), d(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; d[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + d[i - 1]);\n        }\n    }\n    cout &lt;&lt; dp[N][M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P2871(\u6c42\u6700\u4f18\u503c)AcWing278(\u6c42\u4f53\u79ef\u6070\u597d\u4e3aM\u7684\u65b9\u6848\u6570)AcWing11(\u6c42\u6700\u4f18\u65b9\u6848\u6570)AcWing12(\u6c42\u5177\u4f53\u65b9\u6848) <p>P2871 [USACO07DEC] Charm Bracelet S - \u6d1b\u8c37</p> <p>278. \u6570\u5b57\u7ec4\u5408 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; v[i];\n    }\n    vector&lt;int&gt; dp(M + 1);\n    dp[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= v[i] ; j--) {\n            dp[j] = dp[j] + dp[j - v[i]];\n        }\n    }\n    cout &lt;&lt; dp[M] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>11. \u80cc\u5305\u95ee\u9898\u6c42\u65b9\u6848\u6570 - AcWing</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst long long mod = 1000000007;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;long long&gt; dp(M + 1), g(M + 1);\n    g[0] = 1;\n    for (int i = 0 ; i &lt; N ; i++) {\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            long long k;\n            long long temp = dp[j - w[i]] + v[i];\n            if (dp[j] &lt; temp) {\n                g[j] = g[j - w[i]];\n                dp[j] = temp;\n            } else if (dp[j] == temp) {\n                g[j] = (g[j] + g[j - w[i]]) % mod;\n            }\n        }\n    }\n    long long res = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        res = max(res, dp[i]);\n    }\n    long long ans = 0;\n    for (int i = 0 ; i &lt;= M ; i++) {\n        if (dp[i] == res) {\n            ans = (ans + g[i]) % mod;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre> <p>12. \u80cc\u5305\u95ee\u9898\u6c42\u5177\u4f53\u65b9\u6848 - AcWing</p> \u7f16\u53f7\u6b63\u5e8f\u7f16\u53f7\u9006\u5e8f C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = N - 1 ; i &gt;= 0 ; i--) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i + 1][j];\n        }\n        for (int j = M ; j &gt;= w[i] ; j--) {\n            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + v[i]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = 0, j = M ; i &lt; N ; i++) {\n        if (j &gt;= w[i] &amp;&amp; dp[i][j] == dp[i + 1][j - w[i]] + v[i]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    vector&lt;int&gt; v(N), w(N);\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(N + 1, vector&lt;long long&gt;(M + 1));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        for (int j = 0 ; j &lt;= M ; j++) {\n            dp[i][j] = dp[i - 1][j];\n        }\n        for (int j = M ; j &gt;= w[i - 1] ; j--) {\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (int i = N - 1, j = M ; i &gt;= 0 ; i--) {\n        if (j &gt;= w[i] &amp;&amp; dp[i + 1][j] - v[i] == dp[i][j - w[i]]) {\n            ans.emplace_back(i + 1);\n            j -= w[i];\n        }\n    }\n    for (auto &amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/Knapsack/#_2","title":"\u5b8c\u5168\u80cc\u5305","text":"\u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; w(n), v(n), dp(m + 1);\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = w[i] ; j &lt;= m ; j++) {\n            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n        }\n    }\n    cout &lt;&lt; dp[m];\n    return 0;\n}\n</code></pre> \u4f8b\u9898 AcWing3(\u6c42\u6700\u4f18\u503c) <p>3. \u5b8c\u5168\u80cc\u5305\u95ee\u9898 - AcWing</p>"},{"location":"Template/DynamicProgramming/Knapsack/#_3","title":"\u591a\u91cd\u80cc\u5305","text":"\u6a21\u7248 \u4e8c\u8fdb\u5236\u4f18\u5316\u5355\u8c03\u961f\u5217\u4f18\u5316 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n), w(n), s(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    }\n    vector&lt;long long&gt; nv, nw;\n    for (int i = 0 ; i &lt; n ; i++) {\n        long long temp = 1;\n        long long k = s[i];\n        while (k &gt; temp) {\n            k -= temp;\n            nv.emplace_back(v[i] * temp);\n            nw.emplace_back(w[i] * temp);\n            temp &lt;&lt;= 1;\n        }\n        if (k) {\n            nv.emplace_back(v[i] * k);\n            nw.emplace_back(w[i] * k);\n        }\n    }\n    vector&lt;long long&gt; dp(m + 1);\n    int len = nv.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        for (int j = m ; j &gt;= nw[i] ; j--) {\n            dp[j] = max(dp[j], dp[j - nw[i]] + nv[i]);\n        }\n    }\n    cout &lt;&lt; dp[m] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint q[1000005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n), w(n), s(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];\n    }\n    vector&lt;vector&lt;long long&gt;&gt; dp(2, vector&lt;long long&gt;(m + 1));\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = 0 ; j &lt; w[i] ; j++) {\n            int L = 0, R = -1;\n            for (int k = j ; k &lt;= m ; k += w[i]) {\n                while (L &lt;= R &amp;&amp; k - 1LL * s[i] * w[i] &gt; q[L]) {\n                    L++;\n                }\n                while (L &lt;= R &amp;&amp; dp[i &amp; 1][q[R]] + (k - q[R]) / w[i] * v[i] &lt;= dp[i &amp; 1][k]) {\n                    R--;\n                }\n                q[++R] = k;\n                dp[i &amp; 1 ^ 1][k] = dp[i &amp; 1][q[L]] + (k - q[L]) / w[i] * v[i];\n            }\n        }\n    }\n    cout &lt;&lt; dp[n &amp; 1][m] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4f8b\u9898 AcWing5(\u4e8c\u8fdb\u5236\u4f18\u5316)AcWing6(\u5355\u8c03\u961f\u5217\u4f18\u5316) <p>5. \u591a\u91cd\u80cc\u5305\u95ee\u9898 II - AcWing</p> <p>6. \u591a\u91cd\u80cc\u5305\u95ee\u9898 III - AcWing</p>"},{"location":"Template/DynamicProgramming/Knapsack/#_4","title":"\u4e8c\u7ef4\u8d39\u7528\u80cc\u5305","text":"<p>\u540c 0-1 \u80cc\u5305</p> \u4f8b\u9898 \u6d1b\u8c37P1855 <p>P1855 \u69a8\u53d6kkksc03 - \u6d1b\u8c37</p>"},{"location":"Template/DynamicProgramming/Knapsack/#_5","title":"\u5206\u7ec4\u80cc\u5305","text":"\u4f8b\u9898 \u6d1b\u8c37P1757 <p>P1757 \u901a\u5929\u4e4b\u5206\u7ec4\u80cc\u5305 - \u6d1b\u8c37</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; M &gt;&gt; N;\n    map&lt;int, vector&lt;int&gt;&gt; v, w;\n    for (int i = 0 ; i &lt; N ; i++) {\n        int x, y, z;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        w[z].emplace_back(x);\n        v[z].emplace_back(y);\n    }\n    vector&lt;int&gt; dp(M + 1);\n    for (auto&amp; [g, ww] : w) {\n        auto&amp; vv = v[g];\n        for (int i = M ; i &gt;= 0 ; i--) {\n            int len = ww.size();\n            for (int j = 0 ; j &lt; len ; j++) {\n                if (i &gt;= ww[j]) {\n                    dp[i] = max(dp[i], dp[i - ww[j]] + vv[j]);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[M];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/Knapsack/#k","title":"\u591a\u4eba\u80cc\u5305(k\u4f18\u89e3)","text":"\u4f8b\u9898 \u6d1b\u8c37P1858 <p>P1858 \u591a\u4eba\u80cc\u5305 - \u6d1b\u8c37</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int k, m, n;\n    cin &gt;&gt; k &gt;&gt; m &gt;&gt; n;\n    vector&lt;int&gt; w(n), v(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; w[i] &gt;&gt; v[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(m + 1, 0x7fffffff + 1));\n    vector&lt;int&gt; re(k);\n    dp[0][0] = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = m ; j &gt;= w[i] ; j--) {\n            int a = 0, b = 0, t = 0;\n            while (t &lt; k) {\n                if (dp[a][j] &gt;= dp[b][j - w[i]] + v[i]) {\n                    re[t++] = dp[a++][j];\n                } else {\n                    re[t++] = dp[b++][j - w[i]] + v[i];\n                }\n            }\n            for (int L = 0 ; L &lt; k ; L++) {\n                dp[L][j] = re[L];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; k ; i++) ans += dp[i][m];\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/SOSDP/","title":"SOSDP","text":""},{"location":"Template/DynamicProgramming/SOSDP/#aiaj0","title":"\u6c42 \\(a[i]\\&amp;a[j]=0\\) \u7684\u4e2a\u6570","text":"<p>G-A Xor B Problem again_2023\u5e74GPLT\u4e0a\u6d77\u7406\u5de5\u5927\u5b66\u6821\u5185\u9009\u62d4\u8d5b\uff08\u540c\u6b65\u8d5b)</p> Code C++<pre><code>const int D = 17;\nconst int N = (1 &lt;&lt; D) - 1;\nint f[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        f[N &amp; ~a[i]]++;\n    }\n    for (int i = 0 ; i &lt; D ; i++) {\n        for (int mask = 0 ; mask &lt;= N ; mask++) {\n            if (mask &amp; 1 &lt;&lt; i) {\n                f[mask ^ 1 &lt;&lt; i] += f[mask];\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        ans += f[a[i]];\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/SOSDP/#aiaiaj0-aj","title":"\u5df2\u77e5 \\(a[i],a[i]\\&amp;a[j]=0\\) \u6c42 \\(a[j]\\)","text":"<p>Problem - E - Codeforces</p> Code C++<pre><code>const int D = 22;\nconst int N = (1 &lt;&lt; D) - 1;\nint f[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    a[0] = -1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        f[N &amp; ~a[i]] = i;\n    }\n    for (int i = 0 ; i &lt; D ; i++) {\n        for (int mask = 0 ; mask &lt;= N ; mask++) {\n            if (mask &amp; 1 &lt;&lt; i &amp;&amp; f[mask] != 0) {\n                f[mask ^ 1 &lt;&lt; i] = f[mask];\n            }\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; a[f[a[i]]] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/SOSDP/#ijk-maxaiaj","title":"\u5df2\u77e5 \\(i|j\u2264k\\) \u6c42 \\(max(a[i]+a[j])\\)","text":"<p>E - Or Plus Max</p> Code C++<pre><code>const int D = 18;\nconst int N = (1 &lt;&lt; D) - 1;\npair&lt;int, int&gt; f[N + 1];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(1 &lt;&lt; n);\n    for (int i = 0 ; i &lt; 1 &lt;&lt; n ; i++) {\n        cin &gt;&gt; a[i];\n        f[i] = {a[i], 0x7fffffff + 1};\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int mask = 0 ; mask &lt; 1 &lt;&lt; n ; mask++) {\n            if (mask &amp; 1 &lt;&lt; i) {\n                auto x = f[mask], y = f[mask ^ 1 &lt;&lt; i];\n                if (x &lt; y) swap(x, y);\n                auto ans = x;\n                ans.second = max(ans.second, y.first);\n                f[mask] = ans;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt; 1 &lt;&lt; n ; i++) {\n        ans = max(ans, f[i].first + f[i].second);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/SOSDP/#ijk-maxaiajak","title":"\u5df2\u77e5 \\(i&lt;j&lt;k\\) \u6c42 \\(max(a[i]|(a[j]\\&amp;a[k]))\\)","text":"<p>Problem - F - Codeforces</p> Code C++<pre><code>const int D = 21;\nconst int N = (1 &lt;&lt; D) - 1;\npair&lt;int, int&gt; f[N + 1];\nvoid add(int x, int val) {\n    if (f[x].first == -1) {\n        f[x].first = val;\n    } else if (f[x].second == -1) {\n        f[x].second = val;\n        if (f[x].first &lt; f[x].second) {\n            swap(f[x].first, f[x].second);\n        }\n    } else if (f[x].first &lt; val) {\n        f[x].second = f[x].first;\n        f[x].first = val;\n    } else if (f[x].second &lt; val) {\n        if (f[x].first == val) return;\n        f[x].second = val;\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    fill(f, f + N + 1, make_pair(-1, -1));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        add(a[i], i);\n    }\n    for (int i = 0 ; i &lt; D ; i++) {\n        for (int mask = 0 ; mask &lt;= N ; mask++) {\n            if (mask &amp; 1 &lt;&lt; i) {\n                add(mask ^ 1 &lt;&lt; i, f[mask].first);\n                add(mask ^ 1 &lt;&lt; i, f[mask].second);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n - 2 ; i++) {\n        int cur = a[i] ^ N, res = 0;\n        for (int j = D ; j &gt;= 0 ; j--) {\n            if (cur &amp; 1 &lt;&lt; j) {\n                if (f[res ^ 1 &lt;&lt; j].second &gt; i) {\n                    res ^= 1 &lt;&lt; j;\n                }\n            }\n            ans = max(ans, res | a[i]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/Tree/","title":"\u6811\u5f62dp","text":"\u5176\u4ed6\u9898 \u725b\u5ba228258F <p>F-\u6811\u4e0a\u5b50\u94fe_\u725b\u5ba2\u7ade\u8d5b\u52a8\u6001\u89c4\u5212\u4e13\u9898\u73ed\u6811\u578bdp\u4f8b\u9898</p> <p>\u4e00\u68f5\u6811, \u70b9\u6743\u6709\u6b63\u6709\u8d1f, \u95ee\u5b50\u94fe\u6743\u503c\u548c\u7684\u6700\u5927</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nvector&lt;int&gt; adj[100005];\nlong long dp[100005];\nlong long a[100005];\nlong long ans = -1e18;\nvoid dfs(int u, int p) {\n    dp[u] = a[u];\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        ans = max(ans, dp[u] + dp[to]);\n        dp[u] = max(dp[u], a[u] + dp[to]);\n    }\n    ans = max(ans, dp[u]);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/","title":"\u5355\u8c03\u961f\u5217\u4f18\u5316dp","text":"<p>U226418 \u70fd\u706b\u4f20\u9012 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint dp[200005];\nint a[200005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    deque&lt;int&gt; que;\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n    que.emplace_back(0);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int idx = 0;\n        while (!que.empty() &amp;&amp; que.front() &lt; i - m) {\n            que.pop_front();\n        }\n        if (!que.empty()) {\n            idx = que.front();\n        }\n        dp[i] = dp[idx] + a[i];\n        while (!que.empty() &amp;&amp; dp[que.back()] &gt;= dp[i]) {\n            que.pop_back();\n        }\n        que.emplace_back(i);\n    }\n    int ans = 0x7fffffff;\n    for (int i = n - m + 1 ; i &lt;= n ; i++) {\n        ans = min(ans, dp[i]);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","title":"\u6700\u957f\u4e0d\u4e0b\u964d\u5b50\u5e8f\u5217","text":"<p>U290681 \u3010\u6a21\u677f\u3011\u6700\u957f\u4e0d\u4e0b\u964d\u5b50\u5e8f\u5217 - \u6d1b\u8c37</p>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/#onlog-n","title":"\\(O(n\\log n)\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    vector&lt;int&gt; dp(n + 1, 0x7fffffff);\n    for (int i = 0 ; i &lt; n ; i++) {\n        *upper_bound(begin(dp), end(dp), a[i]) = a[i];\n    }\n    int ans = 0;\n    while (ans &lt; n &amp;&amp; dp[ans] != 0x7fffffff) {\n        ans++;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217","text":"<p>P1439 \u3010\u6a21\u677f\u3011\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 - \u6d1b\u8c37</p> <p>#6564. \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 - LibreOJ</p>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/#on2","title":"\\(O(n^2)\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; a(n + 1), b(m + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= m ; j++) {\n            if (a[i] == b[j]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    cout &lt;&lt; dp[n][m];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/#onlog-n","title":"\\(O(n\\log n)\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 70010, B = 63, M = N / B + 1;\nunsigned long long f[M], bs[N][M];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; a(n), b(m);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    k = 1 + (n - 1) / B;\n    for (int i = 0 ; i &lt; n ; i++) {\n        bs[a[i]][i / B] |= 1ULL &lt;&lt; i % B;\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        unsigned long long c = 1;\n        for (int j = 0 ; j &lt; k ; j++) {\n            unsigned long long x = f[j], y = f[j] | bs[b[i]][j];\n            x += x + c + ((~y) &amp; ((1ULL &lt;&lt; B) - 1));\n            f[j] = x &amp; y;\n            c = x &gt;&gt; B;\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; k ; i++) {\n        ans += __builtin_popcountll(f[i]);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/#onlog-n-text","title":"\\(O(n\\log n) \\text{ \u6392\u5217}\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n), b(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    vector&lt;int&gt; p(n + 1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; b[i];\n        p[b[i]] = i + 1;\n    }\n    vector&lt;int&gt; f(1);\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x = p[a[i]];\n        if (x &gt; f.back()) {\n            f.emplace_back(x);\n        } else {\n            f[upper_bound(begin(f), end(f), x) - begin(f)] = x;\n        }\n    }\n    cout &lt;&lt; f.size() - 1;\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%A0%91%E5%BD%A2DP%281%29/","title":"\u6811\u5f62DP(1)","text":""},{"location":"Template/DynamicProgramming/%E6%A0%91%E5%BD%A2DP%281%29/#_1","title":"\u4fdd\u5b89\u7ad9\u5c97\u95ee\u9898","text":"<p>P2899 [USACO08JAN] Cell Phone Network G - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;vector&lt;int&gt;&gt; dp, adj;\n// dp[i][0] \u81ea\u5df1\n// dp[i][1] \u513f\u5b50\n// dp[i][2] \u7236\u4eb2\nvoid dfs(int u, int p) {\n    dp[u][0] = 1;\n    int res = 0x7fffffff;\n    for (auto &amp;i : adj[u]) {\n        if (i == p) continue;\n        dfs(i, u);\n        res = min(res, dp[i][0] - min(dp[i][1], dp[i][0]));\n        dp[u][0] += min({dp[i][0], dp[i][1], dp[i][2]});\n        dp[u][1] += min(dp[i][0], dp[i][1]);\n        dp[u][2] += min(dp[i][0], dp[i][1]);\n    }\n    dp[u][1] += res;\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    dp.assign(n + 1, vector&lt;int&gt;(3));\n    adj.assign(n + 1, vector&lt;int&gt;());\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; min(dp[1][0], dp[1][1]);\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%A0%91%E5%BD%A2DP%281%29/#_2","title":"\u4e0a\u53f8\u7684\u821e\u4f1a","text":"<p>P1352 \u6ca1\u6709\u4e0a\u53f8\u7684\u821e\u4f1a - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; a;\nvector&lt;vector&lt;int&gt;&gt; dp, adj;\nvoid dfs(int u) {\n    dp[u][0] = 0;\n    dp[u][1] = a[u];\n    for (auto &amp;i : adj[u]) {\n        dfs(i);\n        dp[u][0] += max(dp[i][0], dp[i][1]);\n        dp[u][1] += dp[i][0];\n    }\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    a.resize(n + 1);\n    adj.resize(n + 1);\n    dp.resize(n + 1, vector&lt;int&gt;(2));\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n    vector vis(n + 1, 0);\n    for (int i = 1 ; i &lt; n ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        adj[y].emplace_back(x);\n        vis[x] = 1;\n    }\n    int root = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (vis[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n    dfs(root);\n    cout &lt;&lt; max(dp[root][0], dp[root][1]);\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E6%A0%91%E5%BD%A2DP%281%29/#_3","title":"\u6811\u4e0a\u80cc\u5305","text":"<p>P2014 [CTSC1997] \u9009\u8bfe - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; adj[305];\nint val[305];\nint dp[305][305];\nint n, m;\nint dfs(int u) {\n    int p = 1;\n    dp[u][1] = val[u];\n    for (auto &amp;v : adj[u]) {\n        int cnt = dfs(v);\n        for (int i = min(p, m + 1) ; i &gt; 0 ; i--) {\n            for (int j = 1 ; j &lt;= cnt &amp;&amp; i + j &lt;= m + 1 ; j++) {\n                dp[u][i + j] = max(dp[u][i + j], dp[u][i] + dp[v][j]);\n            }\n        }\n        p += cnt;\n    }\n    return p;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int s;\n        cin &gt;&gt; s &gt;&gt; val[i];\n        adj[s].emplace_back(i);\n    }\n    dfs(0);\n    cout &lt;&lt; dp[0][m + 1];\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%281%29/","title":"\u8bb0\u5fc6\u5316\u641c\u7d22(1)","text":""},{"location":"Template/DynamicProgramming/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%281%29/#n-4","title":"\u7b2c n \u4e2a\u6570\u4f4d\u4e2d\u4e0d\u542b\u6709 4 \u7684\u6570","text":"<p>CF1811 - E - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long dp[20];\nint num[20];\nlong long dfs(int x, bool lim) {\n    if (x == -1) {\n        return 1LL;\n    }\n    if (lim == false &amp;&amp; dp[x] != -1) {\n        return dp[x];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        if (i == 4) {\n            continue;\n        }\n        res += dfs(x - 1, lim &amp;&amp; i == mx);\n    }\n    if (lim == false) {\n        dp[x] = res;\n    }\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        dp[cnt] = -1;\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, true);\n}\nvoid solve() {\n    long long k;\n    cin &gt;&gt; k;\n    auto check = [&amp;](long long mid) -&gt; bool {\n        return get(mid) &gt;= k + 1;\n    };\n    long long L = k, R = 1e18;\n    while (L &lt; R) {\n        long long mid = L + R &gt;&gt; 1;\n        if (check(mid)) {\n            R = mid;\n        } else {\n            L = mid + 1;\n        }\n    }\n    cout &lt;&lt; L &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%281%29/#4-7","title":"\u67d0\u4e2a\u6570\u5728\u6570\u4f4d\u4e2d\u53ea\u542b\u6709 4 \u6216 7 \u7684\u6570\u7684\u4e0b\u6807","text":"<p>CF535 - B - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long dp[20];\nint num[20];\nlong long dfs(int x, bool lim) {\n    if (x == -1) {\n        return 1LL;\n    }\n    if (lim == false &amp;&amp; dp[x] != -1) {\n        return dp[x];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        if (!(lim &amp;&amp; i == 0) &amp;&amp; i != 4 &amp;&amp; i != 7) {\n            continue;\n        }\n        res += dfs(x - 1, lim &amp;&amp; i == mx);\n    }\n    if (lim == false) {\n        dp[x] = res;\n    }\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        dp[cnt] = -1;\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, true);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    int cnt = 0;\n    cout &lt;&lt; get(n) - 1;\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%281%29/#62-4","title":"\u6c42\u6570\u4f4d\u4e2d\u4e0d\u542b\u6709 62 \u548c 4 \u7684\u6570\u7684\u6570\u91cf","text":"<p>Problem - 2089 - hdu</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long dp[10][8];\nint num[8];\nlong long dfs(int x, int last, bool lim) {\n    if (x == -1) {\n        return 1LL;\n    }\n    if (lim == false &amp;&amp; dp[last][x] != -1) {\n        return dp[last][x];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        if ((last == 6 &amp;&amp; i == 2) || i == 4) {\n            continue;\n        }\n        res += dfs(x - 1, i, lim &amp;&amp; i == mx);\n    }\n    if (lim == false) {\n        dp[last][x] = res;\n    }\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        for (int i = 0 ; i &lt; 10 ; i++) {\n            dp[i][cnt] = -1;\n        }\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, 0, true);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    while (cin &gt;&gt; n &gt;&gt; m) {\n        if (n == 0) break;\n        cout &lt;&lt; get(m) - get(n - 1) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/DynamicProgramming/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%281%29/#7577","title":"\u6c42\u6570\u4f4d\u4e2d7\u548c5\u7684\u4e2a\u6570\u548c\u5b58\u5728\u8fde\u7eed7\u4e2a7\u7684\u4e2a\u6570","text":"<p>L-7\u662f\u5927\u5956\uff1f_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u56db\uff09\u573a\uff1a\u6cb3\u5357\u5927\u5b66</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long dp[20][2][20][20][20];\nint num[20];\nlong long dfs(int x, bool has, int len, int cnt5, int cnt7, bool lim) {\n    has |= len &gt;= 7;\n    if (x == -1) {\n        return cnt5 + 3 * cnt7 + 300 * has;\n    }\n    if (lim == false &amp;&amp; dp[x][has][len][cnt5][cnt7] != -1) {\n        return dp[x][has][len][cnt5][cnt7];\n    }\n    int mx = lim ? num[x] : 9;\n    long long res = 0;\n    for (int i = 0 ; i &lt;= mx ; i++) {\n        int rlen = (i == 7 ? len + 1 : 0);\n        res += dfs(x - 1, has, rlen, cnt5 + (i == 5), cnt7 + (i == 7), lim &amp;&amp; i == mx);\n    }\n    if (lim == false) {\n        dp[x][has][len][cnt5][cnt7] = res;\n    }\n    return res;\n}\nlong long get(long long x) {\n    int cnt = 0;\n    while (x) {\n        num[cnt++] = x % 10;\n        x /= 10;\n    }\n    return dfs(cnt - 1, false, 0, 0, 0, true);\n}\nvoid solve() {\n    long long L, R;\n    cin &gt;&gt; L &gt;&gt; R;\n    cout &lt;&lt; get(R) - get(L - 1) &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    memset(dp, -1, sizeof dp);\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/2-SAT/","title":"2-SAT","text":"<p>P4782 \u3010\u6a21\u677f\u30112-SAT \u95ee\u9898 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; adj[2000005];\nint dfn[2000005], belong[2000005], sz[2000005], tot = 0;\nvoid tarjan(int x) {\n    static stack&lt;int&gt; st;\n    static bool in[2000005];\n    static int low[2000005], cnt = 0;\n    dfn[x] = low[x] = ++cnt;\n    st.emplace(x);\n    in[x] = true;\n    for (auto &amp;y : adj[x]) {\n        if (!dfn[y]) {\n            tarjan(y);\n            low[x] = min(low[x], low[y]);\n        } else if (in[y]) {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        ++tot;\n        while (true) {\n            int y = st.top();\n            st.pop();\n            in[y] = false;\n            belong[y] = tot;\n            sz[tot]++;\n            if (x == y) {\n                break;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int a, b, c, d;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        adj[a + n * (b &amp; 1)].emplace_back(c + n * (1 - d));\n        adj[c + n * (d &amp; 1)].emplace_back(a + n * (1 - b));\n    }\n    for (int i = 1 ; i &lt;= 2 * n ; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (belong[i] == belong[i + n]) {\n            cout &lt;&lt; \"IMPOSSIBLE\";\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"POSSIBLE\\n\";\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (belong[i] &lt; belong[i + n]) cout &lt;&lt; 1 &lt;&lt; \" \";\n        else cout &lt;&lt; 0 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>P5782 [POI2001] \u548c\u5e73\u59d4\u5458\u4f1a - \u6d1b\u8c37</p> Code Text Only<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; adj[18005];\nint dfn[18005], belong[18005], sz[18005], tot = 0;\nvoid tarjan(int x) {\n    static stack&lt;int&gt; st;\n    static bool in[18005];\n    static int low[18005], cnt = 0;\n    dfn[x] = low[x] = ++cnt;\n    st.emplace(x);\n    in[x] = true;\n    for (auto &amp;y : adj[x]) {\n        if (!dfn[y]) {\n            tarjan(y);\n            low[x] = min(low[x], low[y]);\n        } else if (in[y]) {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        ++tot;\n        while (true) {\n            int y = st.top();\n            st.pop();\n            in[y] = false;\n            belong[y] = tot;\n            sz[tot]++;\n            if (x == y) {\n                break;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        adj[x].emplace_back((y + 1) / 2 * 2 - (y &amp; 1 ^ 1));\n        adj[y].emplace_back((x + 1) / 2 * 2 - (x &amp; 1 ^ 1));\n        if ((x + 1) / 2 == (y + 1) / 2) {\n            cout &lt;&lt; \"NIE\\n\";\n        }\n    }\n    for (int i = 1 ; i &lt;= 2 * n ; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n    for (int i = 1 ; i &lt;= 2 * n ; i += 2) {\n        if (belong[i] == belong[i + 1]) {\n            cout &lt;&lt; \"NIE\";\n            return 0;\n        }\n    }\n    vector&lt;bool&gt; vis(tot + 1);\n    for (int i = 1 ; i &lt;= 2 * n ; i += 2) {\n        if (belong[i] &lt; belong[i + 1]) cout &lt;&lt; i &lt;&lt; \"\\n\";\n        else cout &lt;&lt; i + 1 &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/EulerGraph/","title":"\u6b27\u62c9\u56fe","text":""},{"location":"Template/Graph/EulerGraph/#_2","title":"\u6b27\u62c9\u56fe\u5224\u522b\u6cd5","text":"<ul> <li>\u6b27\u62c9\u56de\u8def\uff1a\u901a\u8fc7\u56fe\u4e2d\u6bcf\u6761\u8fb9\u6070\u597d\u4e00\u6b21\u7684\u56de\u8def</li> <li>\u6b27\u62c9\u901a\u8def\uff1a\u901a\u8fc7\u56fe\u4e2d\u6bcf\u6761\u8fb9\u6070\u597d\u4e00\u6b21\u7684\u901a\u8def</li> <li>\u6b27\u62c9\u56fe\uff1a\u5177\u6709\u6b27\u62c9\u56de\u8def\u7684\u56fe</li> <li>\u534a\u6b27\u62c9\u56fe\uff1a\u5177\u6709\u6b27\u62c9\u901a\u8def\u4f46\u4e0d\u5177\u6709\u6b27\u62c9\u56de\u8def\u7684\u56fe</li> </ul> <p>\u2460\u65e0\u5411\u56fe\u662f\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u8fde\u901a\u7684</li> <li>\u9876\u70b9\u7684\u5ea6\u6570\u90fd\u662f\u5076\u6570</li> </ul> <p>\u2461\u65e0\u5411\u56fe\u662f\u534a\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u8fde\u901a\u7684</li> <li>\u6070\u67092\u4e2a\u5947\u5ea6\u9876\u70b9</li> </ul> <p>\u2462\u6709\u5411\u56fe\u662f\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u5f3a\u8fde\u901a\u7684</li> <li>\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u7b49\u4e8e\u51fa\u5ea6</li> </ul> <p>\u2463\u6709\u5411\u56fe\u662f\u534a\u6b27\u62c9\u56fe\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>\u975e0\u5ea6\u9876\u70b9\u662f\u5f31\u8fde\u901a\u7684</li> <li>1\u4e2a\u9876\u70b9\u7684\u51fa\u5ea6\u4e0e\u5165\u5ea6\u4e4b\u5dee\u4e3a1</li> <li>1\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u4e0e\u51fa\u5ea6\u4e4b\u5dee\u4e3a1</li> <li>\u5176\u4ed6\u9876\u70b9\u7684\u5165\u5ea6\u548c\u51fa\u5ea6\u76f8\u7b49</li> </ul> \u4f8b\u9898 \u6d1b\u8c37P7771(\u6709\u5411\u56fe)\u6d1b\u8c37P2731(\u65e0\u5411\u56fe) <p>P7771 \u3010\u6a21\u677f\u3011\u6b27\u62c9\u8def\u5f84 - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nvector&lt;int&gt; adj[100005];\nint cnt[100005], indeg[100005], outdeg[100005];\nstack&lt;int&gt; ans;\nvoid Hierholzer(int x) {\n    for (int &amp;i = cnt[x] ; i &lt; int(adj[x].size()) ; ) {\n        i++;\n        Hierholzer(adj[x][i - 1]);\n    }\n    ans.emplace(x);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        outdeg[u]++;\n        indeg[v]++;\n    }\n    int idx = 1, scnt = 0, ecnt = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (indeg[i] - outdeg[i] == 1) {\n            ecnt++;\n        } else if (outdeg[i] - indeg[i] == 1) {\n            idx = i;\n            scnt++;\n        } else if (indeg[i] != outdeg[i]) {\n            cout &lt;&lt; \"No\\n\";\n            return 0;\n        }\n    }\n\n    if (!(ecnt == 0 &amp;&amp; scnt == 0) &amp;&amp; !(ecnt == 1 &amp;&amp; scnt == 1)) {\n        cout &lt;&lt; \"NO\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (adj[i].empty()) continue;\n        sort(begin(adj[i]), end(adj[i]));\n    }\n    Hierholzer(idx);\n    while (!ans.empty()) {\n        cout &lt;&lt; ans.top() &lt;&lt; \" \";\n        ans.pop();\n    }\n    return 0;\n}\n</code></pre> <p>P2731 [USACO3.3]\u9a91\u9a6c\u4fee\u6805\u680f Riding the Fences - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nstruct Node {\n    int to, rev;\n    bool exist;\n    Node() = default;\n    Node(const int to) : to(to), rev(0), exist(true) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return to &lt; x.to;\n    }\n};\nstack&lt;int&gt; ans;\nvector&lt;Node&gt; adj[1025];\nint cnt[1025], deg[1025], top[1025];\nvoid Hierholzer(const int x) {\n    for (int &amp;i = cnt[x] ; i &lt; int(adj[x].size()) ; ) {\n        if (adj[x][i].exist) {\n            Node temp = adj[x][i];\n            adj[x][i].exist = false;\n            adj[temp.to][temp.rev].exist = false;\n            i++;\n            Hierholzer(temp.to);\n        } else {\n            i++;\n        }\n    }\n    ans.emplace(x);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    n = 500;\n    cin &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n        deg[u]++;\n        deg[v]++;\n    }\n    int vcnt = 0, idx = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (deg[i] &amp; 1) {\n            vcnt++;\n            if (idx == 0) idx = i;\n        }\n    }\n    if (vcnt != 0 &amp;&amp; vcnt != 2) {\n        return 0;\n    }\n    if (idx == 0) idx = 1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (adj[i].empty()) continue;\n        sort(begin(adj[i]), end(adj[i]));\n        for (auto &amp;k : adj[i]) {\n            k.rev = top[k.to]++;\n        }\n    }\n    Hierholzer(idx);\n    while (!ans.empty()) {\n        cout &lt;&lt; ans.top() &lt;&lt; \"\\n\";\n        ans.pop();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/MinimumSpanningTree/","title":"\u6700\u5c0f\u751f\u6210\u6811","text":""},{"location":"Template/Graph/MinimumSpanningTree/#prim","title":"Prim","text":"<p>\\(O(n\\log n)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int to, val;\n    Node() = default;\n    Node(const int to, const int val) : to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;vector&lt;Node&gt;&gt; adj;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    adj.assign(n + 1, vector&lt;Node&gt;());\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n        adj[v].emplace_back(u, val);\n    }\n    vector&lt;int&gt; dist(n + 1, 0x7fffffff), vis(n + 1);\n    priority_queue&lt;Node&gt; que;\n    que.emplace(1, 0);\n    int res = 0;\n    int cnt = 0;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [to, val] = que.top();\n        que.pop();\n        if (vis[to] == true) continue;\n        vis[to] = true;\n        cnt++;\n        res += val;\n        for (auto &amp;[to, val] : adj[to]) {\n            if (val &lt; dist[to]) {\n                dist[to] = val;\n                que.emplace(to, val);\n            }\n        }\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/MinimumSpanningTree/#kruskal","title":"Kruskal","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>struct Node {\n    int from, to, val;\n    Node() = default;\n    Node(const int from, const int to, const int val) : from(from), to(to), val(val) {}\n    bool operator&lt;(const Node &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint f[5005];\nint find(const int x) {\n    return f[x] == x ? x : f[x] = find(f[x]);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;Node&gt; edge(m);\n    iota(f, f + n + 1, 0);\n    priority_queue&lt;Node&gt; que;\n    for (int i = 0 ; i &lt; m ; i++) {\n        cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].val;\n        que.emplace(edge[i]);\n    }\n    vector&lt;int&gt; vis(n + 1);\n    int res = 0;\n    int cnt = 1;\n    while (!que.empty() &amp;&amp; cnt &lt; n) {\n        auto [from, to, val] = que.top();\n        que.pop();\n        from = find(from);\n        to = find(to);\n        if (from == to) continue;\n        f[from] = to;\n        cnt++;\n        res += val;\n    }\n    if (cnt != n) {\n        cout &lt;&lt; \"orz\\n\";\n    } else {\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3366 <p>P3366 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u751f\u6210\u6811 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/MinimumSpanningTree/#_2","title":"\u6700\u5c0f\u5f02\u6216\u751f\u6210\u6811","text":"\u4f8b\u9898 CF888G <p>Problem - G - Codeforces</p> <p>\\(n\\) \u4e2a\u70b9\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a \\(a_i\\), \u70b9 \\(i\\) \u548c \\(j\\) \u7684\u8fb9\u7684\u6743\u503c\u7b49\u4e8e \\(a_i\\oplus\u2009a_j\\)\uff0c\u95ee\u6700\u5c0f\u751f\u6210\u6811\u7684\u6743\u503c(\u6240\u6709\u8fb9\u6743\u4e4b\u548c)\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint tot = 0;\nconst int N = 200000 * 31;\nvector&lt;int&gt; e[N];\nint nxt[N][2];\nvoid insert(int x) {\n    int index = 0;\n    for (int i = 30 ; i &gt;= 0 ; i--) {\n        int k = x &gt;&gt; i &amp; 1;\n        if (nxt[index][k] == 0) {\n            nxt[index][k] = ++tot;\n        }\n        index = nxt[index][k];\n        e[index].emplace_back(x);\n    }\n}\nint query(int index, int d, int x) {\n    if (d &lt; 0) {\n        return 0;\n    }\n    int k = x &gt;&gt; d &amp; 1;\n    if (nxt[index][k]) {\n        return query(nxt[index][k], d - 1, x);\n    }\n    return query(nxt[index][k ^ 1], d - 1, x) + (1 &lt;&lt; d);\n}\nlong long ans = 0;\nvoid solve(int index, int d) {\n    int L = nxt[index][0], R = nxt[index][1];\n    if (L &amp;&amp; R) {\n        if (e[L].size() &gt; e[R].size()) swap(L, R);\n        int mi = 1 &lt;&lt; 30;\n        for (auto &amp;x : e[L]) {\n            mi = min(mi, query(R, d - 1, x));\n        }\n        ans += mi + (1 &lt;&lt; d);\n    }\n    if (L) {\n        solve(L, d - 1);\n    }\n    if (R) {\n        solve(R, d - 1);\n    }\n\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        insert(a[i]);\n    }\n    solve(0, 30);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/ShortestPath/","title":"\u6700\u77ed\u8def","text":""},{"location":"Template/Graph/ShortestPath/#floyed","title":"Floyed \u7b97\u6cd5","text":"<p>\\(O(n^3)\\)</p> \u6a21\u7248 C++<pre><code>for (int k = 1 ; k &lt;= n ; k++) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= n ; j++) {\n            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n        }\n    }\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3647 <p>B3647 \u3010\u6a21\u677f\u3011Floyd \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#bellman-ford","title":"Bellman-Ford \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nint n;\nvoid bellman_ford(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n    }\n    dist[s] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        bool flag = false;\n        for (int p = 1 ; p &lt;= n ; p++) {\n            if (dist[p] == 0x7fffffff) {\n                continue;\n            }\n            for (auto &amp;[to, val] : adj[p]) {\n                if (dist[p] + val &lt; dist[to]) {\n                    dist[to] = dist[p] + val;\n                    flag = true;\n                }\n            }\n        }\n        if (flag == false) {\n            break;\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    bellman_ford(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#spfa","title":"Spfa \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nint dist[10005];\nbool vis[10005];\nvector&lt;Node&gt; adj[10005];\nint n;\nvoid spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    spfa(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \\n\"[i == n];\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371\u6d1b\u8c37P3385 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p> <p>P3385 \u3010\u6a21\u677f\u3011\u8d1f\u73af - \u6d1b\u8c37</p> <p>\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af(\u8def\u5f84\u548c\u4e3a\u8d1f\u6570\u7684\u73af)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nlong long dist[2005];\nbool vis[2005];\nint cnt[2005];\nvector&lt;Node&gt; adj[2005];\nint n;\nbool spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffffffffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nbool solve() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        adj[i].clear();\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        if (val &gt;= 0) {\n            adj[v].emplace_back(u, val);\n        }\n        adj[u].emplace_back(v, val);\n    }\n    return spfa(1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        cout &lt;&lt; (solve() ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/ShortestPath/#dijkstra","title":"Dijkstra \u7b97\u6cd5","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nbool vis[200005];\nint n;\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    dijkstra(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P4779 <p>P4779 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#johnson","title":"Johnson \u5168\u6e90\u6700\u77ed\u8def\u5f84\u7b97\u6cd5","text":"<p>\\(O(nm\\log m)\\)</p> <p>\u8dd1\u4e00\u904d spfa \u5224\u8d1f\u73af\uff0c\u540e\u8dd1 n \u904d dijkstra</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint h[3005];\nint dist[3005];\nint cnt[3005];\nbool vis[3005];\nvector&lt;Node&gt; adj[3005];\nint n;\nbool spfa() {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        h[i] = 0x7fffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n        adj[0].emplace_back(i, 0);\n    }\n    queue&lt;int&gt; que;\n    que.emplace(0);\n    h[0] = 0;\n    vis[0] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (h[p] + val &lt; h[to]) {\n                h[to] = h[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    if (spfa()) {\n        cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (auto &amp;[to, val] : adj[i]) {\n            val += h[i] - h[to];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dijkstra(i);\n        long long ans = 0;\n        for (int j = 1 ; j &lt;= n ; j++) {\n            if (dist[j] == 0x7fffffff) {\n                ans += j * 1000000000L;\n            } else {\n                ans += 1LL * j * (dist[j] + h[j] - h[i]);\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5905 <p>P5905 \u3010\u6a21\u677f\u3011Johnson \u5168\u6e90\u6700\u77ed\u8def - \u6d1b\u8c37</p>"},{"location":"Template/Graph/%E4%BA%8C%E5%88%86%E5%9B%BE/","title":"\u4e8c\u5206\u56fe","text":"<p>P3386 \u3010\u6a21\u677f\u3011\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d - \u6d1b\u8c37</p>"},{"location":"Template/Graph/%E4%BA%8C%E5%88%86%E5%9B%BE/#_2","title":"\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d","text":""},{"location":"Template/Graph/%E4%BA%8C%E5%88%86%E5%9B%BE/#hungarian-onm","title":"Hungarian - \\(O(nm)\\)","text":"Code C++<pre><code>vector&lt;vector&lt;int&gt;&gt; adj;\nint mch[1001], vis[1001], tag;\nbool find(const int u) {\n    if (vis[u] == tag) return false;\n    vis[u] = tag;\n    for (auto &amp;i : adj[u]) {\n        if ((mch[i] == 0) || find(mch[i])) {\n            mch[i] = u;\n            return true;\n        }\n    }\n    return false;\n}\nint match(const int n) {\n    int res = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (find(tag = i) == true) res++;\n    }\n    return res;\n}\nint main() {\n    int n, m, e;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;\n    adj.assign(n + 1, vector&lt;int&gt;());\n    for (int i = 0, u, v ; i &lt; e ; i++) {\n        cin &gt;&gt; u &gt;&gt; v; adj[u].emplace_back(v);\n    }\n    cout &lt;&lt; match(n);\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","title":"\u5f3a\u8fde\u901a\u5206\u91cf","text":""},{"location":"Template/Graph/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/#tarjan","title":"Tarjan","text":"Code C++<pre><code>vector&lt;int&gt; adj[10005];\nint dfn[10005], belong[10005], sz[10005], tot = 0;\nvoid tarjan(int x) {\n    static stack&lt;int&gt; st;\n    static bool in[10005];\n    static int low[10005], cnt = 0;\n    dfn[x] = low[x] = ++cnt;\n    st.emplace(x);\n    in[x] = true;\n    for (auto &amp;y : adj[x]) {\n        if (!dfn[y]) {\n            tarjan(y);\n            low[x] = min(low[x], low[y]);\n        } else if (in[y]) {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        ++tot;\n        while (true) {\n            int y = st.top();\n            st.pop();\n            in[y] = false;\n            belong[y] = tot;\n            sz[tot]++;\n            if (x == y) {\n                break;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/","title":"\u6700\u5927\u6d41","text":"<p>#101. \u6700\u5927\u6d41 - LibreOJ</p>"},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/#ford-fulkerson","title":"Ford-Fulkerson \u589e\u5e7f","text":""},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/#edmonds-karp-oncdotm2","title":"Edmonds-Karp - \\(O(n\\cdot{m^2})\\)","text":""},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/#_2","title":"\u90bb\u63a5\u77e9\u9635","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 201;\nint n, m;\nint pre[N];\nusing FLOW_TYPE = long long;\nconst FLOW_TYPE INF = 0x7fffffffffffffff;\nFLOW_TYPE g[N][N];\nFLOW_TYPE bfs(int s, int t) {\n    static FLOW_TYPE flow[N];\n    fill(pre + 1, pre + n + 1, -1);\n    flow[s] = INF;\n    pre[s] = 0;\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        if (u == t) break;\n        for (int i = 1 ; i &lt;= n ; i++) {\n            if (i != s &amp;&amp; g[u][i] &gt; 0 &amp;&amp; pre[i] == -1) {\n                pre[i] = u;\n                flow[i] = min(flow[u], g[u][i]);\n                que.emplace(i);\n            }\n        }\n    }\n    if (pre[t] == -1) return -1;\n    return flow[t];\n}\nFLOW_TYPE maxFlow(int s, int t) {\n    FLOW_TYPE res = 0;\n    while (true) {\n        FLOW_TYPE flow = bfs(s, t);\n        if (flow == -1) break;\n        int cur = t;\n        while (cur != s) {\n            int fa = pre[cur];\n            g[fa][cur] -= flow;\n            g[cur][fa] += flow;\n            cur = fa;\n        }\n        res += flow;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int s, t;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u][v] += w;\n    }\n    cout &lt;&lt; maxFlow(s, t) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/#dinic-on2cdotm","title":"Dinic - \\(O(n^2\\cdot{m})\\)","text":""},{"location":"Template/Graph/%E6%9C%80%E5%A4%A7%E6%B5%81/#_3","title":"\u90bb\u63a5\u8868","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nusing FLOW_TYPE = long long;\nconst FLOW_TYPE INF = 0x7fffffffffffffff;\nstruct Edge {\n    int to, rev;\n    FLOW_TYPE flow;\n    Edge() = default;\n    Edge(int to, FLOW_TYPE flow, int rev) : to(to), flow(flow), rev(rev) {}\n};\nconst int N = 201;\nint n, m;\nvector&lt;Edge&gt; g[N];\nbool vis[N];\nint dist[N];\nbool bfs(int s, int t) {\n    fill(dist + 1, dist + n + 1, 0);\n    fill(vis + 1, vis + n + 1, false);\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    vis[s] = true;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (auto &amp;x : g[u]) {\n            if (x.flow &gt; 0 &amp;&amp; !vis[x.to]) {\n                dist[x.to] = dist[u] + 1;\n                vis[x.to] = true;\n                que.emplace(x.to);\n            }\n\n        }\n    }\n    return vis[t];\n}\nint h[N];\nFLOW_TYPE dfs(int now, FLOW_TYPE flow, int t) {\n    if (now == t) return flow;\n    FLOW_TYPE res = 0;\n    int len = g[now].size();\n    for (int &amp;i = h[now] ; i &lt; len ; i++) {\n        auto &amp;e = g[now][i];\n        if (dist[e.to] == dist[now] + 1 &amp;&amp; e.flow &gt; 0) {\n            FLOW_TYPE p = dfs(e.to, min(flow, e.flow), t);\n            flow -= p;\n            e.flow -= p;\n            g[e.to][e.rev].flow += p;\n            res += p;\n            if (flow == 0) return res;\n        }\n    }\n    return res;\n}\nFLOW_TYPE maxFlow(int s, int t) {\n    FLOW_TYPE res = 0;\n    while (bfs(s, t)) {\n        fill(h + 1, h + n + 1, 0);\n        FLOW_TYPE k = dfs(s, INF, t);\n        res += k;\n    }\n    return res;\n}\nvoid add(int a, int b, FLOW_TYPE c) {\n    g[a].emplace_back(b, c, int(g[b].size()));\n    g[b].emplace_back(a, 0, int(g[a].size()) - 1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int s, t;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        add(u, v, w);\n    }\n    cout &lt;&lt; maxFlow(s, t) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%9C%80%E5%B0%8F%E5%89%B2/","title":"\u6700\u5c0f\u5272","text":"<p>P2762 \u592a\u7a7a\u98de\u884c\u8ba1\u5212\u95ee\u9898 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nusing FLOW_TYPE = int;\nconst FLOW_TYPE INF = 0x7fffffff;\nstruct Edge {\n    int to, rev;\n    FLOW_TYPE flow;\n    Edge() = default;\n    Edge(int to, FLOW_TYPE flow, int rev) : to(to), flow(flow), rev(rev) {}\n};\nconst int N = 201;\nint n, m;\nvector&lt;Edge&gt; g[N];\nbool vis[N];\nint dist[N];\nbool bfs(int s, int t) {\n    fill(dist + 1, dist + n + 1, 0);\n    fill(vis + 1, vis + n + 1, false);\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    vis[s] = true;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (auto &amp;x : g[u]) {\n            if (x.flow &gt; 0 &amp;&amp; !vis[x.to]) {\n                dist[x.to] = dist[u] + 1;\n                vis[x.to] = true;\n                que.emplace(x.to);\n            }\n\n        }\n    }\n    return vis[t];\n}\nint h[N];\nFLOW_TYPE dfs(int now, FLOW_TYPE flow, int t) {\n    if (now == t) return flow;\n    FLOW_TYPE res = 0;\n    int len = g[now].size();\n    for (int &amp;i = h[now] ; i &lt; len ; i++) {\n        auto &amp;e = g[now][i];\n        if (dist[e.to] == dist[now] + 1 &amp;&amp; e.flow &gt; 0) {\n            FLOW_TYPE p = dfs(e.to, min(flow, e.flow), t);\n            flow -= p;\n            e.flow -= p;\n            g[e.to][e.rev].flow += p;\n            res += p;\n            if (flow == 0) return res;\n        }\n    }\n    return res;\n}\nFLOW_TYPE maxFlow(int s, int t) {\n    FLOW_TYPE res = 0;\n    while (bfs(s, t)) {\n        fill(h + 1, h + n + 1, 0);\n        FLOW_TYPE k = dfs(s, INF, t);\n        res += k;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int s = N + M + 1;\n    int t = s + 1;\n    n = t;\n    int ans = 0;\n    for (int i = 1 ; i &lt;= N ; i++) {\n        int k;\n        cin &gt;&gt; k;\n        ans += k;\n        g[s].emplace_back(i, k, int(g[i].size()));\n        g[i].emplace_back(s, 0, int(g[s].size()) - 1);\n        string str;\n        getline(cin, str);\n        stringstream ss(str);\n        while (ss &gt;&gt; k) {\n            g[i].emplace_back(N + k, INF, int(g[N + k].size()));\n            g[N + k].emplace_back(i, 0, int(g[i].size()) - 1);\n        }\n    }\n    for (int i = 1 ; i &lt;= M ; i++) {\n        int k;\n        cin &gt;&gt; k;\n        g[N + i].emplace_back(t, k, int(g[t].size()));\n        g[t].emplace_back(N + i, 0, int(g[N + i].size()) - 1);\n    }\n    ans -= maxFlow(s, t);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        if (dist[i]) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n    for (int i = 1 ; i &lt;= M ; i++) {\n        if (dist[N + i]) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P1361 \u5c0fM\u7684\u4f5c\u7269 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nusing FLOW_TYPE = int;\nconst FLOW_TYPE INF = 0x7fffffff;\nstruct Edge {\n    int to, rev;\n    FLOW_TYPE flow;\n    Edge() = default;\n    Edge(int to, FLOW_TYPE flow, int rev) : to(to), flow(flow), rev(rev) {}\n};\nconst int N = 3005;\nint n, m;\nvector&lt;Edge&gt; g[N];\nbool vis[N];\nint dist[N];\nbool bfs(int s, int t) {\n    fill(dist + 1, dist + n + 1, 0);\n    fill(vis + 1, vis + n + 1, false);\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    vis[s] = true;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (auto &amp;x : g[u]) {\n            if (x.flow &gt; 0 &amp;&amp; !vis[x.to]) {\n                dist[x.to] = dist[u] + 1;\n                vis[x.to] = true;\n                que.emplace(x.to);\n            }\n\n        }\n    }\n    return vis[t];\n}\nint h[N];\nFLOW_TYPE dfs(int now, FLOW_TYPE flow, int t) {\n    if (now == t) return flow;\n    FLOW_TYPE res = 0;\n    int len = g[now].size();\n    for (int &amp;i = h[now] ; i &lt; len ; i++) {\n        auto &amp;e = g[now][i];\n        if (dist[e.to] == dist[now] + 1 &amp;&amp; e.flow &gt; 0) {\n            FLOW_TYPE p = dfs(e.to, min(flow, e.flow), t);\n            flow -= p;\n            e.flow -= p;\n            g[e.to][e.rev].flow += p;\n            res += p;\n            if (flow == 0) return res;\n        }\n    }\n    return res;\n}\nFLOW_TYPE maxFlow(int s, int t) {\n    FLOW_TYPE res = 0;\n    while (bfs(s, t)) {\n        fill(h + 1, h + n + 1, 0);\n        FLOW_TYPE k = dfs(s, INF, t);\n        res += k;\n    }\n    return res;\n}\nvoid add(int a, int b, int c) {\n    g[a].emplace_back(b, c, int(g[b].size()));\n    g[b].emplace_back(a, 0, int(g[a].size()) - 1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N;\n    cin &gt;&gt; N;\n    int ans = 0;\n    vector&lt;int&gt; a(N + 1), b(N + 1);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        int w;\n        cin &gt;&gt; w;\n        ans += w;\n        a[i] = w;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        int w;\n        cin &gt;&gt; w;\n        ans += w;\n        b[i] = w;\n    }\n    int M;\n    cin &gt;&gt; M;\n    int s = N + 2 * M + 1;\n    int t = s + 1;\n    n = t;\n    for (int i = 1 ; i &lt;= N ; i++) {\n        add(s, i, a[i]);\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        add(i, t, b[i]);\n    }\n    for (int i = 1 ; i &lt;= M ; i++) {\n        int k, c1, c2;\n        cin &gt;&gt; k &gt;&gt; c1 &gt;&gt; c2;\n        add(s, N + i, c1);\n        add(N + M + i, t, c2);\n        ans += c1;\n        ans += c2;\n        for (int j = 0 ; j &lt; k ; j++) {\n            int x;\n            cin &gt;&gt; x;\n            add(N + i, x, INF);\n            add(x, N + M + i, INF);\n        }\n    }\n    ans -= maxFlow(s, t);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%A0%91%E5%88%86%E6%B2%BB/","title":"\u6811\u5206\u6cbb","text":"<p>P3806 \u3010\u6a21\u677f\u3011\u70b9\u5206\u6cbb 1 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/%E6%A0%91%E5%88%86%E6%B2%BB/#k","title":"\u662f\u5426\u5b58\u5728\u6811\u4e0a\u70b9\u5bf9\u8ddd\u79bb\u7b49\u4e8ek","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;pair&lt;int, int&gt;&gt; adj[10005];\nint dp[10005], cnt[10005];\nint n, m, rt, sum;\nbool vis[10005];\nvoid dfs(int u, int p) {\n    dp[u] = 0;\n    cnt[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dfs(to, u);\n        cnt[u] += cnt[to];\n        dp[u] = max(dp[u], cnt[to]);\n    }\n    dp[u] = max(dp[u], sum - cnt[u]);\n    if (dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nbool exist[105];\nint dist[10005], rev[10005], tot;\nbool flag[10000005];\nint q[105];\nvoid get(int u, int p) {\n    if (dist[u] &lt;= 10000000) {\n        rev[++tot] = dist[u];\n    }\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = dist[u] + w;\n        get(to, u);\n    }\n}\nvoid work(int u) {\n    static int st[10005];\n    int top = 0;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        tot = 0;\n        dist[to] = w;\n        get(to, u);\n        for (int j = 1 ; j &lt;= tot ; j++) {\n            for (int R = 1 ; R &lt;= m ; R++) {\n                if (q[R] &gt;= rev[j]) {\n                    exist[R] |= flag[q[R] - rev[j]];\n                }\n            }\n        }\n        for (int j = 1 ; j &lt;= tot ; j++) {\n            st[++top] = rev[j];\n            flag[rev[j]] = true;\n        }\n    }\n    for (int i = 1 ; i &lt;= top ; i++) {\n        flag[st[i]] = false;\n    }\n}\nvoid solve(int u) {\n    vis[u] = flag[0] = true;\n    dist[u] = 0;\n    work(u);\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        sum = cnt[to];\n        dp[0] = n;\n        rt = 0;\n        dfs(to, u);\n        solve(rt);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    dp[0] = sum = n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; q[i];\n    }\n    dfs(1, 0);\n    solve(rt);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cout &lt;&lt; (exist[i] ? \"AYE\" : \"NAY\") &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%A0%91%E5%88%86%E6%B2%BB/#k_1","title":"\u6811\u4e0a\u70b9\u5bf9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8ek","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;pair&lt;int, int&gt;&gt; adj[40005];\nint dp[40005], cnt[40005];\nint n, rt, sum;\nbool vis[40005];\nvoid dfs(int u, int p) {\n    dp[u] = 0;\n    cnt[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dfs(to, u);\n        cnt[u] += cnt[to];\n        dp[u] = max(dp[u], cnt[to]);\n    }\n    dp[u] = max(dp[u], sum - cnt[u]);\n    if (dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint dist[40005], rev[40005], tot;\nint k;\nint ans = 0;\nvoid get(int u, int p) {\n    rev[++tot] = dist[u];\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = dist[u] + w;\n        get(to, u);\n    }\n}\nint work(int u, int w) {\n    tot = 0;\n    get(u, 0);\n    sort(rev + 1, rev + tot + 1);\n    int L = 1, R = tot, res = 0;\n    while (L &lt;= R) {\n        if (rev[L] + rev[R] &lt;= k) {\n            res += R - L;\n            L++;\n        } else {\n            R--;\n        }\n    }\n    return res;\n\n}\nvoid solve(int u) {\n    vis[u] = true;\n    dist[u] = 0;\n    ans += work(u, 0);\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        dist[to] = w;\n        ans -= work(to, w);\n        sum = cnt[to];\n        dp[0] = n;\n        rt = 0;\n        dfs(to, u);\n        solve(rt);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    dp[0] = sum = n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    cin &gt;&gt; k;\n    dfs(1, 0);\n    solve(rt);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%A0%91%E5%88%86%E6%B2%BB/#3","title":"\u6811\u4e0a\u70b9\u5bf9\u8ddd\u79bb\u4e3a3\u7684\u500d\u6570","text":"<p>P2634 [\u56fd\u5bb6\u96c6\u8bad\u961f] \u806a\u806a\u53ef\u53ef - \u6d1b\u8c37</p> Code Text Only<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;pair&lt;int, int&gt;&gt; adj[20005];\nint dp[20005], cnt[20005];\nint n, rt, sum;\nbool vis[20005];\nvoid dfs(int u, int p) {\n    dp[u] = 0;\n    cnt[u] = 1;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dfs(to, u);\n        cnt[u] += cnt[to];\n        dp[u] = max(dp[u], cnt[to]);\n    }\n    dp[u] = max(dp[u], sum - cnt[u]);\n    if (dp[u] &lt; dp[rt]) {\n        rt = u;\n    }\n}\nint dist[20005], tot;\nint k;\nint ans = 0;\nint book[3];\nvoid get(int u, int p) {\n    book[dist[u] % 3]++;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) continue;\n        dist[to] = (dist[u] + w) % 3;\n        get(to, u);\n    }\n}\nint work(int u, int w) {\n    tot = 0;\n    fill(book, book + 3, 0);\n    get(u, 0);\n    return book[2] * book[1] * 2 + book[0] * book[0];\n\n}\nvoid solve(int u) {\n    vis[u] = true;\n    dist[u] = 0;\n    ans += work(u, 0);\n    for (auto &amp;[to, w] : adj[u]) {\n        if (vis[to]) continue;\n        dist[to] = w % 3;\n        ans -= work(to, w);\n        sum = cnt[to];\n        dp[0] = n;\n        rt = 0;\n        dfs(to, u);\n        solve(rt);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    dp[0] = sum = n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        w %= 3;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    dfs(1, 0);\n    solve(rt);\n    int z = n * n;\n    int d = __gcd(ans, z);\n    z /= d;\n    ans /= d;\n    cout &lt;&lt; ans &lt;&lt; \"/\" &lt;&lt; z &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","title":"\u6811\u94fe\u5256\u5206","text":""},{"location":"Template/Graph/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/#_2","title":"\u6a21\u677f","text":"Code C++<pre><code>vector&lt;int&gt; adj[100005];\nint son[100005], cnt[100005], val[100005];\nint dep[100005], fa[100005], top[100005];\nint rnk[100005], dfn[100005], a[100005];\nint tot;\nint mod;\nvoid dfs1(int u, int p) {\n    son[u] = -1;\n    cnt[u] = 1;\n    for (auto &amp;v : adj[u]) {\n        if (v == p) continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v, u);\n        cnt[u] += cnt[v];\n        if (son[u] == -1 || cnt[v] &gt; cnt[son[u]]) {\n            son[u] = v;\n        }\n    }\n}\nvoid dfs2(int u, int p) {\n    top[u] = p;\n    dfn[u] = ++tot;\n    val[tot] = a[u];\n    rnk[tot] = u;\n    if (son[u] == -1) return;\n    dfs2(son[u], p);\n    for (auto &amp;v : adj[u]) {\n        if (v != son[u] &amp;&amp; v != fa[u]) {\n            dfs2(v, v);\n        }\n    }\n}\nint LCA(int x, int y) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    return x;\n}\n</code></pre> <p>P3384 \u3010\u6a21\u677f\u3011\u91cd\u94fe\u5256\u5206/\u6811\u94fe\u5256\u5206 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; adj[100005];\nint son[100005], cnt[100005], val[100005];\nint dep[100005], fa[100005], top[100005];\nint rnk[100005], dfn[100005], a[100005];\nint tot;\nint mod;\nvoid dfs1(int u, int p) {\n    son[u] = -1;\n    cnt[u] = 1;\n    for (auto &amp;v : adj[u]) {\n        if (v == p) continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v, u);\n        cnt[u] += cnt[v];\n        if (son[u] == -1 || cnt[v] &gt; cnt[son[u]]) {\n            son[u] = v;\n        }\n    }\n}\nvoid dfs2(int u, int p) {\n    top[u] = p;\n    dfn[u] = ++tot;\n    val[tot] = a[u];\n    rnk[tot] = u;\n    if (son[u] == -1) return;\n    dfs2(son[u], p);\n    for (auto &amp;v : adj[u]) {\n        if (v != son[u] &amp;&amp; v != fa[u]) {\n            dfs2(v, v);\n        }\n    }\n}\nint LCA(int x, int y) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    return x;\n}\nstruct Node {\n    int L, R;\n    long long sum, lazy;\n} tree[100005 &lt;&lt; 2];\nvoid push_up(int p) {\n    tree[p].sum = (tree[p &lt;&lt; 1].sum + tree[p &lt;&lt; 1 | 1].sum) % mod;\n}\nvoid push_dowm(int p) {\n    if (tree[p].lazy) {\n        int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n        tree[x].lazy = (tree[x].lazy + tree[p].lazy) % mod;\n        tree[y].lazy = (tree[y].lazy + tree[p].lazy) % mod;\n        tree[x].sum = (tree[x].sum + tree[p].lazy * (tree[x].R - tree[x].L + 1) % mod) % mod;\n        tree[y].sum = (tree[y].sum + tree[p].lazy * (tree[y].R - tree[y].L + 1) % mod) % mod;\n        tree[p].lazy = 0;\n    }\n}\nvoid build(int p, int L, int R) {\n    tree[p].L = L;\n    tree[p].R = R;\n    if (L == R) {\n        tree[p].sum = val[L] % mod;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    push_up(p);\n}\nvoid modify(int p, int QL, int QR, long long k) {\n    int L = tree[p].L, R = tree[p].R;\n    if (QL &gt; R || QR &lt; L) return;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        tree[p].lazy = (tree[p].lazy + k) % mod;\n        tree[p].sum = (tree[p].sum + (R - L + 1) * k % mod) % mod;\n        return;\n    }\n    push_dowm(p);\n    int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, QL, QR, k);\n    modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    push_up(p);\n}\nlong long query(int p, int QL, int QR) {\n    int L = tree[p].L, R = tree[p].R;\n    if (QL &gt; R || QR &lt; L) return 0;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tree[p].sum;\n    }\n    push_dowm(p);\n    int mid = L + R &gt;&gt; 1;\n    return (query(p &lt;&lt; 1, QL, QR) + query(p &lt;&lt; 1 | 1, QL, QR)) % mod;\n}\nvoid add(int x, int y, long long k) {\n    k %= mod;\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        modify(1, dfn[top[x]], dfn[x], k);\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    modify(1, dfn[x], dfn[y], k);\n}\nvoid add(int x, long long k) {\n    k %= mod;\n    modify(1, dfn[x], dfn[x] + cnt[x] - 1, k);\n}\nlong long query(int x, int y) {\n    long long res = 0;\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        res = (res + query(1, dfn[top[x]], dfn[x])) % mod;\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    res = (res + query(1, dfn[x], dfn[y])) % mod;\n    return res;\n}\nlong long query(int x) {\n    return query(1, dfn[x], dfn[x] + cnt[x] - 1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, root;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; root &gt;&gt; mod;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    dfs1(root, 0);\n    dfs2(root, root);\n    build(1, 1, n);\n    for (int i = 0 ; i &lt; m ; i++) {\n        int op, x;\n        cin &gt;&gt; op &gt;&gt; x;\n        if (op == 1) {\n            int y, z;\n            cin &gt;&gt; y &gt;&gt; z;\n            add(x, y, z);\n        } else if (op == 2) {\n            int y;\n            cin &gt;&gt; y;\n            cout &lt;&lt; query(x, y) &lt;&lt; \"\\n\";\n        } else if (op == 3) {\n            int z;\n            cin &gt;&gt; z;\n            add(x, z);\n        } else {\n            cout &lt;&lt; query(x) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>#10138. \u300c\u4e00\u672c\u901a 4.5 \u4f8b 1\u300d\u6811\u7684\u7edf\u8ba1 - LibreOJ</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; adj[100005];\nint son[100005], cnt[100005], val[100005];\nint dep[100005], fa[100005], top[100005];\nint rnk[100005], dfn[100005], a[100005];\nint tot;\nvoid dfs1(int u, int p) {\n    son[u] = -1;\n    cnt[u] = 1;\n    for (auto &amp;v : adj[u]) {\n        if (v == p) continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v, u);\n        cnt[u] += cnt[v];\n        if (son[u] == -1 || cnt[v] &gt; cnt[son[u]]) {\n            son[u] = v;\n        }\n    }\n}\nvoid dfs2(int u, int p) {\n    top[u] = p;\n    dfn[u] = ++tot;\n    val[tot] = a[u];\n    rnk[tot] = u;\n    if (son[u] == -1) return;\n    dfs2(son[u], p);\n    for (auto &amp;v : adj[u]) {\n        if (v != son[u] &amp;&amp; v != fa[u]) {\n            dfs2(v, v);\n        }\n    }\n}\nint LCA(int x, int y) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    return x;\n}\nstruct Node {\n    int L, R;\n    long long sum, mx;\n} tree[100005 &lt;&lt; 2];\nvoid push_up(int p) {\n    int x = p &lt;&lt; 1, y = p &lt;&lt; 1 | 1;\n    tree[p].sum = tree[x].sum + tree[y].sum;\n    tree[p].mx = max(tree[x].mx, tree[y].mx);\n\n}\nvoid build(int p, int L, int R) {\n    tree[p].L = L;\n    tree[p].R = R;\n    if (L == R) {\n        tree[p].sum = tree[p].mx = val[L];\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    push_up(p);\n}\nvoid modify(int p, int QL, int QR, long long k) {\n    int L = tree[p].L, R = tree[p].R;\n    if (QL &gt; R || QR &lt; L) return;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        tree[p].sum = tree[p].mx = k;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    modify(p &lt;&lt; 1, QL, QR, k);\n    modify(p &lt;&lt; 1 | 1, QL, QR, k);\n    push_up(p);\n}\nlong long querySum(int p, int QL, int QR) {\n    int L = tree[p].L, R = tree[p].R;\n    if (QL &gt; R || QR &lt; L) return 0;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tree[p].sum;\n    }\n    int mid = L + R &gt;&gt; 1;\n    return querySum(p &lt;&lt; 1, QL, QR) + querySum(p &lt;&lt; 1 | 1, QL, QR);\n}\nlong long queryMax(int p, int QL, int QR) {\n    int L = tree[p].L, R = tree[p].R;\n    if (QL &gt; R || QR &lt; L) return 0x7fffffffffffffff + 1;\n    if (QL &lt;= L &amp;&amp; R &lt;= QR) {\n        return tree[p].mx;\n    }\n    int mid = L + R &gt;&gt; 1;\n    return max(queryMax(p &lt;&lt; 1, QL, QR), queryMax(p &lt;&lt; 1 | 1, QL, QR));\n}\nvoid modify(int pos, long long k) {\n    modify(1, dfn[pos], dfn[pos], k);\n}\nlong long querySum(int x, int y) {\n    long long res = 0;\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        res += querySum(1, dfn[top[x]], dfn[x]);\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    res += querySum(1, dfn[x], dfn[y]);\n    return res;\n}\nlong long queryMax(int x, int y) {\n    long long res = 0x7fffffffffffffff + 1;\n    while (top[x] != top[y]) {\n        if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        res = max(res, queryMax(1, dfn[top[x]], dfn[x]));\n        x = fa[top[x]];\n    }\n    if (dep[x] &gt; dep[y]) swap(x, y);\n    res = max(res, queryMax(1, dfn[x], dfn[y]));\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, root = 1;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    dfs1(root, 0);\n    dfs2(root, root);\n    build(1, 1, n);\n    int m;\n    cin &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        string op;\n        int x, y;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        if (op == \"QMAX\") {\n            cout &lt;&lt; queryMax(x, y) &lt;&lt; \"\\n\";\n        } else if (op == \"QSUM\") {\n            cout &lt;&lt; querySum(x, y) &lt;&lt; \"\\n\";\n        } else {\n            modify(x, y);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/%E8%B4%B9%E7%94%A8%E6%B5%81/","title":"\u8d39\u7528\u6d41","text":"<p>P3381 \u3010\u6a21\u677f\u3011\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nusing FLOW_TYPE = int;\nconst FLOW_TYPE INF = 0x7fffffff;\nstruct Edge {\n    int to, rev;\n    FLOW_TYPE flow, cost;\n    Edge() = default;\n    Edge(int to, FLOW_TYPE flow, FLOW_TYPE cost, int rev) : to(to), flow(flow), cost(cost), rev(rev) {}\n};\nconst int N = 405;\nint n, m;\nvector&lt;Edge&gt; g[N];\nbool vis[N];\nint dist[N];\nbool spfa(int s, int t) {\n    fill(dist + 1, dist + n + 1, INF);\n    fill(vis + 1, vis + n + 1, false);\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        vis[u] = false;\n        for (auto &amp;x : g[u]) {\n            if (x.flow &gt; 0 &amp;&amp; dist[x.to] &gt; dist[u] + x.cost) {\n                dist[x.to] = dist[u] + x.cost;\n                if (!vis[x.to]) {\n                    que.emplace(x.to);\n                    vis[x.to] = true;\n                }\n            }\n\n        }\n    }\n    return dist[t] != INF;\n}\nint h[N];\nFLOW_TYPE ret;\nFLOW_TYPE dfs(int now, FLOW_TYPE flow, int t) {\n    if (now == t) return flow;\n    vis[now] = true;\n    FLOW_TYPE res = 0;\n    int len = g[now].size();\n    for (int &amp;i = h[now] ; i &lt; len ; i++) {\n        auto &amp;e = g[now][i];\n        if (!vis[e.to] &amp;&amp; dist[e.to] == dist[now] + e.cost &amp;&amp; e.flow &gt; 0) {\n            FLOW_TYPE p = dfs(e.to, min(flow, e.flow), t);\n            flow -= p;\n            e.flow -= p;\n            g[e.to][e.rev].flow += p;\n            res += p;\n            ret += p * e.cost;\n            if (flow == 0) return res;\n        }\n    }\n    vis[now] = false;\n    return res;\n}\npair&lt;FLOW_TYPE, FLOW_TYPE&gt; maxFlow(int s, int t) {\n    pair&lt;FLOW_TYPE, FLOW_TYPE&gt; res;\n    ret = 0;\n    while (spfa(s, t)) {\n        fill(h + 1, h + n + 1, 0);\n        fill(vis + 1, vis + n + 1, false);\n        res.first += dfs(s, INF, t);\n    }\n    res.second = ret;\n    return res;\n}\nvoid add(int a, int b, FLOW_TYPE c, FLOW_TYPE d) {\n    g[a].emplace_back(b, c, d, int(g[b].size()));\n    g[b].emplace_back(a, 0, -d, int(g[a].size()) - 1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int s, t;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, w, c;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;\n        add(u, v, w, c);\n    }\n    auto [x, y] = maxFlow(s, t);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/Tree/LowestCommonAncestor/","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148","text":""},{"location":"Template/Graph/Tree/LowestCommonAncestor/#_2","title":"\u500d\u589e","text":"\u6a21\u7248 \u6811\u4e0a\u500d\u589e\u6b27\u62c9\u5e8fst\u8868 <p>\u9884\u5904\u7406 \\(O(n*\\log n)\\)\uff0c\u67e5\u8be2 \\(O(\\log n)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 500005;\nvector&lt;int&gt; adj[N];\nint fa[N][22], deep[N];\nvoid dfs(int u, int p) {\n    fa[u][0] = p;\n    deep[u] = deep[p] + 1;\n    for (int i = 1 ; i &lt;= 21 ; i++) {\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &lt; deep[y]) swap(x, y);\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[y]) continue;\n        x = fa[x][i];\n    }\n    if (x == y) return x;\n    for (int i = 21 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, rt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(rt, 0);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; LCA(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>\u9884\u5904\u7406 \\(O(n*\\log n)\\)\uff0c\u67e5\u8be2 \\(O(1)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst int N = 500005;\nvector&lt;int&gt; adj[N];\nint fa[N &lt;&lt; 1][22], dfn[N], deep[N], tot, que[N &lt;&lt; 1], lg[N &lt;&lt; 1];\nvoid dfs(int u, int p) {\n    dfn[u] = ++tot;\n    que[tot] = u;\n    deep[u] = deep[p] + 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n        que[++tot] = u;\n    }\n}\nvoid initLCA() {\n    lg[0] = -1;\n    for (int i = 1 ; i &lt;= tot ; i++) {\n        fa[i][0] = que[i];\n        lg[i] = lg[i &gt;&gt; 1] + 1;\n    }\n    for (int j = 1 ; j &lt;= 21 ; j++) {\n        for (int i = 1 ; i + (1 &lt;&lt; j) &lt;= tot ; i++) {\n            int x = fa[i][j - 1], y = fa[i + (1 &lt;&lt; j - 1)][j - 1];\n            fa[i][j] = deep[x] &lt; deep[y] ? x : y;\n        }\n    }\n}\nint LCA(int x, int y) {\n    if (dfn[x] &gt; dfn[y]) swap(x, y);\n    x = dfn[x];\n    y = dfn[y];\n    int k = lg[y - x + 1];\n    x = fa[x][k];\n    y = fa[y - (1 &lt;&lt; k) + 1][k];\n    return deep[x] &lt; deep[y] ? x : y;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, rt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(rt, 0);\n    initLCA();\n    for (int i = 1 ; i &lt;= m ; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; LCA(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3379 <p>P3379 \u3010\u6a21\u677f\u3011\u6700\u8fd1\u516c\u5171\u7956\u5148\uff08LCA\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/Tree/TreeHash/","title":"\u6811\u54c8\u5e0c","text":"\u6a21\u7248 C++<pre><code>const long long mod = 1000000007;\nconst long long base = std::chrono::steady_clock::now().time_since_epoch().count() % mod + 1;\nlong long get(long long x) {\n    x = x * x % mod;\n    x = (x + base) % mod;\n    x = x * x % mod;\n    return x;\n}\nvector&lt;int&gt; adj[100005];\nlong long hashd[100005];\nlong long dfs(int u, int p) {\n    hashd[u] = 1;\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        auto h = get(dfs(to, u));\n        hashd[u] = (hashd[u] + h) % mod;\n    }\n    return hashd[u];\n}\n</code></pre> \u4f8b\u9898 UOJ763QOJ499 <p>\u6811\u54c8\u5e0c - Universal Online Judge</p> <p>\u6811 Hash - QOJ.ac</p>"},{"location":"Template/Math/Berlekamp-Massey%E7%AE%97%E6%B3%95/","title":"Berlekamp-Massey\u7b97\u6cd5","text":"Code <p>Linear_Solve::init(vector a) \u4f20\u5165\u524dk\u9879\u6570\u636e <p>Linear_Solve::Solve(long long n) \u6c42\u89e3\u7b2c n - 1 \u9879</p> C++<pre><code>namespace Linear_Solve {\n    const int mod = 998244353;\n    vector&lt;int&gt; v, a, d;\n    vector&lt;long long&gt; res, tempc, tempd, base;\n    long long qpow(long long a, long long b) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    vector&lt;int&gt; berlekamp_massey(const vector&lt;int&gt;&amp; a) {\n        vector&lt;int&gt; v, last;\n        int k = -1, delta = 0;\n        for (int i = 0 ; i &lt; int(a.size()) ; i++) {\n            int temp = 0;\n            for (int j = 0 ; j &lt; int(v.size()) ; j++) {\n                temp = (temp + 1LL * a[i - j - 1] * v[j]) % mod;\n            }\n            if (a[i] == temp) continue;\n            if (k &lt; 0) {\n                k = i;\n                delta = (a[i] - temp + mod) % mod;\n                v = vector&lt;int&gt;(i + 1);\n                continue;\n            }\n            vector&lt;int&gt; u = v;\n            int val = 1LL * (a[i] - temp + mod) * qpow(delta, mod - 2) % mod;\n            if (int(v.size()) &lt; int(last.size()) + i - k) {\n                v.resize(int(last.size()) + i - k);\n            }\n            v[i - k - 1] = (v[i - k - 1] + val) % mod;\n            for (int j = 0 ; j &lt; int(last.size()) ; j++) {\n                v[i - k + j] = (v[i - k + j] - 1LL * val * last[j] + mod) % mod;\n            }\n            if (int(u.size()) - i &lt; int(last.size()) - k) {\n                last = u;\n                k = i;\n                delta = (a[i] - temp + mod) % mod;\n            }\n        }\n        return v;\n    }\n    void init(const vector&lt;int&gt;&amp; a) {\n        Linear_Solve::a = a;\n        const int&amp; n = a.size() + 1;\n        res.assign(n, 0);\n        base.assign(n, 0);\n        tempc.assign(n, 0);tempd.assign(n, 0);\n        v = berlekamp_massey(a);\n    }\n    long long mul(vector&lt;long long&gt;&amp; a, vector&lt;long long&gt;&amp; b, const int&amp; k) {\n        fill(begin(tempc), begin(tempc) + (k &lt;&lt; 1), 0);\n        for (int i = 0 ; i &lt; k ; i++) {\n            if (a[i]) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    tempc[i + j] = (tempc[i + j] + a[i] * b[j]) % mod;\n                }\n            }\n        }\n        for (int i = (k &lt;&lt; 1) - 1 ; i &gt;= k ; i--) {\n            if (tempc[i]) {\n                for (int j = 0 ; j &lt; int(d.size()) ; j++) {\n                    tempc[i - k + d[j]] = (tempc[i - k + d[j]] - tempc[i] * tempd[d[j]]) % mod;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            a[i] = tempc[i];\n        }\n    }\n    long long Solve(const long long&amp; n) {\n        long long ans = 0, cnt = 0;\n        int k = v.size();\n        vector&lt;int&gt; b = a;\n        b.resize(v.size());\n        for (int i = 0 ; i &lt; k ; i++) {\n            tempd[k - 1 - i] = -v[i];\n        }\n        tempd[k] = 1;\n        d.clear();\n        for (int i = 0 ; i &lt; k ; i++) {\n            if (tempd[i]) {\n                d.emplace_back(i);\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            res[i] = base[i] = 0;\n        }\n        res[0] = 1;\n        while (1LL &lt;&lt; cnt &lt;= n) cnt++;\n        for (int i = cnt ; i &gt;= 0 ; i--) {\n            mul(res, res, k);\n            if (n &gt;&gt; i &amp; 1) {\n                for (int j = k - 1 ; j &gt;= 0 ; j--) {\n                    res[j + 1] = res[j];\n                }\n                res[0] = 0;\n                for (auto&amp; j : d) {\n                    res[j] = (res[j] - res[k] * tempd[j]) % mod;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; k ; i++) {\n            ans = (ans + res[i] * b[i] + mod) % mod;\n        }\n        return ans;\n    }\n} // Linear_Solve\nusing Linear_Solve::mod;\n</code></pre>"},{"location":"Template/Math/%E5%88%86%E6%95%B0/","title":"\u5206\u6570","text":""},{"location":"Template/Math/%E5%88%86%E6%95%B0/#_2","title":"\u6a21\u677f","text":"Code C++<pre><code>struct Frac {\n    long long n, d;\n    Frac(long long n = 0, long long d = 1) : n(n), d(d) {\n        assert(d != 0);\n        if (d &lt; 0) {\n            this -&gt; d = -d;\n            this -&gt; n = -n;\n        }\n        reduct();\n    }\n    void reduct() {\n        long long k = __gcd(llabs(n), d);\n        n /= k;\n        d /= k;\n    }\n    friend Frac operator+(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d + y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator-(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d - y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator*(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.n, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    Frac operator/(const Frac &amp;_) {\n        return *this * _.rev();\n    }\n    Frac&amp; operator+=(const Frac &amp;_) {\n        *this = *this + _;\n        return *this;\n    }\n    Frac&amp; operator-=(const Frac &amp;_) {\n        *this = *this - _;\n        return *this;\n    }\n    Frac&amp; operator*=(const Frac &amp;_) {\n        *this = *this * _;\n        return *this;\n    }\n    Frac&amp; operator/=(const Frac &amp;_) {\n        *this = *this / _;\n        return *this;\n    }\n    Frac rev() const {\n        Frac res(d, llabs(n));\n        if (n &lt; 0) {\n            res.n = -res.n;\n        }\n        return res;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Frac &amp;x) {\n        os &lt;&lt; x.n;\n        if (x.d != 1) os &lt;&lt; \"/\" &lt;&lt; x.d;\n        return os;\n    }\n}; // Frac\n</code></pre>"},{"location":"Template/Math/%E5%8D%9A%E5%BC%88%E8%AE%BA/","title":"\u535a\u5f08\u8bba","text":""},{"location":"Template/Math/%E5%8D%9A%E5%BC%88%E8%AE%BA/#nims-game","title":"\u5c3c\u59c6\u6e38\u620f (Nim's Game)","text":"<p>nim\u535a\u5f08(1\u5806\u62ff\u4efb\u610f) \u5148\u624b\u5fc5\u80dc\u6761\u4ef6 \u5f02\u6216\u548c\u4e0d\u4e3a0</p> <p>exnim\u535a\u5f08(\u4ece1~d\u5806\u62ff\u4efb\u610f) \u5148\u624b\u5fc5\u80dc\u6761\u4ef6 \u67d0\u4f4d\u4e3a1\u7684\u5806\u6570\u4e0d\u80fd\u88ab(d+1)\u6574\u9664</p>"},{"location":"Template/Math/%E5%8D%9A%E5%BC%88%E8%AE%BA/#wythoffs-game","title":"\u5a01\u4f50\u592b\u6e38\u620f (Wythoff's Game)","text":"<p>\u5a01\u4f50\u592b\u535a\u5f08 \u7684 \u7b2c \\(k\\) \u4e2a\u5947\u5f02\u5c40\u52bf\u4e3a \\((\\lfloor\\dfrac{1+\\sqrt{5}}{2}\\cdot{}k\\rfloor,\\lfloor\\dfrac{3+\\sqrt{5}}{2}\\cdot{}k\\rfloor)\\)</p> <p>\u62d3\u5c55\u5a01\u4f50\u592b\u535a\u5f08 \u7684 \u7b2c \\(k\\) \u4e2a\u5947\u5f02\u5c40\u52bf\u4e3a \\((\\lfloor\\dfrac{2-d+\\sqrt{d^2+4}}{2}\\cdot{}k\\rfloor,\\lfloor\\dfrac{2+d+\\sqrt{d^2+4}}{2}\\cdot{}k\\rfloor)\\)</p> <p>acm.hdu.edu.cn/showproblem.php?pid=1527</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble gold = (1 + sqrt(5)) / 2;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, b;\n    while (cin &gt;&gt; a &gt;&gt; b) {\n        if (a &gt; b) swap(a, b);\n        int k = gold * (b - a);\n        if (a == k) cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n        else cout &lt;&lt; 1 &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>acm.hdu.edu.cn/showproblem.php?pid=2177</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble gold = (1 + sqrt(5)) / 2;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, b;\n    while (cin &gt;&gt; a &gt;&gt; b) {\n        if (a == 0 &amp;&amp; b == 0) break;\n        if (a &gt; b) swap(a, b);\n        int k = gold * (b - a);\n        if (a == k) cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n        else {\n            cout &lt;&lt; 1 &lt;&lt; \"\\n\";\n            for (int i = 1 ; i &lt;= a ; i++) {\n                int n = a - i, m = b - i;\n                if (k == n) {\n                    cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; m &lt;&lt; \"\\n\";\n\n                }\n            }\n            for (int i = b ; i &gt;= 0 ; i--) {\n                int n = a, m = i;\n                if (n &gt; m) swap(n, m);\n                k = gold * (m - n);\n                if (k == n) {\n                    cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; m &lt;&lt; \"\\n\";\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/","title":"\u5e73\u8861\u4e09\u8fdb\u5236","text":""},{"location":"Template/Math/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/#_2","title":"\u5b9a\u4e49","text":"<p>\u5e73\u8861\u4e09\u8fdb\u5236\uff0c\u4e5f\u79f0\u4e3a\u5bf9\u79f0\u4e09\u8fdb\u5236\u3002</p> <p>\u5e73\u8861\u4e09\u8fdb\u5236\u7684\u6570\u5b57\u662f\u7531 -1, 0, 1 \u6784\u6210\u7684\u3002\u5b83\u7684\u57fa\u6570\u4e5f\u662f 3 \u3002\u7531\u4e8e\u5c06 -1 \u5199\u6210\u6570\u5b57\u4e0d\u65b9\u4fbf\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u5b57\u6bcd z \u6765\u4ee3\u66ff -1\u3002</p>"},{"location":"Template/Math/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/#_3","title":"\u8fc7\u7a0b","text":"<p>\u5148\u5c06\u5341\u8fdb\u5236\u8f6c\u5316\u4e3a\u666e\u901a\u4e09\u8fdb\u5236\uff0c\u518d\u4ece\u4f4e\u4f4d\u5f00\u59cb\uff0c\u9047\u5230 2 \u5219 \u6539\u4e3a -1 \u4e14\u5c06\u4e0b\u4e00\u4f4d +1\uff0c\u9047\u5230 3 \u5219 \u6539\u4e3a 0 \u4e14\u5c06\u4e0b\u4e00\u4f4d + 1</p> <p>U313611 \u3010\u6a21\u677f\u3011\u5e73\u8861\u4e09\u8fdb\u5236 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    bool sign = true;\n    if (n &lt; 0) {\n        sign = false;\n        n = -n;\n    }\n    vector&lt;int&gt; nums;\n    int temp = n;\n    while (temp) {\n        nums.emplace_back(temp % 3);\n        temp /= 3;\n    }\n    nums.emplace_back(0);\n    int len = nums.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        if (nums[i] == 3) {\n            nums[i] = 0;\n            nums[i + 1]++;\n        } else if (nums[i] == 2) {\n            nums[i] = -1;\n            nums[i + 1]++;\n        }\n    }\n    reverse(begin(nums), end(nums));\n    if (sign == false) {\n        for (int i = 0 ; i &lt; len ; i++) {\n            nums[i] = -nums[i];\n        }\n    }\n    bool has = false;\n    for (int i = 0 ; i &lt; len ; i++) {\n        if (nums[i] == 0) {\n            if (has || i == len - 1) {\n                cout &lt;&lt; nums[i] &lt;&lt; \" \";\n            }\n        } else {\n            has = true;\n            cout &lt;&lt; nums[i] &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/Combinatorics/Derangement/","title":"\u9519\u4f4d\u6392\u5217","text":"<p>\\(D_n=(n-1)*(D_{n-1}+D_{n-2})\\)</p> <p>\\(D_n=n*D_{n-1}+{(-1)}^n\\)</p> \u725b\u5ba254484B(\\(n\\leq10^9\\)) <p>B-\u5199\u4fe1_\u534e\u4e2d\u519c\u4e1a\u5927\u5b662023\u5e74\u5341\u4e8c\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08\u540c\u6b65\u8d5b\uff09</p> \u6253\u8868\u4ee3\u7801\u4ee3\u7801 C++<pre><code>const long long mod = 1000000007;\nlong long ans = 0;\nint block = 1000000;\nfor (int i = 0 ; i &lt;= k ; i++) {\n    ans = ans * i % mod;\n    if (i &amp; 1) {\n        ans--;\n    } else {\n        ans++;\n    }\n    ans = (ans + mod) % mod;\n    if (i % block == 0) {\n        cout &lt;&lt; ans &lt;&lt; \", \";\n    }\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int block = 1000000;\nconst long long mod = 1000000007;\nconst long long res[] = {\u6253\u8868\u51fa\u6765\u7684};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin &gt;&gt; k;\n    long long ans = res[k / block];\n    for (int i = k / block + 1 ; i &lt;= k ; i++) {\n        ans = ans * i % mod;\n        if (i &amp; 1) {\n            ans--;\n        } else {\n            ans++;\n        }\n        ans = (ans + mod) % mod;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/LinearAlgebra/Matrix/","title":"\u77e9\u9635","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt;\nstruct Matrix {\n    int N, M;\n    vector&lt;vector&lt;T&gt;&gt; data;\n    Matrix(int n, int m) : N(n), M(m) {\n        data.resize(n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            data[i].resize(m);\n        }\n    }\n    Matrix E() {\n        Matrix&lt;T&gt; mat(N, M);\n        for (int i = 0 ; i &lt; N ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                if (i == j) mat[i][j] = T(1);\n                 else mat[i][j] = T(0);\n            }\n        }\n        return mat;\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; N ; i++) {\n            data[i].resize(0);\n            data[i].resize(M);\n        }\n    }\n    static Matrix qpow(Matrix base, long long b) {\n        assert(base.N == base.M);\n        Matrix res(base.N, base.M);\n        while (b) {\n            if (b &amp; 1) res *= base;\n            base *= base;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    Matrix&amp; operator*=(const Matrix &amp;x) {\n        assert(M == x.N);\n        Matrix res(N, x.M);\n        for (int i = 0 ; i &lt; N ; i++) {\n            for (int k = 0 ; k &lt; M ; k++) {\n                T r = data[i][k];\n                for (int j = 0 ; j &lt; x.M ; j++) {\n                    res[i][j] += r * x.data[k][j];\n                }\n            }\n        }\n        return *this = res;\n    }\n    Matrix operator*(const Matrix &amp;x) {\n        Matrix res = *this;\n        return res *= x;\n    }\n    vector&lt;T&gt;&amp; operator[](int x) {\n        return data[x];\n    }\n    friend istream&amp; operator&gt;&gt;(istream&amp; is, Matrix &amp;mat) {\n        for (int i = 0 ; i &lt; mat.N ; i++) {\n            for (int j = 0 ; j &lt; mat.M ; j++) {\n                is &gt;&gt; mat.data[i][j];\n            }\n        }\n        return is;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,  Matrix &amp;mat) {\n        for (int i = 0 ; i &lt; mat.N ; i++) {\n            for (int j = 0 ; j &lt; mat.M ; j++) {\n                os &lt;&lt; mat.data[i][j] &lt;&lt; \" \";\n            }\n            os &lt;&lt; \"\\n\";\n        }\n        return os;\n    }\n}; // Matrix\n// Matrix \u77e9\u9635\u7c7b\n// \u884c\u5217\u4e0b\u6807\u4ece 0 \u5f00\u59cb\n// \u5b9e\u73b0\u4e86\u77e9\u9635\u7684\u4e58\u6cd5\u8fd0\u7b97\u548c\u5feb\u901f\u5e42\n// \u5b9e\u73b0\u4e86\u77e9\u9635\u7684\u8f93\u5165\u548c\u8f93\u51fa\n</code></pre>"},{"location":"Template/Math/NumberTheory/Default/","title":"\u6570\u8bba\u57fa\u7840","text":""},{"location":"Template/Math/NumberTheory/Default/#_2","title":"\u6574\u9664","text":"<p>\\(\\lceil\\dfrac{n}{m}\\rceil=\\lfloor\\dfrac{n+m-1}{m}\\rfloor=\\lfloor\\dfrac{n-1}{m}\\rfloor+1\\)</p> <p>\\(\\lfloor\\dfrac{n}{m}\\rfloor=\\dfrac{n}{m}-n\\mod m\\)</p>"},{"location":"Template/Math/NumberTheory/Default/#_3","title":"\u6700\u5927\u516c\u56e0\u6570","text":"<ul> <li> <p>\u5df2\u77e5 \\(a&gt;1,m&gt;0,n&gt;0\\)\uff0c\u5219 \\(\\gcd(a^m-1,a^n-1)=a^{\\gcd(m,n)}-1\\)</p> </li> <li> <p>\u5df2\u77e5 \\(a&gt;b,\\gcd(a,b)=1\\)\uff0c\u5219 \\(\\gcd(a^m-b^m,a^n-b^n)=a^{\\gcd(m,n)}-b^{\\gcd(m,n)}\\)</p> </li> </ul>"},{"location":"Template/Math/NumberTheory/Default/#_4","title":"\u88f4\u8700\u5b9a\u7406","text":"<ul> <li> <p>\u82e5 \\(a,b\\) \u662f\u4e0d\u5168\u4e3a \\(0\\) \u7684\u6574\u6570\uff0c\u5219\u5b58\u5728\u6574\u6570 \\(x,y\\) \u4f7f \\(ax+by=\\gcd(a,b)\\) \u6210\u7acb</p> </li> <li> <p>\u82e5 \\(\\gcd(a,b)=1\\) \u5219 \\(C=ab-a-b\\) \u4e3a \\(ax+by\\) \\((x,y\u22650)\\) \u6240\u8868\u793a\u4e0d\u4e86\u7684\u6700\u5927\u6574\u6570</p> </li> <li> <p>\u5728\u4e0a\u4e2a\u6761\u4ef6\u4e0b \u5bf9\u4efb\u610f\u6574\u6570 \\(n\\)\uff0c\\(n\\) \u4e0e \\(C-n\\) \u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u53ef\u4ee5\u88ab\u8868\u793a </p> </li> </ul>"},{"location":"Template/Math/NumberTheory/Default/#_5","title":"\u8d39\u9a6c\u5c0f\u5b9a\u7406","text":"<ul> <li>\u82e5 \\(p\\) \u4e3a\u7d20\u6570\uff0c\u4e14 \\(\\gcd(a,p)=1\\)\uff0c\u5219 \\(a^{p-1}\\equiv1\\pmod p\\)</li> </ul>"},{"location":"Template/Math/NumberTheory/Default/#_6","title":"\u5a01\u5c14\u900a\u5b9a\u7406","text":"<ul> <li>\u5bf9\u4e8e\u7d20\u6570 \\(p\\) \u6709 \\((p-1)!\\equiv-1\\pmod p\\)</li> </ul>"},{"location":"Template/Math/NumberTheory/Default/#_7","title":"\u63a8\u5e7f","text":"<p>\u5bf9\u4e8e\u7d20\u6570 \\(p\\) \u548c\u6b63\u6574\u6570 \\(q\\) \u6709 \\((p^q!)_p\\equiv\\pm1\\pmod {p^q}\\)</p> \\[ (p^q!)_p= \\begin{cases} 1&amp;(p=2)\\cap(q\\geq3)\\\\ -1&amp;else \\nonumber \\end{cases} \\] \u5e94\u7528 \u8ba1\u7b97\u4f59\u6570\u8ba1\u7b97\u9636\u4e58\u4e2dp\u7684\u5e42\u6b21 <p>\\((n!)_p\\) \u8868\u793a \\(n!\\) \u4e2d\u53bb\u6389\u6240\u6709\u56e0\u5b50 \\(p\\) \u4e4b\u540e\u7684\u4e58\u79ef\u6a21 \\(p\\)</p> <p>\\((n!)_p\\pmod p={\\left((p-1)!\\right)}^{\\lfloor\\dfrac{n}{p}\\rfloor}*\\left((n\\mod p)!\\right)*(\\lfloor\\dfrac{n}{p}\\rfloor!)_p\\\\=(-1)^{\\lfloor\\dfrac{n}{p}\\rfloor}*(n\\mod p)!*(\\lfloor\\dfrac{n}{p}\\rfloor!)_p\\)</p> \u6a21\u7248 C++<pre><code>int factmod(int n, int p) {\n    vector&lt;int&gt; f(p);\n    f[0] = 1;\n    for (int i = 1 ; i &lt; p ; i++) {\n        f[i] = f[i - 1] * i % p;\n    }\n    int res = 1;\n    while (n &gt; 1) {\n        if ((n / p) &amp; 1) res = p - res;\n        res = res * f[n % p] % p;\n        n /= p;\n    }\n    return res;\n}\n</code></pre> C++<pre><code>int multiplicity_factorial(int n, int p) {\n  int count = 0;\n  do {\n    n /= p;\n    count += n;\n  } while (n);\n  return count;\n}\n</code></pre> \u4f8b\u9898 hdu2973 <p>Problem - 2973</p> <p>\u5f53 \\(3k+7\\) \u662f\u8d28\u6570\u65f6, \u53ef\u4ee5\u7531\u5a01\u5c14\u900a\u5b9a\u7406\u5f97\u5230 \\(f(i)=1\\) \u5f53 \\(3k+7\\) \u4e0d\u662f\u8d28\u6570\u65f6, \u53ef\u4ee5\u5316\u7b80\u4e3a \\(f(i)=0\\)</p>"},{"location":"Template/Math/NumberTheory/Default/#_8","title":"\u79ef\u6027\u51fd\u6570","text":"<p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1\\)\uff0c\u4e14 \\(\\gcd(x,y)=1\\)\uff0c\\(f(x*y)=f(x)*f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u79ef\u6027\u51fd\u6570\u3002</p> <p>\u82e5\u51fd\u6570 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1\\)\uff0c\u4e14 \\(f(x*y)=f(x)*f(y)\\)\uff0c\u5219 \\(f(n)\\) \u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570</p> <p>\u82e5 \\(f(x)\\) \u548c \\(g(x)\\) \u5747\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219\u4ee5\u4e0b\u51fd\u6570\u4e5f\u4e3a\u79ef\u6027\u51fd\u6570\uff1a $$ h(x)=f(x_p)\\ h(x)=f^p(x)\\ h(x)=f(x)g(x)\\ h(x)=\\sum_{d|x}f(d)g(\\dfrac{x}{d})\\nonumber $$ \u8bbe \\(x=\\prod p_i^{k_i}\\)\uff0c\u82e5 \\(f(x)\\) \u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u5219 \\(f(x)=\\prod f(p_i^{k_i})\\)\uff0c\u82e5 \\(f(x)\\) \u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff0c\u5219 \\(f(x)=\\prod f(p_i)^{k_i}\\)\u3002</p>"},{"location":"Template/Math/NumberTheory/Default/#_9","title":"\u5e38\u89c1\u7684\u79ef\u6027\u51fd\u6570","text":"<p>\u5355\u4f4d\u51fd\u6570 \\(\\varepsilon(n)=[n=1]\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u6052\u7b49\u51fd\u6570 \\(id_k(n)=n^k\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u5e38\u6570\u51fd\u6570 \\(I(n)=1\\) (\u5b8c\u5168\u79ef\u6027)</p> <p>\u9664\u6570\u51fd\u6570 \\(\\sigma_k(n)=\\sum_{d|n}d^k\\) (\u79ef\u6027)\uff0c\\(\\sigma_0(n)=d(n)\\)</p> <p>\u6b27\u62c9\u51fd\u6570 \\(\\varphi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]\\) (\u79ef\u6027) </p> <p>\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570 \\(\\begin{equation}\\mu(n)=\\begin{cases}1&amp;&amp;n=1\\\\{(-1)}^r&amp;&amp;n=p_1*p_2*\u2026p_r(\\text{\u65e0\u5e73\u65b9\u56e0\u6570})\\\\0&amp;&amp;else\\end{cases}\\nonumber\\end{equation}\\) (\u79ef\u6027\u548c\u52a0\u6027) </p>"},{"location":"Template/Math/NumberTheory/Default/#_10","title":"\u72c4\u5229\u514b\u96f7\u5377\u79ef","text":"\\[ \\nonumber(f*g)(n)=\\sum_{i*j=n}f(i)*g(j)=\\sum_{d|n}f(d)\\cdot{g(\\frac{n}{d})} \\] <p>\u6ee1\u8db3\u4ea4\u6362\u5f8b\uff0c\u7ed3\u5408\u5f8b\uff0c\u5206\u914d\u5f8b $$ \\begin{gather} \\nonumber id_k\\ast I=\\sigma_k\\ \\nonumber \\varphi\\ast I=Id_0\\ \\nonumber \\mu\\ast I=\\varepsilon\\ \\nonumber \\mu\\ast id_0=\\phi \\end{gather} $$</p>"},{"location":"Template/Math/NumberTheory/EulerTotientFunction/","title":"\u6b27\u62c9\u51fd\u6570","text":""},{"location":"Template/Math/NumberTheory/EulerTotientFunction/#_2","title":"\u5b9a\u4e49","text":"<p>\\(\\phi(n)=\\sum^n_{i=1}[\\gcd(i,n)==1]\\)</p>"},{"location":"Template/Math/NumberTheory/EulerTotientFunction/#_3","title":"\u5b9a\u7406","text":"<p>\u2460 \u82e5 \\(\\gcd(p,q)=1\\) \u5219 \\(\\phi(p\\cdot{q})=\\phi(p)\\cdot\\phi(q)\\)</p> <p>\u2461 \\(n\\) \u4e3a\u6b63\u6574\u6570 \u6709 \\(n=\\sum_{d|n}\\phi(d)\\)</p> <p>\u2462 \\(n=p_1^{a_1}\\cdot p_2^{a_2}\\cdot\u2026\\cdot p_s^{a_s}\\) \u662f\u6b63\u6574\u6570 \\(n\\) \u7684\u8d28\u5e42\u56e0\u5b50\u5206\u89e3 \u5219</p> \\[ \\begin{align} \\phi(n)&amp;=n\\cdot(1-\\frac{1}{p_1})\\cdot(1-\\frac{1}{p_2})\\cdot\u2026\\cdot(1-\\frac{1}{p_s})\\\\ &amp;=n\\cdot\\prod_{i=1}^s(1-\\frac{1}{p_i}) \\end{align} \\]"},{"location":"Template/Math/NumberTheory/EulerTotientFunction/#_4","title":"\u6c42\u6b27\u62c9\u51fd\u6570","text":"\u6a21\u7248 \u66b4\u529b\\(O(\\sqrt n)\\)\u6b27\u62c9\u7b5b \\(O(n)\\) C++<pre><code>int euler_phi(int n) {\n    int ans = n;\n    for (int i = 2 ; i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\n</code></pre> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime, phi;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        phi.resize(n);\n        phi[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"Template/Math/NumberTheory/InverseModulo/","title":"\u9006\u5143","text":""},{"location":"Template/Math/NumberTheory/InverseModulo/#_2","title":"\u7ebf\u6027\u9012\u63a8\u516c\u5f0f","text":"\\[ \\nonumber inv(i)=(p-\\dfrac{p}{i})*inv(p\\ mod\\ i)\\ mod\\ p \\]"},{"location":"Template/Math/NumberTheory/InverseModulo/#_3","title":"\u5feb\u901f\u9006\u5143","text":"\u6a21\u7248 \u5e38\u6570\u5c0f, \u67e5\u8be2\u8f83\u6162\u5e38\u6570\u5927\uff0c\u67e5\u8be2\u5feb <p>#110. \u4e58\u6cd5\u9006\u5143 - LibreOJ</p> \u4ee3\u7801 C++<pre><code>struct Inverse {\n    int B, B2, mod;\n    vector&lt;int&gt; inv, pre, suf;\n    vector&lt;pair&lt;int, int&gt;&gt; s;\n    Inverse() = default;\n    Inverse(int mod) : mod(mod) {\n        B = pow(mod, 0.3333333333);\n        B2 = B * B;\n        inv.resize(mod / B + 1);\n        inv[1] = 1;\n        for (int i = 2, j = mod / B ; i &lt;= j ; i++) {\n            inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n        }\n        s.resize(B2 + 1);\n        pre.resize(B2 + 1);\n        suf.resize(B2 + 1);\n        s[0] = {0, 1};\n        s[B2] = {1, 1};\n        pre[B2] = suf[B2] = B2;\n        for (int i = 2 ; i &lt;= B ; i++) {\n            for (int j = 1 ; j &lt; i ; j++) {\n                int pos = 1LL * j * B2 / i;\n                if (pre[pos]) continue;\n                pre[pos] = suf[pos] = pos;\n                s[pos] = {j, i};\n            }\n        }\n        for (int i = 1 ; i &lt;= B2 ; i++) {\n            if (pre[i] == 0) {\n                pre[i] = pre[i - 1];\n            }\n        }\n        for (int i = B2 ; i &gt; 0 ; i--) {\n            if (suf[i] == 0) {\n                suf[i] = suf[i + 1];\n            }\n        }\n    }\n    int calc(int T, pair&lt;int, int&gt; x) {\n        long long pos = 1LL * T * x.second;\n        if (llabs(pos - 1LL * mod * x.first) &gt; mod / B) return -1;\n        pos %= mod;\n        if (pos &lt;= mod / B) return 1LL * x.second * inv[pos] % mod;\n        return mod - 1LL * x.second * inv[mod - pos] % mod;\n    }\n    int operator()(int x) {\n        x %= mod;\n        if (x &lt;= mod / B) return inv[x];\n        int pos = 1LL * x * B2 / mod, res = calc(x, s[pre[pos]]);\n        if (res == -1) res = calc(x, s[suf[pos]]);\n        return res;\n    }\n}; // Inverse\n</code></pre> <p>\u5728\u7ebf O(1) \u9006\u5143 - Problem - QOJ.ac</p> \u4ee3\u7801 C++<pre><code>const int B = 1 &lt;&lt; 10, T = 1 &lt;&lt; 20;\nstruct Inverse {\n    int mod;\n    int f[T + 1], p[T + 1], buf[T * 3 + 3], *I = buf + T;\n    Inverse(int mod) : mod(mod) {\n        for (int i = 1 ; i &lt;= B ; i++) {\n            int s = 0, d = i &lt;&lt; 10;\n            for (int j = 1 ; j &lt;= T ; j++) {\n                if ((s += d) &gt;= mod) s -= mod;\n                if (s &lt;= T) {\n                    if (f[j] == 0) {\n                        f[j] = i;\n                        p[j] = s;\n                    }\n                } else if (s &gt;= mod - T) {\n                    if (f[j] == 0) {\n                        f[j] = i;\n                        p[j] = s - mod;\n                    }\n                } else {\n                    int t = (mod - T - s - 1) / d;\n                    s += t * d;\n                    j += t;\n                }\n            }\n        }\n        I[1] = f[0] = 1;\n        for (int i = 2 ; i &lt;= T &lt;&lt; 1 ; i++) {\n            I[i] = 1LL * (mod - mod / i) * I[mod % i] % mod;\n        }\n        for (int i = -1 ; i &gt;= -T ; i--) {\n            I[i] = mod - I[-i];\n        }\n    }\n    int operator()(int x) {\n        return 1LL * I[p[x &gt;&gt; 10] + (x &amp; 1023) * f[x &gt;&gt; 10]] * f[x &gt;&gt; 10] % mod;\n    }\n}; // Inverse\n</code></pre>"},{"location":"Template/Math/NumberTheory/LightSpeedPow/","title":"\u5149\u901f\u5e42","text":"\u6a21\u7248 C++<pre><code>struct LightSpeedPow {\n    int mod, a, B, phi;\n    vector&lt;array&lt;int, 2&gt;&gt; lsp;\n    LightSpeedPow() = default;\n    LightSpeedPow(int a, int mod) : a(a), mod(mod) {\n        B = pow(mod, 0.5);\n        lsp.resize(B + 1);\n        lsp[0] = {1, 1};\n        for (int i = 1 ; i &lt;= B ; i++) {\n            lsp[i][0] = 1LL * lsp[i - 1][0] * a % mod;\n        }\n        for (int i = 1 ; i &lt;= B ; i++) {\n            lsp[i][1] = 1LL * lsp[i - 1][1] * lsp[B][0] % mod;\n        }\n        phi = mod;\n        int x = mod;\n        for(int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n            if (x % i == 0) {\n                phi = phi / i * (i - 1);\n                while (x % i == 0) x /= i;\n            }\n        }\n        if (x != 1) phi = phi / x * (x - 1);\n    }\n    int operator()(int b) {\n        if (b &gt; phi) b %= phi;\n        return 1LL * lsp[b % B][0] * lsp[b / B][1] %mod;\n    }\n}; // LightSpeedPow\n</code></pre>"},{"location":"Template/Math/NumberTheory/Linear-equation/","title":"\u540c\u4f59","text":"<p>\u57fa\u672c\u5b9a\u4e49 \\(a\\ \\%\\ m=b\\ \\%\\ m\\)\uff0c\u540c\u4f59\u5f0f\u4e3a \\(a\\equiv{b}\\pmod{m}\\)</p>"},{"location":"Template/Math/NumberTheory/Linear-equation/#_2","title":"\u57fa\u672c\u5b9a\u7406","text":"<ol> <li>\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5f53\u4e14\u4ec5\u5f53 \\(m\\ |\\ (a-b)\\)</li> <li>\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6574\u6570 \\(k\\)\uff0c\u4f7f\u5f97 \\(a=b+k\\cdot{m}\\)</li> <li> <p>\u540c\u4f59\u5173\u7cfb\u662f\u7b49\u4ef7\u5173\u7cfb</p> <p>\u81ea\u53cd\uff1a\\(a\\equiv{a}\\pmod{m}\\)</p> <p>\u5bf9\u79f0\u6027\uff1a\\(a\\equiv{b}\\pmod{m}\\)\uff0c\u5219 \\(b\\equiv{a}\\pmod{m}\\)</p> <p>\u4f20\u9012\u6027\uff1a\\(a\\equiv{b}\\pmod{m},b\\equiv{c}\\pmod{m}\\)\uff0c\u5219 \\(a\\equiv{c}\\pmod{m}\\)</p> </li> <li> <p>\u82e5 \\(a\\equiv{b}\\pmod{m},c\\equiv{d}\\pmod{m}\\)\uff0c\u5219</p> </li> </ol> <p>1</p>"},{"location":"Template/Math/NumberTheory/Linear-equation/#_3","title":"\u7ed3\u8bba","text":"<p>\uff081\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n^2\\) \u6a21 \\(3\\) \u6216 \\(4\\) \u7684\u7ed3\u679c\u53ea\u80fd\u662f \\(0\\) \u6216 \\(1\\) </p> <p>\uff082\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n^2\\) \u6a21 \\(8\\) \u7684\u7ed3\u679c\u53ea\u80fd\u662f\\(0\\)\u3001\\(1\\) \u6216 \\(4\\)</p> <p>\uff083\uff09\u5bf9\u4efb\u610f\u6574\u6570 \\(n\\) , \\(n\\) \u4e0e \\(n\\) \u5404\u6570\u4f4d\u4e0a\u7684\u6570\u5b57\u4e4b\u548c\u6a21 \\(9\\) \u540c\u4f59</p>"},{"location":"Template/Math/NumberTheory/Linear-equation/#_4","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; T Exgcd(const T a, const T b, T &amp;x, T &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    T d = Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/Linear-equation/#_5","title":"\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b","text":"<p>\\(a*x\\equiv b\\pmod n\\)</p> \u9006\u5143\u6c42\u89e3\u6269\u6b27\u6c42\u89e3 \\[ \\begin{gather} a\\cdot{x}\\equiv{b}\\pmod{n}\\\\ x\\equiv{b}\\cdot{a}^{-1}\\pmod{n} \\nonumber \\end{gather} \\] <p>\u5f53 \\(a\\) \u5728\u6a21 \\(n\\) \u4e0b\u6709\u9006\u5143\u65f6, \u6709\u89e3\u3002</p> <p>\u5f53 \\(\\gcd(a,n)=1\\) \u65f6\uff0c\u4e00\u5b9a\u5b58\u5728\u9006\u5143\u3002\u5426\u5219\u4ee4 \\(g=\\gcd(a,n)\\)</p> <p>\u5f53 \\(g\\ |\\ b\\) \u65f6\uff0c\u65b9\u7a0b\u53ef\u4ee5\u5316\u7b80\u4e3a</p> \\[ \\begin{gather} \\dfrac{a}{g}*x_0\\equiv\\dfrac{b}{g}\\pmod{\\dfrac{n}{g}}\\\\ x_0=\\dfrac{b}{g}*{(\\dfrac{a}{g})}^{-1}\\pmod{\\dfrac{n}{g}}\\\\ x_1=(x_0+k*\\dfrac{n}{g})\\pmod n \\nonumber \\end{gather} \\] \\[ \\begin{gather} a\\cdot{x}\\equiv{b}\\pmod{n}\\\\ a\\cdot{x}+n\\cdot{y}=b\\pmod{n}     \\nonumber \\end{gather} \\] <p>\u4f7f\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51fa \\(x_0,y_0\\)</p> \\[ \\begin{gather} a\\cdot{x}_0+n\\cdot{y}_0=\\gcd(a,n)\\\\ a\\cdot\\dfrac{x_0}{\\gcd(a,n)}+n\\cdot\\dfrac{y_0}{\\gcd(a,n)}=1\\\\ a\\cdot\\dfrac{x_0\\cdot{b}}{\\gcd(a,n)}+n\\cdot\\dfrac{y_0\\cdot{b}}{\\gcd(a,n)}=b\\\\ x_1=\\frac{x_0\\cdot{b}}{\\gcd(a,n)}\\\\ y_1=\\frac{y_0\\cdot{b}}{\\gcd(a,n)}\\\\ x=x_1+k\\cdot\\frac{n}{\\gcd(a,n)}\\\\ y=y_1-k\\cdot\\frac{a}{\\gcd(a,n)} \\end{gather} \\]"},{"location":"Template/Math/NumberTheory/Meissel-Lehmer%E7%AE%97%E6%B3%95/","title":"Meissel-Lehmer\u7b97\u6cd5","text":"<p>P7884 \u3010\u6a21\u677f\u3011Meissel\u2013Lehmer \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>#6235. \u533a\u95f4\u7d20\u6570\u4e2a\u6570 - LibreOJ</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long Meissel_Lehmer(const long long n) {\n    if (n &lt;= 1) {\n        return 0LL;\n    }\n    if (n &lt;= 2) {\n        return 1LL;\n    }\n    const long long v = sqrtl(n);\n    int s = (v + 1) &gt;&gt; 1;\n    vector&lt;int&gt; smalls(s), roughs(s);\n    vector&lt;long long&gt; larges(s);\n    for (int i = 0 ; i &lt; s ; i++) {\n        smalls[i] = i;\n    }\n    for (int i = 0 ; i &lt; s ; i++) {\n        roughs[i] = i &lt;&lt; 1 | 1;\n    }\n    for (int i = 0 ; i &lt; s ; i++) {\n        larges[i] = (n / (i &lt;&lt; 1 | 1) - 1) &gt;&gt; 1;\n    }\n    vector&lt;bool&gt; skip(v + 1);\n    const auto div = [](long long a, long long b) {\n        return 1.0 * a / b;\n    };\n    const auto half = [](int n) {\n        return (n - 1) &gt;&gt; 1;\n    };\n    int pc = 0;\n    for (int p = 3 ; p &lt;= v ; p += 2) {\n        if (!skip[p]) {\n            int q = p * p;\n            if (1LL * q * q &gt; n) {\n                break;\n            }\n            skip[p] = true;\n            for (int i = q ; i &lt;= v ; i += 2 * p) {\n                skip[i] = true;\n            }\n            int ns = 0;\n            for (int k = 0 ; k &lt; s ; k++) {\n                int i = roughs[k];\n                if (skip[i]) {\n                    continue;\n                }\n                long long d = 1LL * i * p;\n                larges[ns] = larges[k] - (d &lt;= v ? larges[smalls[d &gt;&gt; 1] - pc] : smalls[half(div(n, d))]) + pc;\n                roughs[ns++] = i;\n            }\n            s = ns;\n            for (int i = half(v), j = ((v / p) - 1) | 1 ; j &gt;= p ; j -= 2) {\n                int c = smalls[j &gt;&gt; 1] - pc;\n                for (int e = (j * p) &gt;&gt; 1 ; i &gt;= e ; i--) {\n                    smalls[i] -= c;\n                }\n            }\n            pc++;\n        }\n    }\n    larges[0] += 1LL * (s + 2 * (pc - 1)) * (s - 1) &gt;&gt; 1;\n    for (int k = 1 ; k &lt; s ; k++) {\n        larges[0] -= larges[k];\n    }\n    for (int L = 1 ; L &lt; s ; L++) {\n        int q = roughs[L];\n        long long m = n / q;\n        int e = smalls[half(m / q)] - pc;\n        if (e &lt; L + 1) {\n            break;\n        }\n        long long t = 0;\n        for (int k = L + 1 ; k &lt;= e ; k++) {\n            t += smalls[half(div(m, roughs[k]))];\n        }\n        larges[0] += t - 1LL * (e - L) * (pc + L - 1);\n    }\n    return larges[0] + 1;\n}\nint main() {\n    long long n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; Meissel_Lehmer(n);\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/PrimaryRoot/","title":"\u539f\u6839","text":"\u6a21\u7248 \u6700\u5c0f\u539f\u6839\u6240\u6709\u539f\u6839 C++<pre><code>long long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint euler_phi(int n) {\n    int ans = n;\n    for (int i = 2 ; i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n * (n - 1);\n    }\n    return ans;\n}\nvector&lt;int&gt; get_factors(int x) {\n    vector&lt;int&gt; res;\n    for (int i = 1 ; i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            res.emplace_back(i);\n            if (x != i * i) {\n                res.emplace_back(x / i);\n            }\n        }\n    }\n    return res;\n}\nint get_min_root(int x) {\n    int phi = euler_phi(x);\n    for (int i = 1 ; ; i++) {\n        if (__gcd(i, x) != 1) {\n            continue;\n        }\n        auto factors = get_factors(phi);\n        bool flag = true;\n        for (auto &amp;e : factors) {\n            if (e != phi &amp;&amp; qpow(i, e, x) == 1) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) return i;\n    }\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nnamespace EulerSieve {\n    vector&lt;int&gt; prime, phi;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        phi.resize(n);\n        phi[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    phi[i * x] = phi[i] * x;\n                    break;\n                }\n                phi[i * x] = phi[i] * phi[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\nconst int N = 1000005;\nusing EulerSieve::primeInit;\nusing EulerSieve::phi;\nusing EulerSieve::prime;\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nbool exist[N + 100];\nvoid init_exist() {\n    exist[2] = exist[4] = true;\n    int len = prime.size();\n    for (int i = 1 ; i &lt; len ; i++) {\n        for (long long j = prime[i] ; j &lt;= N ; j *= prime[i]) {\n            exist[j] = true;\n            if (j * 2 &lt;= N) {\n                exist[j * 2] = true;\n            }\n        }\n    }\n}\nvector&lt;int&gt; get_factors(int x) {\n    vector&lt;int&gt; res;\n    for (int i = 1 ; i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            res.emplace_back(i);\n            if (x != i * i) {\n                res.emplace_back(x / i);\n            }\n        }\n    }\n    return res;\n}\nvector&lt;int&gt; get_primative_roots(int m) {\n    if (!exist[m]) return {};\n    int phis = phi[m], fst;\n    auto factors = get_factors(phis);\n    for (int i = 1 ; ; i++) {\n        if (__gcd(i, m) != 1) {\n            continue;\n        }\n        bool flag = true;\n        for (auto &amp;e : factors) {\n            if (e != phis &amp;&amp; qpow(i, e, m) == 1) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            fst = i;\n            break;\n        }\n    }\n    int cur = fst;\n    vector&lt;int&gt; res;\n    for (int i = 1 ; i &lt;= phis ; i++) {\n        if (__gcd(phis, i) == 1) {\n            res.emplace_back(cur);\n        }\n        cur = cur * fst % m;\n    }\n    return res;\n}\nvoid solve() {\n    int n, d;\n    cin &gt;&gt; n &gt;&gt; d;\n    auto res = get_primative_roots(n);\n    sort(begin(res), end(res));\n    cout &lt;&lt; res.size() &lt;&lt; \"\\n\";\n    for (int i = d ; i &lt;= (int(res.size()) / d) * d ; i += d) {\n        if (i - 1 &gt;= 0 &amp;&amp; i - 1 &lt; res.size())\n        cout &lt;&lt; res[i - 1] &lt;&lt; \" \";\n        else\n        cout &lt;&lt; 0 &lt;&lt; \" \";\n    }\n    cout &lt;&lt; \"\\n\";\n}\nint main() {\n    primeInit(N);\n    init_exist();\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P6091 <p>P6091 \u3010\u6a21\u677f\u3011\u539f\u6839 - \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/Prime/","title":"\u7d20\u6570","text":""},{"location":"Template/Math/NumberTheory/Prime/#_2","title":"\u7d20\u6570\u5b9a\u7406","text":"<p>\\(\\pi(x)\\) \u4e3a \\([1,x]\\) \u4e2d\u7684\u7d20\u6570\u4e2a\u6570</p> <p>\u968f\u7740 \\(x\\) \u7684\u589e\u957f \\(\\dfrac{\\pi(x)}{\\frac{x}{\\ln(x)}}=1\\)</p>"},{"location":"Template/Math/NumberTheory/Prime/#_3","title":"\u57fa\u672c\u5b9a\u7406","text":"<p>\\(n=p_1^{\\alpha_1}*p_2^{\\alpha_2}*...*p_k^{\\alpha_k}\\)</p> <p>\u7ea6\u6570\u4e2a\u6570 \\(d(n)=(\\alpha_1+1)*(\\alpha_2+1)*...*(\\alpha_k+1)\\)</p> <p>\u7ea6\u6570\u4e4b\u548c \\(\\phi(n)=\\dfrac{p_1^{\\alpha_1+1}-1}{p_1-1}*\\dfrac{p_k^{\\alpha_k+1}-1}{p_k-1}*...*\\dfrac{p_k^{\\alpha_k+1}-1}{p_k-1}\\)</p> <p>\\(n!\\) \u56e0\u5b50 \\(p\\) \u7684\u6570\u91cf\u4e3a \\(\\lfloor\\dfrac{n}{p^1}\\rfloor+\\lfloor\\dfrac{n}{p^2}\\rfloor+...+\\lfloor\\dfrac{n}{p^{+\\infty}}\\rfloor\\)</p>"},{"location":"Template/Math/NumberTheory/Prime/#_4","title":"\u7d20\u6570\u5224\u65ad","text":"Miller_Rabin - \\(O(k\\log{n}^2)\\) C++<pre><code>namespace Miller_Rabin {\n    long long qpow(long long a, long long b, long long mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = (__int128) res * a % mod;\n            b &gt;&gt;= 1;\n            a = (__int128) a * a % mod;\n        }\n        return res;\n    }\n    bool Miller_Rabin(long long n, const vector&lt;long long&gt; &amp;as) {\n        long long d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        long long e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            long long t = d;\n            long long y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = (__int128) y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(long long n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\n</code></pre>"},{"location":"Template/Math/NumberTheory/Prime/#_5","title":"\u6885\u68ee\u7d20\u6570","text":"<p>\u5982\u679c \\(m\\) \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u4e14 \\(2^m-1\\) \u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5219 \\(m\\) \u662f\u7d20\u6570\u3002\u53cd\u4e4b\uff0c\u5982\u679c \\(m\\) \u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u7d20\u6570\u4e14 \\(M_m=2^m-1\\)\u79f0\u4f5c\u4e3a\u7b2c \\(m\\) \u4e2a\u6885\u68ee\u6570\uff1b\u5982\u679c \\(p\\) \u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5e76\u4e14 \\(M_p=2^p-1\\) \u4e5f\u662f\u4e00\u4e2a\u7d20\u6570\uff0c\u5219 \\(M_p\\) \u6210\u4e3a\u6885\u68ee\u7d20\u6570\u3002</p> \u6d1b\u8c37U313346 <p>U313346 \u3010\u6a21\u677f\u3011Lucas-Lehmer - \u6d1b\u8c37</p> C++<pre><code>long long datas[64];\nbool Lucas_Lehmer(int p) {\n    if (p == 2) {\n        return true;\n    }\n    datas[1] = 4;\n    long long mod = (1LL &lt;&lt; p) - 1;\n    for (int i = 2 ; i &lt;= p - 1 ; i++) {\n        datas[i] = (((__int128)datas[i - 1] * datas[i - 1] % mod) - 2) % mod;\n    }\n    return datas[p - 1] == 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/PrimeFactorization/","title":"\u8d28\u56e0\u6570\u5206\u89e3","text":"\u6a21\u7248 \u66b4\u529b \\(O(n\\sqrt n)\\)Pollard_rho \\(O(n^{\\frac{1}{4}}\\log{n})\\) C++<pre><code>vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long x) {\n    vector&lt;pair&lt;long long, int&gt;&gt; res;\n    for (int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            int cnt = 0;\n            while (x % i == 0) {\n                x /= i;\n                cnt++;\n            }\n            res.emplace_back(i, cnt);\n        }\n    }\n    if (x &gt; 1) {\n        res.emplace_back(x, 1);\n    }\n    return res;\n}\n</code></pre> C++<pre><code>namespace Miller_Rabin {\n    long long qpow(long long a, long long b, long long mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = (__int128) res * a % mod;\n            b &gt;&gt;= 1;\n            a = (__int128) a * a % mod;\n        }\n        return res;\n    }\n    bool Miller_Rabin(long long n, const vector&lt;long long&gt; &amp;as) {\n        long long d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        long long e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            long long t = d;\n            long long y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = (__int128) y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(long long n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nnamespace Pollard_rho {\n    template&lt;class T&gt; struct Random {\n        mt19937 mt;\n        Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n        T operator()(T L, T R) {\n            uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n            return dist(mt);\n        }\n    };\n    Random&lt;long long&gt; rng;\n    long long get(long long n) {\n        if (n % 2 == 0) {\n            return 2;\n        }\n        if (Miller_Rabin::is_prime(n)) {\n            return n;\n        }\n        long long R;\n        auto f = [&amp;](long long x) {\n            return ((__int128) x * x + R) % n;\n        };\n        while (true) {\n            long long x, y, ys, q = 1;\n            R = rng(2, n - 1), y = rng(2, n - 1);\n            long long g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r *= 2) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        q = (__int128) q * ((x - (y = f(y)) + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    g = __gcd((x - (ys = f(ys)) + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;long long&gt; factorize(long long n) {\n        if (n &lt;= 1) {\n            return {};\n        }\n        long long p = get(n);\n        if (p == n) {\n            return {n};\n        }\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;long long, int&gt;&gt; res;\n        for (auto &amp;e : ps) {\n            if (!res.empty() &amp;&amp; res.back().first == e) {\n                res.back().second++;\n            } else {\n                res.emplace_back(e, 1);\n            }\n        }\n        return res;\n    }\n    vector&lt;long long&gt; divisors(long long n) {\n        auto ps = prime_factor(n);\n        int cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            cnt *= t + 1;\n        }\n        vector&lt;long long&gt; res(cnt, 1);\n        cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            long long pw = 1;\n            for (int i = 1 ; i &lt;= t ; i++) {\n                pw *= p;\n                for (int j = 0 ; j &lt; cnt ; j++) {\n                    res[cnt * i + j] = res[j] * pw;\n                }\n            }\n            cnt *= t + 1;\n        }\n        return res;\n    }\n} // Pollard_rho\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u8d28\u6570\nusing Pollard_rho::prime_factor; // \u6240\u6709\u8d28\u56e0\u5b50 (\u8d28\u56e0\u5b50, \u4e2a\u6570)\nusing Pollard_rho::divisors; // \u6240\u6709\u56e0\u5b50\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3715\u6d1b\u8c37P4718 <p>B3715 \u5206\u89e3\u8d28\u56e0\u5b50 2 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{12}\\)</p> <p>P4718 \u3010\u6a21\u677f\u3011Pollard rho \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{18}\\)</p>"},{"location":"Template/Math/NumberTheory/Sieve/","title":"\u7b5b\u6cd5","text":""},{"location":"Template/Math/NumberTheory/Sieve/#_2","title":"\u6b27\u62c9\u7b5b","text":"\u6a21\u7248 usageboolint <p>bool: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f \u82e5 vis[x] \u4e3a true, \u5219 x \u4e0d\u662f\u8d28\u6570, \u5426\u5219 x \u662f\u8d28\u6570.</p> <p>int: vis \u6570\u7ec4\u7684\u542b\u4e49\u662f vis[x] \u4e3a x \u7684\u4e00\u4e2a\u8d28\u56e0\u5b50, vis[x] \u4e0e x \u76f8\u7b49\u65f6, x \u662f\u8d28\u6570 (1\u9664\u5916).</p> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = 1;\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                vis[i] = i;\n                prime.emplace_back(i);\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = i;\n                if (i % x == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3383 <p>P3383 \u3010\u6a21\u677f\u3011\u7ebf\u6027\u7b5b\u7d20\u6570 - \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/Sieve/#_3","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570","text":"<p>\\(d(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570</p> <p>\\(num(i)\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u4e2a\u6570</p> <p>\u7531\u4e8e \\(n=\\prod_i p_i^{a_i}\\)\uff0c\u5219\u6709 \\(d(n)=\\prod_i(a_i+1)\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(d(i)=2\uff0cnum(i)=1\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(d(i*x)=d(i)*d(x)\uff0cnum(i*x)=1\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(num(i*x)=num(i)+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(d(i)=(a_1+1)\\prod_{i=2}(a_i+1)\\)\uff0c\\(d(i*x)=(a_1+1+1)\\prod_{i=2}(a_i+1)\\)    \u6240\u4ee5 \\(d(i*x)=\\dfrac{d(i)}{(a_1+1)}(a_1+1+1)=\\dfrac{d(i)}{num(i)+1}(num(i*x)+1)=\\dfrac{d(i)}{num(i*x)}(num(i*x)+1)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime, d, num;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        d.resize(n);\n        d[1] = 1;\n        num.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                d[i] = 2;\n                num[i] = 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    num[i * x] = num[i] + 1;\n                    d[i * x] = d[i] / num[i * x] * (num[i * x] + 1);\n                    break;\n                }\n                num[i * x] = 1;\n                d[i * x] = d[i] * 2;\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"Template/Math/NumberTheory/Sieve/#_4","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c","text":"<p>\\(sd(i)\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c</p> <p>\\(sp(i)\\) \u8868\u793a\u9996\u9879\u4e3a \\(1\\)\uff0c\u516c\u6bd4\u4e3a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u7684\u7b49\u6bd4\u6570\u5217\u7684\u548c</p> <p>\\(n=\\prod_ip_i^{a_i}\\)</p> <p>\\(sd(n)=(1+p_1+p_1^2+...+p_1^{a_1})(1+p_2+p_2^2+...+p_2^{a_2})...(1+p_k+p_k^2+...+p_k^{a_k})\\)</p> <p>\u6839\u636e\u6b27\u62c9\u7b5b\u6709\u4e09\u79cd\u60c5\u51b5</p> <ol> <li>\\(i\\) \u4e3a\u8d28\u6570\uff1a    \u6b64\u65f6\u6613\u77e5 \\(sd(i)=1+i\uff0csp(i)=1+i\\)\u3002</li> <li>\\(i\\) \u4e0d\u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6 \\(\\gcd(i,x)=1\\)\uff0c\u5373 \\(sd(i*x)=sd(i)*sd(x)\uff0csp(i*x)=1+x\\)\u3002</li> <li>\\(i\\) \u88ab \\(x\\) \u6574\u9664\uff1a    \u6b64\u65f6\u53ef\u4ee5\u77e5\u9053 \\(x\\) \u4e3a \\(i*x\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u53ef\u5f97 \\(sp(i*x)=sp(i)*x+1\\)\u3002    \u7136\u540e\u56e0\u4e3a \\(sd(i)=(1+p_1+p_1^2+...+p_1^{a_1})\\prod\\)\uff0c\\(sd(i*x)=(1+p_1+p_1^2+...+p_1^{a_1}+p_1^{a_1+1})\\prod\\)    \u6240\u4ee5 \\(sd(i*x)=\\dfrac{sd(i)}{sp(i)}sp(i*x)\\)</li> </ol> \u6a21\u7248 C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;long long&gt; sd, sp;\n    vector&lt;bool&gt; vis;\n    void _EulerSieveInit(int n) {\n        n++;\n        vis.resize(n);\n        vis[1] = true;\n        sd.resize(n);\n        sd[1] = 1;\n        sp.resize(n);\n        for (int i = 2 ; i &lt; n ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                sd[i] = sp[i] = i + 1;\n            }\n            for (auto &amp;x : prime) {\n                if (1LL * i * x &gt;= n) break;\n                vis[i * x] = true;\n                if (i % x == 0) {\n                    sp[i * x] = sp[i] * x + 1;\n                    sd[i * x] = sd[i] / sp[i] * sp[i * x];\n                    break;\n                }\n                sp[i * x] = 1 + x;\n                sd[i * x] = sd[i] * sd[x];\n            }\n        }\n    }\n    void primeInit(int n) {\n        _EulerSieveInit(n);\n    }\n} // EulerSieve\nusing namespace EulerSieve;\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"<p>P1495 \u3010\u6a21\u677f\u3011\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08CRT\uff09/ \u66f9\u51b2\u517b\u732a - \u6d1b\u8c37</p> <p>P4777 \u3010\u6a21\u677f\u3011\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08EXCRT\uff09- \u6d1b\u8c37</p> \\[ \\begin{cases} x&amp;\\equiv a_1\\pmod{n_1}\\\\x&amp;\\equiv a_2\\pmod{n_2}\\\\&amp;\\vdots\\\\x&amp;\\equiv a_k\\pmod{n_k} \\end{cases} \\] \\[ \\begin{gather} m_i=\\frac{n}{n_i}\\\\c_i=m_i\\cdot{m_i}^{-1}\\pmod{n}\\\\x=\\sum_{i=1}^ka_i\\cdot{c_i}\\pmod{n} \\end{gather} \\] Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvoid Exgcd(const long long a, const long long b, long long &amp;x, long long &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\nlong long CRT(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;p) {\n    long long n = 1, ans = 0;\n    int len = a.size();\n    for (int i = 0 ; i &lt; len ; i++) {\n        n *= p[i];\n    }\n    for (int i = 0 ; i &lt; len ; i++) {\n        const long long m = n / p[i];\n        long long x, y;\n        Exgcd(m, p[i], x, y);\n        ans = (ans + a[i] * m * x % n + n) % n;\n    }\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n), p(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; p[i] &gt;&gt; a[i];\n    }\n    cout &lt;&lt; CRT(a, p);\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/#_2","title":"\u62d3\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"<p>\u5141\u8bb8\u6a21\u6570\u4e0d\u4e92\u8d28</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long Exgcd(const long long a, const long long b, long long &amp;x, long long &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\nlong long ExCRT(const vector&lt;long long&gt; &amp;a, const vector&lt;long long&gt; &amp;p) {\n    long long n = p[0], ans = a[0];\n    int len = a.size();\n    for (int i = 1 ; i &lt; len ; i++) {\n        long long x, y;\n        long long c = (a[i] - ans % p[i] + p[i]) % p[i];\n        long long d = Exgcd(n, p[i], x, y);\n        if (c % d != 0) {\n            return -1LL;\n        }\n        long long g = p[i] / d;\n        x = (__int128) x * c / d % g;\n        ans += x * n;\n        n *= g;\n        ans = (ans % n + n) % n; \n    }\n    if (ans == 0) ans = n;\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;long long&gt; a(n), p(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; p[i] &gt;&gt; a[i];\n    }\n    cout &lt;&lt; ExCRT(a, p);\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/","title":"\u516c\u5f0f","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_i1ni2dfracncdotn1cdot2n16","title":"\\(\\sum_{i=1}^ni^2=\\dfrac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_i1ni3dfracncdotn122","title":"\\(\\sum_{i=1}^ni^3=[\\dfrac{n\\cdot(n+1)}{2}]^2\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_n1ksum_i1nvarphileftirightcdotlfloordfracnirfloor","title":"\\(\\sum_{n=1}^{k}\\sum_{i=1}^n\\varphi\\left(i\\right)\\cdot\\lfloor\\dfrac{n}{i}\\rfloor\\)","text":"<p>A-\u4f60\u4e5f\u559c\u6b22\u6570\u5b66\u5417_2023\u6cb3\u5357\u840c\u65b0\u8054\u8d5b\u7b2c\uff08\u4e00\uff09\u573a\uff1a\u6cb3\u5357\u519c\u4e1a\u5927\u5b66</p> \\[ \\begin{align} \\sum_{n=1}^{k}\\sum_{i=1}^n\\varphi\\left(i\\right)\\cdot\\lfloor\\dfrac{n}{i}\\rfloor&amp;=\\sum_{n=1}^{k}\\sum_{i=1}^n\\sum_{d|i}\\varphi\\left(d\\right)\\\\ &amp;=\\sum_{n=1}^k\\sum_{i=1}^ni\\\\ &amp;=\\sum_{n=1}^k\\dfrac{n\\cdot{(n+1)}}{2}\\\\ &amp;=\\dfrac{\\sum_{n=1}^kn^2+\\sum_{n=1}^ki}{2}\\\\ &amp;=\\dfrac{\\frac{k\\cdot(k+1)\\cdot(2\\cdot{k}+1)}{6}+\\frac{k\\cdot(k+1)}{2}}{2}\\\\ &amp;=\\dfrac{k\\cdot(k+1)\\cdot(k+2)}{6} \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_iabdbinomiddfracprod_ib-d1bidb-a1cdotprod_ia-da-1i","title":"\\(\\sum_{i=a}^{b}\\dbinom{i}{d}=\\dfrac{\\prod_{i=b-d+1}^bi!}{{d!}^{b-a+1}\\cdot\\prod_{i=a-d}^{a-1}i!}\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_x0minijdbinomixcdotdbinomjxdbinomiji","title":"\\(\\sum_{x=0}^{min(i,j)}\\dbinom{i}{x}\\cdot\\dbinom{j}{x}=\\dbinom{i+j}{i}\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#dxcdotysum_ixsum_jygcdij1","title":"\\(d(x\\cdot{y})=\\sum_{i|x}\\sum_{j|y}[\\gcd(i,j)=1]\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#fnintlimits_scriptsize-0scriptsize-1leftx-x2rightnmathrmdxsum_i0n-1ndfracc_nini1dfracn22n1","title":"\\(f(n)=\\int\\limits_{\\scriptsize 0}^{\\scriptsize 1}{\\left(x-x^{2}\\right)^{n}}{\\;\\mathrm{d}x}=\\sum_{i=0}^n(-1)^n\\dfrac{C_n^i}{n+i+1}=\\dfrac{(n!)^2}{(2n+1)!}\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#insum_j0ic_ijcdoticdots_2nj","title":"\\(i^n=\\sum_{j=0}^iC_i^j\\cdot{i!}\\cdot{}S_2(n,j)\\)","text":""},{"location":"Template/Math/NumberTheory/%E5%85%AC%E5%BC%8F/#sum_i1nc_nicdotiksum_j0k2n-jcdotfracnn-jcdots_2kj","title":"\\(\\sum_{i=1}^nC_n^i\\cdot{}i^k=\\sum_{j=0}^k2^{n-j}\\cdot{}\\frac{n!}{(n-j)!}\\cdot{}s_2(k,j)\\)","text":""},{"location":"Template/Math/NumberTheory/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/Math/NumberTheory/%E6%9D%82%E9%A2%98%281%29/#prod-n-k-oncdotlogn","title":"\u6c42 \\(\\prod {n!}\\) \u4e2d\u56e0\u5b50 \\(k\\) \u7684\u4e2a\u6570 - \\(O(n\\cdot\\log{n})\\)","text":"<p>P2388 \u9636\u4e58\u4e4b\u4e58 - \u6d1b\u8c37</p> Code C++<pre><code>long long solve(int n, int k) {\n    long long ans = 0;\n    long long num = k;\n    while (num &lt;= n) {\n        int z = n / num;\n        ans += num * z * (z - 1) / 2;\n        ans += z * (1 + n % num);\n        num *= k;\n    }\n    return ans;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E6%9D%82%E9%A2%98%281%29/#k","title":"\u7ea6\u6570\u4e2a\u6570\u4e3a k \u7684\u6700\u5c0f\u6570","text":"<p>Problem - E - Codeforces</p> Code C++<pre><code>vector&lt;int&gt; prime{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\nconst int N = prime.size();\nconst long long INF = 0x7fffffffffffffff;\nlong long dfs(int idx, unsigned long long sum, int num, int cnt) {\n    if (num &gt; cnt || idx == N) {\n        return INF;\n    }\n    if (num == cnt) {\n        return sum;\n    }\n    long long res = INF;\n    for (int i = 1 ; i &lt; 64 ; i++) {\n        if (sum * prime[idx] &gt; res) break;\n        res = min(res, dfs(idx + 1, sum *= prime[idx], num * (i + 1), cnt));\n    }\n    return res;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E6%9D%82%E9%A2%98%281%29/#sum_i1lfloorsqrtnrfloori2cdotslfloorfracnirfloor-snnc","title":"\\(\\sum_{i=1}^{\\lfloor\\sqrt{N}\\rfloor}i^2\\cdot{S(\\lfloor\\frac{N}{i}\\rfloor)}\\) S(n)\u4e3an\u4ee5\u4e3a\u8d28\u6570\u7684C\u6b21\u65b9\u548c","text":"<p>P5493 \u8d28\u6570\u524d\u7f00\u7edf\u8ba1 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long mod;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Larange {\n    const int N = 13;\n    long long fact[N], ifact[N], pre[N], suf[N], f[N];\n    int m;\n    void init(int C) {\n        m = C + 2;\n        fact[0] = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            fact[i] = fact[i - 1] * i % mod;\n            f[i] = (f[i - 1] + qpow(i, C)) % mod;\n        }\n        ifact[m] = qpow(fact[m], mod - 2);\n        for (int i = m - 1 ; i &gt;= 0 ; i--) {\n            ifact[i] = ifact[i + 1] * (i + 1) % mod;\n        }\n    }\n    long long get(long long v) {\n        if (v &lt;= m) return f[v];\n        v %= mod;\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            pre[i] = pre[i - 1] * (v - i) % mod;\n        }\n        suf[m + 1] = 1;\n        for (int i = m ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * (v - i) % mod;\n        }\n        long long res = 0;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            long long P = pre[i - 1] * suf[i + 1] % mod;\n            long long Q = ifact[i - 1] * ifact[m - i] % mod;\n            long long sign = ((m - i) &amp; 1 ? mod - 1 : 1);\n            res = (res + P * Q % mod * f[i] % mod * sign + mod) % mod;\n        }\n        return res;\n    }\n} // Larange\nlong long g0[200005], g1[200005];\nlong long add(long long x, long long y) {\n    return x + y &gt;= mod ? x + y - mod : x + y;\n}\nlong long sub(long long x, long long y) {\n    return x - y &lt; 0 ? x - y + mod : x - y;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    long long n;\n    int C;\n    cin &gt;&gt; n &gt;&gt; C &gt;&gt; mod;\n    long long sqr = sqrtl(n);\n    Larange::init(C);\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        g0[i] = sub(Larange::get(i), 1);\n        g1[i] = sub(Larange::get(n / i), 1);\n    }\n    for (int i = 2 ; i &lt;= sqr ; i++) {\n        if (g0[i] == g0[i - 1]) continue;\n        long long pc = qpow(i, C), pg = g0[i - 1];\n        long long L1 = sqr / i, L2 = min(n / i / i, sqr);\n        L1 = min(L1, L2);\n        for (int j = 1 ; j &lt;= L1 ; j++) {\n            g1[j] = sub(g1[j], pc * sub(g1[j * i], pg) % mod);\n        }\n        long long temp = n / i;\n        for (int j = L1 + 1 ; j &lt;= L2 ; j++) {\n            g1[j] = sub(g1[j], pc * sub(g0[temp / j], pg) % mod);\n        }\n        long long st = 1LL * i * i;\n        for (int j = sqr ; j &gt;= st ; j--) {\n            g0[j] = sub(g0[j], pc * sub(g0[j / i], pg) % mod);\n        }\n    }\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        ans = add(ans, g1[i] * i % mod * i % mod);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E6%9D%82%E9%A2%98%281%29/#m0a-b","title":"\u6c42\u6590\u6ce2\u90a3\u5951\u6a21m\u4e3a0\u7684\u9879\uff0ca, b \u4e0d\u5b9a","text":"<p>P7325 [WC2021] \u6590\u6ce2\u90a3\u5951 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvoid Exgcd(long long a, long long b, long long &amp;x, long long &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\nint inv(int a, int mod) {\n    long long x, y;\n    Exgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\nstruct Node {\n    int x, y, z;\n    Node() = default;\n    Node(int x, int y, int z) : x(x), y(y), z(z) {}\n    bool operator&lt;(const Node &amp;node) const {\n        if (x == node.x) {\n            if (y == node.y) {\n                return z &lt; node.z;\n            }\n            return y &lt; node.y;\n        }\n        return x &lt; node.x;\n    }\n};\nmap&lt;Node, int&gt; ans[100005];\nint n, m;\nint solve(int a, int b) {\n    if (a == 0) return 0;\n    if (b == 0) return 1;\n    int d = __gcd(__gcd(a, b), m);\n    int m1 = m / d;\n    a /= d;\n    b /= d;\n    int p = __gcd(a, m1), q = __gcd(b, m1), m2 = m1 / p / q;\n    a /= p;\n    b /= q;\n    int k = 1LL * a * inv(b, m2) % m2;\n    if (ans[m1].count(Node(k, q, p))) return ans[m1][Node(k, q, p)];\n    return -1;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int m1 = 2 ; m1 &lt;= m ; m1++) {\n        if (m % m1 == 0) {\n            int a = 0, b = 1;\n            for (int j = 0 ; ; j++) {\n                if (a &amp;&amp; b) {\n                    int p = __gcd(a, m1), q = __gcd(b, m1), m2 = m1 / p / q;\n                    int ta = a / p, tb = b / q;\n                    int k = 1LL * ta * inv(tb, m2) % m2;\n                    if (!ans[m1].count(Node(k, q, p))) {\n                        ans[m1][Node(k, q, p)] = j;\n                    }\n                }\n                int x1 = b;\n                b = a;\n                a = (x1 + a) % m1;\n                if (b == 1 &amp;&amp; a == 0) break;\n            }\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        a %= m;\n        b = (m - b % m) % m;\n        cout &lt;&lt; solve(a, b) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/","title":"\u675c\u6559\u7b5b","text":"<p>P4213 \u3010\u6a21\u677f\u3011\u675c\u6559\u7b5b\uff08Sum\uff09- \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/#_2","title":"\u89e3\u51b3\u95ee\u9898","text":"<p>\u8bbe \\(f(n)\\) \u662f\u4e00\u4e2a\u6570\u8bba\u51fd\u6570\uff0c\u8ba1\u7b97   \\(S(n)=\\sum_{i=1}^nf(i)\\)</p>"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/#_3","title":"\u516c\u5f0f","text":"\\[ g(1)\\cdot{S}(n)=\\sum_{i=1}^n(f\\ast{g})(i)-\\sum_{i=2}^ng(i)\\cdot{S}(\\lfloor\\frac{n}{i}\\rfloor) \\]"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/#_4","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u524d\u7f00\u548c","text":"\\[ \\begin{gather} \\text{\u4ee4: }g(n)=1(n)\\\\ \\text{\u5219: }f\\ast{g}=\\mu\\ast1=\\epsilon\\\\ \\end{gather} \\] \\[ \\begin{align} S(n)&amp;=\\sum_{i=1}^n\\epsilon(i)-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor)\\\\ &amp;=1-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor) \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/#_5","title":"\u6b27\u62c9\u51fd\u6570\u524d\u7f00\u548c","text":"\\[ \\begin{gather} \\text{\u4ee4: }g(n)=1(n)\\\\ \\text{\u5219: }f\\ast{g}=\\varphi\\ast1=Id_0\\\\ \\end{gather} \\] \\[ \\begin{align} S(n)&amp;=\\sum_{i=1}^nId_0(i)-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor)\\\\ &amp;=\\frac{n\\cdot(n+1)}{2}-\\sum_{i=2}^nS(\\lfloor\\frac{n}{i}\\rfloor) \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E6%9D%9C%E6%95%99%E7%AD%9B/#-onfrac34","title":"\u6a21\u677f - \\(O(n^\\frac{3}{4})\\)","text":"Code C++<pre><code>namespace DlsSieve {\n    int N;\n    vector&lt;int&gt; vis, mob, prime;\n    vector&lt;long long&gt; phi;\n    unordered_map&lt;int, int&gt; mobSums;\n    unordered_map&lt;int, long long&gt; phiSums;\n    void init(const int N) {\n        vis.clear();\n        vis.resize(N + 1);\n        phi.clear();\n        phi.resize(N + 1);\n        mob.clear();\n        mob.resize(N + 1);\n        DlsSieve::N = N;\n        mob[1] = phi[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (!vis[i]) {\n                prime.emplace_back(i);\n                phi[i] = i - 1;\n                mob[i] = -1;\n            }\n            for (int j = 0 ; i * prime[j] &lt;= N ; j++) {\n                vis[i * prime[j]] = 1;\n                if (i % prime[j] == 0) {\n                    phi[i * prime[j]] = phi[i] * prime[j]; \n                    mob[i * prime[j]] = 0;\n                    break;\n                }\n                phi[i * prime[j]] = phi[i] * phi[prime[j]];\n                mob[i * prime[j]] = -mob[i];\n            }\n        }\n        for (int i = 2 ; i &lt;= N ; i++) {\n            phi[i] += phi[i - 1];\n            mob[i] += mob[i - 1];\n        }\n    }\n    int gSum(const int x) {\n        return x;\n    }\n    int mobSum(const int x) {\n        if (x &lt;= N) return mob[x];\n        if (mobSums.count(x)) return mobSums[x];\n        int res = 1;\n        for (long long L = 2, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            res -= (gSum(R) - gSum(L - 1)) * mobSum(x / L);\n        }\n        return mobSums[x] = res / gSum(1);\n    }\n    long long phiSum(const int x) {\n        if (x &lt;= N) return phi[x];\n        if (phiSums.count(x)) return phiSums[x];\n        long long res = x * (x + 1LL) / 2;\n        for (long long L = 2, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            res -= (gSum(R) - gSum(L - 1)) * phiSum(x / L);\n        }\n        return phiSums[x] = res / gSum(1);\n    }\n} // DlsSieve\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","title":"\u6b27\u62c9\u51fd\u6570","text":""},{"location":"Template/Math/NumberTheory/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_1","title":"\u6b27\u62c9\u5b9a\u7406","text":"<p>\u82e5 \\(\\gcd(a,n)=1\\)\uff0c\u5219 \\(a^{\\phi(n)}\\equiv1\\pmod{n}\\)\u3002</p>"},{"location":"Template/Math/NumberTheory/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_2","title":"\u6269\u5c55\u6b27\u62c9\u5b9a\u7406","text":"<p>P5091 \u3010\u6a21\u677f\u3011\u6269\u5c55\u6b27\u62c9\u5b9a\u7406 - \u6d1b\u8c37</p> \\[ a^b\\equiv\\begin{cases} a^{b\\mod\\phi(p)}&amp;\\gcd(a,p)=1\\\\ a^b&amp;\\gcd(a,p)\\neq1,b&lt;\\phi(p)\\\\ a^{b\\mod\\phi(p)+\\phi(p)}&amp;\\gcd(a,p)\\neq1,b\\geq\\phi(p) \\end{cases}\\pmod{p} \\] Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint euler_phi(int n) {\n    int ans = n;\n    for (int i = 2 ; i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, m;\n    cin &gt;&gt; a &gt;&gt; m;\n    string b;\n    cin &gt;&gt; b;\n    int k = euler_phi(m);\n    bool flag = false;\n    long long res = 0;\n    for (int i = 0 ; i &lt; int(b.size()) ; i++) {\n        res = res * 10 + (b[i] ^ 48);\n        if (res &gt; k) {\n            res %= k;\n            flag = true;\n        }\n    }\n    if (flag) res += k;\n    cout &lt;&lt; qpow(a, res, m);\n    return 0;\n}\n</code></pre> <p>P4139 \u4e0a\u5e1d\u4e0e\u96c6\u5408\u7684\u6b63\u786e\u7528\u6cd5 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prime;\nbool flag[10000005];\nint phi[10000005];\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nlong long solve(long long mod) {\n    if (mod == 1) return 0;\n    return qpow(2, solve(phi[mod]) + phi[mod], mod);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    phi[1] = 1;\n    for (int i = 2 ; i &lt;= 10000000 ; i++) {\n        if (flag[i] == false) {\n            prime.emplace_back(i);\n            phi[i] = i - 1;\n        }\n        for (int j = 0 ; j &lt; prime.size() &amp;&amp; 1LL * i * prime[j] &lt;= 10000000 ; j++) {\n            flag[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            }\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n        }\n    }\n    int n;\n    cin &gt;&gt; n;\n    while (n--) {\n        int q;\n        cin &gt;&gt; q;\n        cout &lt;&lt; solve(q) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>P3747 [\u516d\u7701\u8054\u8003 2017] \u76f8\u9022\u662f\u95ee\u5019 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 50005;\nconst int M = 1 &lt;&lt; __lg(N - 1) + 1 &lt;&lt; 2;\nint n, m, p, c, a[N][60];\nstruct Node {\n    int L, R, cnt;\n    long long sum;\n    Node() = default;\n    Node(int L, int R, int cnt, long long sum) : L(L), R(R), cnt(cnt), sum(sum) {}\n    friend Node operator+(const Node &amp;lhs, const Node &amp;rhs) {\n        return Node(\n            lhs.L,\n            rhs.R,\n            min(lhs.cnt, rhs.cnt),\n            (lhs.sum + rhs.sum) % p\n        );\n    }\n} tr[M];\nvector&lt;int&gt; phi, B;\nvector&lt;array&lt;long long, 2&gt;&gt; lsp[60];\nint euler_phi(int n) {\n    int ans = n;\n    for (int i = 2 ; i * i &lt;= n ; i++) {\n        if (n % i == 0) {\n            ans = ans / i * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) ans = ans / n * (n - 1);\n    return ans;\n}\nvoid init() {\n    int x = p;\n    while (x != 1) {\n        B.push_back(10000);\n        int k = phi.size();\n        lsp[k].resize(B[k] + 1);\n        lsp[k][0] = {1, 1};\n        for (int i = 1 ; i &lt;= B[k] ; i++) {\n            lsp[k][i][0] = lsp[k][i - 1][0] * c;\n            if (lsp[k][i][0] &gt;= x) {\n                lsp[k][i][0] = lsp[k][i][0] % x + x;\n            }\n        }\n\n        for (int i = 1 ; i &lt;= B[k] ; i++) {\n            lsp[k][i][1] = lsp[k][i - 1][1] * lsp[k][B[k]][0];\n            if (lsp[k][i][1] &gt;= x) {\n                lsp[k][i][1] = lsp[k][i][1] % x + x;\n            }\n        }\n        phi.emplace_back(x);\n        x = euler_phi(x);\n    }\n    phi.emplace_back(1);\n    phi.emplace_back(0);\n}\nint qpow(int x, int idx) {\n    long long k = lsp[idx][x % B[idx]][0] * lsp[idx][x / B[idx]][1];\n    if (k &gt;= phi[idx]) {\n        k = k % phi[idx] + phi[idx];\n    }\n    return k;\n}\nint calc(int x, int cnt, int idx) {\n    if (cnt == 0) {\n        if (x &gt;= phi[idx]) {\n            x = x % phi[idx] + phi[idx];\n        }\n        return x;\n    }\n    if (phi[idx] == 1) {\n        return c ? 1 : 0;\n    }\n    return qpow(calc(x, cnt - 1, idx + 1), idx);\n}\nvoid build(int p = 1, int L = 1, int R = n) {\n    tr[p].L = L;\n    tr[p].R = R;\n    if (L == R) {\n        tr[p].sum = a[L][0];\n        tr[p].cnt = 0;\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\nvoid modify(int QL, int QR, int p = 1) {\n    if (tr[p].R &lt; QL || tr[p].L &gt; QR) return;\n    if (tr[p].cnt &gt;= phi.size() - 1) return;\n    if (tr[p].L == tr[p].R) {\n        tr[p].cnt++;\n        tr[p].sum = a[tr[p].L][tr[p].cnt];\n        return;\n    }\n    modify(QL, QR, p &lt;&lt; 1);\n    modify(QL, QR, p &lt;&lt; 1 | 1);\n    tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n}\n\nlong long query(int QL, int QR, int p = 1) {\n    if (tr[p].R &lt; QL || tr[p].L &gt; QR) return 0;\n    if (tr[p].L &gt;= QL &amp;&amp; tr[p].R &lt;= QR) {\n        return tr[p].sum;\n    }\n    return (query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1)) % ::p;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; c;\n    init();\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i][0];\n        for (int j = 1 ; j &lt; phi.size() ; j++) {\n            a[i][j] = calc(a[i][0], j, 0) % p;\n        }\n        a[i][0] %= p;\n    }\n    build();\n    for (int i = 0 ; i &lt; m ; i++) {\n        int op, L, R;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R;\n        if (op == 0) {\n            modify(L, R);\n        } else {\n            cout &lt;&lt; query(L, R) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/","title":"\u79bb\u6563\u5bf9\u6570","text":"\\[ A^x\\equiv{B}\\pmod{C} \\]"},{"location":"Template/Math/NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/#bsgs-osqrtp","title":"BSGS - \\(O(\\sqrt{p})\\)","text":"<p>P3846 [TJOI2007] \u53ef\u7231\u7684\u8d28\u6570/\u3010\u6a21\u677f\u3011BSGS - \u6d1b\u8c37</p> <p>C\u4e00\u5b9a\u8981\u4e3a\u8d28\u6570</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint qpow(long long a, int b, int c) {\n    long long res = 1 % c;\n    a %= c;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % c;\n        }\n        a = a * a % c;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint BSGS(int A, int B, int C) {\n    int m = ceil(sqrt(C));\n    A %= C;\n    B %= C;\n    unordered_map&lt;int, int&gt; vis;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = 1LL * B * A % C;\n        vis[B] = i;\n    }\n    int temp = qpow(A, m, C);\n    B = 1;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = 1LL * temp * B % C;\n        if (vis.count(B)) return (1LL * i * m - vis[B] + C) % C;\n    }\n    return -1;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int A, B, C;\n    cin &gt;&gt; C &gt;&gt; A &gt;&gt; B;\n    int k = BSGS(A, B, C);\n    if (k == -1) {\n        cout &lt;&lt; \"no solution\\n\";\n    } else {\n        cout &lt;&lt; k &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/#exbsgs-olog2psqrtp","title":"ExBSGS - \\(O(\\log^2p+\\sqrt{p})\\)","text":"<p>P4195 \u3010\u6a21\u677f\u3011\u6269\u5c55 BSGS/exBSGS - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint qpow(long long a, int b, int c) {\n    long long res = 1 % c;\n    a %= c;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % c;\n        }\n        a = a * a % c;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint BSGS(int A, int B, int C) {\n    int m = ceil(sqrt(C));\n    A %= C;\n    B %= C;\n    unordered_map&lt;int, int&gt; vis;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = 1LL * B * A % C;\n        vis[B] = i;\n    }\n    int temp = qpow(A, m, C);\n    B = 1;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        B = 1LL * temp * B % C;\n        if (vis.count(B)) return (1LL * i * m - vis[B] + C) % C;\n    }\n    return -1;\n}\nvoid Exgcd(int a, int b, int &amp;x, int &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return;\n    }\n    Exgcd(b, a % b, y, x);\n    y -= a / b * x;\n}\nint inv(int a, int b) {\n    int x, y;\n    Exgcd(a, b, x, y);\n    return (x % b + b) % b;\n}\nint ExBSGS(int A, int B, int C) {\n    A %= C;\n    B %= C;\n    if (B == 1 || C == 1) return 0;\n    int g = __gcd(A, C), k = 0, na = 1;\n    while (g &gt; 1) {\n        if (B % g != 0) return -1;\n        k++;\n        B /= g;\n        C /= g;\n        na = 1LL * na * (A / g) % C;\n        if (na == B) return k;\n        g = __gcd(A, C);\n    }\n    int res = BSGS(A, 1LL * B * inv(na, C) % C , C);\n    if (res == -1) return -1;\n    return res + k;\n}\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int A, B, C;\n    while (cin &gt;&gt; A &gt;&gt; C &gt;&gt; B) {\n        if (A == B &amp;&amp; B == C &amp;&amp; C == 0) break;\n        int k = ExBSGS(A, B, C);\n        if (k == -1) {\n            cout &lt;&lt; \"No Solution\\n\";\n        } else {\n            cout &lt;&lt; k &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/#pohlig-hellman-oleftsum_i1te_isqrtq-_i-log-nright","title":"Pohlig-Hellman - \\(O\\left(\\sum_{i=1}^te_i\\sqrt{q _i} + \\log N\\right)\\)","text":"<p>\u6570\u636e\u8303\u56f4\u53ef\u4ee51e18</p> <p>C\u4e00\u5b9a\u8981\u4e3a\u8d28\u6570\u4e14C-1\u8d28\u56e0\u5b50\u6570\u8f83\u5c0f</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a;\n        a = a * a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nlong long qpow(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = (__int128) res * a % mod;\n        }\n        b &gt;&gt;= 1;\n        a = (__int128) a * a % mod;\n    }\n    return res;\n}\ntemplate&lt;class T&gt; struct Random {\n    mt19937 mt;\n    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    T operator()(T L, T R) {\n        uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n        return dist(mt);\n    }\n};\nRandom&lt;long long&gt; rng;\nnamespace Miller_Rabin {\n    bool Miller_Rabin(const long long n, const vector&lt;long long&gt; &amp;as) {\n        long long d = n - 1;\n        while (!(d &amp; 1)) {\n            d &gt;&gt;= 1;\n        }\n        long long e = 1, rev = n - 1;\n        for (auto&amp; a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            long long t = d;\n            long long y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = (__int128) y * y % n;\n                t &lt;&lt;= 1;\n            }\n            if (y != rev &amp;&amp; (!(t &amp; 1))) return false;\n        }\n        return true;\n    }\n    bool is_prime(const long long n) {\n        if (!(n &amp; 1)) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nnamespace Pollard_rho {\n    long long solve(long long n) {\n        if (!(n &amp; 1)) {\n            return 2;\n        }\n        if (Miller_Rabin::is_prime(n)) {\n            return n;\n        }\n        long long R, one = 1;\n        auto f = [&amp;](long long x) {\n            return ((__int128) x * x % n + R) % n;\n        };\n        auto rnd = [&amp;]() {\n            return rng(0, n - 3) + 2;\n        };\n        while (true) {\n            long long x, y, ys, q = one;\n            R = rnd(), y = rnd();\n            long long g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r &lt;&lt;= 1) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        q = (__int128) q * ((x - (y = f(y)) + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    g = __gcd((x - (ys = f(ys)) + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;long long&gt; factorize(long long n) {\n        if (n &lt;= 1) return {};\n        long long p = solve(n);\n        if (p == n) return {n};\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;long long, int&gt;&gt; ret;\n        for (auto &amp;e : ps) {\n            if (!ret.empty() &amp;&amp; ret.back().first == e) {\n                ret.back().second++;\n            } else {\n                ret.emplace_back(e, 1);\n            }\n        }\n        return ret;\n    }\n} // Pollard_rho\nnamespace Pohlig_Hellman {\n    long long BSGS(long long A, long long B, long long C, long long mod) {\n        int m = ceil(sqrtl(C));\n        A %= mod;\n        B %= mod;\n        unordered_map&lt;long long, int&gt; vis;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            B = (__int128) B * A % mod;\n            vis[B] = i;\n        }\n        long long temp = qpow(A, m, mod);\n        B = 1;\n        for (int i = 1 ; i &lt;= m ; i++) {\n            B = (__int128) temp * B % mod;\n            if (vis.count(B)) return ((__int128) i * m - vis[B] + mod) % mod;\n        }\n        return -1;\n    }\n    long long getK(long long A, long long B, long long P, long long C, long long phi, long long mod) {\n        vector&lt;long long&gt; pi;\n        long long temp = 1;\n        for (int i = 0 ; i &lt;= C ; i++) {\n            pi.emplace_back(temp);\n            temp *= P;\n        }\n        long long k = qpow(A, pi[C - 1], mod);\n        long long inv = 0;\n        temp = 1;\n        for (int i = C - 1 ; i &gt;= 0 ; i--) {\n            long long tp = qpow(A, pi[C] - inv, mod);\n            long long tx = temp * BSGS(k, qpow((__int128)B * tp % mod, pi[i], mod), P, mod);\n            inv += tx;\n            temp *= P;\n        }\n        return inv;\n    }\n    int getOrg(long long P, long long phi, const vector&lt;pair&lt;long long, int&gt;&gt;&amp; res) {\n        for (int k = 2 ; ; k++) {\n            bool flag = true;\n            for (auto&amp; [x, y] : res) {\n                if (qpow(k, phi / x, P) == 1LL) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) return k;\n        }\n    }\n    void Exgcd(long long a, long long b, long long&amp; x, long long&amp; y) {\n        if (b == 0) {\n            x = 1;\n            y = 0;\n            return;\n        }\n        Exgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    long long CRT(const vector&lt;long long&gt;&amp; k, const vector&lt;pair&lt;long long, int&gt;&gt;&amp; res) {\n        int len = res.size();\n        long long M = 1, ans = 0;\n        vector&lt;long long&gt; m(len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            m[i] = qpow(res[i].first, res[i].second);\n            M *= m[i];\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            long long Mi = M / m[i];\n            long long x, y;\n            Exgcd(Mi, m[i], x, y);\n            ans = (ans + (__int128)Mi * ((x % m[i] + m[i]) % m[i]) * k[i]) % M;\n        }\n        if (ans &lt; 0) ans += M;\n        return ans;\n    }\n    long long getX(long long B, long long A, long long phi, long long mod, vector&lt;pair&lt;long long, int&gt;&gt;&amp; res) {\n        vector&lt;long long&gt; k;\n        for (auto&amp; [x, y] : res) {\n            long long z = qpow(x, y);\n            long long tA = qpow(A, phi / z, mod);\n            long long tB = qpow(B, phi / z, mod);\n            k.emplace_back(getK(tA, tB, x, y, phi, mod));\n        }\n        return CRT(k, res);\n    }\n    long long Solve(long long A, long long B, long long P) {\n        if (B == 1LL) {\n            return 0LL;\n        }\n        long long phi = P - 1;\n        vector&lt;pair&lt;long long, int&gt;&gt; res = Pollard_rho::prime_factor(phi);\n        int rt = getOrg(P, phi, res);\n        long long x = getX(A, rt, phi, P, res), y = getX(B, rt, phi, P, res);\n        long long a, b;\n        if (x == 0LL) {\n            if (y == 0LL) {\n                return 1LL;\n            } else if (y == 1LL) {\n                return 0LL;\n            }\n            return -1LL;\n        }\n        long long d;\n        if (y % (d = __gcd(x, phi))) return -1;\n        x /= d;\n        phi /= d;\n        y /= d;\n        Exgcd(x, phi, a, b);\n        a = ((__int128)a * y % phi + phi) % phi;\n        return a;\n    }\n} // Pohlig_Hellman\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    long long A, B, P;\n    cin &gt;&gt; P &gt;&gt; A &gt;&gt; B;\n    long long ans = Pohlig_Hellman::Solve(A, B, P);\n    if (ans == -1) {\n        cout &lt;&lt; \"no solution\\n\";\n    } else {\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","title":"\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":""},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/#fabcnsum_i0nlfloorfracacdotibcrfloor","title":"\\(f(a,b,c,n)=\\sum_{i=0}^n\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\)","text":"<p>\u5f53 \\(a\\ge{c}\\text{ \u6216 }b\\ge{c}\\)</p> \\[ \\begin{align} f(a,b,c,n)&amp;=\\sum_{i=0}^n\\lfloor\\dfrac{a\\cdot{i}+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{\\left(\\lfloor\\frac{a}{c}\\rfloor\\cdot{c}+a\\ mod\\ c\\right)\\cdot{i}+\\left(\\lfloor\\frac{b}{c}\\rfloor\\cdot{c}+b\\ mod\\ c\\right)}{c}\\right\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\left\\lfloor\\lfloor\\frac{a}{c}\\rfloor\\cdot{i}+\\frac{\\left(a\\ mod\\ c\\right)\\cdot{i}}{c}+\\lfloor\\frac{b}{c}\\rfloor+\\frac{\\left(b\\ mod\\ c\\right)}{c}\\right\\rfloor\\\\ &amp;=\\frac{n\\cdot(n+1)}{2}\\cdot\\lfloor\\frac{a}{c}\\rfloor+(n+1)\\cdot\\lfloor{\\frac{b}{c}}\\rfloor+\\sum_{i=0}^n\\left\\lfloor\\frac{(a\\ mod\\ c)\\cdot{i}+(b\\ mod\\ c)}{c}\\right\\rfloor\\\\ &amp;=\\frac{n\\cdot(n+1)}{2}\\cdot\\lfloor\\frac{a}{c}\\rfloor+(n+1)\\cdot\\lfloor{\\frac{b}{c}}\\rfloor+f(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] <p>\u5f53 \\(a&lt;c\\text{ \u4e14 }b&lt;c\\)</p> \\[ \\begin{align} f(a,b,c,n)&amp;=\\sum_{i=0}^n\\lfloor\\dfrac{a\\cdot{i}+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor-1}1\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\sum_{i=0}^n\\left[j&lt;\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\right] \\end{align} \\] \\[ \\begin{align} j&lt;\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\Longleftrightarrow{j}+1\\leq\\frac{a\\cdot{i}+b}{c}\\Longleftrightarrow{j}\\cdot{c}+c\\le{a}\\cdot{i}+b\\Longleftrightarrow\\left\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\right\\rfloor&lt;i \\end{align} \\] \\[ \\begin{align} f(a,b,c,b)&amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\sum_{i=0}^n\\left[\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor&lt;i\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\left(n-\\left\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\right\\rfloor\\right)\\\\ &amp;=n\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-f(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1) \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/#gabcnsum_i0nicdotlfloorfracacdotibcrfloor","title":"\\(g(a,b,c,n)=\\sum_{i=0}^ni\\cdot\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\)","text":"<p>\u5f53 \\(a\\ge{c}\\text{ \u6216 }b\\ge{c}\\)</p> \\[ \\begin{align} g(a,b,c,n)&amp;=\\sum_{i=0}^ni\\cdot\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\\\ &amp;=\\frac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\cdot\\lfloor\\frac{a}{c}\\rfloor+\\frac{n\\cdot(n+1)}{2}\\cdot\\lfloor\\frac{b}{c}\\rfloor+g(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] <p>\u5f53 \\(a&lt;c\\text{ \u4e14 }b&lt;c\\)</p> \\[ \\begin{align} g(a,b,c,n)&amp;=\\sum_{i=0}^ni\\cdot\\lfloor\\dfrac{a\\cdot{i}+b}{c}\\rfloor\\\\ &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor-1}i\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\sum_{i=0}^ni\\cdot\\left[j&lt;\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\sum_{i=0}^ni\\cdot\\left[\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor&lt;i\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\frac{(\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor+1+n)\\cdot(n-\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor)}{2}\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}\\left(\\frac{n^2+n-\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor-(\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor)^2}{2}\\right)\\\\ &amp;=\\frac{1}{2}\\cdot{n}\\cdot(n+1)\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-\\frac{1}{2}\\cdot{h}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ &amp;-\\frac{1}{2}\\cdot{f}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1) \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/#habcnsum_i0nleftlfloorfracacdotibcrightrfloor2","title":"\\(h(a,b,c,n)=\\sum_{i=0}^n\\left\\lfloor\\frac{a\\cdot{i}+b}{c}\\right\\rfloor^2\\)","text":"<p>\u5f53 \\(a\\ge{c}\\text{ \u6216 }b\\ge{c}\\)</p> \\[ \\begin{align} h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{a\\cdot{i}+b}{c}\\right\\rfloor^2\\\\ &amp;=(n+1)\\cdot\\lfloor\\frac{b}{c}\\rfloor^2+n\\cdot(n+1)\\cdot\\lfloor\\frac{a}{c}\\rfloor\\cdot\\lfloor\\frac{b}{c}\\rfloor+\\frac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\cdot\\lfloor\\frac{a}{c}\\rfloor^2\\\\ &amp;+2\\cdot\\lfloor\\frac{b}{c}\\rfloor\\cdot{f}(a\\ mod\\ c,b\\ mod\\ c,c,n) +2\\cdot\\lfloor\\frac{a}{c}\\rfloor\\cdot{g}(a\\ mod\\ c,b\\ mod\\ c,c,n) \\end{align} \\] <p>\u5f53 \\(a&lt;c\\text{ \u4e14 }b&lt;c\\)</p> \\[ \\begin{align} n^2&amp;=2\\cdot\\frac{n\\cdot(n+1)}{2}-n=2\\cdot(\\sum_{i=0}^ni)-n\\\\ h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{a\\cdot{i}+b}{c}\\right\\rfloor^2\\\\ &amp;=\\sum_{i=0}^n\\left[2\\cdot(\\sum_{j=1}^{\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor}j)-\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\right]\\\\ &amp;=2\\cdot(\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor}j)-f(a,b,c,n)\\\\ \\sum_{i=0}^n\\sum_{j=1}^{\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor}j&amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}j+1\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}(j+1)\\sum_{i=0}^n\\left[j&lt;\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}(j+1)\\sum_{i=0}^n[\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor&lt;i]\\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}(j+1)\\cdot(n-\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\rfloor)\\\\ &amp;=\\frac{1}{2}\\cdot{n}\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor\\cdot(\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor+1)-\\sum_{j=0}^{\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1}(j+1)\\cdot\\left\\lfloor\\frac{j\\cdot{c}+c-b-1}{a}\\right\\rfloor\\\\ &amp;=\\frac{1}{2}\\cdot{n}\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor\\cdot(\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor+1)-g(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ &amp;-f(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ h(a,b,c,n)&amp;=n\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor\\cdot(\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor+1)-2\\cdot{g}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ &amp;-2\\cdot{f}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)-f(a,b,c,n)\\\\ \\end{align} \\]"},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/#_2","title":"\u603b\u7ed3","text":"\\[ f(a,b,c,n)=\\sum_{i=0}^n\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor= \\begin{cases} \\frac{n\\cdot(n+1)}{2}\\cdot\\lfloor\\frac{a}{c}\\rfloor+(n+1)\\cdot\\lfloor{\\frac{b}{c}}\\rfloor+f(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ n\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-f(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\] \\[ g(a,b,c,n)=\\sum_{i=0}^ni\\cdot\\lfloor\\frac{a\\cdot{i}+b}{c}\\rfloor= \\begin{cases} \\frac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\cdot\\lfloor\\frac{a}{c}\\rfloor+\\frac{n\\cdot(n+1)}{2}\\cdot\\lfloor\\frac{b}{c}\\rfloor+g(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ \\frac{1}{2}\\cdot{n}\\cdot(n+1)\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-\\frac{1}{2}\\cdot{h}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ \\ -\\frac{1}{2}\\cdot{f}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\] \\[ h(a,b,c,n)=\\sum_{i=0}^n\\left\\lfloor\\frac{a\\cdot{i}+b}{c}\\right\\rfloor^2= \\begin{cases} (n+1)\\cdot\\lfloor\\frac{b}{c}\\rfloor^2+n\\cdot(n+1)\\cdot\\lfloor\\frac{a}{c}\\rfloor\\cdot\\lfloor\\frac{b}{c}\\rfloor+\\frac{n\\cdot(n+1)\\cdot(2n+1)}{6}\\cdot\\lfloor\\frac{a}{c}\\rfloor^2\\\\ +2\\cdot\\lfloor\\frac{b}{c}\\rfloor\\cdot{f}(a\\ mod\\ c,b\\ mod\\ c,c,n)+2\\cdot\\lfloor\\frac{a}{c}\\rfloor\\cdot{g}(a\\ mod\\ c,b\\ mod\\ c,c,n)&amp;a\\ge{c}\\text{ \u6216 }b\\ge{c}\\\\ n\\cdot\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor\\cdot(\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor+1)-2\\cdot{g}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)\\\\ -2\\cdot{f}(c,c-b-1,a,\\lfloor\\frac{a\\cdot{n}+b}{c}\\rfloor-1)-f(a,b,c,n)&amp;a&lt;c\\text{ \u4e14 }b&lt;c\\\\ \\end{cases} \\]"},{"location":"Template/Math/NumberTheory/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/#_3","title":"\u4ee3\u7801","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst long long mod = 998244353;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nconst long long i2 = qpow(2, mod - 2);\nconst long long i6 = qpow(6, mod - 2);\nstruct Node {\n    long long f, g, h;\n    Node() = default;\n    Node(long long f, long long g, long long h) : f(f), g(g), h(h) {}\n};\nNode calc(int n, int a, int b, int c) {\n    int ac = a / c, bc = b / c;\n    long long m = (1LL * a * n + b) / c;\n    int n1 = n + 1, n2 = n &lt;&lt; 1 | 1;\n    if (a == 0) {\n        return Node(1LL * bc * n1 % mod, 1LL * bc * n % mod * n1 % mod * i2 % mod, 1LL * bc * bc % mod * n1 % mod);\n    }\n    if (a &gt;= c || b &gt;= c) {\n        Node res = calc(n, a % c, b % c, c);\n        return Node(\n            ((1LL * n * n1 % mod * i2 % mod * ac % mod + 1LL * bc * n1 % mod) % mod + res.f) % mod,\n            ((1LL * ac * n % mod * n1 % mod * n2 % mod * i6 % mod + 1LL * bc * n % mod * n1 % mod * i2 % mod) % mod + res.g) % mod,\n            (((((1LL * ac * ac % mod * n % mod * n1 % mod * n2 % mod * i6 % mod + 1LL * bc * bc % mod * n1 % mod) % mod + 1LL * ac * bc % mod * n % mod * n1 % mod) % mod + res.h) % mod + 2LL * bc % mod * res.f % mod) % mod + 2LL * ac % mod * res.g % mod) % mod);\n    }\n    Node res = calc(m - 1, c, c - b - 1, a);\n    long long f = (1LL * n * m % mod - res.f + mod) % mod;\n    return Node(\n        f,\n        ((1LL * m * n % mod * n1 % mod - res.h - res.f) % mod + mod) * i2 % mod,\n        ((1LL * n * m % mod * (m + 1) % mod - 2LL * res.g - 2LL * res.f - f) % mod + mod) % mod);\n}\nvoid solve() {\n    int n, a, b, c;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    auto [f, g, h] = calc(n, a, b, c);\n    cout &lt;&lt; f &lt;&lt; \" \" &lt;&lt; h &lt;&lt; \" \" &lt;&lt; g &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> Code C++<pre><code>const long long mod = 998244353;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nconst long long i2 = qpow(2, mod - 2);\nconst long long i6 = qpow(6, mod - 2);\nlong long calc(int n, int a, int b, int c) {\n    int ac = a / c, bc = b / c;\n    long long m = (1LL * a * n + b) / c;\n    int n1 = n + 1, n2 = n &lt;&lt; 1 | 1;\n    if (a == 0) {\n        return 1LL * bc * n1 % mod;\n    }\n    if (a &gt;= c || b &gt;= c) {\n        long long res = calc(n, a % c, b % c, c);\n        return 1LL * n * n1 % mod * i2 % mod * ac % mod + 1LL * bc * n1 % mod) % mod + res) % mod;\n    }\n    long long res = calc(m - 1, c, c - b - 1, a);\n    return (1LL * n * m % mod - res + mod) % mod;\n}\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570","text":""},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#_2","title":"\u5b9a\u4e49","text":"\\[ \\begin{equation} \\mu(n)= \\begin{cases} 1&amp;&amp;n=1\\\\ {(-1)}^r&amp;&amp;n=p_1*p_2*\u2026p_r\\\\ 0&amp;&amp;else \\end{cases} \\end{equation} \\]"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#_3","title":"\u5b9a\u7406","text":"\\[ \\begin{equation} \\sum_{d|n}\\mu(d)= \\begin{cases} 1&amp;&amp;n=1\\\\ 0&amp;&amp;n&gt;1 \\end{cases} \\end{equation} \\]"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#_4","title":"\u7b5b\u6cd5\u6c42\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570","text":"Code C++<pre><code>namespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    void init(const int N) {\n        prime.clear();\n        vis.clear();\n        vis.resize(N + 1);\n        mob.clear();\n        mob.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.emplace_back(i);\n                mob[i] = -1;\n            }\n            for (int j = 0 ; i * prime[j] &lt;= N ; j++) {\n                vis[i * prime[j]] = prime[j];\n                if (i % prime[j] == 0) {\n                    mob[i * prime[j]] = 0;\n                    break;\n                }\n                mob[i * prime[j]] = -mob[i];\n            }\n        }\n    }\n} // MobiusSieve\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#_5","title":"\u83ab\u6bd4\u4e4c\u65af\u53d8\u6362","text":"<p>\u2460 \u5982\u679c \\(f(n)=\\sum_{d|n}g(d)\\)\uff0c\u90a3\u4e48 \\(g(n)=\\sum_{d|n}\\mu(d)\\cdot{f(\\frac{n}{d})}\\)</p> <p>\u2461 \u5982\u679c \\(f(n)=\\sum_{n|d}g(d)\\)\uff0c\u90a3\u4e48 \\(g(n)=\\sum_{n|d}\\mu(\\frac{d}{n})\\cdot{f(d)}\\)</p>"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#_6","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14","text":"\\[ [\\gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d) \\] <p>P2522 [HAOI2011] Problem b - \u6d1b\u8c37</p> \\[ \\begin{align} F(x,y)&amp;=\\sum_{i=1}^x\\sum_{j=1}^y[\\gcd(i,j)=k]\\\\ &amp;=\\sum_{i=1}^{\\lfloor\\frac{x}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{y}{k}\\rfloor}[\\gcd(i,j)=1]\\\\ &amp;=\\sum_{i=1}^{\\lfloor\\frac{x}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{y}{k}\\rfloor}\\sum_{d|\\gcd(i,j)}\\mu(d)\\\\ &amp;=\\sum_{d=1}^{min(x,y)}\\mu(d)\\cdot\\lfloor\\frac{x}{d}\\rfloor\\cdot\\lfloor\\frac{y}{d}\\rfloor \\end{align} \\] \\[ \\sum_{i=x}^n\\sum_{j=y}^m[\\gcd(i,j)=k]=F(\\frac{n}{k},\\frac{m}{k})-F(\\frac{x-1}{k},\\frac{m}{k})-F(\\frac{n}{k},\\frac{y-1}{k})+F(\\frac{x-1}{k},\\frac{y-1}{k}) \\] Code C++<pre><code>auto F = [&amp;](const int x, const int y) {\n    int res = 0, k = min(x, y);\n        for (int i = 1, R ; i &lt;= k ; i = R + 1) {\n            R = min(x / (x / i), y / (y / i));\n            res += (mob[R] - mob[i - 1]) * (x / i) * (y / i);\n        }\n    return res;\n};\n</code></pre>"},{"location":"Template/Math/NumberTheory/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/#sum_i1nsum_j1mdicdotj","title":"\\(\\sum_{i=1}^n\\sum_{j=1}^md(i\\cdot{j})\\)","text":"\\[ \\begin{align} d(i\\cdot{j})&amp;=\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]\\\\ \\sum_{i=1}^n\\sum_{j=1}^md(i\\cdot{j})&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]\\\\ &amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor[\\gcd(i,j)=1]\\\\ f(x)&amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor[\\gcd(i,j)=x]\\\\ g(x)&amp;=\\sum_{x|d}f(d)=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor[x|\\gcd(i,j)]\\\\\\\\ &amp;=\\sum_{i=1}^n\\sum_{j=1}^m\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor[x|\\gcd(i,j)]\\\\ &amp;=\\sum_{i=1}^\\frac{n}{x}\\sum_{j=1}^\\frac{m}{x}\\lfloor\\frac{n}{i\\cdot{x}}\\rfloor\\lfloor\\frac{m}{j\\cdot{x}}\\rfloor\\\\ &amp;=\\sum_{i=1}^\\frac{n}{x}\\lfloor\\frac{n}{i\\cdot{x}}\\rfloor\\sum_{j=1}^\\frac{m}{x}\\lfloor\\frac{m}{j\\cdot{x}}\\rfloor\\\\ &amp;=\\sum_{i=1}^\\frac{n}{x}\\lfloor\\frac{n}{i\\cdot{x}}\\rfloor\\cdot\\sum_{j=1}^\\frac{m}{x}\\lfloor\\frac{m}{j\\cdot{x}}\\rfloor\\\\ f(x)&amp;=\\sum_{x|d}\\mu(\\frac{d}{x})\\cdot{g}(d)\\\\ f(1)&amp;=\\sum_{1|d}\\mu(d)\\cdot{g}(d)=\\sum_{i=1}^n\\mu(i)\\cdot{g}(i)\\\\ s(x)&amp;=\\sum_{i=1}^x\\lfloor\\frac{x}{i}\\rfloor\\\\ g(x)&amp;=s(\\frac{n}{x})\\cdot{s}(\\frac{m}{x})\\\\ f(1)&amp;=\\sum_{i=1}^n\\mu(i)\\cdot{s}(\\frac{n}{i})\\cdot{s}(\\frac{m}{i})\\\\ \\end{align} \\] Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nnamespace MobiusSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    vector&lt;int&gt; mob;\n    void init(const int N) {\n        prime.clear();\n        vis.clear();\n        vis.resize(N + 1);\n        mob.clear();\n        mob.resize(N + 1);\n        mob[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.emplace_back(i);\n                mob[i] = -1;\n            }\n            for (int j = 0 ; i * prime[j] &lt;= N ; j++) {\n                vis[i * prime[j]] = prime[j];\n                if (i % prime[j] == 0) {\n                    mob[i * prime[j]] = 0;\n                    break;\n                }\n                mob[i * prime[j]] = -mob[i];\n            }\n        }\n        for (int i = 1 ; i &lt;= N ; i++) {\n            mob[i] += mob[i - 1];\n        }\n    }\n} // MobiusSieve\nusing MobiusSieve::mob;\nlong long g[50005];\nvoid solve() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    if (n &lt; m) swap(n, m);\n    long long ans = 0;\n    for (int L = 1, R ; L &lt;= m ; L = R + 1) {\n        R = min(n / (n / L), m / (m / L));\n        ans += 1LL * (mob[R] - mob[L - 1]) * g[n / L] * g[m / L];\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    MobiusSieve::init(50005);\n    for (int x = 1 ; x &lt;= 50000 ; x++) {\n        long long res = 0;\n        for (int L = 1, R ; L &lt;= x ; L = R + 1) {\n            R = x / (x / L);\n            res += 1LL * (R - L + 1) * (x / L);\n        }\n        g[x] = res;\n    }\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/NumericalAlgorithm/Lagrange/","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c","text":"<p>\\(f(x)=\\sum_{i=1}^ny_i*\\prod_{j\\neq i}\\dfrac{x-x_j}{x_i-x_j}\\)</p> \u4f8b\u9898 <p>P4781 \u3010\u6a21\u677f\u3011\u62c9\u683c\u6717\u65e5\u63d2\u503c - \u6d1b\u8c37</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst long long mod = 998244353;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nlong long x[2005], y[2005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i] &gt;&gt; y[i];\n    }\n    auto larange = [&amp;](long long k) {\n        long long res = 0;\n        for (int i = 0 ; i &lt; n ; i++) {\n            long long s1 = 1, s2 = 1;\n            for (int j = 0 ; j &lt; n ; j++) {\n                if (i == j) continue;\n                s1 = s1 * (k - x[j]) % mod;\n                s2 = s2 * (x[i] - x[j]) % mod;\n            }\n            s1 = (s1 % mod + mod) % mod;\n            s2 = (s2 % mod + mod) % mod;\n            res = (res + y[i] * s1 % mod * qpow(s2, mod - 2) % mod) % mod;\n        }\n        return res;\n    };\n    cout &lt;&lt; larange(k) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> \u4e60\u9898 \u6d1b\u8c37P4593CF622FHydroOJP3453 <p>P4593 [TJOI2018] \u6559\u79d1\u4e66\u822c\u7684\u4eb5\u6e0e - \u6d1b\u8c37</p> <p>\\(ans=\\sum_{i=0}^m\\left(\\sum_{j=1}^{n-a_i}j^{m+1}-\\sum_{j=i+1}^m({(a_j-a_i)}^{m+1})\\right)\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst long long mod = 1000000007;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nlong long y[55];\nlong long a[55];\nvoid solve() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a, a + m + 1);\n    int k = m + 1;\n    y[1] = 1;\n    for (int i = 2 ; i &lt;= k + 2 ; i++) {\n        y[i] = (y[i - 1] + qpow(i, k)) % mod;\n    }\n    auto larange = [&amp;](long long x) {\n        if (x &lt;= k + 2) return y[x];\n        long long res = 0;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            long long s1 = 1, s2 = 1;\n            for (int j = 1 ; j &lt;= k + 2 ; j++) {\n                if (i == j) continue;\n                s1 = s1 * (x - j) % mod;\n                s2 = s2 * (i - j) % mod;\n            }\n            s1 = (s1 % mod + mod) % mod;\n            s2 = (s2 % mod + mod) % mod;\n            res = (res + y[i] * s1 % mod * qpow(s2, mod - 2) % mod) % mod;\n        }\n        return res;\n    };\n    long long ans = 0;\n    for (int i = 0 ; i &lt;= m ; i++) {\n        ans = (ans + larange(n - a[i])) % mod;\n        long long res = 0;\n        for (int j = i + 1 ; j &lt;= m ; j++) {\n            res = res + qpow(a[j] - a[i], k);\n        }\n        ans = ((ans - res) % mod + mod) % mod;\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre> <p>Problem - F - Codeforces</p> <p>\u6c42 \\(\\sum_{i=1}^ni^k\\)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst long long mod = 1000000007;\nlong long pre[1000005], suf[1000005], y[1000005], fact[1000005], invf[1000005];\nlong long qpow(long long a, long long b = mod - 2) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1 ; i &lt;= k + 2 ; i++) {\n        y[i] = (y[i - 1] + qpow(i, k)) % mod;\n    }\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= k + 2 ; i++) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n    invf[k + 2] = qpow(fact[k + 2], mod - 2);\n    for (int i = k + 2 ; i &gt;= 1 ; i--) {\n        invf[i - 1] = invf[i] * i % mod;\n    }\n    auto lagrange = [&amp;](int x) {\n        if (x &lt;= k + 2) {\n            return y[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            pre[i] = pre[i - 1] * (x - i) % mod;\n        }\n        suf[k + 3] = 1;\n        for (int i = k + 2 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * (x - i) % mod;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 2 - i] \u7b26\u53f7(-1)^{k + 2 - i}\n        long long res = 0;\n        for (int i = 1 ; i &lt;= k + 2 ; i++) {\n            long long s1 = pre[i - 1] * suf[i + 1] % mod;\n            long long s2 = invf[i - 1] * invf[k + 2 - i] % mod;\n            if ((k + 2 - i) &amp; 1) {\n                s2 = mod - s2;\n            }\n            res = (res + s1 * s2 % mod * y[i] % mod) % mod;\n        }\n        return res;\n    };\n    cout &lt;&lt; lagrange(n);\n    return 0;\n}\n</code></pre> <p>tyvj 1858 XLkxc - HydroOJ</p> <p>f\u51fd\u6570\u662fk+1\u9636\u591a\u9879\u5f0f, g\u51fd\u6570\u662fk+2\u9636\u591a\u9879\u5f0f</p> <p>\u8bbe\u7b54\u6848\u4e3ah\u51fd\u6570, \u5219 h\u51fd\u6570\u662fk+3\u9636\u591a\u9879\u5f0f</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nconst long long mod = 1234567891;\nlong long pre[200], suf[200], y[200], fact[200], invf[200];\nlong long qpow(long long a, long long b = mod - 2) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nlong long f[200], g[200], h[200];\nvoid solve() {\n    int k, a, n, d;\n    cin &gt;&gt; k &gt;&gt; a &gt;&gt; n &gt;&gt; d;\n    for (int i = 1 ; i &lt;= k + 3 ; i++) {\n        f[i] = (f[i - 1] + qpow(i, k)) % mod;\n        g[i] = (g[i - 1] + f[i]) % mod;\n    }\n    auto lagrange1 = [&amp;](long long x) {\n        if (x &lt;= k + 3) {\n            return g[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 3 ; i++) {\n            pre[i] = pre[i - 1] * ((x - i) % mod) % mod;\n        }\n        suf[k + 4] = 1;\n        for (int i = k + 3 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * ((x - i) % mod) % mod;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 3 - i] \u7b26\u53f7(-1)^{k + 3 - i}\n        long long res = 0;\n        for (int i = 1 ; i &lt;= k + 3 ; i++) {\n            long long s1 = pre[i - 1] * suf[i + 1] % mod;\n            long long s2 = invf[i - 1] * invf[k + 3 - i] % mod;\n            if ((k + 3 - i) &amp; 1) {\n                s2 = mod - s2;\n            }\n            res = (res + s1 * s2 % mod * g[i] % mod) % mod;\n        }\n        return res;\n    };\n    auto lagrange2 = [&amp;](long long x) {\n        if (x &lt;= k + 4) {\n            return h[x];\n        }\n        pre[0] = 1;\n        for (int i = 1 ; i &lt;= k + 4 ; i++) {\n            pre[i] = pre[i - 1] * ((x - i) % mod) % mod;\n        }\n        suf[k + 5] = 1;\n        for (int i = k + 4 ; i &gt;= 1 ; i--) {\n            suf[i] = suf[i + 1] * ((x - i) % mod) % mod;\n        }\n        // \u5206\u5b50 pre[i - 1] * suf[i + 1]\n        // \u5206\u6bcd invf[i - 1] * invf[k + 4 - i] \u7b26\u53f7(-1)^{k + 4 - i}\n        long long res = 0;\n        for (int i = 1 ; i &lt;= k + 4 ; i++) {\n            long long s1 = pre[i - 1] * suf[i + 1] % mod;\n            long long s2 = invf[i - 1] * invf[k + 4 - i] % mod;\n            if ((k + 4 - i) &amp; 1) {\n                s2 = mod - s2;\n            }\n            res = (res + s1 * s2 % mod * h[i] % mod) % mod;\n        }\n        return res;\n    };\n    for (int i = 1 ; i &lt;= k + 4 ; i++) {\n        h[i] = (h[i - 1] + lagrange1(a + 1LL * (i - 1) * d)) % mod;\n    }\n    cout &lt;&lt; lagrange2(n + 1) &lt;&lt; \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= 150 ; i++) {\n        fact[i] = fact[i - 1] * i % mod;\n    }\n    invf[150] = qpow(fact[150], mod - 2);\n    for (int i = 150 ; i &gt;= 1 ; i--) {\n        invf[i - 1] = invf[i] * i % mod;\n    }\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/Poly/FFT/","title":"\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362","text":"\u6a21\u7248 \u7ed3\u6784\u4f53\u975e\u7ed3\u6784\u4f53 C++<pre><code>template&lt;class T = double&gt; struct __Complex {\n    T x, y;\n    __Complex() = default;\n    __Complex(const T x, const T y) : x(x), y(y) {}\n    __Complex &amp;operator+=(const __Complex &amp;b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n    __Complex &amp;operator-=(const __Complex &amp;b) {\n        x -= b.x;\n        y -= b.y;\n        return *this;\n    }\n    __Complex &amp;operator*=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = x * b.x - y * b.y;\n        temp.y = x * b.y + y * b.x;\n        *this = temp;\n        return *this;\n    }\n    __Complex &amp;operator*=(const double &amp;b) {\n        x *= b;\n        y *= b;\n        return *this;\n    }\n    __Complex &amp;operator/=(const double b) {\n        x /= b;\n        y /= b;\n        return *this;\n    }\n    __Complex operator+(const __Complex &amp;b) {\n        __Complex a = *this;\n        a += b;\n        return a;\n    }\n    __Complex operator-(const __Complex &amp;b) {\n        __Complex a = *this;\n        a -= b;\n        return a;\n    }\n    __Complex operator*(const __Complex &amp;b) {\n        __Complex a = *this;\n        a *= b;\n        return a;\n    }\n};\nusing Complex = __Complex&lt;&gt;;\nconst double PI = acos(-1.0);\nconst double PI2 = PI / 2;\nnamespace Poly {\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    vector&lt;Complex&gt; r;\n    int _len = 0;\n    void init(int lenbL, int lenbR) {\n        if (lenbL &gt;= lenbR) return;\n        r.resize(1 &lt;&lt; (lenbR + 1));\n        for (int i = lenbL ; i &lt; lenbR ; i++) {\n            int L = 1 &lt;&lt; i;\n            r[L] = {cos(PI2 / L), sin(PI2 / L)};\n            for (int j = L + 1 ; j &lt; 2 * L ; j++) {\n                r[j] = r[j - L] * r[L];\n            }\n        }\n        _len = lenbR;\n    }\n    void FFT(vector&lt;Complex&gt; &amp;a) {\n        int len = a.size();\n        for (int i = len ; i &gt;= 2 ; i /= 2) {\n            int L = i / 2;\n            for (int j = 0 ; j &lt; L ; j++) {\n                Complex z = a[j + L];\n                a[j + L] = a[j] - z;\n                a[j] += z;\n            }\n            for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n                for (int k = 0 ; k &lt; L ; k++) {\n                    Complex z = a[j + k + L] * r[res];\n                    a[j + k + L] = a[j + k] - z;\n                    a[j + k] += z;\n                }\n            }\n        }\n    }\n    void IFFT(vector&lt;Complex&gt; &amp;a) {\n        int len = a.size();\n        for (int i = 2 ; i &lt;= len ; i *= 2) {\n            int L = i / 2;\n            for (int j = 0 ; j &lt; L ; j++) {\n                Complex z = a[j + L];\n                a[j + L] = a[j] - z;\n                a[j] += z;\n            }\n            for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n                for (int k = 0 ; k &lt; L ; k++) {\n                    Complex z = a[j + k + L];\n                    a[j + k + L] = (a[j + k] - z) * r[res];\n                    a[j + k] += z;\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] /= len;\n        }\n        reverse(begin(a) + 1, end(a));\n    }\n    vector&lt;Complex&gt; mul(vector&lt;Complex&gt; a, vector&lt;Complex&gt; b) {\n        int n = a.size(), m = b.size();\n        int len = getLen(n + m);\n        int lenb = int(ceil(log2(len)));\n        init(_len, lenb);\n        a.resize(len);\n        b.resize(len);\n        FFT(a);\n        FFT(b);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] *=  b[i];\n        }\n        IFFT(a);\n        return a;\n    }\n}; // Poly\n</code></pre> C++<pre><code>template&lt;class T = double&gt; struct __Complex {\n    T x, y;\n    __Complex() = default;\n    __Complex(const T x, const T y) : x(x), y(y) {}\n    __Complex &amp;operator+=(const __Complex &amp;b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n    __Complex &amp;operator-=(const __Complex &amp;b) {\n        x -= b.x;\n        y -= b.y;\n        return *this;\n    }\n    __Complex &amp;operator*=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = x * b.x - y * b.y;\n        temp.y = x * b.y + y * b.x;\n        *this = temp;\n        return *this;\n    }\n    __Complex &amp;operator*=(const double &amp;b) {\n        x *= b;\n        y *= b;\n        return *this;\n    }\n    __Complex &amp;operator/=(const double b) {\n        x /= b;\n        y /= b;\n        return *this;\n    }\n    __Complex operator+(const __Complex &amp;b) {\n        __Complex a = *this;\n        a += b;\n        return a;\n    }\n    __Complex operator-(const __Complex &amp;b) {\n        __Complex a = *this;\n        a -= b;\n        return a;\n    }\n    __Complex operator*(const __Complex &amp;b) {\n        __Complex a = *this;\n        a *= b;\n        return a;\n    }\n};\nusing Complex = __Complex&lt;&gt;;\nconst double PI = acos(-1.0);\nconst double PI2 = PI / 2;\nconstexpr int getLen(int x) {\n    x |= x &gt;&gt; 1;\n    x |= x &gt;&gt; 2;\n    x |= x &gt;&gt; 4;\n    x |= x &gt;&gt; 8;\n    x |= x &gt;&gt; 16;\n    return x + 1;\n}\nconst int N = getLen(1000000 + 1000000);\nComplex r[N];\nint _ = [](){\n    int lenb = ceil(log2(N));\n    for (int i = 0 ; i &lt; lenb ; i++) {\n        int L = 1 &lt;&lt; i;\n        r[L] = {cos(PI2 / L), sin(PI2 / L)};\n        for (int j = L + 1 ; j &lt; 2 * L ; j++) {\n            r[j] = r[j - L] * r[L];\n        }\n    }\n    return 0;\n}();\nvoid FFT(Complex *a, int len) {\n    for (int i = len ; i &gt;= 2 ; i /= 2) {\n        int L = i / 2;\n        for (int j = 0 ; j &lt; L ; j++) {\n            Complex z = a[j + L];\n            a[j + L] = a[j] - z;\n            a[j] += z;\n        }\n        for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n            for (int k = 0 ; k &lt; L ; k++) {\n                Complex z = a[j + k + L] * r[res];\n                a[j + k + L] = a[j + k] - z;\n                a[j + k] += z;\n            }\n        }\n    }\n}\nvoid IFFT(Complex *a, int len) {\n    for (int i = 2 ; i &lt;= len ; i *= 2) {\n        int L = i / 2;\n        for (int j = 0 ; j &lt; L ; j++) {\n            Complex z = a[j + L];\n            a[j + L] = a[j] - z;\n            a[j] += z;\n        }\n        for (int j = i, res = 1 ; j &lt; len ; j += i, res++) {\n            for (int k = 0 ; k &lt; L ; k++) {\n                Complex z = a[j + k + L];\n                a[j + k + L] = (a[j + k] - z) * r[res];\n                a[j + k] += z;\n            }\n        }\n    }\n    double inv = 1.0 / len;\n    for (int i = 0 ; i &lt; len ; i++) {\n        a[i] *= inv;\n    }\n    reverse(a + 1, a + len);\n}\nvoid mul(Complex *a, Complex *b, int n, int m) {\n    int len = getLen(n + m);\n    FFT(a, len);\n    FFT(b, len);\n    for (int i = 0 ; i &lt; len ; i++) {\n        a[i] *=  b[i];\n    }\n    IFFT(a, len);\n}\nComplex a[N], b[N];\n</code></pre> \u4f8b\u9898 <p>#108. \u591a\u9879\u5f0f\u4e58\u6cd5 - LibreOJ</p>"},{"location":"Template/Math/Poly/NTT/","title":"\u5feb\u901f\u6570\u8bba\u53d8\u6362","text":"\u6a21\u7248 \u7ed3\u6784\u4f53\u975e\u7ed3\u6784\u4f53 C++<pre><code>// (167772161, 3)(469762049, 3)(754974721, 11)(998244353, 3)(1004535809, 3)\nconst int mod = 998244353;\nconst int g = 3;\nint add(int x, int y) {\n    return x &gt;= mod - y ? x + y - mod : x + y;\n}\nint sub(int x, int y) {\n    return x &lt; y ? x - y + mod : x - y;\n}\nint qpow(long long a, int b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Poly {\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    vector&lt;int&gt; w;\n    int _len = 0;\n    void init(int lenbL, int lenbR) {\n        if (lenbL &gt;= lenbR) return;\n        w.resize(1 &lt;&lt; (lenbR + 1));\n        for (int i = lenbL ; i &lt; lenbR ; i++) {\n            int L = 1 &lt;&lt; i;\n            long long k = qpow(g, (mod - 1) / (2 * L));\n            w[L] = 1;\n            for (int j = L + 1 ; j &lt; 2 * L ; j++) {\n                w[j] = w[j - 1] * k % mod;\n            }\n        }\n        _len = lenbR;\n    }\n    void DNT(vector&lt;int&gt; &amp;a) {\n        int len = a.size();\n        for (int k = len / 2 ; k &gt;= 1 ; k /= 2) {\n            int L = 2 * k;\n            for (int i = 0 ; i &lt; len ; i += L) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    long long z = a[i + j + k];\n                    a[i + j + k] = 1LL * sub(a[i + j], z) * w[j + k] % mod;\n                    a[i + j] = add(a[i + j], z);\n                }\n            }\n        }\n    }\n    void IDNT(vector&lt;int&gt; &amp;a) {\n        int len = a.size();\n        for (int k = 1 ; k &lt; len ; k *= 2) {\n            int L = 2 * k;\n            for (int i = 0 ; i &lt; len ; i += L) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    long long z = 1LL * a[i + j + k] * w[j + k] % mod;\n                    a[i + j + k] = sub(a[i + j], z);\n                    a[i + j] = add(a[i + j], z);\n                }\n            }\n        }\n        long long inv = qpow(len, mod - 2);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = a[i] * inv % mod;\n        }\n        reverse(begin(a) + 1, end(a));\n    }\n    vector&lt;int&gt; mul(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n        int n = a.size(), m = b.size();\n        int len = getLen(n + m);\n        int lenb = ceil(log2(len));\n        init(_len, lenb);\n        a.resize(len);\n        b.resize(len);\n        DNT(a);\n        DNT(b);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mod;\n        }\n        IDNT(a);\n        a.resize(n + m + 1);\n        return a;\n    }\n}; // Poly\n</code></pre> C++<pre><code>// (167772161, 3)(469762049, 3)(754974721, 11)(998244353, 3)(1004535809, 3)\nconst int mod = 998244353;\nconst int g = 3;\nconst int N = 26214500;\nint add(int x, int y) {\n    return x &gt;= mod - y ? x + y - mod : x + y;\n}\nint sub(int x, int y) {\n    return x &lt; y ? x - y + mod : x - y;\n}\nint qpow(long long a, int b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint get(int len) {\n    int lenb = 1;\n    while (1 &lt;&lt; lenb &lt;= len) {\n        lenb++;\n    }\n    return lenb;\n}\n\nint w[N];\nvoid init(int len) {\n    int lenb = ceil(log2(len));\n    for (int i = 0 ; i &lt; lenb ; i++) {\n        int L = 1 &lt;&lt; i;\n        long long k = qpow(g, (mod - 1) / (2 * L));\n        w[L] = 1;\n        for (int j = L + 1 ; j &lt; 2 * L ; j++) {\n            w[j] = w[j - 1] * k % mod;\n        }\n    }\n}\nvoid DNT(int *a, int len) {\n    for (int k = len / 2 ; k &gt;= 1 ; k /= 2) {\n        int L = 2 * k;\n        for (int i = 0 ; i &lt; len ; i += L) {\n            for (int j = 0 ; j &lt; k ; j++) {\n                long long z = a[i + j + k];\n                a[i + j + k] = 1LL * sub(a[i + j], z) * w[j + k] % mod;\n                a[i + j] = add(a[i + j], z);\n            }\n        }\n    }\n}\nvoid IDNT(int *a, int len) {\n    for (int k = 1 ; k &lt; len ; k *= 2) {\n        int L = 2 * k;\n        for (int i = 0 ; i &lt; len ; i += L) {\n            for (int j = 0 ; j &lt; k ; j++) {\n                long long z = 1LL * a[i + j + k] * w[j + k] % mod;\n                a[i + j + k] = sub(a[i + j], z);\n                a[i + j] = add(a[i + j], z);\n            }\n        }\n    }\n    long long inv = qpow(len, mod - 2);\n    for (int i = 0 ; i &lt; len ; i++) {\n        a[i] = a[i] * inv % mod;\n    }\n    reverse(a + 1, a + len);\n}\nvoid NTT(int *a, int *b, int n, int m) {\n    int lenb = get(n + m);\n    int len = 1 &lt;&lt; lenb;\n    init(len);\n    DNT(a, len);\n    DNT(b, len);\n    for (int i = 0 ; i &lt; len ; i++) {\n        a[i] = 1LL * a[i] * b[i] % mod;\n    }\n    IDNT(a, len);\n}\nint a[N], b[N];\n</code></pre> \u4f8b\u9898 <p>P3803 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u4e58\u6cd5\uff08FFT\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/NTT/#ntt","title":"\u5206\u6cbbNTT","text":"\u4e60\u9898 P5644 <p>P5644 [PKUWC2018] \u730e\u4eba\u6740 - \u6d1b\u8c37</p> <p>\u4ee4 \\(F(S)\\) \u4e3a\u96c6\u5408 \\(S\\) \u4e2d\u7684\u730e\u4eba\u5728 \\(1\\) \u53f7\u730e\u4eba\u540e\u9762\u6b7b\u7684\u6982\u7387\uff0c\\(G(S)\\) \u5728 \\(1\\) \u53f7\u730e\u4eba\u6b7b\u540e\uff0c\u730e\u4eba\u96c6\u5408\u6070\u597d\u4e3a \\(S\\) \u7684\u6982\u7387\u3002</p> <p>\u90a3\u4e48\u6709 \\(F(S)=\\sum_{S\\subseteq T}G(T)\\)</p> <p>\u7531\u5b50\u96c6\u53cd\u6f14\u5f97 \\(G(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}*F(T)\\)</p> <p>\u90a3\u4e48 \\(G(\\varnothing)=\\sum_S(-1)^{|S|}*F(S)\\)</p> <p>\\(F(S)=\\sum_{i=0}^{+\\infty}(\\dfrac{w(U)-w_1-w(S)}{w(U)})^i*\\dfrac{w_1}{w(U)}=\\dfrac{w_1}{w_1+w(S)}\\)</p> <p>\u5f97 \\(G(\\varnothing)=\\sum_S(-1)^{|S|}*\\dfrac{w_1}{w_1+w(S)}\\)</p> <p>\u7531\u4e8e \\(w(S)\\leq10^5\\), \u6240\u4ee5\u53ef\u4ee5\u679a\u4e3e \\(w(S)\\)</p> <p>\u5f97 \\(G(\\varnothing)=\\sum_{w(S)=i}(-1)^{|S|}*\\dfrac{w_1}{w_1+i}\\)</p> <p>\u7136\u540e\u8f6c\u6362\u6210\u4e00\u4e2a\u80cc\u5305\u7684\u65e0\u6807\u53f7\u8ba1\u6570\u95ee\u9898\uff0c\u5bf9\u751f\u6210\u51fd\u6570 \\(1-w_i\\) \u8fdb\u884c\u5206\u6cbbNTT\u6c42\u89e3\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint __OneWan_2024 = [](){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 0;\n}();\nint w[100005];\n// (167772161, 3)(469762049, 3)(754974721, 11)(998244353, 3)(1004535809, 3)\nconst int mod = 998244353;\nconst int g = 3;\nint add(int x, int y) {\n    return x &gt;= mod - y ? x + y - mod : x + y;\n}\nint sub(int x, int y) {\n    return x &lt; y ? x - y + mod : x - y;\n}\nint qpow(long long a, int b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Poly {\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    vector&lt;int&gt; w;\n    int _len = 0;\n    void init(int lenbL, int lenbR) {\n        if (lenbL &gt;= lenbR) return;\n        w.resize(1 &lt;&lt; (lenbR + 1));\n        for (int i = lenbL ; i &lt; lenbR ; i++) {\n            int L = 1 &lt;&lt; i;\n            long long k = qpow(g, (mod - 1) / (2 * L));\n            w[L] = 1;\n            for (int j = L + 1 ; j &lt; 2 * L ; j++) {\n                w[j] = w[j - 1] * k % mod;\n            }\n        }\n        _len = lenbR;\n    }\n    void DNT(vector&lt;int&gt; &amp;a) {\n        int len = a.size();\n        for (int k = len / 2 ; k &gt;= 1 ; k /= 2) {\n            int L = 2 * k;\n            for (int i = 0 ; i &lt; len ; i += L) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    int x = a[i + j], y = a[i + j + k];\n                    a[i + j] = add(x, y);\n                    a[i + j + k] = 1LL * sub(x, y) * w[j + k] % mod;\n                }\n            }\n        }\n    }\n    void IDNT(vector&lt;int&gt; &amp;a) {\n        int len = a.size();\n        for (int k = 1 ; k &lt; len ; k *= 2) {\n            int L = 2 * k;\n            for (int i = 0 ; i &lt; len ; i += L) {\n                for (int j = 0 ; j &lt; k ; j++) {\n                    int x = a[i + j], y = 1LL * a[i + j + k] * w[j + k] % mod;\n                    a[i + j] = add(x, y);\n                    a[i + j + k] = sub(x, y);\n\n                }\n            }\n        }\n        long long inv = qpow(len, mod - 2);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = a[i] * inv % mod;\n        }\n        reverse(begin(a) + 1, end(a));\n    }\n    vector&lt;int&gt; mul(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n        int n = a.size(), m = b.size();\n        int len = getLen(n + m);\n        int lenb = ceil(log2(len));\n        init(_len, lenb);\n        a.resize(len);\n        b.resize(len);\n        DNT(a);\n        DNT(b);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mod;\n        }\n        IDNT(a);\n        a.resize(n + m + 1);\n        return a;\n    }\n}; // Poly\nusing Poly::mul;\nvector&lt;int&gt; solve(int L, int R) {\n    if (L == R) {\n        vector&lt;int&gt; a(w[L] + 1);\n        a[0] = 1;\n        a[w[L]] = mod - 1;\n        return a;\n    }\n    int mid = L + R &gt;&gt; 1;\n    return mul(solve(L, mid), solve(mid + 1, R));   \n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; w[i];\n    }\n    auto res = solve(2, n);\n    long long ans = 0;\n    for (int i = 0 ; i &lt; res.size() ; i++) {\n        ans = (ans + 1LL * w[1] * res[i] % mod * qpow(i + w[1], mod - 2) % mod) % mod;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/Poly/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/","title":"\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5","text":"<p>P4245 \u3010\u6a21\u677f\u3011\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/#fft","title":"\u57fa\u4e8eFFT\u5b9e\u73b0","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 2097153;\nconst int CONQUER_BIT = 16;\nconst int CONQUER_MASK = (1 &lt;&lt; CONQUER_BIT) - 1;\ntemplate&lt;class T = double&gt; struct __Complex {\n    T x, y;\n    __Complex() = default;\n    __Complex(const T x, const T y) : x(x), y(y) {}\n    __Complex &amp;operator+=(const __Complex &amp;b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n    __Complex &amp;operator-=(const __Complex &amp;b) {\n        x -= b.x;\n        y -= b.y;\n        return *this;\n    }\n    __Complex &amp;operator*=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = x * b.x - y * b.y;\n        temp.y = x * b.y + y * b.x;\n        *this = temp;\n        return *this;\n    }\n    __Complex &amp;operator*=(const double &amp;b) {\n        this -&gt; x *= b;\n        this -&gt; y *= b;\n        return *this;\n    }\n    __Complex &amp;operator/=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = (x * b.x + y * b.y) / (b.x * b.x + b.y * b.y);\n        temp.y = (y * b.x - x * b.y) / (b.x * b.x + b.y * b.y);\n        *this = temp;\n        return *this;\n    }\n    __Complex &amp;operator/=(const double b) {\n        this -&gt; x /= b;\n        this -&gt; y /= b;\n        return *this;\n    }\n    __Complex operator+(const __Complex &amp;b) {\n        __Complex a = *this;\n        a += b;\n        return a;\n    }\n    __Complex operator-(const __Complex &amp;b) {\n        __Complex a = *this;\n        a -= b;\n        return a;\n    }\n    __Complex operator*(const __Complex &amp;b) {\n        __Complex a = *this;\n        a *= b;\n        return a;\n    }\n    __Complex operator/(const __Complex &amp;b) {\n        __Complex a = *this;\n        a /= b;\n        return a;\n    }\n    __Complex conj() {\n        return __Complex(x, -y);\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const __Complex &amp;a) {\n        os &lt;&lt; a.x &lt;&lt; \" \" &lt;&lt; a.y;\n        return os;\n    }\n};\nusing Complex = __Complex&lt;&gt;;\nconst long double PI = acos(-1.0);\nconst long double PI2 = PI / 2;\nconst Complex I(0, 1);\ntemplate&lt;class T&gt; long long Tint2(const T val, const int mod) {\n    long long v = val;\n    return ((v &lt; 0) ? (mod + (v - 1) / 2 % mod) : (v + 1) / 2) % mod;\n}\nnamespace Poly {\n    Complex r[N];\n    int preR = 0;\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    int init(int len) {\n        len = ceil(log2(len));\n        if (len &lt;= preR) {\n            return len;\n        }\n        preR = len;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int L = 1 &lt;&lt; i;\n            r[L] = Complex(cos(PI2 / L), sin(PI2 / L));\n            for (int j = L + 1 ; j &lt; (L &lt;&lt; 1) ; j++) {\n                r[j] = r[j - L] * r[L];\n            }\n        }\n        return len;\n    }\n    void FFT(Complex *a, int len) {\n        for (int i = len ; i &gt;= 2 ; i &gt;&gt;= 1) {\n            int L = i &gt;&gt; 1;\n            Complex *x = a, *y = x + L;\n            for (int j = 0 ; j &lt; L ; j++, x++, y++) {\n                Complex z = *y;\n                *y = *x - z;\n                *x += z;\n            }\n            Complex *rt = r + 1;\n            for (int j = i ; j &lt; len ; j += i, rt++) {\n                x = a + j, y = x + L;\n                for (int k = 0 ; k &lt; L ; k++, x++, y++) {\n                    Complex z = *y * *rt;\n                    *y = *x - z;\n                    *x += z;\n                }\n            }\n        }\n    }\n    void IFFT(Complex *a, int len) {\n        for (int i = 2 ; i &lt;= len ; i &lt;&lt;= 1) {\n            int L = i &gt;&gt; 1;\n            Complex *x = a, *y = x + L;\n            for (int j = 0 ; j &lt; L ; j++, x++, y++) {\n                Complex z = *y;\n                *y = *x - z;\n                *x += z;\n            }\n            Complex *rt = r + 1;\n            for (int j = i ; j &lt; len ; j += i, rt++) {\n                x = a + j, y = x + L;\n                for (int k = 0 ; k &lt; L ; k++, x++, y++) {\n                    Complex z = *y;\n                    *y = (*x - z) * *rt;\n                    *x += z;\n                }\n            }\n        }\n        double inv = 1.0 / len;\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] *= inv;\n        }\n        reverse(a + 1, a + len);\n    }\n    void FFT(Complex *a, Complex *b, int n, int m) {\n        int len = getLen(n + m);\n        init(len);\n        FFT(a, len);\n        FFT(b, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] *= b[i];\n        }\n        IFFT(a, len);\n    }\n    void MTT(int *a, int *b, int n, int m, int mod) {\n        int len = getLen(n + m);\n        int lg = init(len);\n        static Complex c[N], d[N], e[N];\n        for (int i = 0 ; i &lt;= n ; i++) {\n            c[i] = Complex(a[i] &amp; CONQUER_MASK, a[i] &gt;&gt; CONQUER_BIT);\n        }\n        for (int i = 0 ; i &lt;= m ; i++) {\n            d[i] = Complex(b[i] &amp; CONQUER_MASK, b[i] &gt;&gt; CONQUER_BIT);\n        }\n        fill(c + n + 1, c + len, Complex());\n        fill(d + m + 1, d + len, Complex());\n        FFT(c, len);\n        FFT(d, len);\n        copy(c, c + len, e);\n        c[0] *= d[0].x * 2;\n        e[0] *= d[0].y * 2;\n        for (int z = 0 ; z &lt; lg ; z++) {\n            int L = 1 &lt;&lt; z, mask = L - 1;\n            for (int i = L ; i &lt; (L &lt;&lt; 1) ; i++) {\n                Complex p = d[i], q = d[i ^ mask].conj();\n                Complex x = (p + q), y = (q - p) * I;\n                c[i] *= x;\n                e[i] *= y;\n            }\n        }\n        IFFT(c, len);\n        IFFT(e, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            long long cur = (Tint2(e[i].y, mod) &lt;&lt; (CONQUER_BIT &lt;&lt; 1))\n                + (Tint2(e[i].x + c[i].y, mod) &lt;&lt; CONQUER_BIT)\n                + (Tint2(c[i].x, mod));\n            a[i] = cur % mod;\n        }\n    }\n} // Poly\nusing Poly::MTT;\nint a[N], b[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, p;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    for (int i = 0 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n    for (int i = 0 ; i &lt;= m ; i++) cin &gt;&gt; b[i];\n    MTT(a, b, n, m, p);\n    for (int i = 0 ; i &lt;= n + m ; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/Poly/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/#ntt","title":"\u57fa\u4e8eNTT\u5b9e\u73b0","text":"<p>\u6700\u597d\u522b\u7528 TLE++</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define add(x, y) (x &gt;= mods[mod] - y ? x + y - mods[mod] : x + y)\n#define sub(x, y) (x &lt; y ? x - y + mods[mod] : x - y)\nconst int N = 2097153;\nint qpow(int a, int b, int mod) {\n    int res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = 1LL * res * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nconst int mods[3] = {469762049, 998244353, 1004535809};\nconst long long modd = 1LL * mods[0] * mods[1];\nconst long long mmod[3] = {\n    qpow(mods[1] % mods[0], mods[0] - 2, mods[0]),\n    qpow(mods[0] % mods[1], mods[1] - 2, mods[1]),\n    qpow(modd % mods[2], mods[2] - 2, mods[2])\n};\nnamespace Poly {\n    int w[3][N];\n    int preW = 0;\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    void init(int len) {\n        if (len &lt;= preW) {\n            return;\n        }\n        preW = len;\n        for (int z : {0, 1, 2}) {\n            for (int i = 1, j, k ; i &lt; len ; i &lt;&lt;= 1) {\n                for (w[z][j = i] = 1, k = qpow(3, (mods[z] - 1) / (i &lt;&lt; 1), mods[z]), j++ ; j &lt; i &lt;&lt; 1 ; j++) {\n                    w[z][j] = 1LL * w[z][j - 1] * k % mods[z];\n                }\n            }\n        }\n    }\n    void DNT(int *a, int len, int mod) {\n        for (int i, j, k = len &gt;&gt; 1, L, *W, *x, *y, z ; k ; k &gt;&gt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w[mod] + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = add(*y, 0);\n                    *y = 1LL * sub(*x, z) * *W % mods[mod];\n                    *x = add(*x, z);\n                }\n            }\n        }\n    }\n    void IDNT(int *a, int len, int mod) {\n        for (int i, j, k = 1, L, *W, *x, *y, z ; k &lt; len  ; k &lt;&lt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w[mod] + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = 1LL * *W * *y % mods[mod];\n                    *y = sub(*x, z);\n                    *x = add(*x, z);\n                }\n            }\n        }\n        reverse(a + 1, a + len);\n        for (int inv = qpow(len, mods[mod] - 2, mods[mod]), i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * inv % mods[mod];\n        }\n    }\n    void NTT(int *a, int *b, int n, int m, int mod) {\n        int len = getLen(n + m);\n        init(len);\n        DNT(a, len, mod);\n        DNT(b, len, mod);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mods[mod];\n        }\n        IDNT(a, len, mod);\n    }\n    void MTT(int *a, int *b, int n, int m, int mod) {\n        int len = getLen(n + m);\n        static int c[N], d[N], e[N], f[N];\n        for (int i = 0 ; i &lt;= n ; i++) {\n            c[i] = d[i] = e[i] = a[i];\n        }\n        copy(b, b + len, f);\n        NTT(c, f, n, m, 0);\n        copy(b, b + len, f);\n        NTT(d, f, n, m, 1);\n        copy(b, b + len, f);\n        NTT(e, f, n, m, 2);\n        for (int i = 0 ; i &lt; len ; i++) {\n            long long x1 = (__int128) c[i] * mods[1] % modd * mmod[0] % modd;\n            long long x2 = (__int128) d[i] * mods[0] % modd * mmod[1] % modd;\n            long long x = ((__int128) x1 + x2) % modd;\n            long long y = (((__int128) e[i] - x) % mods[2] + mods[2]) % mods[2] * mmod[2] % mods[2];\n            a[i] = (x % mod + (y % mod) * (modd % mod) % mod) % mod;\n        }\n    }\n} // Poly\nusing Poly::MTT;\nint a[N], b[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m, p;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    for (int i = 0 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n    for (int i = 0 ; i &lt;= m ; i++) cin &gt;&gt; b[i];\n    MTT(a, b, n, m, p);\n    for (int i = 0 ; i &lt;= n + m ; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/","title":"\u591a\u9879\u5f0f\u521d\u7b49\u51fd\u6570","text":""},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#1","title":"\u6a21\u677f1","text":"Code C++<pre><code>#define add(x, y) (x &gt;= mod - y ? x + y - mod : x + y)\n#define sub(x, y) (x &lt; y ? x - y + mod : x - y)\nconst int mod = 998244353;\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = 1LL * res * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nvector&lt;int&gt; w;\nint preN;\nvoid pre(const int n, const int lg) {\n    w.resize(n + 1);\n    w[0] = 1;\n    w[1LL &lt;&lt; lg] = qpow(3, mod - 1 &gt;&gt; lg + 2);\n    for (int i = lg ; i &gt;= 1 ; i--) {\n        w[1LL &lt;&lt; i - 1] = 1LL * w[1LL &lt;&lt; i] * w[1LL &lt;&lt; i] % mod;\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        w[i] = 1LL * w[i &amp; i - 1] * w[i &amp; -i] % mod;\n    }\n}\nstruct Poly {\n    vector&lt;int&gt; a;\n    Poly(const int size) {\n        a.resize(size);\n    }\n    Poly operator&lt;&lt;(const size_t x) const {\n        Poly res(a.size() + x);\n        for (int i = 0 ; i &lt; int(a.size()) ; i++) {\n            res[i + x] = a[i];\n        }\n        return res;\n    }\n    Poly operator&gt;&gt;(const size_t x) const {\n        int len = int(a.size()) - x;\n        if (len &lt;= 0) {\n            return Poly(0);\n        }\n        Poly res(len);\n        for (int i = 0 ; i &lt; int(a.size()) ; i++) {\n            res[i] = a[i + x];\n        }\n        return res;\n    }\n    Poly operator*(const int x) {\n        Poly res(*this);\n        int len = a.size();\n        for (int i = 0 ; i &lt; len ; i++) {\n            res[i] = 1LL * res[i] * x % mod;\n        }\n        return res;\n    }\n    int &amp;operator[](const int x) {\n        return a[x];\n    }\n    void resize(const int n) {\n        a.resize(n);\n    }\n    int size() {\n        return a.size();\n    }\n    void DIF() {\n        int n = a.size();\n        for (int L = n &gt;&gt; 1 ; L ; L &gt;&gt;= 1) {\n            for (int i = 0, k = 0 ; i &lt; n ; i += L &lt;&lt; 1, k++) {\n                for (int j = 0 ; j &lt;= L - 1 ; j++) {\n                    int x = a[i + j], y = 1LL * a[i + j + L] * w[k] % mod;\n                    a[i + j] = add(x, y);\n                    a[i + j + L] = sub(x, y);\n                }\n            }\n        }\n    }\n    void DIT() {\n        int n = a.size();\n        for (int L = 1 ; L &lt; n ; L &lt;&lt;= 1) {\n            for (int i = 0, k = 0 ; i &lt; n ; i += (L &lt;&lt; 1), k++) {\n                for (int j = 0 ; j &lt; L ; j++) {\n                    int x = a[i + j], y = a[i + j + L];\n                    a[i + j] = add(x, y);\n                    a[i + j + L] = 1LL * sub(x, y) * w[k] % mod;\n                }\n            }\n        }\n        for (int i = 1 ; i &lt;= n - 1 &gt;&gt; 1 ; i++) {\n            a[i] ^= a[n - i] ^= a[i] ^= a[n - i];\n        }\n        int inv = qpow(n, mod - 2);\n        for (int i = 0 ; i &lt; n ; i++) {\n            a[i] = 1LL * a[i] * inv % mod;\n        }\n    }\n    void mul(Poly &amp;x) {\n        Poly z(x);\n        int n = 1, lg = 0, len = a.size() + x.size();\n        while (n &lt; len) {\n            n &lt;&lt;= 1;\n            lg++;\n        }\n        if (n &gt; preN) {\n            pre(n, lg);\n            preN = n;\n        }\n        a.resize(n);\n        z.resize(n);\n        DIF();\n        z.DIF();\n        for (int i = 0 ; i &lt; n ; i++) {\n            a[i] = 1LL * a[i] * z[i] % mod;\n        }\n        DIT();\n        a.resize(n - 1);\n    }\n    Poly inv() {\n        int len = a.size();\n        int n = 1, lg = 0;\n        while (n &lt; len) {\n            n &lt;&lt;= 1;\n            lg++;\n        }\n        if (n &gt; preN) {\n            pre(n, lg);\n            preN = n;\n        }\n        Poly res(1);\n        Poly temp(1);\n        res.a.reserve(n &lt;&lt; 1);\n        temp.a.reserve(n &lt;&lt; 1);\n        res[0] = qpow(a[0], mod - 2);\n        for (int t = 2 ; t &lt;= n ; t &lt;&lt;= 1) {\n            int t2 = t &lt;&lt; 1;\n            res.resize(t2);\n            temp.resize(t2);\n            copy(begin(a), begin(a) + t, begin(temp.a));\n            res.DIF();\n            temp.DIF();\n            for (int i = 0 ; i &lt; t2 ; i++) {\n                res[i] = (2LL - 1LL * temp[i] * res[i] % mod + mod) % mod * res[i] % mod; \n            }\n            res.DIT();\n            fill(begin(res.a) + t, begin(res.a) + t2, 0);\n        }\n        return res;\n    }\n    Poly derivative() {\n        int len = a.size();\n        Poly res(len);\n        for (int i = 1 ; i &lt; len ; i++) {\n            res[i - 1] = 1LL * a[i] * i % mod;\n        }\n        res[len - 1] = 0;\n        return res;\n    }\n    Poly integrate() {\n        int len = a.size();\n        Poly res(len);\n        for (int i = 1 ; i &lt; len ; i++) {\n            res[i] = 1LL * a[i - 1] * qpow(i, mod - 2) % mod;\n        }\n        res[0] = 0;\n        return res;\n    }\n    Poly ln() {\n        Poly x = derivative(), y = inv();\n        x.mul(y);\n        return x.integrate();\n    }\n    Poly exp() {\n        int len = a.size();\n        int n = 1, lg = 0;\n        while (n &lt; len) {\n            n &lt;&lt;= 1;\n            lg++;\n        }\n        if (n &gt; preN) {\n            pre(n, lg);\n            preN = n;\n        }\n        Poly res(1);\n        res.a.reserve(n &lt;&lt; 1);\n        res[0] = 1;\n        for (int t = 2 ; t &lt;= n ; t &lt;&lt;= 1) {\n            int t2 = t &lt;&lt; 1;\n            Poly ln = res.ln();\n            res.resize(t2);\n            ln.resize(t2);\n            ln[0] = sub(a[0] + 1, ln[0]);\n            for (int i = 1 ; i &lt; t ; i++) {\n                ln[i] = sub(a[i], ln[i]);\n            }\n            res.DIF();\n            ln.DIF();\n            for (int i = 0 ; i &lt; t2 ; i++) {\n                res[i] = 1LL * res[i] * ln[i] % mod;\n            }\n            res.DIT();\n            fill(begin(res.a) + t, begin(res.a) + t2, 0);\n        }\n        return res;\n    }\n}; // Poly\n</code></pre>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#2","title":"\u6a21\u677f2","text":"Code C++<pre><code>#define add(x, y) (x &gt;= mod - y ? x + y - mod : x + y)\n#define sub(x, y) (x &lt; y ? x - y + mod : x - y)\nconst int mod = 998244353;\nconst int N = 2097153;\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = 1LL * res * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Poly {\n    int w[N];\n    int preW = 0;\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    const int inv2 = qpow(2, mod - 2);\n    void init(int len) {\n        if (len &lt;= preW) {\n            return;\n        }\n        preW = len;\n        for (int i = 1, j, k ; i &lt; len ; i &lt;&lt;= 1) {\n            for (w[j = i] = 1, k = qpow(3, (mod - 1) / (i &lt;&lt; 1)), j++ ; j &lt; i &lt;&lt; 1 ; j++) {\n                w[j] = 1LL * w[j - 1] * k % mod;\n            }\n        }\n    }\n    void DNT(int *a, int len) {\n        for (int i, j, k = len &gt;&gt; 1, L, *W, *x, *y, z ; k ; k &gt;&gt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = *y;\n                    *y = 1LL * sub(*x, z) * *W % mod;\n                    *x = add(*x, z);\n                }\n            }\n        }\n    }\n    void IDNT(int *a, int len) {\n        for (int i, j, k = 1, L, *W, *x, *y, z ; k &lt; len  ; k &lt;&lt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = 1LL * *W * *y % mod;\n                    *y = sub(*x, z);\n                    *x = add(*x, z);\n                }\n            }\n        }\n        reverse(a + 1, a + len);\n        for (int inv = qpow(len, mod - 2), i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * inv % mod;\n        }\n    }\n    int NTT(int *a, int *b, int n, int m) {\n        int len = getLen(n + m);\n        init(len);\n        DNT(a, len);\n        DNT(b, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mod;\n        }\n        IDNT(a, len);\n        return len;\n    }\n    void inv(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = qpow(a[0], mod - 2);\n            return;\n        }\n        inv(a, b, n + 1 &gt;&gt; 1);\n        int len = getLen(n &lt;&lt; 1);\n        init(len);\n        static int c[N];\n        copy(a, a + n, c);\n        fill(c + n, c + len, 0);\n        DNT(b, len);\n        DNT(c, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            b[i] = (2LL - 1LL * c[i] * b[i] % mod + mod) % mod * b[i] % mod;\n        }\n        IDNT(b, len);\n        fill(b + n, b + len, 0);\n    }\n    void derivative(int *a, int n) {\n        for (int i = 1 ; i &lt; n ; i++) {\n            a[i - 1] = 1LL * i * a[i] % mod;\n        }\n        a[n - 1] = 0;\n    }\n    void integrate(int *a, int n) {\n        for (int i = n - 1 ; i &gt; 0 ; i--) {\n            a[i] = 1LL * qpow(i, mod - 2) * a[i - 1] % mod;\n        }\n        a[0] = 0;\n    }\n    void ln(int *a, int *b, int n) {\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        copy(a, a + len, b);\n        fill(c, c + len, 0);\n        inv(b, c, n);\n        derivative(b, n);\n        NTT(b, c, n, n);\n        integrate(b, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n    void exp(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = 1;\n            return;\n        }\n        exp(a, b, n + 1 &gt;&gt; 1);\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        fill(c, c + len, 0);\n        ln(b, c, n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            c[i] = sub(a[i], c[i]);\n        }\n        c[0] = add(c[0], 1);\n        NTT(b, c, n, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n    void sqrt(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = 1;\n            return;\n        }\n        sqrt(a, b, n + 1 &gt;&gt; 1);\n        static int c[N], d[N];\n        int len = getLen(n &lt;&lt; 1);\n        init(len);\n        fill(c, c + len, 0);\n        fill(d, d + len, 0);\n        inv(a, c, n);\n        copy(a, a + n, d);\n        DNT(b, len);\n        DNT(c, len);\n        DNT(d, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            b[i] = (b[i] % mod + 1LL * c[i] * d[i] % mod) % mod * inv2 % mod;\n        }\n        IDNT(b, len);\n        fill(b + n, b + len, 0);\n    }\n    void div(int *a, int *b, int n, int m) {\n        int len = getLen(n + m);\n        static int c[N], d[N], e[N];\n        copy(a, a + len, c);\n        copy(b, b + len, d);\n        reverse(a, a + n + 1);\n        reverse(b, b + m + 1);\n        inv(b, e, n - m + 2);\n        fill(e + n - m + 2, e + len, 0);\n        NTT(a, e, n, n - m + 2);\n        reverse(a, a + n - m + 1);\n        fill(a + n - m + 1, a + len, 0);\n        copy(a, a + len, e);\n        NTT(d, e, m, n);\n        for (int i = 0 ; i &lt; len ; i++) {\n            b[i] = sub(c[i], d[i]);\n        }\n    }\n} // Poly\nusing Poly::NTT;\nusing Poly::DNT;\nusing Poly::IDNT;\nusing Poly::inv;\nusing Poly::ln;\nusing Poly::exp;\nusing Poly::sqrt;\nusing Poly::div;\nint a[N], b[N];\n</code></pre>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#-oncdotlogn","title":"\u591a\u9879\u5f0f\u6c42\u9006 - \\(O(n\\cdot\\log{n})\\)","text":"<p>P4238 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u4e58\u6cd5\u9006 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#-oncdotlogn_1","title":"\u591a\u9879\u5f0f\u5bf9\u6570\u51fd\u6570 - \\(O(n\\cdot\\log{n})\\)","text":"<p>P4725 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5bf9\u6570\u51fd\u6570\uff08\u591a\u9879\u5f0f ln\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#-oncdotlogn2","title":"\u591a\u9879\u5f0f\u6307\u6570\u51fd\u6570 - \\(O(n\\cdot\\log{n}^2)\\)","text":"<p>P4726 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6307\u6570\u51fd\u6570\uff08\u591a\u9879\u5f0f exp\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#-oncdotlogn2_1","title":"\u591a\u9879\u5f0f\u5f00\u6839 - \\(O(n\\cdot\\log{n}^2)\\)","text":"<p>P5205 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/#-oncdotlogn_2","title":"\u591a\u9879\u5f0f\u9664\u6cd5&amp;\u53d6\u6a21 - \\(O(n\\cdot\\log{n})\\)","text":"<p>P4512 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u9664\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/Math/Poly/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%82%E9%A2%98/","title":"\u2460","text":"\\[ A[i]=(\\sum_{j=i}^{min(i+L-1,n)}A[j])\\mod{P} \\] <p>\u6bcf\u6b21\u5bf9i\u4ece1\u5230n\u505a\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u95ee\u505am\u6b21\u64cd\u4f5c\u540eA[i]\u7684\u503c?</p> Code C++<pre><code>int a[N], b[N];\nvoid solve() {\n    int n, L, m;\n    cin &gt;&gt; n &gt;&gt; L &gt;&gt; m;\n    for (int i = 0, t = 1 ; i * L &lt; n &amp;&amp; i &lt;= m ; i++) {\n        a[i * L] = t;\n        t = 1LL * (mod - 1) * t % mod * (m - i) % mod * qpow(i + 1, mod - 2) % mod;\n    }\n    for (int i = 0, t = 1 ; i &lt; n ; i++) {\n        b[i] = t;\n        t = 1LL * t * (i + m) % mod * qpow(i + 1, mod - 2) % mod;\n    }\n    int lim = NTT(a, b, n, n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; b[i];\n    }\n    reverse(b, b + n);\n    fill(a + n, a + lim, 0);\n    fill(b + n, b + lim, 0);\n    NTT(a, b, n, n);\n    reverse(a, a + n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cout &lt;&lt; \" \" &lt;&lt; a[i];\n    }\n    fill(a, a + lim, 0);\n    fill(b, b + lim, 0);\n}\n</code></pre>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/","title":"\u6570\u503c\u79ef\u5206","text":""},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/#_2","title":"\u8f9b\u666e\u68ee\u6cd5","text":""},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/#_3","title":"\u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u6cd5","text":"<p>P4525 \u3010\u6a21\u677f\u3011\u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u6cd5 1 - \u6d1b\u8c37</p> <p>P4526 \u3010\u6a21\u677f\u3011\u81ea\u9002\u5e94\u8f9b\u666e\u68ee\u6cd5 2 - \u6d1b\u8c37</p> Code C++<pre><code>template&lt;class T&gt; struct Simpson {\n    function&lt;T(T)&gt; f;\n    Simpson(function&lt;T(T)&gt; f) : f(f) {}\n    T simpson(T L, T R) {\n        T mid = (L + R) / 2;\n        return (R - L) * (f(L) + 4 * f(mid) + f(R)) / 6;\n    }\n    T asr(T L, T R, T eps, T ans, int step) {\n        T mid = (L + R) / 2;\n        T fL = simpson(L, mid), fR = simpson(mid, R);\n        if (fabs(fL + fR - ans) &lt;= 15 * eps &amp;&amp; step &lt; 0) {\n            return fL + fR + (fL + fR - ans) / 15;\n        }\n        return asr(L, mid, eps / 2, fL, step - 1) + asr(mid, R, eps / 2, fR, step - 1);\n    }\n    T operator()(T L, T R) {\n        return (*this)(L, R, 1e-1001);\n    }\n    T operator()(T L, T R, T eps) {\n        return asr(L, R, eps, simpson(L, R), eps);\n    }\n}; // Simpson\n</code></pre>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/#_4","title":"\u9f99\u8d1d\u683c\u7b97\u6cd5","text":"Code C++<pre><code>template&lt;class T&gt; struct Romberg {\n    function&lt;T(T)&gt; f;\n    Romberg(function&lt;T(T)&gt; f) : f(f) {}\n    T ctqf(T L, T R, T h) {\n        static T ans;\n        ans = 0.0;\n        for (T i = L + h / 2 ; i &lt; R ; i += h) {\n            ans += f(i);\n        }\n        return ans;\n    }\n    T operator()(T L, T R, T eps) {\n        static T T1, T2, S1, S2, C1, C2, R1, R2, h, S;\n        static int cnt, k;\n        cnt = 0;\n        k = 1;\n        h = R - L;\n        T1 = (f(L) + f(R)) * h / 2;\n        while (true) {\n            S = ctqf(L, R, h);\n            T2 = (T1 + h * S) / 2;\n            S2 = (4 * T2 - T1) / 3;\n            h /= 2;\n            T1 = T2;\n            S1 = S2;\n            C1 = C2;\n            R1 = R2;\n            cnt++;\n            if (k == 1) {\n                k++;\n                continue;\n            }\n            C2 = (16 * S2 - S1) / 15;\n            if (k == 2) {\n                k++;\n                continue;\n            }\n            R2 = (64 * C2 - C1) / 63;\n            if (k == 3) {\n                k++;\n                continue;\n            }\n            if (fabs(R1 - R2) &lt; eps || cnt &gt; 100) {\n                break;\n            }\n        }\n        return R2;\n    }\n}; // Romberg\n</code></pre>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"\u725b\u987f\u8fed\u4ee3\u6cd5","text":"<p>\u5728 \\([a,b]\\) \u4e0a\u8fde\u7eed\u4e14\u5355\u8c03\u7684\u51fd\u6570 \\(f(x)\\)\uff0c\u6c42\u65b9\u7a0b \\(f(x)=0\\) \u7684\u8fd1\u4f3c\u89e3 $$ x_{i+1}=x_i-\\dfrac{f(x_i)}{f^\\prime(x_i)} $$</p>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/#_2","title":"\u6c42\u89e3\u5e73\u65b9\u6839","text":"Code C++<pre><code>const double eps = 1e-15;\ntemplate&lt;class T&gt; T Sqrt(T n) {\n    double x = 1;\n    while (true) {\n        double nx = (x + n / x) / 2;\n        if (fabs(x - nx) &lt; eps) {\n            break;\n        }\n        x = nx;\n    }\n    return x;\n}\n</code></pre>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","title":"\u9ad8\u65af\u6d88\u5143","text":""},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/#_2","title":"\u9ad8\u65af\u6d88\u5143\u89e3\u7ebf\u6027\u65b9\u7a0b\u7ec4","text":"<p>P3389 \u3010\u6a21\u677f\u3011\u9ad8\u65af\u6d88\u5143\u6cd5 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst double eps = 1e-8;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;vector&lt;double&gt;&gt; a(n + 2, vector&lt;double&gt;(n + 2));\n    for (int i = 1 ; i &lt;= n + 1 ; i++) {\n        for (int j = 1 ; j &lt;= n + 1 ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int mx = i;\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            if (fabs(a[j][i]) &gt; fabs(a[mx][i])) {\n                mx = j;\n            }\n        }\n        if (fabs(a[mx][i]) &lt; eps) {\n            cout &lt;&lt; \"No Solution\";\n            return 0;\n        }\n        if (i != mx) {\n            swap(a[i], a[mx]);\n        }\n        double div = a[i][i];\n        for (int j = i ; j &lt;= n + 1 ; j++) {\n            a[i][j] /= div;\n        }\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            div = a[j][i];\n            for (int k = i ; k &lt;= n + 1 ; k++) {\n                a[j][k] -= a[i][k] * div;\n            }\n        }\n    }\n    vector&lt;double&gt; ans(n + 1);\n    ans[n] = a[n][n + 1];\n    for (int i = n - 1 ; i &gt;= 1 ; i--) {\n        ans[i] = a[i][n + 1];\n        for (int j = i + 1 ; j &lt;= n ; j++) {\n            ans[i] -= (a[i][j] * ans[j]);\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/#_3","title":"\u9ad8\u65af\u6d88\u5143\u6cd5\u89e3\u5f02\u6216\u65b9\u7a0b\u7ec4","text":"<p>P2447 [SDOI2010] \u5916\u661f\u5343\u8db3\u866b - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint n, m;\nbitset&lt;1001&gt; matrix[2001];\nint Gauss() {\n    int res = -1;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        int cur = i;\n        while (cur &lt;= m &amp;&amp; !matrix[cur].test(i)) {\n            cur++;\n        }\n        if (cur &gt; m) {\n            return 0;\n        }\n        res = max(res, cur);\n        if (cur != i) {\n            swap(matrix[cur], matrix[i]);\n        }\n        for (int j = 1 ; j &lt;= m ; j++) {\n            if (i != j &amp;&amp; matrix[j].test(i)) {\n                matrix[j] ^= matrix[i];\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        string str;\n        int x;\n        cin &gt;&gt; str &gt;&gt; x;\n        for (int j = 0 ; j &lt; n ; j++) {\n            matrix[i].set(j + 1,(str[j] == '1'));\n        }\n        matrix[i].set(0, x);\n    }\n    int ret = Gauss();\n    if (ret) {\n        cout &lt;&lt; ret &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= n ; i++) {\n            cout &lt;&lt; (matrix[i].test(0) ? \"?y7M#\" : \"Earth\") &lt;&lt; \"\\n\";\n        }\n    } else {\n        cout &lt;&lt; \"Cannot Determine\" &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/","title":"\u7ebf\u6027\u57fa","text":""},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_2","title":"\u6a21\u677f","text":"<p>P3812 \u3010\u6a21\u677f\u3011\u7ebf\u6027\u57fa - \u6d1b\u8c37</p> Code C++<pre><code>template&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_3","title":"\u6807\u53f7\u7ebf\u6027\u57fa","text":"<p>P4570 [BJWC2011] \u5143\u7d20 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f, idx;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n        idx.assign(_M + 1, -1);\n    }\n    bool insert(T x, int id) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (idx[i] == -1) {\n                    idx[i] = id;\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n}; // Linear_Basis\nstruct Node {\n    long long a;\n    int b;\n    Node() = default;\n    Node(long long a, int b) : a(a), b(b) {}\n    bool operator&lt;(const Node &amp;x) {\n        return b &gt; x.b;\n    }\n};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Node&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i].a &gt;&gt; a[i].b;\n    }\n    sort(begin(a), end(a));\n    Linear_Basis&lt;long long, 62&gt; LB;\n    LB.init();\n    for (int i = 0 ; i &lt; n ; i++) {\n        LB.insert(a[i].a, i);\n    }\n    long long ans = 0;\n    for (int i = 62 ; i &gt;= 0 ; i--) {\n        if (LB.idx[i] != -1) {\n            ans += a[LB.idx[i]].b;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P4301 [CQOI2013] \u65b0Nim\u6e38\u620f - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(begin(a), end(a), greater&lt;int&gt;());\n    Linear_Basis&lt;int, 30&gt; LB;\n    LB.init();\n    long long ans = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        if (!LB.insert(a[i])) {\n            ans += a[i];\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_4","title":"\u5b9e\u6570\u7ebf\u6027\u57fa","text":"<p>P3265 [JLOI2015] \u88c5\u5907\u8d2d\u4e70 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    vector&lt;double&gt; a;\n    int w;\n    bool operator&lt;(const Node &amp;x) const {\n        return w &lt; x.w;\n    }\n};\nconst double eps = 1e-5;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;Node&gt; A(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        A[i].a.resize(m);\n        for (int j = 0 ; j &lt; m ; j++) {\n            cin &gt;&gt; A[i].a[j];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; A[i].w;\n    }\n    sort(begin(A) + 1, end(A));\n    vector&lt;int&gt; idx(m);\n    long long ans = 0;\n    int cnt = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; m ; j++) {\n            if (fabs(A[i].a[j]) &lt; eps) continue;\n            if (idx[j] == 0) {\n                idx[j] = i;\n                cnt++;\n                ans += A[i].w;\n                break;\n            } else {\n                double z = A[i].a[j] / A[idx[j]].a[j];\n                for (int k = j ; k &lt; m ; k++) {\n                    A[i].a[k] -= z * A[idx[j]].a[k];\n                }\n            }\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; \" \" &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#k","title":"k\u5927\u5f02\u6216\u548c","text":"<p>#114. k \u5927\u5f02\u6216\u548c - LibreOJ</p> Code <p>'''c++</p>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#include","title":"include  <p>using namespace std; // 2023 OneWan template struct Linear_Basis {     int tot;     vector f, d;     bool flag;     Linear_Basis() = default;     void init() {         f.assign(_M + 1, 0);         d.assign(_M + 1, 0);         tot = 0;         flag = false;     }     bool insert(T x) {         for (int i = _M ; i &gt;= 0 ; i--) {             if (x &amp; T(1) &lt;&lt; i) {                 if (f[i] == 0) {                     f[i] = x;                     return true;                 }                 x ^= f[i];             }         }         flag = true;         return false;     }     void build() {         for (int i = 0 ; i &lt;= _M ; i++) {             for (int j = i + 1 ; j &lt;= _M ; j++) {                 if (f[j] &amp; T(1) &lt;&lt; i) {                     f[j] ^= f[i];                 }             }             if (f[i]) {                 d[tot++] = f[i];             }         }     }     T query(long long rank) {         if (flag) {             rank--;         }         if (rank == 0) return 0;         if (rank &gt;= T(1) &lt;&lt; tot) return -1;         T ans = 0;         for (int i = _M ; i &gt;= 0 ; i--) {             if (rank &amp; T(1) &lt;&lt; i) {                 ans ^= d[i];             }         }         return ans;     } }; // Linear_Basis int main() {     ios::sync_with_stdio(0);     cin.tie(0);     cout.tie(0);     int n;     cin &gt;&gt; n;     vector a(n);     Linear_Basis LB;     LB.init();     for (int i = 0 ; i &lt; n ; i++) {         cin &gt;&gt; a[i];         LB.insert(a[i]);     }     LB.build();     int m;     cin &gt;&gt; m;     for (int i = 0 ; i &lt; m ; i++) {         long long k;         cin &gt;&gt; k;         cout &lt;&lt; LB.query(k) &lt;&lt; \"\\n\";     }     return 0; } '''","text":""},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_5","title":"\u533a\u95f4\u6700\u5927\u5f02\u6216\u548c(\u5728\u7ebf)","text":""},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_6","title":"\u4e0d\u5e26\u4fee","text":"<p>Problem - F - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f, idx;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n        idx.assign(_M + 1, -1);\n    }\n    bool insert(Linear_Basis LB, T x, int id) {\n        *this = LB;\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (idx[i] == -1) {\n                    idx[i] = id;\n                    f[i] = x;\n                    return true;\n                } else if (idx[i] &lt; id) {\n                    swap(idx[i], id);\n                    swap(f[i], x);\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(int k) {\n        T ans = 0;\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (f[i] &amp;&amp; idx[i] &gt;= k) {\n                ans = max(ans, ans ^ f[i]);\n            }\n        }\n        return ans;\n    }\n}; // Linear_Basis\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;Linear_Basis&lt;int&gt;&gt; LB(n + 1);\n    LB[0].init();\n    vector&lt;int&gt; a(n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        LB[i].insert(LB[i - 1], a[i], i);\n    }\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        cout &lt;&lt; LB[R].query(L) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_7","title":"\u5e26\u4fee(\u5355\u70b9\u6dfb\u52a0)","text":"<p>P4839 P \u54e5\u7684\u6876 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 50005;\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nstruct Node {\n    int L, R;\n    Node() = default;\n    Node(int L, int R) : L(L), R(R) {}\n} tree[N &lt;&lt; 2];\nLinear_Basis&lt;int, 30&gt; f[N &lt;&lt; 2];\nvoid modify(int p, int pos, int k) {\n    if (pos &lt; tree[p].L || pos &gt; tree[p].R) return;\n    if (tree[p].L == tree[p].R) {\n        f[p].insert(k);\n        return;\n    }\n    modify(p &lt;&lt; 1, pos, k);\n    modify(p &lt;&lt; 1 | 1, pos, k);\n    f[p] = f[p &lt;&lt; 1] + f[p &lt;&lt; 1 | 1];\n}\nLinear_Basis&lt;int, 30&gt; query(int p, int L, int R) {\n    if (L &lt;= tree[p].L &amp;&amp; tree[p].R &lt;= R) {\n        return f[p];\n    }\n    int mid = tree[p].L + tree[p].R &gt;&gt; 1;\n    if (R &lt;= mid) return query(p &lt;&lt; 1, L, R);\n    else if (L &gt; mid) return query(p &lt;&lt; 1 | 1, L, R);\n    return query(p &lt;&lt; 1, L, R) + query(p &lt;&lt; 1 | 1, L, R);\n}\nvoid build(int p, int L, int R) {\n    tree[p].L = L;\n    tree[p].R = R;\n    f[p].init();\n    if (L == R) {\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    build(1, 1, m);\n    for (int i = 0 ; i &lt; n ; i++) {\n        int op, x, y;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        if (op == 1) {\n            modify(1, x, y);\n        } else {\n            cout &lt;&lt; query(1, x, y).query() &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_8","title":"\u5e26\u4fee(\u533a\u95f4\u5f02\u6216)","text":"<p>P5607 [Ynoi2013] \u65e0\u529b\u56de\u5929 NOI2017 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 50005;\nconst int M = 30;\ntemplate&lt;class T, const int _M = ::M&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nstruct Node {\n    int L, R;\n    Node() = default;\n    Node(int L, int R) : L(L), R(R) {}\n} tree[N &lt;&lt; 2];\nLinear_Basis&lt;int&gt; f[N &lt;&lt; 2];\nint a[N];\nvoid modify(int p, int pos, int k) {\n    if (pos &lt; tree[p].L || pos &gt; tree[p].R) return;\n    if (tree[p].L == tree[p].R) {\n        a[pos] ^= k;\n        f[p].init();\n        f[p].insert(a[pos]);\n        return;\n    }\n    modify(p &lt;&lt; 1, pos, k);\n    modify(p &lt;&lt; 1 | 1, pos, k);\n    f[p] = f[p &lt;&lt; 1] + f[p &lt;&lt; 1 | 1];\n}\nLinear_Basis&lt;int&gt; query(int p, int L, int R) {\n    if (L &lt;= tree[p].L &amp;&amp; tree[p].R &lt;= R) {\n        return f[p];\n    }\n    int mid = tree[p].L + tree[p].R &gt;&gt; 1;\n    if (R &lt;= mid) return query(p &lt;&lt; 1, L, R);\n    if (L &gt; mid) return query(p &lt;&lt; 1 | 1, L, R);\n    return query(p &lt;&lt; 1, L, R) + query(p &lt;&lt; 1 | 1, L, R);\n}\nint n, sumxor[N];\nint lowbit(int x) {\n    return x &amp; -x;\n}\nvoid add(int x, int k) {\n    while (x &lt;= n) {\n        sumxor[x] ^= k;\n        x += lowbit(x);\n    }\n}\nint query(int x) {\n    int res = 0;\n    while (x) {\n        res ^= sumxor[x];\n        x -= lowbit(x);\n    }\n    return res;\n}\nvoid build(int p, int L, int R) {\n    tree[p].L = L;\n    tree[p].R = R;\n    if (L == R) {\n        f[p].init();\n        f[p].insert(a[L]);\n        return;\n    }\n    int mid = L + R &gt;&gt; 1;\n    build(p &lt;&lt; 1, L, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, R);\n    f[p] = f[p &lt;&lt; 1] + f[p &lt;&lt; 1 | 1];\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = n ; i &gt;= 2 ; i--) {\n        a[i] ^= a[i - 1];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        add(i, a[i]);\n    }\n    build(1, 1, n);\n    for (int i = 0 ; i &lt; m ; i++) {\n        int op, L, R, v;\n        cin &gt;&gt; op &gt;&gt; L &gt;&gt; R &gt;&gt; v;\n        if (op == 1) {\n            modify(1, L, v);\n            add(L, v);\n            if (R &lt; n) {\n                modify(1, R + 1, v);\n                add(R + 1, v);\n            }\n        } else {\n            int temp = query(L);\n            Linear_Basis&lt;int&gt; res;\n            res.init();\n            if (L != R) res = query(1, L + 1, R);\n            res.insert(temp);\n            cout &lt;&lt; res.query(v) &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_9","title":"\u6811\u4e0a\u6700\u5927\u5f02\u6216\u548c","text":"<p>P3292 [SCOI2016] \u5e78\u8fd0\u6570\u5b57 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nLinear_Basis&lt;long long, 60&gt; f[20005][16];\nvector&lt;int&gt; adj[20005];\nint fa[20005][16], deep[20005];\nlong long val[20005];\nvoid dfs(int u, int p) {\n    deep[u] = deep[p] + 1;\n    fa[u][0] = p;\n    f[u][0].init();\n    f[u][0].insert(val[u]);\n    for (int i = 1 ; (1 &lt;&lt; i) &lt;= deep[u] ; i++) {\n        f[u][i] = f[u][i - 1] + f[fa[u][i - 1]][i - 1];\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    }\n    for (auto &amp;to : adj[u]) {\n        if (to == p) continue;\n        dfs(to, u);\n    }\n}\nint LCA(int x, int y) {\n    if (deep[x] &gt; deep[y]) swap(x, y);\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (deep[x] &gt; deep[fa[y][i]]) continue;\n        y = fa[y][i];\n    }\n    if (x == y) return x;\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (fa[x][i] == fa[y][i]) continue;\n        x = fa[x][i];\n        y = fa[y][i];\n    }\n    return fa[x][0];\n}\nlong long get(int x, int y) {\n    int k = LCA(x, y);\n    Linear_Basis&lt;long long, 60&gt; res;\n    res.init();\n    res.insert(val[k]);\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (deep[fa[x][i]] &lt; deep[k]) continue;\n        res = res + f[x][i];\n        x = fa[x][i];\n    }\n    for (int i = 15 ; i &gt;= 0 ; i--) {\n        if (deep[fa[y][i]] &lt; deep[k]) continue;\n        res = res + f[y][i];\n        y = fa[y][i];\n    }\n    return res.query();\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; val[i];\n    }\n    for (int i = 1 ; i &lt; n ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    dfs(1, 0);\n    while (q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; get(x, y) &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E5%9F%BA/#_10","title":"\u56fe\u4e0a\u6700\u5927\u5f02\u6216\u548c\u8def\u5f84","text":"<p>P4151 [WC2011] \u6700\u5927XOR\u548c\u8def\u5f84 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (!(x &amp; T(1) &lt;&lt; i)) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nLinear_Basis&lt;long long, 62&gt; LB;\nvector&lt;pair&lt;int, long long&gt;&gt; adj[50005];\nbool vis[50005];\nlong long dist[50005];\nvoid dfs(int u, int p) {\n    vis[u] = true;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) {\n            LB.insert(dist[u] ^ w ^ dist[to]);\n            continue;\n        }\n        dist[to] = dist[u] ^ w;\n        dfs(to, u);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    LB.init();\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        long long w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; LB.query(dist[n]) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>Problem - G - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ntemplate&lt;class T, const int _M = 30&gt; struct Linear_Basis {\n    vector&lt;T&gt; f;\n    int cnt = 0;\n    Linear_Basis() = default;\n    void init() {\n        f.assign(_M + 1, 0);\n    }\n    bool insert(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] == 0) {\n                    f[i] = x;\n                    cnt++;\n                    return true;\n                }\n                x ^= f[i];\n            }\n        }\n        return false;\n    }\n    T query(T x = 0) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                x ^= f[i];\n            }\n        }\n        return x;\n    }\n    bool check(T x) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (x &amp; T(1) &lt;&lt; i) {\n                if (f[i] != 0) {\n                    x ^= f[i];\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    friend Linear_Basis operator+(Linear_Basis x, Linear_Basis y) {\n        for (int i = _M ; i &gt;= 0 ; i--) {\n            if (y.f[i] == 0) continue;\n            x.insert(y.f[i]);\n        }\n        return x;\n    }\n}; // Linear_Basis\nLinear_Basis&lt;int, 30&gt; LB;\nvector&lt;pair&lt;int, int&gt;&gt; adj[100005];\nbool vis[100005];\nint dist[100005];\nvoid dfs(int u, int p) {\n    vis[u] = true;\n    for (auto &amp;[to, w] : adj[u]) {\n        if (to == p) continue;\n        if (vis[to]) {\n            LB.insert(dist[u] ^ w ^ dist[to]);\n            continue;\n        }\n        dist[to] = dist[u] ^ w;\n        dfs(to, u);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    LB.init();\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    dfs(1, 0);\n    cout &lt;&lt; LB.query(dist[n]) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","title":"\u5361\u7279\u5170\u6570","text":"<p>P1754 \u7403\u8ff7\u8d2d\u7968\u95ee\u9898 - \u6d1b\u8c37</p> <p>P1044 [NOIP2003 \u666e\u53ca\u7ec4] \u6808 - \u6d1b\u8c37</p> <p>P3200 [HNOI2009] \u6709\u8da3\u7684\u6570\u5217 - \u6d1b\u8c37</p> <ol> <li>\u6709 \\(2n\\) \u4e2a\u4eba\u6392\u6210\u4e00\u884c\u8fdb\u5165\u5267\u573a\u3002\u5165\u573a\u8d39 \\(5\\) \u5143\u3002\u5176\u4e2d\u53ea\u6709  \u4e2a\u4eba\u6709\u4e00\u5f20 \\(5\\) \u5143\u949e\u7968\uff0c\u53e6\u5916  \u4eba\u53ea\u6709 \\(10\\) \u5143\u949e\u7968\uff0c\u5267\u9662\u65e0\u5176\u5b83\u949e\u7968\uff0c\u95ee\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\u4f7f\u5f97\u53ea\u8981\u6709 \\(10\\) \u5143\u7684\u4eba\u4e70\u7968\uff0c\u552e\u7968\u5904\u5c31\u6709 \\(5\\) \u5143\u7684\u949e\u7968\u627e\u96f6\uff1f</li> <li>\u4e00\u4f4d\u5927\u57ce\u5e02\u7684\u5f8b\u5e08\u5728\u5979\u4f4f\u6240\u4ee5\u5317  \\(n\\) \u4e2a\u8857\u533a\u548c\u4ee5\u4e1c \\(n\\) \u4e2a\u8857\u533a\u5904\u5de5\u4f5c\u3002\u6bcf\u5929\u5979\u8d70 \\(n\\)\u4e2a\u8857\u533a\u53bb\u4e0a\u73ed\u3002\u5982\u679c\u4ed6\u4ece\u4e0d\u7a7f\u8d8a\uff08\u4f46\u53ef\u4ee5\u78b0\u5230) \u4ece\u5bb6\u5230\u529e\u516c\u5ba4\u7684\u5bf9\u89d2\u7ebf\uff0c\u90a3\u4e48\u6709\u591a\u5c11\u6761\u53ef\u80fd\u7684\u9053\u8def\uff1f</li> <li>\u5728\u5706\u4e0a\u9009\u62e9 \\(2n\\) \u4e2a\u70b9\uff0c\u5c06\u8fd9\u4e9b\u70b9\u6210\u5bf9\u8fde\u63a5\u8d77\u6765\u4f7f\u5f97\u6240\u5f97\u5230\u7684 \\(n\\) \u6761\u7ebf\u6bb5\u4e0d\u76f8\u4ea4\u7684\u65b9\u6cd5\u6570\uff1f</li> <li>\u5bf9\u89d2\u7ebf\u4e0d\u76f8\u4ea4\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\u533a\u57df\u5206\u6210\u4e09\u89d2\u5f62\u533a\u57df\u7684\u65b9\u6cd5\u6570\uff1f</li> <li>\u4e00\u4e2a\u6808\uff08\u65e0\u7a77\u5927\uff09\u7684\u8fdb\u6808\u5e8f\u5217\u4e3a \\(1,2,3,4,\u2026,n\\) \u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u51fa\u6808\u5e8f\u5217\uff1f</li> <li>\\(n\\) \u4e2a\u7ed3\u70b9\u53ef\u6784\u9020\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u4e8c\u53c9\u6811\uff1f</li> <li>\\(n\\) \u4e2a \\(+1\\) \u548c \\(n\\) \u4e2a \\(-1\\) \u6784\u6210 \\(2n\\) \u9879  \\(a_1,a_2, \\cdots ,a_{2n}\\)\uff0c\u5176\u90e8\u5206\u548c\u6ee1\u8db3 \\(a_1+a_2+ \\cdots +a_k \\geq 0(k=1,2,3, \\cdots ,2n)\\) \u5bf9\u4e0e\u8be5 \\(n\\) \u6570\u5217\u4e3a\uff1f</li> </ol> \\(H_0\\) \\(H_1\\) \\(H_2\\) \\(H_3\\) \\(H_4\\) \\(H_5\\) \\(H_6\\) \\(\u2026\\) 1 1 2 5 14 42 132 \u2026 \\[ \\begin{gather} H_n=\\frac{C_{2n}^n}{n+1}\\ (n\u22652,n\u2208N_+)\\\\ H_n=\\begin{cases} \\sum_{i=1}^nH_{i-1}H_{n-i}&amp;n\u22652,n\u2208N_+\\\\ 1&amp;n=0,1 \\end{cases}\\\\ H_n=\\frac{H_{n-1}\\cdot(4n-2)}{n+1}\\\\ H_n=C_{2n}^n-C_{2n}^{n-1} \\end{gather} \\] <p>\u7406\u89e3\u4e3a \\(2n\\) \u4e2a\u64cd\u4f5c\uff0c\u4e00\u5171\u6709 \\(2\\) \u79cd\u7c7b\u578b\uff0c\u4fdd\u8bc1\u5176\u4e2d\u4e00\u79cd\u7c7b\u578b\u7684\u6570\u91cf\u6052\u5927\u4e8e\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u6570\u91cf</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/#_2","title":"\u65e0\u6a21\u6570\u6216\u8005\u6a21\u6570\u4e3a\u8d28\u6570","text":"Code C++<pre><code>template&lt;const long long mod = 1000000007&gt; struct Combination {\n    int n;\n    vector&lt;long long&gt; _fac, _invfac, _inv;\n    Combination() : n(0), _fac{1}, _invfac{1}, _inv{0} {}\n    Combination(const int&amp; n) : Combination() {}\n    void init(const int&amp; m) {\n        if (m &lt;= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        for (int i = n + 1 ; i &lt;= m ; i++) {\n            _fac[i] = _fac[i - 1] * i % mod;\n        }\n        _invfac[m] = qinv(_fac[m]);\n        for (int i = m ; i &gt; n ; i--) {\n            _invfac[i - 1] = _invfac[i] * i % mod;\n            _inv[i] = _invfac[i] * _fac[i - 1] % mod;\n        }\n        n = m;\n    }\n    long long fac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _fac[m];\n    }\n    long long invfac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _invfac[m];\n    }\n    long long inv(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _inv[m];\n    }\n    long long C(const int n, const int m) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        return fac(n) * invfac(m) % mod * invfac(n - m) % mod;\n    }\n    long long operator()(int n, int m) {\n        return C(n, m);\n    }\n    static long long qinv(long long a) {\n        long long res = 1;\n        long long b = mod - 2;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n};\nconst long long mod = 1000000007;\nCombination&lt;mod&gt; C;\nlong long Catalan(const int n, bool hasMod) {\n    if (hasMod) return (C(2 * n, n) - C(2 * n, n - 1) + mod) % mod;\n    else {\n        long long ans = 1;\n        for (int i = 2 ; i &lt;= n ; i++) ans = ans * (4 * i - 2) / (i + 1);\n        return ans;\n    }\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/#_3","title":"\u6a21\u6570\u4e0d\u4e00\u5b9a\u4e3a\u8d28\u6570","text":"Code C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    void init(const int N) {\n        prime.clear();\n        vis.clear();\n        vis.resize(N + 1);\n        vis[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.emplace_back(i);\n            }\n            for (int j = 0 ; i * prime[j] &lt;= N ; j++) {\n                vis[i * prime[j]] = prime[j];\n                if (i % prime[j] == 0) break;\n            }\n        }\n    }\n} // EulerSieve\nEulerSieve::init(1000000);\nnamespace Combination {\n    long long qpow(long long a, int b, const int mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    long long C(const int n, const int m, const int mod) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        long long res = 1;\n        for (auto &amp;i : prime) {\n            if (i &gt; n * 2) break;\n            int s = 0;\n            int k = n;\n            while (k &gt; 0) {\n                k /= i;\n                s += k;\n            }\n            k = n - m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            k = m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            res = res * qpow(i, s, mod) % mod;\n        }\n        return res;\n    }\n} // Combination\nusing Combination::C;\nlong long Catalan(const int n, int mod) {\n    return (C(2 * n, n, mod) - C(2 * n, n - 1, mod) + mod) % mod;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/#_4","title":"\u8def\u5f84\u8ba1\u6570\u95ee\u9898","text":"<ol> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((m,n)\\) \u7684\u975e\u964d\u8def\u5f84\u6570\u7b49\u4e8e \\(m\\) \u4e2a \\(x\\) \u548c \\(n\\) \u4e2a \\(y\\) \u7684\u6392\u5217\u6570\uff0c\u5373\\(C_{n+m}^m\\)\u3002</p> </li> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((n,n)\\) \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u63a5\u89e6\u76f4\u7ebf \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a     \u5148\u8003\u8651 \\(y=x\\) \u4e0b\u65b9\u7684\u8def\u5f84\uff0c\u90fd\u662f\u4ece\u51fa \\((0,0)\\) \u53d1\uff0c\u7ecf\u8fc7 \\((1,0)\\) \u53ca \\((n,n-1)\\) \u5230 \\((n,n)\\) \uff0c\u53ef\u4ee5\u770b\u505a\u662f \\((1,0)\\) \u5230 \\((n,n-1)\\) \u4e0d\u63a5\u89e6 \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\u3002     \u6240\u6709\u7684\u7684\u975e\u964d\u8def\u5f84\u6709 \\(C_{2n-2}^{n-1}\\) \u6761\u3002\u5bf9\u4e8e\u8fd9\u91cc\u9762\u4efb\u610f\u4e00\u6761\u63a5\u89e6\u4e86 \\(y=x\\) \u7684\u8def\u5f84\uff0c\u53ef\u4ee5\u628a\u5b83\u6700\u540e\u79bb\u5f00\u8fd9\u6761\u7ebf\u7684\u70b9\u5230 \\((1,0)\\) \u4e4b\u95f4\u7684\u90e8\u5206\u5173\u4e8e \\(y=x\\) \u5bf9\u79f0\u53d8\u6362\uff0c\u5c31\u5f97\u5230\u4ece \\((0,1)\\) \u5230 \\((n,n-1)\\) \u7684\u4e00\u6761\u975e\u964d\u8def\u5f84\u3002\u53cd\u4e4b\u4e5f\u6210\u7acb\u3002\u4ece\u800c \\(y=x\\) \u4e0b\u65b9\u7684\u975e\u964d\u8def\u5f84\u6570\u662f \\(C_{2n-2}^{n-1}-C_{2n-2}^{n}\\) \u3002\u6839\u636e\u5bf9\u79f0\u6027\u53ef\u77e5\u6240\u6c42\u7b54\u6848\u4e3a \\(2(C_{2n-2}^{n-1}-C_{2n-2}^{n})=\\frac{2C_{2n-2}^{n-1}}{n}\\)\u3002</p> </li> <li> <p>\u4ece \\((0,0)\\) \u5230 \\((n,n)\\) \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u7a7f\u8fc7\u76f4\u7ebf \\(y=x\\) \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a\u7528\u7c7b\u4f3c\u7684\u65b9\u6cd5\u53ef\u4ee5\u5f97\u5230\uff1a\\(\\frac{2C_{2n}^n}{n+1}\\)</p> </li> </ol>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","title":"\u5bb9\u65a5\u539f\u7406","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/#_2","title":"\u4e0d\u5b9a\u65b9\u7a0b\u975e\u8d1f\u6574\u6570\u89e3\u8ba1\u6570","text":"<p>P1450 [HAOI2008] \u786c\u5e01\u8d2d\u7269 - \u6d1b\u8c37</p> <p>\\(f(x)\\) \u4e3a \\(a_0\\cdot b_0+a_1\\cdot b_1+\u2026a_k\\cdot b_k=x\\) \u7684\u6240\u6709\u65b9\u6848\u6570\uff0c\\(a_i\\) \u4e3a\u5e38\u6570\uff0c\\(b_i\\) \u4e3a\u53d8\u91cf</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long f[100001];\nint main() {\n    vector&lt;int&gt; c(4);\n    int n;\n    cin &gt;&gt; c[0] &gt;&gt; c[1] &gt;&gt; c[2] &gt;&gt; c[3] &gt;&gt; n; f[0] = 1;\n    for (int i = 0 ; i &lt; 4 ; i++) {\n        for (int j = 0 ; j &lt;= 100000 ; j++) {\n            if (j &gt;= c[i]) f[j] += f[j - c[i]];\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        vector&lt;int&gt; d(4); long long s;\n        cin &gt;&gt; d[0] &gt;&gt; d[1] &gt;&gt; d[2] &gt;&gt; d[3] &gt;&gt; s;\n        long long res = 0;\n        for (int i = 1 ; i &lt; 1 &lt;&lt; 4 ; i++) {\n            long long m = s;\n            int sign = -1;\n            for (int j = 0 ; j &lt; 4 ; j++) {\n                if (i &gt;&gt; j &amp; 1) {\n                    m -= (d[j] + 1) * c[j]; sign = -sign;\n                }\n            }\n            if (m &gt;= 0) res += sign * f[m];\n        }\n        cout &lt;&lt; f[s] - res &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","title":"\u5eb7\u6258\u5c55\u5f00","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/#_2","title":"\u7b97\u6cd5\u5b9a\u4e49","text":"<p>\u6c42\u4e00\u4e2a \\(1~n\\) \u7684\u4efb\u610f\u6392\u5217\u7684\u6392\u540d</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/#-oncdotlogn","title":"\u6b63\u5eb7\u6258\u5c55\u5f00 - \\(O(n\\cdot\\log{n})\\)","text":"Code C++<pre><code>long long cantor(const vector&lt;int&gt; &amp;p, const int n) {\n    long long res = 1;\n    FenwickTree&lt;int&gt; ft(n + 1);\n    for (int i = n - 1 ; i &gt;= 0 ; i--) {\n        res = (res + f[n - 1 - i] * ft.query(p[i]) % mod) % mod;\n        ft.add(p[i], 1);\n    }\n    return res;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/#-oncdotlogn_1","title":"\u9006\u5eb7\u6258\u5c55\u5f00 - \\(O(n\\cdot\\log{n})\\)","text":"Code C++<pre><code>vector&lt;int&gt; decantor(long long x, const int n) {\n    x--;\n    Treap&lt;int&gt; tr(n);\n    vector&lt;long long&gt; a(n);\n    vector&lt;int&gt; b(n);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        tr.insert(i);\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i] = x / f[n - i - 1];\n        x %= f[n - i - 1];\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        b[i] = tr.queryNum(a[i] + 1);\n        tr.erase(b[i]);\n    }\n    return b;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/#_3","title":"\u6a21\u677f","text":"<p>P5367 \u3010\u6a21\u677f\u3011\u5eb7\u6258\u5c55\u5f00 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint lowbit(const int x) {\n    return x &amp; -x;\n}\ntemplate&lt;class T&gt; struct FenwickTree {\n    vector&lt;T&gt; sum;\n    int size;\n    FenwickTree() {}\n    FenwickTree(const int n) {\n        size = n;\n        sum.assign(n + 1, 0);\n    }\n    void clear() {\n        sum.clear();\n    }\n    T query(int x) {\n        T res = 0;\n        while (x) {\n            res += sum[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n    T query(const int L, const int R) {\n        return query(R) - query(L - 1);\n    }\n    void add(int x, const T k) {\n        while (x &lt;= size) {\n            sum[x] += k;\n            x += lowbit(x);\n        }\n    }\n}; // FenwickTree\ntemplate&lt;class T&gt; struct Info {\n    int L, R, rnd, cnt, size;\n    T val;\n    Info() = default;\n    Info(const int L, const int R, const int rnd, const int cnt, const int size, const T val) : L(L), R(R), rnd(rnd), cnt(cnt), size(size), val(val) {}\n};\ntemplate&lt;class T&gt; struct Treap {\n    vector&lt;Info&lt;T&gt;&gt; info;\n    int tot, root;\n    Treap(const int N) : tot(0), root(0), info(N + 1) {}\n    void push(const int p) {\n        info[p].size = info[info[p].L].size + info[info[p].R].size + info[p].cnt;\n    }\n    void LRotate(int &amp;p) {\n        int temp = info[p].R;\n        info[p].R = info[temp].L;\n        info[temp].L = p;\n        info[temp].size = info[p].size;\n        push(p);\n        p = temp;\n    }\n    void RRotate(int &amp;p) {\n        int temp = info[p].L;\n        info[p].L = info[temp].R;\n        info[temp].R = p;\n        info[temp].size = info[p].size;\n        push(p);\n        p = temp;\n    }\n    void build(int &amp;p, const T x) {\n        p = ++tot;\n        info[p] = Info(0, 0, rand(), 1, 1, x);\n    }\n    void insert(const T x) {\n        insert(root, x);\n    }\n    void insert(int &amp;p, const T x) {\n        if (p == 0) {\n            build(p, x);\n            return;\n        }\n        info[p].size++;\n        if (info[p].val == x) {\n            info[p].cnt++;\n        } else if (info[p].val &lt; x) {\n            insert(info[p].R, x);\n            if (info[info[p].R].rnd &lt; info[p].rnd) {\n                LRotate(p);\n            }\n        } else {\n            insert(info[p].L, x);\n            if (info[info[p].L].rnd &lt; info[p].rnd) {\n                RRotate(p);\n            }\n        }\n    }\n    bool erase(const T x) {\n        return erase(root, x);\n    }\n    bool erase(int &amp;p, const T x) {\n        if (p == 0) {\n            return false;\n        }\n        if (info[p].val == x) {\n            if (info[p].cnt &gt; 1) {\n                info[p].cnt--;\n                info[p].size--;\n                return true;\n            }\n            if (info[p].L == 0 || info[p].R == 0) {\n                p = info[p].L + info[p].R;\n                return true;\n            } else if (info[info[p].L].rnd &lt; info[info[p].R].rnd) {\n                RRotate(p);\n                return erase(p, x);\n            } else {\n                LRotate(p);\n                return erase(p, x);\n            }\n        } else if (info[p].val &lt; x) {\n            bool succ = erase(info[p].R, x);\n            if (succ) info[p].size--;\n            return succ;\n        } else {\n            bool succ = erase(info[p].L, x);\n            if (succ) info[p].size--;\n            return succ;\n        }\n    }\n    int queryRank(const T x) {\n        return queryRank(root, x);\n    }\n    int queryRank(const int p, const T x) {\n        if (p == 0) return 0;\n        if (info[p].val == x) {\n            return info[info[p].L].size + 1;\n        } else if (info[p].val &lt; x) {\n            return info[info[p].L].size + info[p].cnt + queryRank(info[p].R, x);\n        } else {\n            return queryRank(info[p].L, x);\n        }\n    }\n    T queryNum(const T x) {\n        return queryNum(root, x);\n    }\n    T queryNum(const int p, const T x) {\n        if (p == 0) return 0;\n        if (x &lt;= info[info[p].L].size) {\n            return queryNum(info[p].L, x);\n        } else if (x &gt; info[info[p].L].size + info[p].cnt) {\n            return queryNum(info[p].R, x - info[info[p].L].size - info[p].cnt);\n        } else {\n            return info[p].val;\n        }\n    }\n    int queryPre(const T x) {\n        return queryPre(root, x);\n    }\n    int queryPre(const int p, const T x) {\n        if (p == 0) return -1;\n        if (info[p].val &lt; x) {\n            int res = queryPre(info[p].R, x);\n            if (res != -1) return res;\n            return p;\n        }\n        return queryPre(info[p].L, x);\n    }\n    int querySub(const T x) {\n        return querySub(root, x);\n    }\n    int querySub(const int p, const T x) {\n        if (p == 0) return -1;\n        if (info[p].val &gt; x) {\n            int res = querySub(info[p].L, x);\n            if (res != -1) return res;\n            return p;\n        } else {\n            return querySub(info[p].R, x);\n        }\n    }\n    T &amp;operator[](const int p) {\n        return info[p].val;\n    }\n}; // Treap\nnamespace CantorExpansion {\n    const int&amp; mod = 998244353;\n    vector&lt;long long&gt; f(1, 1);\n    void init(const int n) {\n        const int k = f.size();\n        if (n &gt; k) {\n            f.resize(n + 1);\n            for (int i = k ; i &lt;= n ; i++) {\n                f[i] = f[i - 1] * i % mod;\n            }\n        } else return;\n    }\n    long long cantor(const vector&lt;int&gt;&amp; p, const int n) {\n        init(n);\n        long long res = 1;\n        FenwickTree&lt;int&gt; ft(n);\n        for (int i = n - 1 ; i &gt;= 0 ; i--) {\n            res = (res + f[n - 1 - i] * ft.query(p[i]) % mod) % mod;\n            ft.add(p[i], 1);\n        }\n        return res;\n    }\n    vector&lt;int&gt; decantor(long long x, const int n) {\n        init(n);\n        x--;\n        Treap&lt;int&gt; tr(n);\n        vector&lt;long long&gt; a(n);\n        vector&lt;int&gt; b(n);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            tr.insert(i);\n        }\n        for (int i = 0 ; i &lt; n ; i++) {\n            a[i] = x / f[n - i - 1];\n            x %= f[n - i - 1];\n        }\n        for (int i = 0 ; i &lt; n ; i++) {\n            b[i] = tr.queryNum(a[i] + 1);\n            tr.erase(b[i]);\n        }\n        return b;\n    }\n} // CantorExpansion\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    cout &lt;&lt; CantorExpansion::cantor(a, n);\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/","title":"\u6392\u5217\u7ec4\u5408","text":"<p>P3807 \u3010\u6a21\u677f\u3011\u5362\u5361\u65af\u5b9a\u7406/Lucas \u5b9a\u7406 - \u6d1b\u8c37</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_2","title":"\u6c42\u7ec4\u5408\u6570","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_3","title":"\u9012\u5f52\u6c42\u7ec4\u5408\u6570","text":"Code C++<pre><code>namespace Combination {\n    const int mod = 1000000007;\n    int c[5001][5001];\n    c[0][0] = 1;\n    for (int i = 1 ; i &lt;= 5000 ; i++) {\n        c[i][0] = 1;\n        for (int j = 0 ; j &lt;= i ; j++) {\n            c[i][j] = (1LL * c[i - 1][j - 1] + c[i - 1][j]) % mod;\n        }\n    }\n    int get(const int n, const int r) {\n        return c[n][r];\n    }\n} // Combination\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_4","title":"\u6a21\u6570\u4e3a\u8d28\u6570","text":"Code C++<pre><code>template&lt;const long long mod = 1000000007&gt; struct Combination {\n    int n;\n    vector&lt;long long&gt; _fac, _invfac, _inv;\n    Combination() : n(0), _fac{1}, _invfac{1}, _inv{0} {}\n    Combination(const int&amp; n) : Combination() {}\n    void init(const int&amp; m) {\n        if (m &lt;= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        for (int i = n + 1 ; i &lt;= m ; i++) {\n            _fac[i] = _fac[i - 1] * i % mod;\n        }\n        _invfac[m] = qinv(_fac[m]);\n        for (int i = m ; i &gt; n ; i--) {\n            _invfac[i - 1] = _invfac[i] * i % mod;\n            _inv[i] = _invfac[i] * _fac[i - 1] % mod;\n        }\n        n = m;\n    }\n    long long fac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _fac[m];\n    }\n    long long invfac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _invfac[m];\n    }\n    long long inv(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _inv[m];\n    }\n    long long C(const int n, const int m) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        return fac(n) * invfac(m) % mod * invfac(n - m) % mod;\n    }\n    long long operator()(int n, int m) {\n        return C(n, m);\n    }\n    static long long qinv(long long a) {\n        long long res = 1;\n        long long b = mod - 2;\n        while (b) {\n            if (b &amp; 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n};\nCombination&lt;998244353&gt; C;\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_5","title":"\u6a21\u6570\u4e0d\u4e3a\u8d28\u6570","text":"Code C++<pre><code>namespace EulerSieve {\n    vector&lt;int&gt; prime;\n    vector&lt;int&gt; vis;\n    void init(const int N) {\n        prime.clear();\n        vis.clear();\n        vis.resize(N + 1);\n        vis[1] = 1;\n        for (int i = 2 ; i &lt;= N ; i++) {\n            if (vis[i] == 0) {\n                vis[i] = i;\n                prime.emplace_back(i);\n            }\n            for (int j = 0 ; i * prime[j] &lt;= N ; j++) {\n                vis[i * prime[j]] = prime[j];\n                if (i % prime[j] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n} // EulerSieve\nEulerSieve::init(1000000);\nnamespace Combination {\n    long long qpow(long long a, int b, const int mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    long long C(const int n, const int m, const int mod) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        long long res = 1;\n        for (auto &amp;i : prime) {\n            if (i &gt; n * 2) {\n                break;\n            }\n            int s = 0;\n            int k = n;\n            while (k &gt; 0) {\n                k /= i;\n                s += k;\n            }\n            k = n - m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            k = m;\n            while (k &gt; 0) {\n                k /= i;\n                s -= k;\n            }\n            res = res * qpow(i, s, mod) % mod;\n        }\n        return res;\n    }\n} // Combination\nusing Combination::C;\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_6","title":"\u5927\u7ec4\u5408\u6570","text":"Code C++<pre><code>namespace Lucas {\n    const int mod = 1000000007;\n    long long inv(long long a) {\n        long long res = 1, b = mod - 2;\n        while (b) {\n            if (b &amp; 1) res = res * a % mod;\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n    long long C(const long long &amp;n, const long long &amp;m) {\n        long long x = 1, y = 1;\n        if (n &lt; m) return 0;\n        else if (n == m) return 1;\n        for (int i = n - m + 1 ; i &lt;= n ; i++) x = x * i % mod;\n        for (int i = 1 ; i &lt;= m ; i++) y = y * i % mod;\n        return x * inv(y) % mod;\n    }\n    long long get(const long long&amp; n, const long long&amp; m) {\n      if (m == 0) return 1;\n      return (C(n % mod, m % mod) * get(n / mod, m / mod)) % mod;\n    }\n} // Lucas\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_7","title":"\u91cd\u590d\u6392\u5217","text":"<p>\u4ecen\u4e2a\u4e0d\u540c\u7684\u7269\u4f53\u4e2d\uff0c\u5141\u8bb8\u91cd\u590d\u5730\u9009\u53d6r\u4e2a\u7269\u4f53\u7684\u6392\u5217\u6709 \\(n^r\\) \u79cd\u65b9\u6848</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_8","title":"\u91cd\u590d\u7ec4\u5408","text":"<p>\u4ecen\u4e2a\u4e0d\u540c\u7684\u7269\u4f53\u4e2d\uff0c\u5141\u8bb8\u91cd\u590d\u5730\u9009\u53d6r\u4e2a\u7269\u4f53\u7684\u7ec4\u5408\u6709 \\(C_{n+r-1}^r\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_9","title":"\u4e0d\u5168\u76f8\u5f02\u5168\u6392\u5217","text":"<p>\u7b2c \\(i\\) \u79cd\u7269\u54c1\u6709 \\(n_i\\) \u4e2a\uff0c\u5168\u6392\u5217\u6570\u4e3a \\(\\dfrac{n!}{n_1!\\cdot{n_2!}\\cdot\\cdots\\cdot{n_k!}}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_10","title":"\u5706\u5468\u6392\u5217","text":"<p>\u4eceN\u4e2a\u5143\u7d20\u4e2d\u53d6\u51faR\u4e2a\u5143\u7d20\u5f62\u6210\u7684\u5706\u5468\u6392\u5217\u65b9\u6848\u6570\u4e3a \\(\\dfrac{A_N^R}{R}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_11","title":"\u63d2\u677f\u6cd5","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_12","title":"\u6b63\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u6b63\u6574\u6570\u89e3\u7684\u7ec4\u6570 \\(C_{n-1}^{k-1}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_13","title":"\u975e\u8d1f\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u975e\u8d1f\u6574\u6570\u89e3\u7684\u7ec4\u6570 \\(C_{n+k-1}^{k-1}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_14","title":"\u4e0d\u540c\u4e0b\u754c\u6574\u6570\u548c\u7684\u6570\u76ee","text":"<p>\\(x_1+x_2+\u2026+x_k=n\\) \u7684\u89e3\u7684\u7ec4\u6570\uff0c\u5176\u4e2d \\(x\\geq{}a_i\\)</p> <p>\\(C_{n-\\sum{}a_i+k-1}^{n-\\sum{}a_i}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_15","title":"\u4e0d\u76f8\u90bb\u7684\u6392\u5217","text":"<p>n \u6392\u5217\u4e2d\u9009 k \u4e2a\u6570\uff0c\u8fd9 k \u4e2a\u6570\u4e2d\u4efb\u4f55\u4e24\u4e2a\u6570\u90fd\u4e0d\u76f8\u90bb\u7684\u7ec4\u5408\u6709 \\(C_{n-k+1}^k\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_16","title":"\u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5","text":"\u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5 \u7403(n) \u76d2\u5b50(m) \u9650\u5236\u6761\u4ef6 \u65b9\u6848\u6570 1 \u4e0d\u540c \u4e0d\u540c \u65e0 \\(m^n\\) 2 \u4e0d\u540c \u4e0d\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\(A_m^n\\) 3 \u4e0d\u540c \u4e0d\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \\(\\sum_{i=0}^m(-1)^i{(m-i)}^nC_m^i\\) \u6216\u8005 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(m!\\cdot{}S(n,m)\\) 4 \u4e0d\u540c \u76f8\u540c \u65e0 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(\\sum_{i=1}^mS(n,i)\\) 5 \u4e0d\u540c \u76f8\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\([n\\leq{}m]\\) 6 \u4e0d\u540c \u76f8\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(S(n,m)\\) 7 \u76f8\u540c \u4e0d\u540c \u65e0 \\(C_{n+m-1}^{m-1}\\) 8 \u76f8\u540c \u4e0d\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\(C_m^n\\) 9 \u76f8\u540c \u4e0d\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \\(C_{n-1}^{m-1}\\) 10 \u76f8\u540c \u76f8\u540c \u65e0 \u5206\u62c6\u6570 \\(F(n)\\) 11 \u76f8\u540c \u76f8\u540c \u81f3\u591a\u88c5\u4e00\u4e2a\u7403 \\([n\\leq{}m]\\) 12 \u76f8\u540c \u76f8\u540c \u81f3\u5c11\u88c5\u4e00\u4e2a\u7403 \u5206\u62c6\u6570 \\(F(n-m)\\) <p>P5824 \u5341\u4e8c\u91cd\u8ba1\u6570\u6cd5 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n#define add(x, y) (x &gt;= mod - y ? x + y - mod : x + y)\n#define sub(x, y) (x &lt; y ? x - y + mod : x - y)\nconst int N = 524289;\nint n, m;\nconst long long mod = 998244353;\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b &amp; 1) res = 1LL * res * a % mod;\n        a = 1LL * a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Poly {\n    int w[N];\n    int preW = 0;\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    const int inv2 = qpow(2, mod - 2);\n    void init(int len) {\n        if (len &lt;= preW) {\n            return;\n        }\n        preW = len;\n        for (int i = 1, j, k ; i &lt; len ; i &lt;&lt;= 1) {\n            for (w[j = i] = 1, k = qpow(3, (mod - 1) / (i &lt;&lt; 1)), j++ ; j &lt; i &lt;&lt; 1 ; j++) {\n                w[j] = 1LL * w[j - 1] * k % mod;\n            }\n        }\n    }\n    void DNT(int *a, int len) {\n        for (int i, j, k = len &gt;&gt; 1, L, *W, *x, *y, z ; k ; k &gt;&gt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = *y;\n                    *y = 1LL * sub(*x, z) * *W % mod;\n                    *x = add(*x, z);\n                }\n            }\n        }\n    }\n    void IDNT(int *a, int len) {\n        for (int i, j, k = 1, L, *W, *x, *y, z ; k &lt; len  ; k &lt;&lt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = 1LL * *W * *y % mod;\n                    *y = sub(*x, z);\n                    *x = add(*x, z);\n                }\n            }\n        }\n        reverse(a + 1, a + len);\n        for (int inv = qpow(len, mod - 2), i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * inv % mod;\n        }\n    }\n    int NTT(int *a, int *b, int n, int m) {\n        int len = getLen(n + m);\n        init(len);\n        DNT(a, len);\n        DNT(b, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mod;\n        }\n        IDNT(a, len);\n        return len;\n    }\n    void inv(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = qpow(a[0], mod - 2);\n            return;\n        }\n        inv(a, b, n + 1 &gt;&gt; 1);\n        int len = getLen(n &lt;&lt; 1);\n        init(len);\n        static int c[N];\n        copy(a, a + n, c);\n        fill(c + n, c + len, 0);\n        DNT(b, len);\n        DNT(c, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            b[i] = (2LL - 1LL * c[i] * b[i] % mod + mod) % mod * b[i] % mod;\n        }\n        IDNT(b, len);\n        fill(b + n, b + len, 0);\n    }\n    void derivative(int *a, int n) {\n        for (int i = 1 ; i &lt; n ; i++) {\n            a[i - 1] = 1LL * i * a[i] % mod;\n        }\n        a[n - 1] = 0;\n    }\n    void integrate(int *a, int n) {\n        for (int i = n - 1 ; i &gt; 0 ; i--) {\n            a[i] = 1LL * qpow(i, mod - 2) * a[i - 1] % mod;\n        }\n        a[0] = 0;\n    }\n    void ln(int *a, int *b, int n) {\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        copy(a, a + len, b);\n        fill(c, c + len, 0);\n        inv(b, c, n);\n        derivative(b, n);\n        NTT(b, c, n, n);\n        integrate(b, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n    void exp(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = 1;\n            return;\n        }\n        exp(a, b, n + 1 &gt;&gt; 1);\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        fill(c, c + len, 0);\n        ln(b, c, n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            c[i] = sub(a[i], c[i]);\n        }\n        c[0] = add(c[0], 1);\n        NTT(b, c, n, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n} // Poly\nusing Poly::NTT;\nusing Poly::inv;\nusing Poly::exp;\ntemplate&lt;const long long mod = 998244353&gt; struct Combination {\n    int n;\n    vector&lt;long long&gt; _fac, _invfac, _inv;\n    Combination() : n(0), _fac{1}, _invfac{1}, _inv{0} {}\n    Combination(const int&amp; n) : Combination() {}\n    void init(const int&amp; m) {\n        if (m &lt;= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        for (int i = n + 1 ; i &lt;= m ; i++) {\n            _fac[i] = _fac[i - 1] * i % mod;\n        }\n        _invfac[m] = qinv(_fac[m]);\n        for (int i = m ; i &gt; n ; i--) {\n            _invfac[i - 1] = _invfac[i] * i % mod;\n            _inv[i] = _invfac[i] * _fac[i - 1] % mod;\n        }\n        n = m;\n    }\n    long long fac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _fac[m];\n    }\n    long long invfac(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _invfac[m];\n    }\n    long long inv(const int&amp; m) {\n        if (m &gt; n) init(m &lt;&lt; 1);\n        return _inv[m];\n    }\n    long long C(const int n, const int m) {\n        if (n &lt; m || m &lt; 0) return 0LL;\n        return fac(n) * invfac(m) % mod * invfac(n - m) % mod;\n    }\n    long long operator()(int n, int m) {\n        return C(n, m);\n    }\n    static long long qinv(long long a) {\n        long long res = 1;\n        long long b = mod - 2;\n        while (b) {\n            if (b &amp; 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b &gt;&gt;= 1;\n        }\n        return res;\n    }\n};\nCombination&lt;mod&gt; C;\nint a[N], b[N], c[N], s[N], f[N];\nvoid init() {\n    int sgn = 1;\n    for (int i = 0 ; i &lt;= n ; i++) {\n        s[i] = C.invfac(i) * qpow(i, n) % mod;\n        a[i] = sgn * C.invfac(i) % mod;\n        sgn = mod - sgn;\n    }\n    NTT(s, a, n, n);\n    fill(s + n + 1, s + max(n, m) + 1, 0);\n    for (int i = 1 ; i &lt;= m ; i++) {\n        for (int j = i ; j &lt;= n ; j += i) {\n            b[j] = (b[j] + mod - C.inv(j / i)) % mod;\n        }\n    }\n    exp(b, c, n + 1);\n    inv(c, f, n + 1);\n}\nint solve01() {\n    return qpow(m, n);\n}\nint solve02() {\n    if (n &gt; m) return 0;\n    int res = 1;\n    for (int i = m ; i &gt;= m - n + 1 ; i--) {\n        res = 1LL * res * i % mod;\n    }\n    return res;\n}\nint solve03() {\n    int res = 0, sgn = 1;\n    for (int i = 0 ; i &lt;= m ; i++) {\n        res = (res + 1LL * qpow(m - i, n) * C(m, i) % mod * sgn % mod) % mod;\n        sgn = mod - sgn;\n    }\n    return res;\n}\nint solve04() {\n    int res = 0;\n    for (int i = 1 ; i &lt;= m ; i++) {\n        res = (res + s[i]) % mod;\n    }\n    return res;\n}\nint solve05() {\n    return n &lt;= m;\n}\nint solve06() {\n    return s[m];\n}\nint solve07() {\n    return C(n + m - 1, m - 1);\n}\nint solve08() {\n    return C(m, n);\n}\nint solve09() {\n    return C(n - 1, m - 1);\n}\nint solve10() {\n    return f[n];\n}\nint solve11() {\n    return n &lt;= m;\n}\nint solve12() {\n    return n &gt;= m ? f[n - m] : 0;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    init();\n    cout &lt;&lt; solve01() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve02() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve03() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve04() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve05() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve06() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve07() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve08() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve09() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve10() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve11() &lt;&lt; \"\\n\";\n    cout &lt;&lt; solve12() &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_17","title":"\u7ec4\u5408\u6570\u6027\u8d28 | \u4e8c\u9879\u5f0f\u63a8\u8bba","text":"\\[ \\begin{align} C_n^m&amp;=C_n^{n-m}\\\\ C_n^k&amp;=\\frac{n}{k}\\cdot{}C_{n-1}^{k-1}\\\\ \\sum_{i=0}^nC_n^i&amp;=2^n\\\\ \\sum_{i=0}^n(-1)^i\\cdot{}C_n^i&amp;=[n==0]\\\\ \\sum_{i=0}^kC_n^i\\cdot{}C_m^{k-i}&amp;=C_{m+n}^k\\\\ \\sum_{i=0}^n(C_n^i)^2&amp;=C_{2n}^n\\\\ \\sum_{i=0}^ni\\cdot{}C_n^i&amp;=n\\cdot{}2^{n-1}\\\\ \\sum_{i=0}^ni^2\\cdot{}C_n^i&amp;=n\\cdot{}(n+1)\\cdot{}2^{n-2}\\\\ \\sum_{i=0}^nC_i^k&amp;=C_{n+1}^{k+1}\\\\ C_n^r\\cdot{}C_r^k&amp;=C_n^k\\cdot{}C_{n-k}^{r-k}\\\\ \\sum_{i=0}^nC_{n-i}^i&amp;=F_{n+1}(\\text{\u6590\u6ce2\u90a3\u5951\u6570\u5217})\\\\ \\sum_{i=L}^RC_i^k&amp;=C_{k+1}^{R+1}-C_{k+1}^L\\\\ \\sum_{r=0}^kC_{n+r-1}^r&amp;=C_{n+k}^k\\\\ \\sum_{i=L}^RC_{a+i}^i&amp;=C_{a+R+1}^R-C_{a+L}^{L-1}\\\\ \\sum_{i=L}^RC_i^k&amp;=C_{R+1}^{k+1}-C_{L}^{k+1} \\end{align} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_18","title":"\u4e8c\u9879\u5f0f\u5b9a\u7406","text":"<p>\\((a+b)^n=\\sum_{i=0}^nC_n^i\\cdot{}a^{n-i}\\cdot{}b^i\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/#_19","title":"\u4e8c\u9879\u5f0f\u53cd\u6f14","text":"<p>\u8bb0 \\(f_n\\) \u8868\u793a\u6070\u597d\u4f7f\u7528 \\(n\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u65b9\u6848\u6570\uff0c\\(g_n\\) \u8868\u793a\u4ece \\(n\\) \u4e2a\u4e0d\u540c\u5143\u7d20\u4e2d\u9009\u51fa \\(i\\geq0\\) \u4e2a\u5143\u7d20\u5f62\u6210\u7279\u5b9a\u7ed3\u6784\u7684\u603b\u65b9\u6848\u6570\u3002</p> \\[ g_n=\\sum_{i=0}^nC_n^i\\cdot{}f_i \\] \\[ f_n=\\sum_{i=0}^nC_n^i\\cdot{}(-1)^{n-i}\\cdot{}g_i \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"\u6590\u6ce2\u90a3\u5951\u6570\u5217","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/#_2","title":"\u6590\u6ce2\u90a3\u5951\u6570\u5217\u901a\u9879\u516c\u5f0f","text":"\\[ \\begin{gather} F_0=0,\\ F_1=1\\\\ F_n=F_n-1+F_{n-2}\\\\ F_n=\\left[\\frac{\\frac{(1+\\sqrt5)^n}{2}-\\frac{(1-\\sqrt5)^n}{2}}{\\sqrt5}\\right] \\end{gather} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/#n-ologn","title":"\u6c42\u6590\u6ce2\u90a3\u5951\u7b2c n \u9879 - \\(O(\\log{n})\\)","text":"Code C++<pre><code>pair&lt;int, int&gt; fib(const int n) {\n    if (n == 0) {\n        return {0, 1};\n    }\n    auto [a, b] = fib(n &gt;&gt; 1);\n    const int c = a * (2 * b - a), d = a * a + b * b;\n    if (n &amp; 1) {\n        return {d, c + d};\n    }\n    return {c, d};\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/#n-p-osqrtp","title":"\u6c42\u6590\u6ce2\u90a3\u5951\u7b2c n \u9879 % p - \\(O(\\sqrt{p})\\)","text":"<p>P4000 \u6590\u6ce2\u90a3\u5951\u6570\u5217 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int MAX_SQRT = 1 &lt;&lt; 18;\nint mod;\nstruct Matrix {\n    long long a[2][2];\n    Matrix(bool flag = true) {\n        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0;\n        if (flag == true) {\n            a[0][0] = a[1][1] = 1;\n        }\n    }\n    long long* operator[](int x) {\n        return a[x];\n    }\n    friend Matrix operator*(Matrix x, Matrix y) {\n        Matrix res(false);\n        for (int i = 0 ; i &lt; 2 ; i++) {\n            for (int k = 0 ; k &lt; 2 ; k++) {\n                long long r = x[i][k];\n                for (int j = 0 ; j &lt; 2 ; j++) {\n                    res[i][j] += r * y[k][j];\n                }\n            }\n        }\n        for (int i = 0 ; i &lt; 2 ; i++) {\n            for (int j = 0 ; j &lt; 2 ; j++) {\n                res[i][j] %= mod;\n            }\n        }\n        return res;\n    }\n};\narray&lt;Matrix, 2&gt; mat[MAX_SQRT + 1];\nint main() {\n    mt19937_64 rnd(time(nullptr));\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string str;\n    cin &gt;&gt; str &gt;&gt; mod;\n    Matrix base(false);\n    base[0][0] = 0;\n    base[0][1] = base[1][0] = base[1][1] = 1;\n    for (int i = 1 ; i &lt;= MAX_SQRT ; i++) {\n        mat[i][0] = mat[i - 1][0] * base;\n    }\n    for (int i = 1 ; i &lt;= MAX_SQRT ; i++) {\n        mat[i][1] = mat[i - 1][1] * mat[MAX_SQRT][0];\n    }\n    map&lt;unsigned long long, long long&gt; loop;\n    long long len = 0;\n    while (true) {\n        long long a = rnd() &lt;&lt; 28 &gt;&gt; 28;\n        Matrix res = mat[a &amp; MAX_SQRT - 1][0] * mat[a &gt;&gt; 18][1];\n        unsigned long long val = ((1ULL * res[0][0]) &lt;&lt; 32ULL) | res[0][1];\n        if (loop.find(val) != end(loop)) {\n            len = llabs(loop[val] - a);\n            break;\n        }\n        loop[val] = a;\n    }\n    long long n = 0;\n    for (auto c : str) {\n        n = (n * 10 + (c xor 48)) % len;\n    }\n    cout &lt;&lt; (mat[n &amp; MAX_SQRT - 1][0] * mat[n &gt;&gt; 18][1])[0][1] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/#_3","title":"\u5362\u5361\u65af\u6570\u5217","text":"\\[ \\begin{align} L_n&amp;={(\\frac{1+\\sqrt5}{2})}^n+{(\\frac{1-\\sqrt5}{2})}^n\\\\ {L_n}^2&amp;-5{F_n}^2=-4 \\end{align} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","title":"\u65af\u7279\u6797\u6570","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_2","title":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 (\u65af\u7279\u6797\u5b50\u96c6\u6570)","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_3","title":"\u5b9a\u4e49","text":"<p>\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \\(S(n,k)=\\begin{Bmatrix}n\\\\k\\end{Bmatrix}\\)</p> <p>\u8868\u793a\u5c06 \\(n\\) \u4e2a\u4e24\u4e24\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u4e3a \\(k\\) \u4e2a\u4e92\u4e0d\u533a\u5206\u7684\u975e\u7a7a\u5b50\u96c6\u7684\u65b9\u6848\u6570\u3002</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_4","title":"\u901a\u9879\u516c\u5f0f","text":"\\[ \\begin{align} S(0,0)&amp;=1\\\\ S(n,k)&amp;=S(n-1,k-1)+k\\cdot{}S(n-1,k) \\end{align} \\] \\[ \\begin{align} G_i&amp;=i^n\\\\ G_i&amp;=\\sum_{j=0}^iC_i^j\\cdot{}F_j\\\\ F_i&amp;=\\sum_{j=0}^i\\frac{i!\\cdot{}(-1)^{i-j}\\cdot{}j^n}{j!\\cdot{}(i-j)!}\\\\ i^n&amp;=\\sum_{j=0}^nS(n,j)\\cdot{}C_i^j\\cdot{}j! \\end{align} \\] \\[ \\begin{Bmatrix}n\\\\m \\end{Bmatrix}=\\frac{F_m}{m!}=\\sum_{i=0}^m\\frac{(-1)^{m-i}\\cdot{i}^n}{i!\\cdot(m-i)!} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_5","title":"\u540c\u4e00\u884c","text":"\\[ \\begin{Bmatrix}n\\\\0\\end{Bmatrix},\\begin{Bmatrix}n\\\\1\\end{Bmatrix},\\dots,\\begin{Bmatrix}n\\\\n-1\\end{Bmatrix}\\begin{Bmatrix}n\\\\n\\end{Bmatrix} \\] <p>P5395 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\u00b7\u884c - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u591a\u9879\u5f0f NTT \u6a21\u677f }\nint a[N], b[N];\nlong long fact[N], invfact[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) fact[i] = fact[i - 1] * i % mod;;\n    invfact[n] = qpow(fact[n], mod - 2);\n    for (int i = n - 1 ; i &gt;= 0 ; i--) invfact[i] = invfact[i + 1] * (i + 1) % mod;\n    for (int i = 0 ; i &lt;= n ; i++) {\n        a[i] = invfact[i] * qpow(i, n) % mod;\n        b[i] = (i &amp; 1 ? mod - 1 : 1) * invfact[i] % mod;\n    }\n    NTT(a, b, n, n);\n    for (int i = 0 ; i &lt;= n ; i++) {\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_6","title":"\u540c\u4e00\u5217","text":"\\[ \\begin{Bmatrix}0\\\\k\\end{Bmatrix},\\begin{Bmatrix}1\\\\k\\end{Bmatrix},\\dots,\\begin{Bmatrix}n-1\\\\k\\end{Bmatrix}\\begin{Bmatrix}n\\\\k\\end{Bmatrix} \\] <p>P5396 \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\u00b7\u5217 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u591a\u9879\u5f0f NTT \u6a21\u677f }\nint a[N], b[N];\nlong long fact[N], invfact[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) fact[i] = fact[i - 1] * i % mod;;\n    invfact[n] = qpow(fact[n], mod - 2);\n    for (int i = n - 1 ; i &gt;= 0 ; i--) invfact[i] = invfact[i + 1] * (i + 1) % mod;\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i] = invfact[i + 1] % mod;\n    }\n    ln(a, b, n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        b[i] = 1LL * b[i] * k % mod;\n    }\n    fill(a, a + n, 0);\n    exp(b, a, n);\n    for (int i = n ; i &gt;= k ; i--) {\n        a[i] = a[i - k];\n    }\n    for (int i = 0 ; i &lt; k ; i++) {\n        a[i] = 0;\n    }\n    for (int i = 0 ; i &lt;= n ; i++) {\n        a[i] = 1LL * a[i] * fact[i] % mod * invfact[k] % mod;\n    }\n    for (int i = 0 ; i &lt;= n ; i++) {\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_7","title":"\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570 (\u65af\u7279\u6797\u8f6e\u6362\u6570)","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_8","title":"\u5b9a\u4e49","text":"<p>\u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570 \\(S(n,k)=\\begin{bmatrix}n\\\\k\\end{bmatrix}\\)</p> <p>\u8868\u793a \\(n\\) \u4e2a\u4e24\u4e24\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u5212\u5206\u4e3a \\(k\\) \u4e2a\u4e0d\u533a\u5206\u7684\u975e\u7a7a\u8f6e\u6362\u7684\u65b9\u6848\u6570\u3002</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_9","title":"\u901a\u9879\u516c\u5f0f","text":"\\[ \\begin{align} S(0,0)&amp;=1\\\\ S(n,k)&amp;=S(n-1,k-1)+(n-1)\\cdot{}S(n-1,k) \\end{align} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_10","title":"\u540c\u4e00\u884c","text":"\\[ \\begin{bmatrix}n\\\\0\\end{bmatrix},\\begin{bmatrix}n\\\\1\\end{bmatrix},\\dots,\\begin{bmatrix}n\\\\n-1\\end{bmatrix}\\begin{bmatrix}n\\\\n\\end{bmatrix} \\] <p>P5408 \u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570\u00b7\u884c - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u591a\u9879\u5f0f NTT \u6a21\u677f }\nint a[N], b[N];\nlong long fact[N], invfact[N];\nvoid solve(int *a, int n) {\n    static int b[N], c[N];\n    if (n == 1) {\n        a[1] = 1;\n        return;\n    }\n    if (n &amp; 1) {\n        solve(a, n - 1);\n        for (int i = n ; i &gt; 0 ; i--) {\n            a[i] = (a[i - 1] + 1LL * (n - 1) * a[i] % mod) % mod;\n        }\n        a[0] = 1LL * (n - 1) * a[0] % mod;\n    } else {\n        solve(a, n &gt;&gt; 1);\n        int len = n &gt;&gt; 1;\n        int L = getLen(n);\n        for (int i = 0 ; i &lt;= len ; i++) {\n            b[i] = 1LL * a[len - i] * fact[len - i] % mod;\n        }\n        fill(b + len + 1, b + L, 0);\n        for (int i = 0 ; i &lt;= len ; i++) {\n            c[i] = 1LL * qpow(len, i) * invfact[i] % mod;\n        }\n        fill(c + len + 1, c + L, 0);\n        NTT(b, c, len, len);\n        for (int i = 0 ; i &lt;= len ; i++) {\n            c[i] = 1LL * b[len - i] * invfact[i] % mod;\n        }\n        fill(c + len + 1, c + L, 0);\n        NTT(a, c, len, len);\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) fact[i] = fact[i - 1] * i % mod;;\n    invfact[n] = qpow(fact[n], mod - 2);\n    for (int i = n - 1 ; i &gt;= 0 ; i--) invfact[i] = invfact[i + 1] * (i + 1) % mod;\n    solve(a, n);\n    for (int i = 0 ; i &lt;= n ; i++) {\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_11","title":"\u540c\u4e00\u5217","text":"\\[ \\begin{bmatrix}0\\\\k\\end{bmatrix},\\begin{bmatrix}1\\\\k\\end{bmatrix},\\dots,\\begin{bmatrix}n-1\\\\k\\end{bmatrix}\\begin{bmatrix}n\\\\k\\end{bmatrix} \\] <p>P5409 \u7b2c\u4e00\u7c7b\u65af\u7279\u6797\u6570\u00b7\u5217 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n{ \u591a\u9879\u5f0f NTT \u6a21\u677f }\nint a[N], b[N];\nlong long fact[N], invfact[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    fact[0] = 1;\n    for (int i = 1 ; i &lt;= n ; i++) fact[i] = fact[i - 1] * i % mod;;\n    invfact[n] = qpow(fact[n], mod - 2);\n    for (int i = n - 1 ; i &gt;= 0 ; i--) invfact[i] = invfact[i + 1] * (i + 1) % mod;\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i] = fact[i] * invfact[i + 1] % mod;\n    }\n    ln(a, b, n);\n    for (int i = 0 ; i &lt; n ; i++) {\n        b[i] = 1LL * b[i] * k % mod;\n    }\n    fill(a, a + n, 0);\n    exp(b, a, n);\n    for (int i = n ; i &gt;= k ; i--) {\n        a[i] = a[i - k];\n    }\n    fill(a, a + k, 0);\n    for (int i = 0 ; i &lt;= n ; i++) {\n        a[i] = 1LL * a[i] * fact[i] % mod * invfact[k] % mod;\n    }\n    for (int i = 0 ; i &lt;= n ; i++) {\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_12","title":"\u4e0a\u5347\u5e42\u4e0e\u666e\u901a\u5e42\u7684\u76f8\u4e92\u8f6c\u5316","text":"<p>\\(x^\\overline{n}=\\prod_{k=0}^{n-1}(x+k)=\\sum_kS_1(n,k)\\cdot{x^k}\\)</p> <p>\\(x^n=\\sum_kS_2(n,k)\\cdot(-1)^{n-k}\\cdot{x^\\overline{k}}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/#_13","title":"\u4e0b\u964d\u5e42\u4e0e\u666e\u901a\u5e42\u7684\u4e92\u76f8\u8f6c\u5316","text":"<p>\\(x^\\underline{n}=\\prod_{k=0}^{n-1}(x-k)=\\sum_kS_1(n,k)\\cdot(-1)^{n-k}\\cdot{x^k}\\)</p> <p>\\(x^n=\\sum_kS_2(n,k)\\cdot{x^\\underline{k}}\\)</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%9D%82%E9%A2%98%281%29/#1-bx1-dy-gcdxyk-xy-2332","title":"\u5728[1, b]\u9009\u4e00\u4e2ax\uff0c[1, d]\u9009\u4e00\u4e2ay\uff0c\u4f7f\u5f97 \\(\\gcd(x,y)=k\\)\uff0c\u95ee\u4e0d\u540c\u7684 \\((x,y)\\) \u7684\u5bf9\u6570\uff0c(2,3)=(3,2)","text":"<p>Problem - 1695</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prime[100005];\nlong long phi[100005];\nvoid init() {\n    phi[1] = 1;\n    for (int i = 2 ; i &lt;= 100000 ; i++) {\n        if (phi[i] == 0) {\n            for (int j = i ; j &lt;= 100000 ; j += i) {\n                if (phi[j] == 0) phi[j] = j;\n                phi[j] = phi[j] * (i - 1) / i;\n                prime[j].emplace_back(i);\n            }\n        }\n        phi[i] += phi[i - 1];\n    }\n}\nlong long get(int idx, int b, int n) {\n    long long res = 0, temp;\n    for (int i = idx ; i &lt; prime[n].size() ; i++) {\n        temp = b / prime[n][i];\n        res += temp - get(i + 1, temp, n);\n    }\n    return res;\n}\nint cnt = 1;\nvoid solve() {\n    int a, b, c, d, k;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k;\n    long long ans = 0;\n    if (k != 0) { \n        if (b &gt; d) swap(b, d);\n        b /= k;\n        d /= k;\n        ans = phi[b];\n        for (int i = b + 1 ; i &lt;= d ; i++) {\n            ans += b - get(0, b, i);\n        }\n    }\n    cout &lt;&lt; \"Case \" &lt;&lt; cnt++ &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; \"\\n\"; \n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    init();\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%9D%82%E9%A2%98%281%29/#68","title":"\u533a\u95f4\u5185\u4ec5\u67096\u548c8\u7ec4\u6210\u7684\u6570\u7684\u500d\u6570\u7684\u4e2a\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;long long&gt; a;\nconst long long A = 10000000000;\nvoid dfs(long long res) {\n    if (res &gt; A) return;\n    a.emplace_back(res);\n    dfs(res * 10 + 6);\n    dfs(res * 10 + 8);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    dfs(0);\n    a.erase(begin(a));\n    sort(begin(a), end(a));\n    vector&lt;long long&gt; b;\n    for (int i = 0 ; i &lt; 2046 ; i++) {\n        bool flag = true;\n        for (int j = 0 ; j &lt; i ; j++) {\n            if (a[i] % a[j] == 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            b.emplace_back(a[i]);\n        }\n    }\n    cout &lt;&lt; \"{\";\n    for (auto &amp;i : b) {\n        cout &lt;&lt; i &lt;&lt; \", \";\n    }\n    cout &lt;&lt; \"}\";\n    cout &lt;&lt; \"\\n\" &lt;&lt; b.size() &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nlong long a[943] = {\u6253\u8868\u7a0b\u5e8f\u5728\u4e0a\u9762};\nlong long L, R;\nlong long ans;\nvoid dfs(int idx, int cnt, long long res) {\n    if (res &gt; R) return;\n    if (idx &gt; 942) {\n        if (cnt &gt; 0) {\n            if (cnt &amp; 1) ans += R / res - (L - 1) / res;\n            else ans -= R / res - (L - 1) / res;\n        }\n        return;\n    }\n    dfs(idx + 1, cnt, res);\n    res /= __gcd(res, a[idx]);\n    __int128 temp = res;\n    temp *= a[idx];\n    if (temp &lt;= R) dfs(idx + 1, cnt + 1, temp);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    sort(a, a + 943, [&amp;](const auto &amp;x, const auto &amp;y) {\n        return x &gt; y;\n    });\n    cin &gt;&gt; L &gt;&gt; R;\n    dfs(0, 0, 1);\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E5%8D%B7%E7%A7%AF/","title":"\u8303\u5fb7\u8499\u5fb7\u5377\u79ef","text":"\\[ \\sum_{i=0}^kC_n^i\\cdot{}C_m^{k-i}=C_{n+m}^k \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E5%8D%B7%E7%A7%AF/#_2","title":"\u63a8\u8bba","text":"\\[ \\sum_{i=-r}^sC_n^{r+i}\\cdot{}C_m^{s-i}=C_{n+m}^{r+s} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%B4%9D%E5%B0%94%E6%95%B0/","title":"\u8d1d\u5c14\u6570","text":""},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%B4%9D%E5%B0%94%E6%95%B0/#_2","title":"\u5b9a\u4e49","text":"<p>\\(B_n\\) \u662f\u57fa\u6570\u4e3a \\(n\\) \u7684\u96c6\u5408\u7684\u5212\u5206\u65b9\u6cd5\u7684\u6570\u76ee\u3002</p>"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%B4%9D%E5%B0%94%E6%95%B0/#_3","title":"\u516c\u5f0f","text":"\\[ \\begin{align} B_{n+1}&amp;=\\sum_{k=0}^nC_n^k\\cdot{}B_k\\\\ B_n&amp;=\\sum_{k=0}^nC_n^k \\end{align} \\]"},{"location":"Template/Math/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E8%B4%9D%E5%B0%94%E6%95%B0/#-on2","title":"\u6c42\u8d1d\u5c14\u6570 - \\(O(n^2)\\)","text":"Code C++<pre><code>for (int i = 1 ; i &lt;= n ; i++) {\n    B[i][0] = B[i - 1][i - 1];\n    for (int j = 1 ; j &lt;= i ; j++) {\n        B[i][j] = B[i - 1][j - 1] + B[i][j - 1];\n    }\n}\n</code></pre>"},{"location":"Template/Other/BeatMatching/","title":"\u5bf9\u62cd","text":"\u4ee3\u7801 WindowsLinux C++<pre><code>while (true) {\n    system(\"dataGeneration.exe &gt; in.txt\");\n    system(\"A.exe &lt; in.txt &gt; A.txt\");\n    system(\"B.exe &lt; in.txt &gt; B.txt\");\n    if (system(\"fc A.txt B.txt\")) break;\n}\n</code></pre> Bash<pre><code>#!/bin/bash\ng++ a.cpp -o a -Wall\ng++ data.cpp -o data -Wall\ng++ b.cpp -o b -Wall\nwhile true;do\n    ./data&gt;data.in\n    ./a&lt;data.in&gt;a.out\n    ./b&lt;data.in&gt;b.out\n    if diff -b -B -q a.out b.out;then\n        echo \"AC\"\n    else\n        echo \"WA\"\n        break\n    fi\ndone\n</code></pre>"},{"location":"Template/Other/Complex/","title":"\u590d\u6570","text":"\u6a21\u7248 C++<pre><code>template&lt;class T = double&gt;\nstruct __Complex {\n    T x, y;\n    __Complex() = default;\n    __Complex(const T x, const T y) : x(x), y(y) {}\n    __Complex&amp; operator+=(const __Complex &amp;b) {\n        x += b.x;\n        y += b.y;\n        return *this;\n    }\n    __Complex&amp; operator-=(const __Complex &amp;b) {\n        x -= b.x;\n        y -= b.y;\n        return *this;\n    }\n    __Complex&amp; operator*=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = x * b.x - y * b.y;\n        temp.y = x * b.y + y * b.x;\n        *this = temp;\n        return *this;\n    }\n    __Complex&amp; operator*=(const T &amp;b) {\n        x *= b;\n        y *= b;\n        return *this;\n    }\n    __Complex&amp; operator/=(const __Complex &amp;b) {\n        __Complex temp;\n        temp.x = (x * b.x + y * b.y) / (b.x * b.x + b.y * b.y);\n        temp.y = (y * b.x - x * b.y) / (b.x * b.x + b.y * b.y);\n        *this = temp;\n        return *this;\n    }\n    __Complex&amp; operator/=(const T b) {\n        x /= b;\n        y /= b;\n        return *this;\n    }\n    __Complex operator+(const __Complex &amp;b) {\n        __Complex a = *this;\n        a += b;\n        return a;\n    }\n    __Complex operator-(const __Complex &amp;b) {\n        __Complex a = *this;\n        a -= b;\n        return a;\n    }\n    __Complex operator*(const __Complex &amp;b) {\n        __Complex a = *this;\n        a *= b;\n        return a;\n    }\n    __Complex operator/(const __Complex &amp;b) {\n        __Complex a = *this;\n        a /= b;\n        return a;\n    }\n    friend istream&amp; operator&gt;&gt;(istream &amp;is, __Complex &amp;a) {\n        is &gt;&gt; a.x &gt;&gt; \" \" &gt;&gt; a.y;\n        return is;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const __Complex &amp;a) {\n        os &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; a.x &lt;&lt; \" \" &lt;&lt; a.y;\n        return os;\n    }\n}; // __Complex\nusing Complex = __Complex&lt;&gt;;\n// \u590d\u6570\u7c7b\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u4e4b\u95f4\u7684\u52a0\u51cf\u4e58\u9664\u8fd0\u7b97\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u7684\u8f93\u5165\u8f93\u51fa\n// \u5b9e\u73b0\u4e86 \u590d\u6570\u4e0e\u6574\u5f62/\u6d6e\u70b9\u578b\u53d8\u91cf\u4e4b\u95f4\u7684\u4e58\u9664\u8fd0\u7b97\n// \u7c7b\u578b\u540d\u79f0 Complex\n</code></pre>"},{"location":"Template/Other/Frac/","title":"\u5206\u6570","text":"\u6a21\u7248 C++<pre><code>struct Frac {\n    long long n, d;\n    Frac(long long n = 0, long long d = 1) : n(n), d(d) {\n        assert(d != 0);\n    }\n    void reduct() {\n        long long k = __gcd(llabs(n), d);\n        n /= k;\n        d /= k;\n    }\n    friend Frac operator+(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d + y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator-(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.d - y.n * x.d, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    friend Frac operator*(const Frac &amp;x, const Frac &amp;y) {\n        Frac res(x.n * y.n, x.d * y.d);\n        res.reduct();\n        return res;\n    }\n    Frac operator/(const Frac &amp;_) {\n        return *this * _.rev();\n    }\n    Frac&amp; operator+=(const Frac &amp;_) {\n        *this = *this + _;\n        return *this;\n    }\n    Frac&amp; operator-=(const Frac &amp;_) {\n        *this = *this - _;\n        return *this;\n    }\n    Frac&amp; operator*=(const Frac &amp;_) {\n        *this = *this * _;\n        return *this;\n    }\n    Frac&amp; operator/=(const Frac &amp;_) {\n        *this = *this / _;\n        return *this;\n    }\n    Frac rev() const {\n        Frac res(d, llabs(n));\n        if (n &lt; 0) {\n            res.n = -res.n;\n        }\n        return res;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Frac &amp;x) {\n        os &lt;&lt; x.n\n        if (x.d !== 1) os &lt;&lt; \"/\" &lt;&lt; x.n;\n\n        return os;\n    }\n}; // Frac\n</code></pre>"},{"location":"Template/Other/ManhattanDistance/","title":"\u66fc\u54c8\u987f\u8ddd\u79bb\u6700\u503c","text":"<p>\u4e24\u4e2a \\(d\\) \u7ef4\u7684\u70b9 \\((x_1,x_2,...,x_d)\\) \u548c \\((y_1,y2,...,y_d)\\) \u7684\u54c8\u66fc\u987f\u8ddd\u79bb\u5b9a\u4e49\u4e3a \\(|x_1-y_1|+|x_2-y_2|+...+|x_d-y_d|\\)</p> \u4f8b\u9898 \u6d1b\u8c37P1648(d\u7ef4\u4e24\u70b9\u6700\u5927)CF1093G(d\u7ef4\u4e24\u70b9\u6700\u5927/\u5e26\u4fee/\u591a\u6b21\u533a\u95f4\u67e5\u8be2) <p>P1648 \u770b\u5b88 - \u6d1b\u8c37</p> <p>\u4e8c\u8fdb\u5236\u679a\u4e3e\u6bcf\u4e00\u7ef4\u6700\u7ec8\u7684\u6b63\u8d1f\u53f7, \u6c42\u7684\u6700\u7ec8\u6bcf\u4e00\u7ef4\u7684\u548c\u7684\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c</p> <p>\u7b54\u6848\u5373\u4e3a\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u4e4b\u5dee</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; a[1000005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, d;\n    cin &gt;&gt; n &gt;&gt; d;\n    for (int i = 0 ; i &lt; n ; i++) {\n        a[i].resize(d);\n        for (int j = 0 ; j &lt; d ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    int ans = 0;\n    for (int i = 0 ; i &lt; 1 &lt;&lt; d ; i++) {\n        int mx = 0x7fffffff + 1, mi = 0x7fffffff;\n        for (int j = 0 ; j &lt; n ; j++) {\n            int sum = 0;\n            for (int k = 0 ; k &lt; d ; k++) {\n                if (i &amp; 1 &lt;&lt; k) {\n                    sum += a[j][k];\n                } else {\n                    sum -= a[j][k];\n                }\n            }\n            mx = max(mx, sum);\n            mi = min(mi, sum);\n        }\n        ans = max(ans, mx - mi);\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>Problem - G - Codeforces</p> <p>\u4e8c\u8fdb\u5236\u679a\u4e3e\u7edd\u5bf9\u503c\u7b26\u53f7, \u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4max</p> <p>\u7b54\u6848\u4e3a max(f[i]+f[(~i) &amp; ((1 &lt;&lt; k) - 1)])</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nint k;\nstruct Info {\n    int L, R;\n    array&lt;int, 32&gt; f;\n    Info() {\n        f = array&lt;int, 32&gt;{};\n    }\n    void init(int tL, int tR, array&lt;int, 32&gt; v) { // build \u5185\u521d\u59cb\u5316\n        L = tL;\n        R = tR;\n        for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n            f[i] = 0;\n            for (int j = 0 ; j &lt; k ; j++) {\n                if (i &amp; 1 &lt;&lt; j) {\n                    f[i] += v[j];\n                } else {\n                    f[i] -= v[j];\n                }\n            }\n        }\n    }\n    friend Info operator+(const Info &amp;lhs, const Info &amp;rhs) { // pushup\n        Info res;\n        res.L = lhs.L;\n        res.R = rhs.R;\n        for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n            res.f[i] = max(lhs.f[i], rhs.f[i]);\n        }\n        return res;\n    }\n};\narray&lt;int, 32&gt; a[200005];\nstruct SegmentTree {\n    int N = 0;\n    vector&lt;Info&gt; tr;\n    SegmentTree(int n) {\n        init(n);\n    }\n    void clear() {\n        N = 0;\n        tr.resize(0);\n    }\n    void init(int n) {\n        N = n;\n        n &lt;&lt;= 2;\n        tr.resize(n);\n    }\n    void build() {\n        build(1, N);\n    }\n    void build(int L, int R, int p = 1) {\n        if (L == R) {\n            tr[p].init(L, R, a[L]);\n            return;\n        }\n        int mid = L + R &gt;&gt; 1;\n        build(L, mid, p &lt;&lt; 1);\n        build(mid + 1, R, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    void modify(int QL, int QR, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            tr[p].init(QL, QR, a[QL]);\n            return;\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        if (QL &lt;= mid) modify(QL, QR, p &lt;&lt; 1);\n        if (QR &gt;= mid + 1) modify(QL, QR, p &lt;&lt; 1 | 1);\n        tr[p] = tr[p &lt;&lt; 1] + tr[p &lt;&lt; 1 | 1];\n    }\n    Info query(int QL, int QR, int p = 1) {\n        if (QL &lt;= tr[p].L &amp;&amp; tr[p].R &lt;= QR) {\n            return tr[p];\n        }\n        int mid = tr[p].L + tr[p].R &gt;&gt; 1;\n        if (QR &lt;= mid) return query(QL, QR, p &lt;&lt; 1);\n        else if (QL &gt;= mid + 1) return query(QL, QR, p &lt;&lt; 1 | 1);\n        return query(QL, QR, p &lt;&lt; 1) + query(QL, QR, p &lt;&lt; 1 | 1);\n    }\n}; // SegmentTree\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; k ; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    SegmentTree st(n);\n    st.build();\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int op;\n        cin &gt;&gt; op;\n        if (op == 1) {\n            int pos;\n            cin &gt;&gt; pos;\n            for (int i = 0 ; i &lt; k ; i++) {\n                cin &gt;&gt; a[pos][i];\n            }\n            st.modify(pos, pos);\n        } else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            auto res = st.query(L, R);\n            int ans = 0;\n            for (int i = 0 ; i &lt; 1 &lt;&lt; k ; i++) {\n                ans = max(ans, res.f[i] + res.f[(~i) &amp; ((1 &lt;&lt; k) - 1)]);\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/","title":"\u533a\u95f4\u4f17\u6570","text":""},{"location":"Template/Other/%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/#_2","title":"\u4e0d\u5e26\u4fee","text":""},{"location":"Template/Other/%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/#-onsqrtn","title":"\u79bb\u7ebf(\u56de\u6eda\u83ab\u961f/\u4e0d\u5220\u9664\u83ab\u961f) - \\(O(n\\sqrt{n})\\)","text":"<p>P1997 faebdc \u7684\u70e6\u607c - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[100005];\nstruct MQuery {\n    int L, R, idx;\n    bool operator&lt;(const MQuery&amp; x) const {\n        if (belong[L] != belong[x.L]) return L &lt; x.L;\n        return R &lt; x.R;\n    }\n};\nint a[100005], b[100005];\nint cnt[100005], cnt1[100005];\nint res;\nvector&lt;int&gt; c(1);\nvoid add(int i) {\n    cnt[a[i]]++;\n    res = max(res, cnt[a[i]]);\n}\nvoid del(int i) {\n    cnt[a[i]]--;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\nint N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = sqrt(N);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = (i - 1)/ mx + 1;\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        b[i] = (i == belong[N]) ? N : mx * i;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; a[i];\n        c.emplace_back(a[i]);\n    }\n    sort(begin(c), end(c));\n    c.resize(unique(begin(c), end(c)) - begin(c));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        a[i] = lower_bound(begin(c), end(c), a[i]) - begin(c);\n    }\n    vector&lt;MQuery&gt; mq;\n    for (int i = 0 ; i &lt; M ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        mq.push_back({L, R, i});\n    }\n    sort(begin(mq), end(mq));\n    vector&lt;int&gt; ans(M);\n    int last = belong[mq[0].L], R = b[last], L = R + 1;\n    for (int i = 0 ; i &lt; M ; i++) {\n        if (belong[mq[i].L] == belong[mq[i].R]) {\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]++;\n            }\n            int temp = 0;\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                temp = max(temp, cnt1[a[j]]);\n            }\n            for (int j = mq[i].L ; j &lt;= mq[i].R ; j++) {\n                cnt1[a[j]]--;\n            }\n            ans[mq[i].idx] = temp;\n            continue;\n        }\n        if (last != belong[mq[i].L]) {\n            while (R &gt; b[belong[mq[i].L]]) del(R--);\n            while (L &lt; b[belong[mq[i].L]] + 1) del(L++);\n            res = 0;\n            last = belong[mq[i].L];\n        }\n        while (R &lt; mq[i].R) add(++R);\n        long long temp = res;\n        int L1 = L;\n        while (L1 &gt; mq[i].L) add(--L1);\n        ans[mq[i].idx] = res;\n        while (L1 &lt; L) del(L1++);\n        res = temp;\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/#-onsqrt3n2","title":"\u5728\u7ebf(\u5206\u5757) - \\(O(n\\sqrt[3]{n^2})\\)","text":"<p>P4168 [Violet] \u84b2\u516c\u82f1 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint belong[40005];\nstruct Block {\n    int L, R;\n} block[40005];\nint a[40005];\nint cnt[40][40][40005], mode[40][40], cnt1[40005];\nvector&lt;int&gt; c(1);\nint res;\nvoid add(int L, int R, int i) {\n    cnt[L][R][a[i]]++;\n    if (cnt[L][R][a[i]] &gt; cnt[L][R][0] || (cnt[L][R][a[i]] == cnt[L][R][0] &amp;&amp; c[a[i]] &lt; mode[L][R])) {\n        mode[L][R] = c[a[i]];\n    }\n    cnt[L][R][0] = max(cnt[L][R][0], cnt[L][R][a[i]]);\n}\nvoid del(int L, int R, int i) {\n    cnt[L][R][a[i]]--;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n    int mx = pow(N, 0.6666666666);\n    for (int i = 1 ; i &lt;= N ; i++) {\n        belong[i] = (i - 1)/ mx + 1;\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        block[i].L = block[i - 1].R + 1; \n        block[i].R = (i == belong[N]) ? N : mx * i;\n    }\n    for (int i = 1 ; i &lt;= N ; i++) {\n        cin &gt;&gt; a[i];\n        c.emplace_back(a[i]);\n    }\n    sort(begin(c), end(c));\n    c.resize(unique(begin(c), end(c)) - begin(c));\n    for (int i = 1 ; i &lt;= N ; i++) {\n        a[i] = lower_bound(begin(c), end(c), a[i]) - begin(c);\n    }\n    for (int i = 1 ; i &lt;= belong[N] ; i++) {\n        for (int j = i ; j &lt;= belong[N] ; j++) {\n            for (int k = block[i].L ; k &lt;= block[j].R ; k++) {\n                add(i, j, k);\n            }\n        }\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        L = (L + res - 1) % N + 1;\n        R = (R + res - 1) % N + 1;\n        if (L &gt; R) swap(L, R);\n        int bL = belong[L] + 1, bR = belong[R] - 1;\n        if (belong[L] == belong[R] || bL == bR + 1) {\n            res = 0;\n            for (int j = L ; j &lt;= R ; j++) {\n                cnt1[a[j]]++;\n                if (cnt1[a[j]] &gt; cnt1[0] || (cnt1[a[j]] == cnt1[0] &amp;&amp; c[a[j]] &lt; res)) {\n                    res = c[a[j]];\n                }\n                cnt1[0] = max(cnt1[0], cnt1[a[j]]);\n            }\n            cout &lt;&lt; res &lt;&lt; \"\\n\";\n            for (int j = L ; j &lt;= R ; j++) {\n                cnt1[a[j]]--;\n            }\n            cnt1[0] = 0;\n            continue;\n        }\n        int temp1 = mode[bL][bR];\n        int temp2 = cnt[bL][bR][0];\n        for (int j = L ; j &lt;= block[belong[L]].R ; j++) {\n            add(bL, bR, j);\n        }\n        for (int j = block[belong[R]].L ; j &lt;= R ; j++) {\n            add(bL, bR, j);\n        }\n        res = mode[bL][bR];\n        cout &lt;&lt; res &lt;&lt; \"\\n\";\n        mode[bL][bR] = temp1;\n        cnt[bL][bR][0] = temp2;\n        for (int j = L ; j &lt;= block[belong[L]].R ; j++) {\n            del(bL, bR, j);\n        }\n        for (int j = block[belong[R]].L ; j &lt;= R ; j++) {\n            del(bL, bR, j);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/","title":"\u6574\u6570\u62c6\u5206","text":""},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#_2","title":"\u5b9a\u4e49","text":"<p>\u6b63\u6574\u6570\u62c6\u5206\u662f\u628a\u6b63\u6574\u6570\u5206\u89e3\u6210\u82e5\u5e72\u6b63\u6574\u6570\u7684\u548c</p>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#_3","title":"\u5b9a\u7406","text":"<p>\u2460 N\u62c6\u5206\u6210\u4e0d\u540c\u6574\u6570\u7684\u548c\u7684\u62c6\u5206\u6570(\u4e0d\u5141\u8bb8\u91cd\u590d) \u7b49\u4e8e N\u62c6\u5206\u6210\u5947\u6570\u7684\u62c6\u5206\u6570(\u5141\u8bb8\u91cd\u590d)</p> <p>\u2461 N\u62c6\u5206\u6210\u4e00\u4e9b\u91cd\u590d\u6b21\u6570\u4e0d\u8d85\u8fc7 k \u6b21\u7684\u6574\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u4e0d\u88ab k+1 \u6574\u9664\u7684\u6570\u7684\u548c\u7684\u62c6\u5206\u6570</p> <p>\u2462 N\u62c6\u5206\u6210k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u6700\u5927\u6570\u4e3ak\u7684\u62c6\u5206\u6570</p> <p>\u2463 N\u62c6\u5206\u6210\u6700\u591a\u4e0d\u8d85\u8fc7k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N\u62c6\u5206\u6210\u6700\u5927\u6570\u4e0d\u8d85\u8fc7k\u7684\u62c6\u5206\u6570</p> <p>\u2464 N\u62c6\u5206\u6210\u4e0d\u8d85\u8fc7k\u4e2a\u6570\u7684\u548c\u7684\u62c6\u5206\u6570 \u7b49\u4e8e N+k\u62c6\u5206\u6210\u6070\u597dk\u4e2a\u6570\u7684\u62c6\u5206\u6570</p>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#_4","title":"\u5141\u8bb8\u91cd\u590d\u7684\u6574\u6570\u62c6\u5206","text":"<p>#6268. \u5206\u62c6\u6570 - LibreOJ</p> <p>P6189 [NOI Online #1 \u5165\u95e8\u7ec4] \u8dd1\u6b65 - \u6d1b\u8c37</p>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#on2","title":"\\(O(n^2)\\) \u4efb\u610f\u6a21\u6570","text":"C++<pre><code>dp[0] = 1;\nfor (int i = 1 ; i &lt;= N ; i++) {\n    for (int j = i ; j &lt;= N ; j++) {\n        dp[j] += dp[j - i];\n    }\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#oncdotsqrtn","title":"\\(O(n\\cdot{}\\sqrt{n})\\) \u4efb\u610f\u6a21\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nconst int N = 100005;\nint ans[N], temp[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, mod;\n    cin &gt;&gt; n &gt;&gt; mod;\n    int sqr = sqrt(n);\n    ans[0] = temp[0] = 1;\n    for (int i = 1 ; i &lt;= sqr ; i++) {\n        for (int k = 0 ; k &lt; 2 ; k++) {\n            for (int j = i ; j &lt;= n - i * i ; j++) {\n                temp[j] = (temp[j] + temp[j - i]) % mod;\n            }\n        }\n        for (int j = i * i ; j &lt;= n ; j++) {\n            ans[j] = (ans[j] + temp[j - i * i]) % mod;\n        }\n    }\n    cout &lt;&lt; ans[n] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#oncdotlogn","title":"\\(O(n\\cdot{}\\log{}n)\\) \u5927\u8d28\u6570","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\n#define add(x, y) (x &gt;= mod - y ? x + y - mod : x + y)\n#define sub(x, y) (x &lt; y ? x - y + mod : x - y)\nconst int mod = 998244353;\nconst int N = 262145;\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b &amp; 1) {\n            res = 1LL * res * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nnamespace Poly {\n    int w[N];\n    int preW = 0;\n    int getLen(int x) {\n        x |= x &gt;&gt; 1;\n        x |= x &gt;&gt; 2;\n        x |= x &gt;&gt; 4;\n        x |= x &gt;&gt; 8;\n        x |= x &gt;&gt; 16;\n        return x + 1;\n    }\n    const int inv2 = qpow(2, mod - 2);\n    void init(int len) {\n        if (len &lt;= preW) {\n            return;\n        }\n        preW = len;\n        for (int i = 1, j, k ; i &lt; len ; i &lt;&lt;= 1) {\n            for (w[j = i] = 1, k = qpow(3, (mod - 1) / (i &lt;&lt; 1)), j++ ; j &lt; i &lt;&lt; 1 ; j++) {\n                w[j] = 1LL * w[j - 1] * k % mod;\n            }\n        }\n    }\n    void DNT(int *a, int len) {\n        for (int i, j, k = len &gt;&gt; 1, L, *W, *x, *y, z ; k ; k &gt;&gt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = *y;\n                    *y = 1LL * sub(*x, z) * *W % mod;\n                    *x = add(*x, z);\n                }\n            }\n        }\n    }\n    void IDNT(int *a, int len) {\n        for (int i, j, k = 1, L, *W, *x, *y, z ; k &lt; len  ; k &lt;&lt;= 1) {\n            for (L = k &lt;&lt; 1, i = 0 ; i &lt; len ; i += L) {\n                for (j = 0, W = w + k, x = a + i, y = x + k ; j &lt; k ; j++, W++, x++, y++) {\n                    z = 1LL * *W * *y % mod;\n                    *y = sub(*x, z);\n                    *x = add(*x, z);\n                }\n            }\n        }\n        reverse(a + 1, a + len);\n        for (int inv = qpow(len, mod - 2), i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * inv % mod;\n        }\n    }\n    int NTT(int *a, int *b, int n, int m) {\n        int len = getLen(n + m);\n        init(len);\n        DNT(a, len);\n        DNT(b, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            a[i] = 1LL * a[i] * b[i] % mod;\n        }\n        IDNT(a, len);\n        return len;\n    }\n    void inv(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = qpow(a[0], mod - 2);\n            return;\n        }\n        inv(a, b, n + 1 &gt;&gt; 1);\n        int len = getLen(n &lt;&lt; 1);\n        init(len);\n        static int c[N];\n        copy(a, a + n, c);\n        fill(c + n, c + len, 0);\n        DNT(b, len);\n        DNT(c, len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            b[i] = (2LL - 1LL * c[i] * b[i] % mod + mod) % mod * b[i] % mod;\n        }\n        IDNT(b, len);\n        fill(b + n, b + len, 0);\n    }\n    void derivative(int *a, int n) {\n        for (int i = 1 ; i &lt; n ; i++) {\n            a[i - 1] = 1LL * i * a[i] % mod;\n        }\n        a[n - 1] = 0;\n    }\n    void integrate(int *a, int n) {\n        for (int i = n - 1 ; i &gt; 0 ; i--) {\n            a[i] = 1LL * qpow(i, mod - 2) * a[i - 1] % mod;\n        }\n        a[0] = 0;\n    }\n    void ln(int *a, int *b, int n) {\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        copy(a, a + len, b);\n        fill(c, c + len, 0);\n        inv(b, c, n);\n        derivative(b, n);\n        NTT(b, c, n, n);\n        integrate(b, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n    void exp(int *a, int *b, int n) {\n        if (n == 1) {\n            b[0] = 1;\n            return;\n        }\n        exp(a, b, n + 1 &gt;&gt; 1);\n        static int c[N];\n        int len = getLen(n &lt;&lt; 1);\n        fill(c, c + len, 0);\n        ln(b, c, n);\n        for (int i = 0 ; i &lt; n ; i++) {\n            c[i] = sub(a[i], c[i]);\n        }\n        c[0] = add(c[0], 1);\n        NTT(b, c, n, n);\n        for (int i = n ; i &lt; len ; i++) {\n            b[i] = 0;\n        }\n    }\n} // Poly\nusing Poly::inv;\nusing Poly::exp;\nint a[N], b[N], ans[N];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = i ; j &lt;= n ; j += i) {\n            a[j] = (a[j] + mod - qpow(j / i, mod - 2)) % mod;\n        }\n    }\n    exp(a, b, n + 1);\n    inv(b, ans, n + 1);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#k","title":"k \u90e8\u5206\u62c6\u6570","text":"<p>\u5c06 \\(n\\) \u5206\u6210\u6070\u6709 \\(k\\) \u4e2a\u90e8\u5206\u7684\u5206\u62c6\uff0c\u6210\u4e3a \\(k\\) \u90e8\u5206\u62c6\u6570\uff0c\u8bb0\u4f5c \\(P(n,k)\\) $$ P(n,k)=\\sum_{j=0}^kP(n-k,j) $$</p> \\[ P(n,k)=P(n-1,k-1)+P(n-k,k) \\]"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#oncdotk","title":"\\(O(n\\cdot{}k)\\)","text":"Code C++<pre><code>P[0][0] = 1;\nfor (int i = 1 ; i &lt;= n ; i++) {\n    for (int j = 1 ; j &lt;= k ; j++) {\n        if (i &gt;= j) {\n            P[i][j] = P[i - j][j] + P[i - 1][j - 1];\n        }\n    }\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#_5","title":"\u4e92\u5f02\u62c6\u5206\u6570","text":"<p>\\(pd_n\\) \uff0c\u81ea\u7136\u6570 \\(n\\) \u7684\u5404\u90e8\u5206\u4e92\u4e0d\u76f8\u540c\u7684\u5206\u62c6\u65b9\u6cd5\u6570\u3002</p>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#osqrtncdotk","title":"\\(O(\\sqrt{n\\cdot{}k})\\)","text":"Code C++<pre><code>int n;\ncin &gt;&gt; n;\nPD[0][0] = 1;\nint ans = 0;\nint mx = sqrt(n) + 100;\nfor (int j = 1 ; j &lt; mx ; j++) {\n    for (int i = 0 ; i &lt; mx ; i++) {\n        PD[i][j &amp; 1] = 0;\n    }\n    for (int i = 0 ; i &lt;= n ; i++) {\n        if (i &gt;= j) {\n            PD[i][j &amp; 1] = PD[i - j][j &amp; 1] + PD[i - j][(j - 1) &amp; 1];\n        }\n    }\n    ans += PD[n][j &amp; 1];\n}\n</code></pre>"},{"location":"Template/Other/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/#_6","title":"\u5947\u62c6\u5206\u6570","text":"<p>\\(po_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5947\u6570\u7684\u5206\u62c6\u65b9\u6cd5\u6570\u3002 $$ po_n=pd_n $$ \\(pde_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5076\u6570\u7684\u4e92\u5f02\u5206\u62c6\u65b9\u6cd5\u6570\u3002</p> <p>\\(pdo_n\\)\uff0c\u81ea\u7136\u6570 \\(n\\) \u5404\u90e8\u5206\u90fd\u662f\u5947\u6570\u7684\u4e92\u5f02\u5206\u62c6\u65b9\u6cd5\u6570\u3002 $$ pd_n=pde_n+pdo_n $$</p>"},{"location":"Template/Other/Interval/gcd/","title":"\u533a\u95f4gcd","text":""},{"location":"Template/Other/Interval/gcd/#_1","title":"\u591a\u6b21\u67e5\u8be2\u533a\u95f4\u67e5\u8be2","text":"<p>\\(\\gcd(a_L,a_{L+1},...,a_R)\\)</p> <p>\u4f7f\u7528 ST\u8868 \u53ef\u4ee5 \\(O(nlogn)\\) \u9884\u5904\u7406\u51fa\u533a\u95f4\u7684gcd\uff0c\u7136\u540e \\(O(1)\\) \u67e5\u8be2\u3002</p>"},{"location":"Template/Other/Interval/gcd/#_2","title":"\u6027\u8d28","text":"<p>\u4ee4 \\(f(L,R)=\\gcd(a_L,a_{L+1},...,a_R)\\)</p> <p>\u4ece \\(f(L,R),f(L+1,R),f(L+2,R),...,f(R,R)\\)\uff0c\u4e00\u5b9a\u662f\u5355\u8c03\u4e0d\u5347\u7684\u4e00\u4e2a\u5e8f\u5217\u3002</p> <p>\u4ece\u4e0a\u53ef\u5f97\uff0c\u6700\u591a\u6709 \\(logx\\) \u79cd \\(\\gcd\\) \u7684\u53d6\u503c\u3002</p> <p>\u6545\u53ef\u4ee5\u901a\u8fc7 \\(O(nlogn)\\) \u7684\u590d\u6742\u5ea6\u9884\u5904\u7406\u51fa\u6240\u6709\u7684\u533a\u95f4 \\(\\gcd\\)\u3002</p> \u4f8b\u9898 \u725b\u5ba269791F(\u56fa\u5b9a\u53f3\u7aef\u70b9)\u725b\u5ba276681K(\u56fa\u5b9a\u5de6\u7aef\u70b9) <p>F-\u5c0f\u8fb0\u521a\u5b66 gcd_\u725b\u5ba2\u5c0f\u767d\u6708\u8d5b81</p> <p>\u591a\u6b21\u67e5\u8be2\u96c6\u5408 \\(S=U_{i=L}^R \\{\\gcd_{j=i}^Ra_j\\}\\) \u7684\u5927\u5c0f</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nlong long a[600005];\nvector&lt;pair&lt;long long, int&gt;&gt; f[600005];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        long long g = a[i];\n        f[i].emplace_back(g, i);\n        for (auto &amp;[preg, idx] : f[i - 1]) {\n            long long tg = __gcd(g, preg);\n            if (tg != g) {\n                f[i].emplace_back(tg, idx);\n                g = tg;\n            }\n            if (g == 1) break;\n        }\n    }\n    while (m--) {\n        int L, R;\n        cin &gt;&gt; L &gt;&gt; R;\n        int ans = 0;\n        for (int i = 0 ; i &lt; int(f[R].size()) ; i++) {\n            // \u6b64\u65f6\u533a\u95f4 [L, R] \u7684 gcd \u5747\u4e3a f[R][i].first\n            // L \u5c5e\u4e8e\u533a\u95f4 [f[R][i + 1].second + 1, f[R][i].second]\n            // \u5f53 i = f[R].size() - 1 \u65f6, L = 1\n            if (L &lt;= f[R][i].second) {\n                ans++;\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>K-\u540c\u5b66\u805a\u4f1a_\u7b2c\u5341\u4e00\u5c4a\"\u56fe\u7075\u676f\"NEUQ-ACM\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b</p> <p>\u6c42 \\(\\dfrac{\\sum_{L=1}^{n}\\sum_{R=L}^n(R-L+1)*\\gcd_{i=L}^Ra_i}{\\dfrac{n*(n+1)}{2}}\\)</p> C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2024 OneWan\nint a[200005];\nvector&lt;pair&lt;int, int&gt;&gt; f[200005];\nconst long long mod = 998244353;\nlong long qpow(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = n ; i &gt;= 1 ; i--) {\n        int g = a[i];\n        f[i].emplace_back(g, i);\n        for (auto &amp;[preg, idx] : f[i + 1]) {\n            int tg = __gcd(g, preg);\n            if (tg != g) {\n                f[i].emplace_back(tg, idx);\n                g = tg;\n            }\n            if (g == 1) break;\n        }\n    }\n    long long ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt; int(f[i].size()) ; j++) {\n            // \u6b64\u65f6\u533a\u95f4 [i, R] \u7684 gcd \u5747\u4e3a f[i][j].first\n            // R \u5c5e\u4e8e\u533a\u95f4 [f[i][j].second, f[i][j + 1].second - 1]\n            // \u5f53 j = f[i].size() - 1 \u65f6, R = n;\n            int L = f[i][j].second, R, g = f[i][j].first;\n            if (j &lt; int(f[i].size()) - 1) {\n                R = f[i][j + 1].second - 1;\n            } else {\n                R = n;\n            }\n            long long res = (1LL * (L + R) * (R - L + 1) / 2 - 1LL * (i - 1) * (R - L + 1) % mod + mod) % mod * g % mod;\n            ans = (ans + res) % mod;\n        }\n    }\n    cout &lt;&lt; ans * qpow(1LL * n * (n + 1) / 2 % mod, mod - 2) % mod &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/Randomization/Radom/","title":"\u968f\u673a\u6570","text":"\u6a21\u7248 usage\u4ee3\u7801 <p>\u5747\u7b49\u5206\u5e03</p> <p>\u4ec5\u652f\u6301\u6574\u6570\u7c7b\u578b int / long long / unsigned long long</p> <p>\u548c\u6d6e\u70b9\u6570\u7c7b\u578b double / long double</p> C++<pre><code>template&lt;class T&gt;\nstruct Random {\n    mt19937 mt;\n    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    T operator()(const T&amp; L, const T&amp; R);\n};\ntemplate&lt;&gt;\nint Random&lt;int&gt;::operator()(const int &amp;L, const int &amp;R) {\n    uniform_int_distribution&lt;int&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong long Random&lt;long long&gt;::operator()(const long long &amp;L, const long long &amp;R) {\n    uniform_int_distribution&lt;long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nunsigned long long Random&lt;unsigned long long&gt;::operator()(const unsigned long long &amp;L, const unsigned long long &amp;R) {\n    uniform_int_distribution&lt;unsigned long long&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\ndouble Random&lt;double&gt;::operator()(const double &amp;L, const double &amp;R) {\n    uniform_real_distribution&lt;double&gt; dist(L, R);\n    return dist(mt);\n}\ntemplate&lt;&gt;\nlong double Random&lt;long double&gt;::operator()(const long double &amp;L, const long double &amp;R) {\n    uniform_real_distribution&lt;long double&gt; dist(L, R);\n    return dist(mt);\n}\nRandom&lt;int&gt; rng;\n</code></pre>"},{"location":"Template/Other/Randomization/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","title":"\u6a21\u62df\u9000\u706b","text":"<p>#2076. \u300cJSOI2016\u300d\u70b8\u5f39\u653b\u51fb - LibreOJ</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble x[10], y[10], r[10], p[1005], q[1005];\nint main() {\n    srand(time(nullptr));\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M, R;\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; R;\n    int ans = 0;\n    for (int i = 0 ; i &lt; N ; i++) {\n        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i];\n    }\n    for (int i = 0 ; i &lt; M ; i++) {\n        cin &gt;&gt; p[i] &gt;&gt; q[i];\n    }\n    auto dist = [&amp;](double x1, double y1, double x2, double y2) {\n        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    };\n    auto check = [&amp;](double x1, double y1) {\n        double mi = R;\n        for (int i = 0 ; i &lt; N ; i++) {\n            mi = min(mi, dist(x1, y1, x[i], y[i]) - r[i]);\n        }\n        int res = 0;\n        for (int i = 0 ; i &lt; M ; i++) {\n            if (dist(x1, y1, p[i], q[i]) &lt;= mi) {\n                res++;\n            }\n        }\n        return res;\n    };\n    auto rng = [&amp;](int L, int R) {\n        return rand() % (R - L + 1) + L;\n    };\n    auto Sa = [&amp;]() {\n        int pos = rng(0, M);\n        double nx = p[pos], ny = q[pos];\n        int k = check(nx, ny);\n        ans = max(ans, k);\n        for (double t = 3000 ; t &gt;= 1e-8 ; t *= 0.99) {\n            double mx = nx + t * rng(-100, 100), my = ny + t * rng(-100, 100);\n            int _k = check(mx, my);\n            ans = max(ans, _k);\n            int delta = _k - k;\n            if (delta &gt; 0) {\n                nx = mx;\n                ny = my;\n                k = check(nx, ny);\n                ans = max(ans, k);\n            }\n        }\n    };\n    for (int i = 0 ; i &lt; 10 ; i ++) {\n        Sa();\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <p>P2503 [HAOI2006] \u5747\u5206\u6570\u636e - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nint a[25], s[25];\nint main() {\n    srand(time(0));\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int sum = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cin &gt;&gt; a[i];\n        sum += a[i];\n    }\n    double ans = 0x7fffffff;\n    double _x = (double) sum / m;\n    auto check = [&amp;]() {\n        int que[8] = {0};\n        for (int i = 1 ; i &lt;= n ; i++) {\n            int mi = 0;\n            for (int j = 0 ; j &lt; m ; j++) {\n                if (que[j] &lt; que[mi]) {\n                    mi = j;\n                }\n            }\n            que[mi] += a[i];\n        }\n        double res = 0;\n        for (int i = 0 ; i &lt; m ; i++) {\n            res += (_x - que[i]) * (_x - que[i]);\n        }\n        return res;\n    };\n    ans = min(ans, check());\n    for (int i = 0 ; i &lt; 1000000 ; i++) {\n        random_shuffle(a + 1, a + 1 + n);\n        ans = min(ans, check());\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sqrt(ans / m) &lt;&lt; \"\\n\"; \n    return 0;\n}\n</code></pre>"},{"location":"Template/Other/Randomization/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95/","title":"\u722c\u5c71\u7b97\u6cd5","text":"<p>P4035 [JSOI2008] \u7403\u5f62\u7a7a\u95f4\u4ea7\u751f\u5668 - \u6d1b\u8c37</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\ndouble a[11][10], sum[11], dist[11], cans[11];\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0 ; i &lt; n + 1 ; i++) {\n        for (int j = 0 ; j &lt; n ; j++) {\n            cin &gt;&gt; a[i][j];\n            sum[j] += a[i][j];\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum[i] /= n + 1;\n    }\n    auto check = [&amp;]() {\n        double res = 0;\n        for (int i = 0 ; i &lt; n + 1 ; i++) {\n            dist[i] = cans[i] = 0;\n            for (int j = 0 ; j &lt; n ; j++) {\n                dist[i] += (a[i][j] - sum[j]) * (a[i][j] - sum[j]);\n            }\n            dist[i] = sqrt(dist[i]);\n            res += dist[i];\n        }\n        res /= n + 1;\n        for (int i = 0 ; i &lt; n + 1 ; i++) {\n            for (int j = 0 ; j &lt; n ; j++) {\n                cans[j] += (dist[i] - res) * (a[i][j] - sum[j]) / res;\n            }\n        }\n    };\n    for (double t = 10000 ; t &gt;= 1e-4 ; t *= 0.99995) {\n        check();\n        for (int i = 0 ; i &lt; n ; i++) {\n            sum[i] += cans[i] * t;\n        }\n    }\n    for (int i = 0 ; i &lt; n ; i++) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; sum[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/","title":"AC\u81ea\u52a8\u673a(AC_Automaton)","text":"<p>P3808 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u7b80\u5355\u7248\uff09 - \u6d1b\u8c37</p> <p>P3796 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 - \u6d1b\u8c37</p> Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_1","title":"\u6c42\u6709\u591a\u5c11\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u51fa\u73b0\u8fc7\u7684\u4e2a\u6570","text":"Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    AC_Automaton *ac = new AC_Automaton();\n    string str;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; str;\n        ac -&gt; insert(str);\n    }\n    ac -&gt; build();\n    cin &gt;&gt; str;\n    cout &lt;&lt; (ac -&gt; query(str));\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_2","title":"\u6c42\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u6a21\u5f0f\u4e32","text":"Code C++<pre><code>const int N = 151;\nconst int M = N * 70;\nstruct AC_Automaton {\n    int tree_size, fail[M], nxt[M][26], val[M], idx[M];\n    int cnt[N], id_num;\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        idx[index] = ++id_num;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 ; j = fail[j]) {\n                val[j]++;\n            }\n        }\n        for (int i = 1 ; i &lt;= tree_size ; i++) {\n            if (idx[i] == 0) continue;\n            res = max(res, val[i]);\n            cnt[idx[i]] = val[i];\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    AC_Automaton *ac = new AC_Automaton();\n    while (cin &gt;&gt; n) {\n        if (n == 0) break;\n        for (int i = 0 ; i &lt; M ; i++) {\n            ac -&gt; fail[i] = 0;\n            ac -&gt; val[i] = 0;\n            ac -&gt; idx[i] = 0;\n            for (int j = 0 ; j &lt; 26 ; j++) {\n                ac -&gt; nxt[i][j] = 0;\n            }\n        }\n        for (int i = 0 ; i &lt; N ; i++) {\n            ac -&gt; cnt[i] = 0;\n        }\n        ac -&gt; id_num = 0;\n        ac -&gt; tree_size = 0;\n        vector&lt;string&gt; s(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            cin &gt;&gt; s[i];\n            ac -&gt; insert(s[i]);\n        }\n        ac -&gt; build();\n        string str;\n        cin &gt;&gt; str;\n        int ans = ac -&gt; query(str);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= n ; i++) {\n            if (ac -&gt; cnt[i] == ans) {\n                cout &lt;&lt; s[i] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/KMP/","title":"KMP","text":"\u6a21\u7248 base0base1 \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; prefix(const string &amp;str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 1 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &gt; 0 &amp;&amp; str[i] != str[j]) {\n            j = nxt[j - 1];\n        }\n        if (str[i] == str[j]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\nvector&lt;int&gt; findOccurrences(const string &amp;str, const string &amp;x) {\n    string cur = x + \"#\" + str;\n    int len1 = str.size(), len2 = x.size();\n    vector&lt;int&gt; nxt = prefix(cur);\n    vector&lt;int&gt; pos;\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 ; i++) {\n        if (nxt[i] == len2) {\n            pos.push_back(i - 2 * len2);\n        }\n    }\n    return pos;\n}\nint match(const string &amp;str, const string &amp;x) {\n    int cnt = 0;\n    int len1 = str.size(), len2 = x.size();\n    auto nxt = prefix(x);\n    int j = 0;\n    for (int i = 0 ; i &lt; len1 ; i++) {\n        while (j != 0 &amp;&amp; str[i] != x[j]) {\n            j = nxt[j - 1];\n        }\n        if (str[i] == x[j]) {\n            j++;\n        }\n        if (j == len2) {\n            return i - len2 + 1;\n            j = nxt[j - 1];\n        }\n    }\n    return -1;\n}\n</code></pre> \u4ee3\u7801 C++<pre><code>vector&lt;int&gt; prefix(const string &amp;str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n  return nxt;\n}\n</code></pre>"},{"location":"Template/String/KMP/#_1","title":"\u5e94\u7528","text":""},{"location":"Template/String/KMP/#_2","title":"\u5b57\u7b26\u4e32\u7684\u5468\u671f","text":"<p>\u5b57\u7b26\u4e32\u7684\u6700\u5c0f\u5468\u671f\u5c31\u662f \\(len-nxt.back()\\)</p>"},{"location":"Template/String/KMP/#_3","title":"\u7edf\u8ba1\u6bcf\u4e2a\u524d\u7f00\u51fa\u73b0\u7684\u6b21\u6570","text":"\u4ee3\u7801 C++<pre><code>string a;\ncin &gt;&gt; a;\nauto nxt = prefix(a);\nint len = a.size();\nvector&lt;long long&gt; ans(len + 1);\nfor (int i = 0 ; i &lt; len ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = len ; i &gt;= 1 ; i--) {\n    ans[nxt[i - 1]] += ans[i];\n}\nfor (int i = 1 ; i &lt;= len ; i++) {\n    ans[i]++;\n}\nlong long res = 0;\nfor (int i = 1 ; i &lt;= len ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre> \u4f8b\u9898 QOJ464LOJ103 <p>\u524d\u7f00\u51fd\u6570 / KMP - QOJ.ac</p> <p>#103. \u5b50\u4e32\u67e5\u627e - LibreOJ</p>"},{"location":"Template/String/Manacher/","title":"\u9a6c\u62c9\u8f66","text":"\u6a21\u7248 C++<pre><code>string str;\ncin &gt;&gt; str;\nint maxLen = 0;\nint idx = 0;\nint r = 0;\nint c = 0;\nint len = int(str.size()) * 2 + 1;\nvector&lt;char&gt; a(len);\nvector&lt;int&gt; b(len);\nfor (int i = 0 ; i &lt; len ; i++) {\n    a[i] = i &amp; 1 ? str[idx++] : '#';\n}\nfor (int i = 0 ; i &lt; len ; i++) {\n    b[i] = r &gt; i ? min(r - i, b[c * 2 - i]) : 1;\n    while (i - b[i] &gt; -1 &amp;&amp; i + b[i] &lt; len &amp;&amp; a[i - b[i]] == a[i + b[i]]) {\n        b[i]++;\n    }\n    if (i + b[i] &gt; r) {\n        r = i + b[i];\n        c = i;\n    }\n    if (b[i] - 1 &gt; maxLen) {\n        maxLen = b[i] - 1;\n        idx = i;\n    }\n}\ncout &lt;&lt; maxLen &lt;&lt; \" \" &lt;&lt; str.substr((idx - maxLen + 1) / 2, maxLen);\n</code></pre> \u793a\u4f8b \u6d1b\u8c37P3805 <p>P3805 \u3010\u6a21\u677f\u3011manacher \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/String/StringHash/","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"\u6a21\u7248 C++<pre><code>template&lt;int N&gt;\nstruct _StringHash {\n    static int mod;\n    static array&lt;int, N&gt; base;\n    static vector&lt;array&lt;int, N&gt;&gt; bases;\n    static bool noInit;\n    vector&lt;array&lt;int, N&gt;&gt; hash;\n    _StringHash(const string &amp;str) {\n        if (noInit) {\n            for (int i = 0 ; i &lt; N ; i++) {\n                base[i] = getRandom();\n            }\n            noInit = false;\n        }\n        int len = str.size() + 1;\n        hash.resize(len);\n        if (len &gt; int(bases.size())) {\n            int k = bases.size();\n            bases.resize(len);\n            for (int i = k ; i &lt; len ; i++) {\n                for (int j = 0 ; j &lt; N ; j++) {\n                    bases[i][j] = 1LL * bases[i - 1][j] * base[j] % mod;\n                }\n            }\n        }\n        for (int i = 1 ; i &lt; len ; i++) {\n            for (int j = 0 ; j &lt; N ; j++) {\n                hash[i][j] = (1LL * hash[i - 1][j] * base[j] + str[i - 1]) % mod;\n            }\n        }\n    }\n    static mt19937 rnd;\n    static int getRandom() {\n        return rnd() % 1000000 + 1000000;\n    }\n    array&lt;int, N&gt; get(int L, int R) {\n        array&lt;int, N&gt; res{};\n        for (int i = 0 ; i &lt; N ; i++) {\n            res[i] = (hash[R][i] - 1LL * hash[L - 1][i] * bases[R - L + 1][i] % mod + mod) % mod;\n        }\n        return res;\n    }\n}; // _StringHash\ntemplate&lt;int N&gt;\nmt19937 _StringHash&lt;N&gt;::rnd(time(nullptr));\ntemplate&lt;int N&gt;\nvector&lt;array&lt;int, N&gt;&gt; _StringHash&lt;N&gt;::bases;\ntemplate&lt;int N&gt;\narray&lt;int, N&gt; _StringHash&lt;N&gt;::base{};\ntemplate&lt;int N&gt;\nbool _StringHash&lt;N&gt;::noInit = true;\n\ntemplate&lt;int N&gt; // \u6b64\u5904\u4fee\u6539\u6a21\u6570, \u4ec5\u652f\u6301\u5355\u6a21\u6570\nint _StringHash&lt;N&gt;::mod = 1000000007;\nusing StringHash = _StringHash&lt;2&gt;; // \u786e\u5b9a\u5e95\u6570\u4e2a\u6570\n// \u5b9a\u4e49 StringHash sh(str)\n// \u4f20\u5165\u5b57\u7b26\u4e32\u5fc5\u987b\u4e0b\u6807\u4ece0\u5f00\u59cb\n// \u83b7\u53d6\u54c8\u5e0c\u503c sh.get(L, R) \u533a\u95f4\u4e0b\u6807\u4ee51\u4e3a\u57fa\u7840\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3370 <p>P3370 \u3010\u6a21\u677f\u3011\u5b57\u7b26\u4e32\u54c8\u5e0c - \u6d1b\u8c37</p>"},{"location":"Template/String/Trie/","title":"\u5b57\u5178\u6811","text":"\u6a21\u7248 \u7ed3\u6784\u4f53 C++<pre><code>struct Trie {\n    const static int N = 100000;\n    const static int M = 26;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int find(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) return 0;\n            index = nxt[index][c];\n        }\n        return exist[index];\n    }\n}; // Trie\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P8306AcWing143(\u6700\u5927\u5f02\u6216\u5bf9) <p>P8306 \u3010\u6a21\u677f\u3011\u5b57\u5178\u6811 - \u6d1b\u8c37</p> <p>143. \u6700\u5927\u5f02\u6216\u5bf9 - AcWing\u9898\u5e93</p> <p>\\(n\\) \u4e2a\u6574\u6570 \\(a\\), \u4efb\u9009\u4e24\u4e2a\u6570\u8fdb\u884c\u5f02\u6216\uff0c\u6c42\u6700\u5927\u503c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nstruct Trie {\n    const static int N = 100000 * 30;\n    const static int M = 2;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(int x) {\n        int index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int query(int x) {\n        int res = 0, index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c ^ 1]) {\n                res |= 1 &lt;&lt; i;\n                index = nxt[index][c ^ 1];\n            } else if (nxt[index][c]) {\n                index = nxt[index][c];\n            } else {\n                return res;\n            }\n        }\n        return res;\n    }\n}; // Trie\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    Trie trie;\n    int ans = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        int res = trie.query(x);\n        ans = max(ans, res);\n        trie.insert(x);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/","title":"\u524d\u7f00\u51fd\u6570\u4e0eKMP","text":"<p>P3375 \u3010\u6a21\u677f\u3011KMP \u5b57\u7b26\u4e32\u5339\u914d - \u6d1b\u8c37</p>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_1","title":"\u524d\u7f00\u51fd\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len + 1);\n    nxt[0] = -1;\n    int j = -1;\n    for (int i = 0 ; i &lt; len ; i++) {\n        while (j != -1 &amp;&amp; str[i] != str[j]) {\n            j = nxt[j];\n        }\n        nxt[i + 1] = ++j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2, j = 0 ; i &lt; len ; i++) {\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_1","title":"KMP","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_1","title":"Base0","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    int j = 0;\n    for (int i = 0 ; i &lt; len1 ; i++) {\n        while (j != -1 &amp;&amp; str[i] != x[j]) j = nxt[j];\n        j++;\n        if (j == len2) {\n            return i - len2 + 1;\n            j = nxt[j];\n        }\n    }\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_1","title":"Base1","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    for (int i = 1, j = 0 ; i &lt; len1 ; i++) {\n        while (j &amp;&amp; str[i] != x[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == x[j + 1]) {\n            j++;\n        }\n        if (j + 1 == len2) {\n            return i - len2 + 2;\n            j = nxt[j];\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_2","title":"KMP\u5e94\u7528","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_2","title":"\u67e5\u627e\u5b50\u4e32\u51fa\u73b0\u7684\u6240\u6709\u4f4d\u7f6e","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_2","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string str, const string x) {\n    string cur = x + '#' + str;\n    int len1 = str.size(), len2 = x.size();\n    vector&lt;int&gt; pos;\n    vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 + 1 ; i++) {\n        if (nxt[i] == len2) {\n            pos.push_back(i - 2 * len2);\n        }\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_2","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string&amp; str, const string&amp; x) {\n    string cur = x + str;\n    int len1 = str.size(), len2 = x.size();\n        vector&lt;int&gt; pos;\n        vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 ; i++) {\n        if (nxt[i] == len2 - 1)\n          pos.push_back(i - 2 * (len2 - 1));\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_3","title":"\u7edf\u8ba1\u6bcf\u4e2a\u524d\u7f00\u7684\u51fa\u73b0\u6b21\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_3","title":"Base0","text":"Code C++<pre><code>string str;\ncin &gt;&gt; str;\nint len = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(len + 1);\nfor (int i = 1 ; i &lt;= len ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = len - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_3","title":"Base1","text":"Code C++<pre><code>string str, x;\nstr = \" \" + str;\nint n = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(n);\nfor (int i = 1 ; i &lt; n ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = n - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","title":"\u540e\u7f00\u6570\u7ec4","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#-onlog2n","title":"\u500d\u589e - \\(O(n\\log^2{n})\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct SuffixArray {\n    string str;\n    vector&lt;int&gt; rank, sa, nxt;\n    SuffixArray() = default;\n    SuffixArray(string s) { init(s); }\n    void init(string s) {\n        static int cnt[2000005];\n        int m = 127;\n        fill(cnt, cnt + m + 1, 0);\n        int len = s.size();\n        rank.resize(len + 1);\n        sa.resize(len + 1);\n        nxt.resize(len + 1);\n        str = \" \" + s;\n        for (int i = 1 ; i &lt;= len ; i++) {\n            cnt[rank[i] = str[i]]++;\n        }\n        for (int i = 1 ; i &lt;= m ; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        for (int i = len ; i &gt;= 1 ; i--) {\n            sa[cnt[rank[i]]--] = i;\n        }\n        for (int k = 1 ; k &lt;= len ; k &lt;&lt;= 1) {\n            int r = 0;\n            for (int i = len - k + 1 ; i &lt;= len ; i++) {\n                nxt[++r] = i;\n            }\n            for (int i = 1 ; i &lt;= len ; i++) {\n                if (sa[i] &gt; k) {\n                    nxt[++r] = sa[i] - k;\n                }\n            }\n            fill(cnt, cnt + m + 1, 0);\n            for (int i = 1 ; i &lt;= len ; i++) {\n                cnt[rank[i]]++;\n            }\n            for (int i = 1 ; i &lt;= m ; i++) {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = len ; i &gt;= 1 ; i--) {\n                sa[cnt[rank[nxt[i]]]--] = nxt[i];\n            }\n            swap(nxt, rank);\n            rank[sa[1]] = 1;\n            r = 1;\n            for (int i = 2 ; i &lt;= len ; rank[sa[i]] = r, i++) {\n                if (nxt[sa[i - 1]] != nxt[sa[i]] || nxt[sa[i - 1] + k] != nxt[sa[i] + k]) {\n                    r++;\n                }\n            }\n            if (r &gt;= len) break;\n            m = r;\n        }\n    }\n    int operator[](int x) {\n        return sa[x];\n    }\n}; // SuffixArray\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string str;\n    cin &gt;&gt; str;\n    SuffixArray sa(str);\n    int len = str.size();\n    for (int i = 1 ; i &lt;= len ; i++) {\n        cout &lt;&lt; sa[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_2","title":"\u5e94\u7528","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_3","title":"\u67e5\u627e\u5b50\u4e32","text":"Code C++<pre><code>string str, x;\ncin &gt;&gt; str &gt;&gt; x;\nSuffixArray sa(str);\nint L = 1, R = str.size();\nstr = \" \" + str;\nwhile (L &lt; R) {\n    int mid = L + R &gt;&gt; 1;\n    cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n    int k = str.compare(sa[mid], x.size(), x);\n    if (k &gt; 0) R = mid - 1;\n    else if (k &lt; 0) L = mid + 1;\n    else R = mid;\n}\nint k = -1;\nif (str.compare(sa[L], x.size(), x) == 0) k = sa[L];\ncout &lt;&lt; k &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/#ts","title":"\u4e32T\u5728\u4e32S(\u542b\u95ee\u53f7)\u4e2d\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570","text":"<p>Problem - G - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) j++;\n        nxt[i] = j;\n    }\n    return nxt;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int n = a.size(), m = b.size();\n    a = \" \" + a;\n    b = \" \" + b;\n    auto kmp = prefix(b);\n    vector nxt(m + 1, vector(26, 0));\n    for (int i = 1 ; i &lt;= m + 1 ; i++) {\n        for (int j = 0 ; j &lt; 26 ; j++) {\n            if (i &lt;= m &amp;&amp; b[i] == 'a' + j) {\n                nxt[i - 1][j] = i;\n            } else {\n                nxt[i - 1][j] = nxt[kmp[i - 1]][j];\n            }\n        }\n    }\n    vector dp(n + 1, vector(m + 1, -100000000));\n    dp[0][0] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt;= m ; j++) {\n            if (a[i] == '?') {\n                for (int k = 0 ; k &lt; 26 ; k++) {\n                    dp[i][nxt[j][k]] = max(dp[i][nxt[j][k]], dp[i - 1][j]);\n                }\n            } else {\n                dp[i][nxt[j][a[i] - 'a']] = max(dp[i][nxt[j][a[i] - 'a']], dp[i - 1][j]);\n            }\n        }\n        dp[i][m]++;\n    }\n    int mx = 0;\n    for (int i = 0 ; i &lt;= m ; i++) mx = max(mx, dp[n][i]);\n    cout &lt;&lt; mx;\n    return 0;\n}\n</code></pre>"}]}