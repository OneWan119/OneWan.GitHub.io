{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"Template/Default/FastIO/","title":"\u5feb\u8bfb","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; inline void read(T &amp;k) {\n    T x = 0, f = 1; \n    char ch = getchar(); \n    while (ch &lt; '0' || ch &gt; '9') {\n        if (ch == '-') {\n            f = -1;\n        }\n        ch = getchar();\n    }\n    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {\n        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);\n        ch = getchar();\n    }\n    k = x * f;\n}\ntemplate&lt;class T&gt; inline void write(T x) {\n    if (x &lt; 0) {\n        putchar('-'), x = -x;\n    }\n    if (x &gt; 9) {\n        write(x / 10);\n    }\n    putchar(x % 10 + '0');\n}\n</code></pre>"},{"location":"Template/Default/HashCode/","title":"\u54c8\u5e0c\u8868\u91cd\u5199\u54c8\u5e0c\u51fd\u6570","text":"\u6a21\u7248 \u6574\u6570pair C++<pre><code>struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ x &gt;&gt; 30) * 0xbf58476d1ce4e5b9;\n        x = (x ^ x &gt;&gt; 27) * 0x94d049bb133111eb;\n        return x ^ x &gt;&gt; 31;\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nunordered_map&lt;int, int, custom_hash&gt; safe_map;\n</code></pre> C++<pre><code>struct pair_hash {\n    template&lt;class T1, class T2&gt;\n    size_t operator() (const pair&lt;T1, T2&gt;&amp; pair) const {\n        return hash&lt;T1&gt;()(pair.first) ^ hash&lt;T2&gt;()(pair.second);\n    }\n};\nunordered_map&lt;pair&lt;int, int&gt;, int, pair_hash&gt; safe_map;\n</code></pre>"},{"location":"Template/Default/HighAccuracy/","title":"\u9ad8\u7cbe\u5ea6","text":"\u6a21\u7248 C++<pre><code>struct BigInt {\n    static const int BASE = 100000000;\n    static const int WIDTH = 8;\n    bool sign = true;\n    vector&lt;int&gt; num;\n    BigInt() : num(1) {}\n    BigInt(int x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(long long x) {\n        if (x &lt; 0) {\n            x = -x;\n            sign = false;\n        }\n        do {\n            num.emplace_back(x % BASE);\n            x /= BASE;\n        } while (x);\n    }\n    BigInt(const string x) {\n        if (x.front() == '-') {\n            sign = false;\n        }\n        int len = (int(x.size()) - 1 - (!sign)) / WIDTH + 1;\n        num.resize(len);\n        for (int i = 0 ; i &lt; len ; i++) {\n            int end = int(x.size()) - i * WIDTH;\n            int start = max(int(!sign), end - WIDTH);\n            long long k = 0;\n            for (int j = start ; j &lt; end ; j++) {\n                k = k * 10 + (x[j] ^ 48);\n            }\n            num[i] = k;\n        }\n    }\n    int abs_equal(const BigInt &amp;L, const BigInt &amp;R) {\n        int lenL = L.num.size(), lenR = R.num.size();\n        if (lenL == lenR) {\n            for (int i = lenL - 1 ; i &gt;= 0 ; i--) {\n                if (L.num[i] == R.num[i]) {\n                    continue;\n                }\n                return L.num[i] &lt; R.num[i] ? -1 : 1;\n            }\n            return 0;\n        }\n        return lenL &lt; lenR ? -1 : 1;\n    }\n    BigInt operator+(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !x.sign;\n            return *this - _x;\n        }\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        int len = max(lenA, lenB);\n        res.resize(len);\n        int k = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            if (i &lt; lenA) {\n                k += num[i];\n            }\n            if (i &lt; lenB) {\n                k += x.num[i];\n            }\n            res[i] = k % BASE;\n            k /= BASE;\n        }\n        if (k &gt; 0) res.push_back(k);\n        res.sign = sign;\n        return res;\n    }\n    BigInt operator-(const BigInt &amp;x) {\n        if (sign ^ x.sign) {\n            BigInt _x(x);\n            _x.sign = !_x.sign;\n            return *this + _x;\n        }\n        BigInt res(*this), _x(x);\n        if (abs_equal(res, _x) &lt; 0) {\n            swap(res, _x);\n            res.sign = !res.sign;\n        }\n        int lenA = res.size(), lenB = _x.size();\n        int k = 0;\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            res[i] -= k;\n            if (i &lt; lenB) {\n                res[i] -= _x[i];\n            } else if (k == 0) {\n                continue;\n            }\n            k = 0;\n            if (res[i] &lt; 0) {\n                res[i] += BASE;\n                k += 1;\n            }\n        }\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator*(const BigInt &amp;x) {\n        BigInt res;\n        int lenA = num.size(), lenB = x.num.size();\n        res.resize(lenA + lenB);\n        for (int i = 0 ; i &lt; lenA ; i++) {\n            for (int j = 0 ; j &lt; lenB ; j++) {\n                long long k = 1LL * num[i] * x.num[j] + res[i + j];\n                res[i + j] = k % BASE;\n                res[i + j + 1] += k / BASE;\n            }\n        }\n        res.sign = !(sign ^ x.sign);\n        while (res.size() != 1 &amp;&amp; res.back() == 0) {\n            res.pop_back();\n        }\n        return res;\n    }\n    BigInt operator /(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return res;\n        } else if (k == -1) {\n            return BigInt(0);\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return res;\n    }\n    BigInt operator %(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            return BigInt(0);\n        } else if (k == -1) {\n            return *this;\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return Remain;\n    }\n    BigInt&amp; operator+=(const BigInt &amp;x) {\n        *this = *this + x;\n        return *this;\n    }\n    BigInt&amp; operator-=(const BigInt &amp;x) {\n        *this = *this - x;\n        return *this;\n    }\n    BigInt&amp; operator*=(const BigInt &amp;x) {\n        *this = *this * x;\n        return *this;\n    }\n    BigInt&amp; operator/=(const BigInt &amp;x) {\n        *this = *this / x;\n        return *this;\n    }\n    BigInt operator-() {\n        BigInt a(*this);\n        a.sign = !a.sign;\n        return a;\n    }\n    pair&lt;BigInt, BigInt&gt; divide(const BigInt &amp;x) {\n        int k = abs_equal(*this, x);\n        if (k == 0) {\n            BigInt res(1);\n            res.sign = !(sign ^ x.sign);\n            return {res, BigInt(0)};\n        } else if (k == -1) {\n            return {BigInt(0), BigInt(0)};\n        }\n        int len = num.size() - x.num.size() + 1;\n        BigInt res;\n        res.resize(len);\n        int z = log2(BASE);\n        int pow2[z + 5];\n        pow2[0] = 1;\n        for (int i = 1 ; i &lt;= z ; i++) {\n            pow2[i] = pow2[i - 1] &lt;&lt; 1;\n        }\n        BigInt Remain(*this);\n        Remain.sign = true;\n        for (int i = len - 1 ; i &gt;= 0 ; i--) {\n            BigInt temp = Copy(x, i);\n            for (int j = z ; j &gt;= 0 ; j--) {\n                BigInt Temp = temp * pow2[j];\n                if (abs_equal(Remain, Temp) &gt;= 0) {\n                    res[i] += pow2[j];\n                    Remain -= Temp;\n                }\n            }\n        }\n        while (res.back() == 0 &amp;&amp; res.size() &gt; 1) {\n            res.pop_back();\n        }\n        Remain.sign = sign;\n        return {res, Remain};\n    }\n    static BigInt Copy(const BigInt &amp;x, const int pos) {\n        BigInt res;\n        int len = x.num.size();\n        res.resize(len + pos);\n        for (int i = 0 ; i &lt; len ; i++) {\n            res[i + pos] = x.num[i];\n        }\n        return res;\n    }\n    int &amp;operator[](const int pos) {\n        return num[pos];\n    }\n    int &amp;back() {\n        return num.back();\n    }\n    int size() {\n        return num.size();\n    }\n    void resize(const int size) {\n        num.resize(size);\n    }\n    void emplace_back(const int x) {\n        num.emplace_back(x);\n    }\n    void pop_back() {\n        num.pop_back();\n    }\n    void print() const {\n        if (num.size() == 1 &amp;&amp; num[0] == 0) {\n            cout &lt;&lt; num[0];\n            return;\n        }\n        if (!sign) cout &lt;&lt; \"-\";\n        cout &lt;&lt; num.back();\n        int len = num.size();\n        for (int i = len - 2 ; i &gt;= 0 ; i--) {\n            cout &lt;&lt; setfill('0') &lt;&lt; setw(WIDTH) &lt;&lt; num[i];\n        }\n    }\n    friend istream &amp;operator&gt;&gt;(istream &amp;is, BigInt &amp;x) {\n        string str;\n        is &gt;&gt; str;\n        BigInt a(str);\n        x = a;\n        return is;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const BigInt &amp;x) {\n        return x.print(), os;\n    }\n}; // BigInt;\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1932 <p>P1932 A+B A-B A*B A/B A%B Problem - \u6d1b\u8c37</p>"},{"location":"Template/Default/ModInt/","title":"ModInt","text":"\u6a21\u7248 C++<pre><code>template&lt;class T&gt; constexpr T qpow(T a, long long b) {\n    T res = 1;\n    while (b) {\n        if (b &amp; 1) res *= a;\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\ntemplate &lt;class T&gt; struct _MInt {\n    T value;\n    constexpr _MInt() : value() {}\n    constexpr _MInt(T value) : value(normal(value % getMod())) {}\n    static int _mod;\n    constexpr static int getMod() {\n        return _mod;\n    }\n    constexpr T normal(T x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr _MInt inv() const {\n        return qpow(*this, getMod() - 2);\n    }\n    constexpr _MInt operator-() const {\n        _MInt res;\n        res.value = normal(getMod() - value);\n        return res;\n    }\n    constexpr _MInt &amp;operator*=(_MInt rhs) &amp; {\n        if (is_same&lt;T, long long&gt;::value) {\n            value = (__int128) value * rhs.x % getMod();\n        } else {\n            value = (long long) value * rhs.x % getMod();\n        }\n        return *this;\n    }\n    constexpr _MInt &amp;operator+=(_MInt rhs) &amp; {\n        value = normal(value + rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator-=(_MInt rhs) &amp; {\n        value = normal(value - rhs.value);\n        return *this;\n    }\n    constexpr _MInt &amp;operator/=(_MInt rhs) &amp; {\n        return *this *= rhs.inv(); \n    }\n    friend constexpr _MInt operator*(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator+(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr _MInt operator-(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr _MInt operator/(_MInt lhs, _MInt rhs) {\n        _MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr istream &amp;operator&gt;&gt;(istream &amp;is, _MInt &amp;a) {\n        long long v;\n        is &gt;&gt; v;\n        a = _MInt(v);\n        return is;\n    }\n    friend constexpr ostream &amp;operator&lt;&lt;(ostream &amp;os, const _MInt &amp;a) {\n        return os &lt;&lt; a.value;\n    }\n    friend constexpr bool operator==(_MInt lhs, _MInt rhs) {\n        return lhs.value == rhs.value;\n    }\n    friend constexpr bool operator!=(_MInt lhs, _MInt rhs) {\n        return lhs.value != rhs.value;\n    }\n};\ntemplate &lt;&gt; int _MInt&lt;int&gt;::_mod = 998244353;\nusing MInt = _MInt&lt;int&gt;;\n</code></pre>"},{"location":"Template/Default/Sort/","title":"\u6392\u5e8f","text":"\u6a21\u7248 \u5feb\u901f\u6392\u5e8f\\(O(n\\log n)\\)\u5f52\u5e76\u6392\u5e8f \\(O(n\\log n)\\)\u63d2\u5165\u6392\u5e8f \\(O(n^2)\\)\u5192\u6ce1\u6392\u5e8f \\(O(n^2)\\)\u9009\u62e9\u6392\u5e8f \\(O(n^2)\\)\u5e0c\u5c14\u6392\u5e8f \\(O(n\\log n)\\) C++<pre><code>void quickSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    int i = L - 1, j = R + 1;\n    int k = a[L + R &gt;&gt; 1];\n    while (i &lt; j) {\n        do i++; while (a[i] &lt; k);\n        do j--; while (a[j] &gt; k);\n        if (i &lt; j) swap(a[i], a[j]);\n    }\n    quickSort(a, L, j);\n    quickSort(a, j + 1, R);\n}\n</code></pre> C++<pre><code>int cnt = 0;\nvoid mergeSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    if (L == R) return;\n    vector&lt;int&gt; b(R - L + 1);\n    int mid = L + R &gt;&gt; 1;\n    mergeSort(a, L, mid);\n    mergeSort(a, mid + 1, R);\n    int i = L, j = mid + 1, k = 0;\n    while (i &lt;= mid &amp;&amp; j &lt;= R) {\n        if (a[i] &lt;= a[j]) {\n            b[k++] = a[i++];\n        } else {\n            b[k++] = a[j++];\n            cnt += mid - i + 1;\n        }\n    }\n    while (i &lt;= mid) b[k++] = a[i++];\n    while (j &lt;= R) {\n        b[k++] = a[j++];\n        cnt += mid - i + 1;\n    }\n    for (int i = L ; i &lt;= R ; i++) a[i] = b[i - L];\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L + 1 ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - 1;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + 1] = a[j];\n            --j;\n        }\n        a[j + 1] = v;\n    }\n}\n</code></pre> C++<pre><code>void bubbleSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt;= R ; i++) {\n        for (int j = R ; j &gt; i ; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                swap(a[j - 1], a[j]);\n            }\n        }\n    }\n}\n</code></pre> C++<pre><code>void selectSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    for (int i = L ; i &lt; R ; i++) {\n        int t = i;\n        for (int j = i ; j &lt;= R ; j++) {\n            if (a[j] &lt; a[t]) {\n                t = j;\n            }\n        }\n        swap(a[t], a[i]);\n    }\n}\n</code></pre> C++<pre><code>void insertSort(vector&lt;int&gt; &amp;a, int L, int R, int g) {\n    for (int i = L + g ; i &lt;= R ; ++i) {\n        int v = a[i];\n        int j = i - g;\n        while (j &gt;= L &amp;&amp; v &lt; a[j]) {\n            a[j + g] = a[j];\n            j -= g;\n        }\n        a[j + g] = v;\n    }\n}\nvoid shellSort(vector&lt;int&gt; &amp;a, int L, int R) {\n    vector&lt;int&gt; g;\n    for (int h = 1 ; h &lt;= R ; h = 3 * h + 1 ) g.emplace_back(h);\n    reverse(begin(g), end(g));\n    for (auto &amp;i : g) insertSort(a, L, R, i);\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P1177\u6d1b\u8c37U232725 <p>P1177 \u3010\u6a21\u677f\u3011\u6392\u5e8f - \u6d1b\u8c37</p> <p>U232725 \u3010\u6a21\u677f\u3011\u5f52\u5e76\u6392\u5e8f - \u6d1b\u8c37</p>"},{"location":"Template/Default/__builtin/","title":"__builtin","text":"\u51fd\u6570 \u63cf\u8ff0 __builtin_ctz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero __builtin_ctzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u672b\u5c3e 0 \u7684\u4e2a\u6570 check tail zero long long __builtin_clz(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero __builtin_clzll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d\u524d\u5bfc 0 \u7684\u4e2a\u6570 check lead zero long long __builtin_popcount(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count __builtin_popcountll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570 pop count long long __builtin_parity(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u7684\u5947\u5076\u6027(1, 0) parity __builtin_parityll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d 1 \u7684\u4e2a\u6570\u5947\u5076\u6027(1, 0) parity long long __builtin_ffs(int x) \u8fd4\u56de int x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat __builtin_ffsll(long long x) \u8fd4\u56de long long x \u4e8c\u8fdb\u5236\u4e2d \u6700\u540e\u4e00\u4e2a 1 \u7684\u4f4d\u7f6e(base 1) front first seat long long __builtin_sqrt(double x) \u8fd4\u56de  \\(\\sqrt {double\\ x}\\)  \u7684\u503c sqrt __builtin_sqrtf(float x) \u8fd4\u56de  \\(\\sqrt {float\\ x}\\)  \u7684\u503c sqrt float"},{"location":"Template/Graph/ShortestPath/","title":"\u6700\u77ed\u8def","text":""},{"location":"Template/Graph/ShortestPath/#floyed","title":"Floyed \u7b97\u6cd5","text":"<p>\\(O(n^3)\\)</p> \u6a21\u7248 C++<pre><code>for (int k = 1 ; k &lt;= n ; k++) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 1 ; j &lt;= n ; j++) {\n            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n        }\n    }\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3647 <p>B3647 \u3010\u6a21\u677f\u3011Floyd \u7b97\u6cd5 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#bellman-ford","title":"Bellman-Ford \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nint n;\nvoid bellman_ford(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n    }\n    dist[s] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        bool flag = false;\n        for (int p = 1 ; p &lt;= n ; p++) {\n            if (dist[p] == 0x7fffffff) {\n                continue;\n            }\n            for (auto &amp;[to, val] : adj[p]) {\n                if (dist[p] + val &lt; dist[to]) {\n                    dist[to] = dist[p] + val;\n                    flag = true;\n                }\n            }\n        }\n        if (flag == false) {\n            break;\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    bellman_ford(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#spfa","title":"Spfa \u7b97\u6cd5","text":"<p>\\(O(nm)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nint dist[10005];\nbool vis[10005];\nvector&lt;Node&gt; adj[10005];\nint n;\nvoid spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    spfa(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \\n\"[i == n];\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3371\u6d1b\u8c37P3385 <p>P3371 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u5f31\u5316\u7248\uff09 - \u6d1b\u8c37</p> <p>P3385 \u3010\u6a21\u677f\u3011\u8d1f\u73af - \u6d1b\u8c37</p> <p>\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af(\u8def\u5f84\u548c\u4e3a\u8d1f\u6570\u7684\u73af)</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n};\nlong long dist[2005];\nbool vis[2005];\nint cnt[2005];\nvector&lt;Node&gt; adj[2005];\nint n;\nbool spfa(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffffffffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n    }\n    queue&lt;int&gt; que;\n    que.emplace(s);\n    dist[s] = 0;\n    vis[s] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (dist[p] + val &lt; dist[to]) {\n                dist[to] = dist[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nbool solve() {\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        adj[i].clear();\n    }\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        if (val &gt;= 0) {\n            adj[v].emplace_back(u, val);\n        }\n        adj[u].emplace_back(v, val);\n    }\n    return spfa(1);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while (T--) {\n        cout &lt;&lt; (solve() ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/Graph/ShortestPath/#dijkstra","title":"Dijkstra \u7b97\u6cd5","text":"<p>\\(O(m\\log m)\\)</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nvector&lt;Node&gt; adj[200005];\nint dist[200005];\nbool vis[200005];\nint n;\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    dijkstra(s);\n    for (int i = 1 ; i &lt;= n ; i++) {\n        cout &lt;&lt; dist[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P4779 <p>P4779 \u3010\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09 - \u6d1b\u8c37</p>"},{"location":"Template/Graph/ShortestPath/#johnson","title":"Johnson \u5168\u6e90\u6700\u77ed\u8def\u5f84\u7b97\u6cd5","text":"<p>\\(O(nm\\log m)\\)</p> <p>\u8dd1\u4e00\u904d spfa \u5224\u8d1f\u73af\uff0c\u540e\u8dd1 n \u904d dijkstra</p> \u6a21\u7248 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct Node {\n    int to, val;\n    Node() = default;\n    Node(int to, int val) : to(to), val(val) {}\n    bool operator&lt;(const auto &amp;x) const {\n        return val &gt; x.val;\n    }\n};\nint h[3005];\nint dist[3005];\nint cnt[3005];\nbool vis[3005];\nvector&lt;Node&gt; adj[3005];\nint n;\nbool spfa() {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        h[i] = 0x7fffffff;\n        vis[i] = false;\n        cnt[i] = 0;\n        adj[0].emplace_back(i, 0);\n    }\n    queue&lt;int&gt; que;\n    que.emplace(0);\n    h[0] = 0;\n    vis[0] = true;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        vis[p] = false;\n        for (auto &amp;[to, val] : adj[p]) {\n            if (h[p] + val &lt; h[to]) {\n                h[to] = h[p] + val;\n                if (vis[to] == false) {\n                    vis[to] = true;\n                    if (++cnt[to] &gt;= n) {\n                        return true;\n                    }\n                    que.emplace(to);\n                }\n            }\n        }\n    }\n    return false;\n}\nvoid dijkstra(int s) {\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dist[i] = 0x7fffffff;\n        vis[i] = false;\n    }\n    dist[s] = 0;\n    priority_queue&lt;Node&gt; que;\n    que.emplace(s, 0);\n    while (!que.empty()) {\n        auto x = que.top().to;\n        que.pop();\n        if (vis[x] == true) {\n            continue;\n        }\n        vis[x] = true;\n        for (auto &amp;[to, val] : adj[x]) {\n            if (dist[x] + val &lt; dist[to]) {\n                dist[to] = dist[x] + val;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v, val;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;\n        adj[u].emplace_back(v, val);\n    }\n    if (spfa()) {\n        cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n        return 0;\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (auto &amp;[to, val] : adj[i]) {\n            val += h[i] - h[to];\n        }\n    }\n    for (int i = 1 ; i &lt;= n ; i++) {\n        dijkstra(i);\n        long long ans = 0;\n        for (int j = 1 ; j &lt;= n ; j++) {\n            if (dist[j] == 0x7fffffff) {\n                ans += j * 1000000000L;\n            } else {\n                ans += 1LL * j * (dist[j] + h[j] - h[i]);\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P5905 <p>P5905 \u3010\u6a21\u677f\u3011Johnson \u5168\u6e90\u6700\u77ed\u8def - \u6d1b\u8c37</p>"},{"location":"Template/Math/NumberTheory/PrimeFactorization/","title":"\u8d28\u56e0\u6570\u5206\u89e3","text":"\u6a21\u7248 \u66b4\u529b \\(O(n\\sqrt n)\\)Pollard_rho - \\(O(n^{\\frac{1}{4}}\\log{n})\\) C++<pre><code>vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long x) {\n    vector&lt;pair&lt;long long, int&gt;&gt; res;\n    for (int i = 2 ; 1LL * i * i &lt;= x ; i++) {\n        if (x % i == 0) {\n            int cnt = 0;\n            while (x % i == 0) {\n                x /= i;\n                cnt++;\n            }\n            res.emplace_back(i, cnt);\n        }\n    }\n    if (x &gt; 1) {\n        res.emplace_back(x, 1);\n    }\n    return res;\n}\n</code></pre> C++<pre><code>namespace Miller_Rabin {\n    long long qpow(long long a, long long b, long long mod) {\n        long long res = 1;\n        while (b) {\n            if (b &amp; 1) res = (__int128) res * a % mod;\n            b &gt;&gt;= 1;\n            a = (__int128) a * a % mod;\n        }\n        return res;\n    }\n    bool Miller_Rabin(long long n, const vector&lt;long long&gt; &amp;as) {\n        long long d = n - 1;\n        while (d % 2 == 0) {\n            d /= 2;\n        }\n        long long e = 1, rev = n - 1;\n        for (auto &amp;a : as) {\n            if (n &lt;= a) {\n                break;\n            }\n            long long t = d;\n            long long y = qpow(a, t, n);\n            while (t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {\n                y = (__int128) y * y % n;\n                t *= 2;\n            }\n            if (y != rev &amp;&amp; t % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool is_prime(long long n) {\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        if (n &lt;= 1) {\n            return false;\n        }\n        if (n &lt; (1LL &lt;&lt; 30)) {\n            return Miller_Rabin(n, {2, 7, 61});\n        }\n        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n    }\n} // Miller_Rabin\nnamespace Pollard_rho {\n    template&lt;class T&gt; struct Random {\n        mt19937 mt;\n        Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n        T operator()(T L, T R) {\n            uniform_int_distribution&lt;int64_t&gt; dist(L, R);\n            return dist(mt);\n        }\n    };\n    Random&lt;long long&gt; rng;\n    long long get(long long n) {\n        if (n % 2 == 0) {\n            return 2;\n        }\n        if (Miller_Rabin::is_prime(n)) {\n            return n;\n        }\n        long long R;\n        auto f = [&amp;](long long x) {\n            return ((__int128) x * x + R) % n;\n        };\n        while (true) {\n            long long x, y, ys, q = 1;\n            R = rng(2, n - 1), y = rng(2, n - 1);\n            long long g = 1;\n            int m = 128;\n            for (int r = 1 ; g == 1 ; r *= 2) {\n                x = y;\n                for (int i = 0 ; i &lt; r ; i++) {\n                    y = f(y);\n                }\n                for (int k = 0 ; g == 1 &amp;&amp; k &lt; r ; k += m) {\n                    ys = y;\n                    for (int i = 0 ; i &lt; m &amp;&amp; i &lt; r - k ; i++) {\n                        q = (__int128) q * ((x - (y = f(y)) + n) % n) % n;\n                    }\n                    g = __gcd(q, n);\n                }\n            }\n            if (g == n) {\n                do {\n                    g = __gcd((x - (ys = f(ys)) + n) % n, n);\n                } while (g == 1);\n            }\n            if (g != n) {\n                return g;\n            }\n        }\n        return 0;\n    }\n    vector&lt;long long&gt; factorize(long long n) {\n        if (n &lt;= 1) {\n            return {};\n        }\n        long long p = get(n);\n        if (p == n) {\n            return {n};\n        }\n        auto L = factorize(p);\n        auto R = factorize(n / p);\n        copy(R.begin(), R.end(), back_inserter(L));\n        return L;\n    }\n    vector&lt;pair&lt;long long, int&gt;&gt; prime_factor(long long n) {\n        auto ps = factorize(n);\n        sort(ps.begin(), ps.end());\n        vector&lt;pair&lt;long long, int&gt;&gt; res;\n        for (auto &amp;e : ps) {\n            if (!res.empty() &amp;&amp; res.back().first == e) {\n                res.back().second++;\n            } else {\n                res.emplace_back(e, 1);\n            }\n        }\n        return res;\n    }\n    vector&lt;long long&gt; divisors(long long n) {\n        auto ps = prime_factor(n);\n        int cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            cnt *= t + 1;\n        }\n        vector&lt;long long&gt; res(cnt, 1);\n        cnt = 1;\n        for (auto &amp;[p, t] : ps) {\n            long long pw = 1;\n            for (int i = 1 ; i &lt;= t ; i++) {\n                pw *= p;\n                for (int j = 0 ; j &lt; cnt ; j++) {\n                    res[cnt * i + j] = res[j] * pw;\n                }\n            }\n            cnt *= t + 1;\n        }\n        return res;\n    }\n} // Pollard_rho\nusing Miller_Rabin::is_prime; // \u5224\u65ad\u8d28\u6570\nusing Pollard_rho::prime_factor; // \u6240\u6709\u8d28\u56e0\u5b50 (\u8d28\u56e0\u5b50, \u4e2a\u6570)\nusing Pollard_rho::divisors; // \u6240\u6709\u56e0\u5b50\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37B3715\u6d1b\u8c37P4718 <p>B3715 \u5206\u89e3\u8d28\u56e0\u5b50 2 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{12}\\)</p> <p>P4718 \u3010\u6a21\u677f\u3011Pollard rho \u7b97\u6cd5 - \u6d1b\u8c37</p> <p>\\(1\\leq x\\leq10^{18}\\)</p>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/","title":"AC\u81ea\u52a8\u673a(AC_Automaton)","text":"<p>P3808 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u7b80\u5355\u7248\uff09 - \u6d1b\u8c37</p> <p>P3796 \u3010\u6a21\u677f\u3011AC \u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 - \u6d1b\u8c37</p> Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_1","title":"\u6c42\u6709\u591a\u5c11\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32\u51fa\u73b0\u8fc7\u7684\u4e2a\u6570","text":"Code C++<pre><code>const int N = 1000005;\nstruct AC_Automaton {\n    int tree_size, fail[N], nxt[N][26], exist[N];\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 &amp;&amp; exist[j] != -1 ; j = fail[j]) {\n                res += exist[j];\n                exist[j] = -1;\n            }\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    AC_Automaton *ac = new AC_Automaton();\n    string str;\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; str;\n        ac -&gt; insert(str);\n    }\n    ac -&gt; build();\n    cin &gt;&gt; str;\n    cout &lt;&lt; (ac -&gt; query(str));\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%28AC_Automaton%29/#_2","title":"\u6c42\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u6a21\u5f0f\u4e32","text":"Code C++<pre><code>const int N = 151;\nconst int M = N * 70;\nstruct AC_Automaton {\n    int tree_size, fail[M], nxt[M][26], val[M], idx[M];\n    int cnt[N], id_num;\n    void insert(const string str) {\n        const int&amp; len = str.size();\n        int index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            if (nxt[index][c] == 0) {\n                nxt[index][c] = ++tree_size;\n            }\n            index = nxt[index][c];\n        }\n        idx[index] = ++id_num;\n    }\n    void build() {\n        queue&lt;int&gt; que;\n        for (int i = 0 ; i &lt; 26 ; i++) {\n            if (nxt[0][i] != 0) {\n                que.emplace(nxt[0][i]);\n            } \n        }\n        while (!que.empty()) {\n            int index = que.front();\n            que.pop();\n            for (int i = 0 ; i &lt; 26 ; i++) {\n                if (nxt[index][i] != 0) {\n                    fail[nxt[index][i]] = nxt[fail[index]][i];\n                    que.emplace(nxt[index][i]);\n                } else {\n                    nxt[index][i] = nxt[fail[index]][i];\n                }\n            }\n        }\n    }\n    int query(const string str) {\n        const int&amp; len = str.size();\n        int index = 0, res = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            const int&amp; c = str[i] - 'a';\n            index = nxt[index][c];\n            for (int j = index ; j != 0 ; j = fail[j]) {\n                val[j]++;\n            }\n        }\n        for (int i = 1 ; i &lt;= tree_size ; i++) {\n            if (idx[i] == 0) continue;\n            res = max(res, val[i]);\n            cnt[idx[i]] = val[i];\n        }\n        return res;\n    }\n}; // AC_Automaton\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    AC_Automaton *ac = new AC_Automaton();\n    while (cin &gt;&gt; n) {\n        if (n == 0) break;\n        for (int i = 0 ; i &lt; M ; i++) {\n            ac -&gt; fail[i] = 0;\n            ac -&gt; val[i] = 0;\n            ac -&gt; idx[i] = 0;\n            for (int j = 0 ; j &lt; 26 ; j++) {\n                ac -&gt; nxt[i][j] = 0;\n            }\n        }\n        for (int i = 0 ; i &lt; N ; i++) {\n            ac -&gt; cnt[i] = 0;\n        }\n        ac -&gt; id_num = 0;\n        ac -&gt; tree_size = 0;\n        vector&lt;string&gt; s(n + 1);\n        for (int i = 1 ; i &lt;= n ; i++) {\n            cin &gt;&gt; s[i];\n            ac -&gt; insert(s[i]);\n        }\n        ac -&gt; build();\n        string str;\n        cin &gt;&gt; str;\n        int ans = ac -&gt; query(str);\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        for (int i = 1 ; i &lt;= n ; i++) {\n            if (ac -&gt; cnt[i] == ans) {\n                cout &lt;&lt; s[i] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/StringHash/","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"\u6a21\u7248 usageHashOneTwo <p>T \u4e00\u5b9a\u8981CV\u5230Hash\u7684\u4e0b\u65b9</p> <p>\u521d\u59cb\u5316\u54c8\u5e0c\uff0c\u6b64\u5904 T \u53ef\u4ee5\u4e3a One/Two/unsigned long long \u5206\u522b\u4ee3\u8868 \u5355\u54c8\u5e0c/\u53cc\u54c8\u5e0c/\u81ea\u7136\u6ea2\u51fa</p> Text Only<pre><code>Hash&lt;T&gt; h(str); \n</code></pre> <p>\u83b7\u53d6\u67d0\u4e00\u6bb5\u7684\u54c8\u5e0c\u503c\uff0c\u8c28\u9632\u8d8a\u754c</p> Text Only<pre><code>h.get(L, R);\n</code></pre> C++<pre><code>template&lt;class T&gt; struct Hash {\n    static vector&lt;T&gt; base;\n    vector&lt;T&gt; hashVal;\n    Hash(string &amp;val) {\n        if (base.empty()) {\n            base = vector&lt;T&gt;();\n            base.emplace_back(T(1));\n            base.emplace_back(T(true));\n        }\n        int len = val.size() + 1;\n        int lenBase = base.size();\n        if (len &gt; lenBase) {\n            base.resize(len);\n            for (int i = lenBase ; i &lt; len ; i++) {\n                base[i] = base[i - 1] * base[1];\n            }\n        }\n        hashVal.resize(len);\n        for (int i = 1 ; i &lt; len ; i++) {\n            hashVal[i] = hashVal[i - 1] * base[1] + T(val[i - 1]);\n        }\n    }\n    T get(int L, int R) {\n        return hashVal[R] - hashVal[L - 1] * base[R - L + 1];\n    }\n}; // Hash\n</code></pre> C++<pre><code>#define base1 rand() + 1\nconst long long mod = 1000000007;\nstruct One {\n    int x;\n    One() = default;\n    One(const bool flag) : x(base1) {}\n    One(const int x) : x(x) {}\n    friend One operator+(const One &amp;lhs, const One &amp;rhs) {\n        int xVal = lhs.x &gt;= mod - rhs.x ? lhs.x + rhs.x - mod : lhs.x + rhs.x;\n        return One(xVal);\n    }\n    friend One operator-(const One &amp;lhs, const One &amp;rhs) {\n        int xVal = lhs.x &lt; rhs.x ? lhs.x - rhs.x + mod : lhs.x - rhs.x;\n        return One(xVal);\n    }\n    friend One operator*(const One &amp;lhs, const One &amp;rhs) {\n        return One(int(1LL * lhs.x * rhs.x % mod));\n    }\n    friend bool operator==(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x == rhs.x;\n    }\n    friend bool operator!=(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x != rhs.x;\n    }\n    friend bool operator&lt;(const One &amp;lhs, const One &amp;rhs) {\n        return lhs.x &lt; rhs.x;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const One &amp;one) {\n        return os &lt;&lt; one.x;\n    }\n}; // One\ntemplate&lt;&gt;\nvector&lt;One&gt; Hash&lt;One&gt;::base(0);\n</code></pre> C++<pre><code>#define base1 rand() + 1\n#define base2 23333\nconst long long mod = 1000000007;\nstruct Two {\n    int x, y;\n    Two() = default;\n    Two(const bool flag) : x(base1), y(base2) {}\n    Two(const int val) : x(val), y(val) {}\n    Two(const int x, const int y) : x(x), y(y) {}\n    friend Two operator+(const Two &amp;lhs, const Two &amp;rhs) {\n        int xVal = lhs.x &gt;= mod - rhs.x ? lhs.x + rhs.x - mod : lhs.x + rhs.x;\n        int yVal = lhs.y &gt;= mod - rhs.y ? lhs.y + rhs.y - mod : lhs.y + rhs.y;\n        return Two(xVal, yVal);\n    }\n    friend Two operator-(const Two &amp;lhs, const Two &amp;rhs) {\n        int xVal = lhs.x &lt; rhs.x ? lhs.x - rhs.x + mod : lhs.x - rhs.x;\n        int yVal = lhs.y &lt; rhs.y ? lhs.y - rhs.y + mod : lhs.y - rhs.y; \n        return Two(xVal, yVal);\n    }\n    friend Two operator*(const Two &amp;lhs, const Two &amp;rhs) {\n        return Two(int(1LL * lhs.x * rhs.x % mod), int(1LL * lhs.y * rhs.y % mod));\n    }\n    friend bool operator==(const Two &amp;lhs, const Two &amp;rhs) {\n        return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;\n    }\n    friend bool operator!=(const Two &amp;lhs, const Two &amp;rhs) {\n        return lhs.x != rhs.x &amp;&amp; lhs.y != rhs.y;\n    }\n    friend bool operator&lt;(const Two &amp;lhs, const Two &amp;rhs) {\n        if (lhs.x == rhs.x) return lhs.y &lt; rhs.y;\n        return lhs.x &lt; rhs.x;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Two &amp;two) {\n        return os &lt;&lt; two.x &lt;&lt; \" \" &lt;&lt; two.y;\n    }\n}; // Two\ntemplate&lt;&gt;\nvector&lt;Two&gt; Hash&lt;Two&gt;::base(0);\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P3370 <p>P3370 \u3010\u6a21\u677f\u3011\u5b57\u7b26\u4e32\u54c8\u5e0c - \u6d1b\u8c37</p>"},{"location":"Template/String/Trie/","title":"\u5b57\u5178\u6811","text":"\u6a21\u7248 \u7ed3\u6784\u4f53 C++<pre><code>struct Trie {\n    const static int N = 100000;\n    const static int M = 26;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int find(string str) {\n        int len = str.size(), index = 0;\n        for (int i = 0 ; i &lt; len ; i++) {\n            int c = str[i] - 'a';\n            if (nxt[index][c] == 0) return 0;\n            index = nxt[index][c];\n        }\n        return exist[index];\n    }\n}; // Trie\n</code></pre> \u4f8b\u9898 \u6d1b\u8c37P8306AcWing143(\u6700\u5927\u5f02\u6216\u5bf9) <p>P8306 \u3010\u6a21\u677f\u3011\u5b57\u5178\u6811 - \u6d1b\u8c37</p> <p>143. \u6700\u5927\u5f02\u6216\u5bf9 - AcWing\u9898\u5e93</p> <p>\\(n\\) \u4e2a\u6574\u6570 \\(a\\), \u4efb\u9009\u4e24\u4e2a\u6570\u8fdb\u884c\u5f02\u6216\uff0c\u6c42\u6700\u5927\u503c\u3002</p> \u4ee3\u7801 C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 2024 OneWan\n\nstruct Trie {\n    const static int N = 100000 * 30;\n    const static int M = 2;\n    int nxt[N][M], exist[N], tree_size;\n    Trie() {\n        tree_size = N;\n        clear();\n    }\n    void clear() {\n        for (int i = 0 ; i &lt; tree_size ; i++) {\n            for (int j = 0 ; j &lt; M ; j++) {\n                nxt[i][j] = 0;\n            }\n            exist[i] = 0;\n        }\n        tree_size = 0;\n    }\n    void insert(int x) {\n        int index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c] == 0) nxt[index][c] = ++tree_size;\n            index = nxt[index][c];\n        }\n        exist[index]++;\n    }\n    int query(int x) {\n        int res = 0, index = 0;\n        for (int i = 30 ; i &gt;= 0 ; i--) {\n            int c = x &gt;&gt; i &amp; 1;\n            if (nxt[index][c ^ 1]) {\n                res |= 1 &lt;&lt; i;\n                index = nxt[index][c ^ 1];\n            } else if (nxt[index][c]) {\n                index = nxt[index][c];\n            } else {\n                return res;\n            }\n        }\n        return res;\n    }\n}; // Trie\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    Trie trie;\n    int ans = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        int x;\n        cin &gt;&gt; x;\n        int res = trie.query(x);\n        ans = max(ans, res);\n        trie.insert(x);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/","title":"\u524d\u7f00\u51fd\u6570\u4e0eKMP","text":"<p>P3375 \u3010\u6a21\u677f\u3011KMP \u5b57\u7b26\u4e32\u5339\u914d - \u6d1b\u8c37</p>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_1","title":"\u524d\u7f00\u51fd\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len + 1);\n    nxt[0] = -1;\n    int j = -1;\n    for (int i = 0 ; i &lt; len ; i++) {\n        while (j != -1 &amp;&amp; str[i] != str[j]) {\n            j = nxt[j];\n        }\n        nxt[i + 1] = ++j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2, j = 0 ; i &lt; len ; i++) {\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) {\n            j++;\n        }\n        nxt[i] = j;\n    }\n    return nxt;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_1","title":"KMP","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_1","title":"Base0","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    int j = 0;\n    for (int i = 0 ; i &lt; len1 ; i++) {\n        while (j != -1 &amp;&amp; str[i] != x[j]) j = nxt[j];\n        j++;\n        if (j == len2) {\n            return i - len2 + 1;\n            j = nxt[j];\n        }\n    }\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_1","title":"Base1","text":"Code C++<pre><code>int match(const string str, const string x) {\n    int len1 = str.size(), len2 = x.size();\n    for (int i = 1, j = 0 ; i &lt; len1 ; i++) {\n        while (j &amp;&amp; str[i] != x[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == x[j + 1]) {\n            j++;\n        }\n        if (j + 1 == len2) {\n            return i - len2 + 2;\n            j = nxt[j];\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#kmp_2","title":"KMP\u5e94\u7528","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_2","title":"\u67e5\u627e\u5b50\u4e32\u51fa\u73b0\u7684\u6240\u6709\u4f4d\u7f6e","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_2","title":"Base0","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string str, const string x) {\n    string cur = x + '#' + str;\n    int len1 = str.size(), len2 = x.size();\n    vector&lt;int&gt; pos;\n    vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 + 1 ; i++) {\n        if (nxt[i] == len2) {\n            pos.push_back(i - 2 * len2);\n        }\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_2","title":"Base1","text":"Code C++<pre><code>vector&lt;int&gt; find_occurrences(const string&amp; str, const string&amp; x) {\n    string cur = x + str;\n    int len1 = str.size(), len2 = x.size();\n        vector&lt;int&gt; pos;\n        vector&lt;int&gt; nxt = prefix(cur);\n    for (int i = len2 + 1 ; i &lt;= len1 + len2 ; i++) {\n        if (nxt[i] == len2 - 1)\n          pos.push_back(i - 2 * (len2 - 1));\n    }\n    return pos;\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#_3","title":"\u7edf\u8ba1\u6bcf\u4e2a\u524d\u7f00\u7684\u51fa\u73b0\u6b21\u6570","text":""},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base0_3","title":"Base0","text":"Code C++<pre><code>string str;\ncin &gt;&gt; str;\nint len = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(len + 1);\nfor (int i = 1 ; i &lt;= len ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = len - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt;= len ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E4%B8%8EKMP/#base1_3","title":"Base1","text":"Code C++<pre><code>string str, x;\nstr = \" \" + str;\nint n = str.size();\nauto nxt = prefix(str);\nvector&lt;int&gt; ans(n);\nfor (int i = 1 ; i &lt; n ; i++) {\n    ans[nxt[i]]++;\n}\nfor (int i = n - 1 ; i &gt; 0 ; i--) {\n    ans[nxt[i]] += ans[i];\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    ans[i]++;\n}\nfor (int i = 0 ; i &lt; n ; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","title":"\u540e\u7f00\u6570\u7ec4","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#-onlog2n","title":"\u500d\u589e - \\(O(n\\log^2{n})\\)","text":"Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nstruct SuffixArray {\n    string str;\n    vector&lt;int&gt; rank, sa, nxt;\n    SuffixArray() = default;\n    SuffixArray(string s) { init(s); }\n    void init(string s) {\n        static int cnt[2000005];\n        int m = 127;\n        fill(cnt, cnt + m + 1, 0);\n        int len = s.size();\n        rank.resize(len + 1);\n        sa.resize(len + 1);\n        nxt.resize(len + 1);\n        str = \" \" + s;\n        for (int i = 1 ; i &lt;= len ; i++) {\n            cnt[rank[i] = str[i]]++;\n        }\n        for (int i = 1 ; i &lt;= m ; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        for (int i = len ; i &gt;= 1 ; i--) {\n            sa[cnt[rank[i]]--] = i;\n        }\n        for (int k = 1 ; k &lt;= len ; k &lt;&lt;= 1) {\n            int r = 0;\n            for (int i = len - k + 1 ; i &lt;= len ; i++) {\n                nxt[++r] = i;\n            }\n            for (int i = 1 ; i &lt;= len ; i++) {\n                if (sa[i] &gt; k) {\n                    nxt[++r] = sa[i] - k;\n                }\n            }\n            fill(cnt, cnt + m + 1, 0);\n            for (int i = 1 ; i &lt;= len ; i++) {\n                cnt[rank[i]]++;\n            }\n            for (int i = 1 ; i &lt;= m ; i++) {\n                cnt[i] += cnt[i - 1];\n            }\n            for (int i = len ; i &gt;= 1 ; i--) {\n                sa[cnt[rank[nxt[i]]]--] = nxt[i];\n            }\n            swap(nxt, rank);\n            rank[sa[1]] = 1;\n            r = 1;\n            for (int i = 2 ; i &lt;= len ; rank[sa[i]] = r, i++) {\n                if (nxt[sa[i - 1]] != nxt[sa[i]] || nxt[sa[i - 1] + k] != nxt[sa[i] + k]) {\n                    r++;\n                }\n            }\n            if (r &gt;= len) break;\n            m = r;\n        }\n    }\n    int operator[](int x) {\n        return sa[x];\n    }\n}; // SuffixArray\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string str;\n    cin &gt;&gt; str;\n    SuffixArray sa(str);\n    int len = str.size();\n    for (int i = 1 ; i &lt;= len ; i++) {\n        cout &lt;&lt; sa[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_2","title":"\u5e94\u7528","text":""},{"location":"Template/String/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/#_3","title":"\u67e5\u627e\u5b50\u4e32","text":"Code C++<pre><code>string str, x;\ncin &gt;&gt; str &gt;&gt; x;\nSuffixArray sa(str);\nint L = 1, R = str.size();\nstr = \" \" + str;\nwhile (L &lt; R) {\n    int mid = L + R &gt;&gt; 1;\n    cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \"\\n\";\n    int k = str.compare(sa[mid], x.size(), x);\n    if (k &gt; 0) R = mid - 1;\n    else if (k &lt; 0) L = mid + 1;\n    else R = mid;\n}\nint k = -1;\nif (str.compare(sa[L], x.size(), x) == 0) k = sa[L];\ncout &lt;&lt; k &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/","title":"\u6742\u9898(1)","text":""},{"location":"Template/String/%E6%9D%82%E9%A2%98%281%29/#ts","title":"\u4e32T\u5728\u4e32S(\u542b\u95ee\u53f7)\u4e2d\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570","text":"<p>Problem - G - Codeforces</p> Code C++<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 2023 OneWan\nvector&lt;int&gt; prefix(const string str) {\n    int len = str.size();\n    vector&lt;int&gt; nxt(len);\n    for (int i = 2 ; i &lt; len ; i++) {\n        int j = nxt[i - 1];\n        while (j &amp;&amp; str[i] != str[j + 1]) {\n            j = nxt[j];\n        }\n        if (str[i] == str[j + 1]) j++;\n        nxt[i] = j;\n    }\n    return nxt;\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int n = a.size(), m = b.size();\n    a = \" \" + a;\n    b = \" \" + b;\n    auto kmp = prefix(b);\n    vector nxt(m + 1, vector(26, 0));\n    for (int i = 1 ; i &lt;= m + 1 ; i++) {\n        for (int j = 0 ; j &lt; 26 ; j++) {\n            if (i &lt;= m &amp;&amp; b[i] == 'a' + j) {\n                nxt[i - 1][j] = i;\n            } else {\n                nxt[i - 1][j] = nxt[kmp[i - 1]][j];\n            }\n        }\n    }\n    vector dp(n + 1, vector(m + 1, -100000000));\n    dp[0][0] = 0;\n    for (int i = 1 ; i &lt;= n ; i++) {\n        for (int j = 0 ; j &lt;= m ; j++) {\n            if (a[i] == '?') {\n                for (int k = 0 ; k &lt; 26 ; k++) {\n                    dp[i][nxt[j][k]] = max(dp[i][nxt[j][k]], dp[i - 1][j]);\n                }\n            } else {\n                dp[i][nxt[j][a[i] - 'a']] = max(dp[i][nxt[j][a[i] - 'a']], dp[i - 1][j]);\n            }\n        }\n        dp[i][m]++;\n    }\n    int mx = 0;\n    for (int i = 0 ; i &lt;= m ; i++) mx = max(mx, dp[n][i]);\n    cout &lt;&lt; mx;\n    return 0;\n}\n</code></pre>"},{"location":"Template/String/%E9%A9%AC%E6%8B%89%E8%BD%A6%28Manacher%29/","title":"\u9a6c\u62c9\u8f66(Manacher)","text":"<p>P3805 \u3010\u6a21\u677f\u3011manacher \u7b97\u6cd5 - \u6d1b\u8c37</p> Code C++<pre><code>int maxLen = 0, idx = 0, r = 0, c = 0, len = (int(str.size()) &lt;&lt; 1 | 1);\nvector&lt;char&gt; a(len);\nvector&lt;int&gt; b(len);\nfor (int i = 0 ; i &lt; len ; i++) {\n    a[i] = i &amp; 1 ? str[idx++] : '#';\n}\nfor (int i = 0 ; i &lt; len ; i++) {\n    b[i] = r &gt; i ? min(r - i, b[c * 2 - i]) : 1;\n    while (i - b[i] &gt; -1 &amp;&amp; i + b[i] &lt; len &amp;&amp; a[i - b[i]] == a[i + b[i]]) {\n        b[i]++;\n    }\n    if (i + b[i] &gt; r) {\n        r = i + b[i];\n        c = i;\n    }\n    if (b[i] - 1 &gt; maxLen) {\n        maxLen = b[i] - 1;\n        idx = i;\n    }\n}\ncout &lt;&lt; maxLen &lt;&lt; \" \" &lt;&lt; str.substr((idx - maxLen + 1) / 2, maxLen);\n</code></pre>"},{"location":"Template-Print/Default/Default-1/","title":"\u57fa\u7840","text":""},{"location":"Template-Print/Default/Default-1/#_2","title":"\u5feb\u8bfb","text":""},{"location":"Template-Print/Default/Default-1/#modint","title":"ModInt","text":""},{"location":"Template-Print/Default/Default-1/#_3","title":"\u54c8\u5e0c\u8868\u91cd\u5199\u54c8\u5e0c\u51fd\u6570","text":""},{"location":"Template-Print/Default/Default-1/#_4","title":"\u6392\u5e8f","text":""},{"location":"Template-Print/Default/Default-1/#_5","title":"\u9ad8\u7cbe\u5ea6","text":""}]}